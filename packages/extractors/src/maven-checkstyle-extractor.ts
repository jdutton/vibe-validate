/**
 * Maven Checkstyle error extractor
 *
 * Extracts errors from Maven Checkstyle plugin output.
 * Supports both output formats generated by maven-checkstyle-plugin.
 */

import type { ErrorExtractorResult, FormattedError } from './types.js';
import { MAX_ERRORS_IN_ARRAY } from './result-schema.js';

/**
 * Maven Checkstyle output has TWO formats:
 *
 * Format 1: [WARN] with absolute paths (during audit)
 * [WARN] /absolute/path/to/File.java:3:17: Using the '.*' form of import should be avoided - java.util.*. [AvoidStarImport]
 *
 * Format 2: [WARNING] with relative paths (summary)
 * [WARNING] src/main/java/com/example/File.java:[3,17] (imports) AvoidStarImport: Using the '.*' form of import should be avoided - java.util.*.
 */

interface CheckstyleViolation {
  file: string;
  line: number;
  column?: number;
  message: string;
  rule: string;
  category?: string;
}

const CHECKSTYLE_PATTERNS = {
  // Format 1: [WARN] /absolute/path:line:col: message [Rule]
  // eslint-disable-next-line sonarjs/slow-regex -- Safe: Maven Checkstyle output is structured, limited line length
  warnFormat: /^\[WARN\]\s+([^:]+):(\d+):(\d+):\s+(.+?)\s+\[(\w+)\]$/,

  // Format 2: [WARNING] relative/path:[line,col] (category) Rule: message
  // eslint-disable-next-line sonarjs/slow-regex -- Safe: Maven Checkstyle output is structured, limited line length
  warningFormat: /^\[WARNING\]\s+([^:]+):\[(\d+)(?:,(\d+))?\]\s+\((\w+)\)\s+(\w+):\s+(.+)$/,

  // Summary line: "You have N Checkstyle violations"
  summary: /You have (\d+) Checkstyle violations/,
};

/**
 * Detects if output is from Maven Checkstyle
 */
export function detectMavenCheckstyle(output: string): {
  confidence: number;
  patterns: string[];
  reason: string;
} {
  const lines = output.split('\n');
  let score = 0;
  const foundPatterns: string[] = [];

  // Look for Checkstyle-specific markers
  let hasViolationFormat = false;

  for (const line of lines) {
    if (line.includes('maven-checkstyle-plugin')) {
      score += 40;
      foundPatterns.push('maven-checkstyle-plugin reference');
    }
    if (line.includes('Starting audit')) {
      score += 20;
      foundPatterns.push('Checkstyle audit start marker');
    }
    if (line.includes('Audit done')) {
      score += 20;
      foundPatterns.push('Checkstyle audit complete marker');
    }
    if (CHECKSTYLE_PATTERNS.summary.test(line)) {
      score += 30;
      foundPatterns.push('Checkstyle violation summary');
    }
    if (!hasViolationFormat && (CHECKSTYLE_PATTERNS.warnFormat.test(line) || CHECKSTYLE_PATTERNS.warningFormat.test(line))) {
      score += 10;
      foundPatterns.push('Checkstyle violation format');
      hasViolationFormat = true; // Only count once, but don't break - keep looking for other markers
    }
  }

  // Determine reason based on score
  let reason: string;
  if (score >= 70) {
    reason = 'Maven Checkstyle plugin output detected';
  } else if (score >= 40) {
    reason = 'Possible Maven Checkstyle output';
  } else {
    reason = 'Not Maven Checkstyle output';
  }

  return {
    confidence: Math.min(score, 100),
    patterns: foundPatterns,
    reason,
  };
}

/**
 * Extracts Checkstyle violations from Maven output
 */
export function extractMavenCheckstyle(
  output: string,
  command?: string,
): ErrorExtractorResult {
  const detection = detectMavenCheckstyle(output);

  if (detection.confidence < 40) {
    return {
      summary: 'Not Maven Checkstyle output',
      totalErrors: 0,
      errors: [],
      metadata: {
        detection: {
          extractor: 'maven-checkstyle',
          confidence: detection.confidence,
          patterns: detection.patterns,
          reason: detection.reason,
        },
        confidence: detection.confidence,
        completeness: 100,
        issues: [],
      },
    };
  }

  const violations: CheckstyleViolation[] = [];
  const lines = output.split('\n');

  for (const line of lines) {
    // Try Format 1: [WARN] /path:line:col: message [Rule]
    const warnMatch = CHECKSTYLE_PATTERNS.warnFormat.exec(line);
    if (warnMatch) {
      const [, filePath, lineStr, colStr, message, rule] = warnMatch;
      violations.push({
        file: extractRelativePath(filePath),
        line: Number.parseInt(lineStr, 10),
        column: Number.parseInt(colStr, 10),
        message: message.trim(),
        rule: rule.trim(),
      });
      continue;
    }

    // Try Format 2: [WARNING] path:[line,col] (category) Rule: message
    const warningMatch = CHECKSTYLE_PATTERNS.warningFormat.exec(line);
    if (warningMatch) {
      const [, filePath, lineStr, colStr, category, rule, message] = warningMatch;
      violations.push({
        file: filePath.trim(),
        line: Number.parseInt(lineStr, 10),
        column: colStr ? Number.parseInt(colStr, 10) : undefined,
        message: message.trim(),
        rule: rule.trim(),
        category: category.trim(),
      });
    }
  }

  // Remove duplicates (both formats report same violations)
  const uniqueViolations = deduplicateViolations(violations);

  // Convert to FormattedError format
  const errors: FormattedError[] = uniqueViolations.slice(0, MAX_ERRORS_IN_ARRAY).map((v) => ({
    file: v.file,
    line: v.line,
    column: v.column,
    message: `${v.message} [${v.rule}]`,
  }));

  // Group by file for summary
  const fileGroups = groupByFile(uniqueViolations);
  const summary = `${uniqueViolations.length} Checkstyle violation(s) in ${fileGroups.size} file(s)`;

  // Generate guidance
  const guidance =
    uniqueViolations.length > 0
      ? `Fix Checkstyle violations. Run ${command ?? 'mvn checkstyle:check'} to see all details.`
      : undefined;

  // Create error summary
  const errorSummary = errors.length > 0
    ? errors.map((e, i) => `[Error ${i + 1}/${errors.length}] ${e.file}:${e.line}\n${e.message}`).join('\n\n')
    : undefined;

  return {
    summary,
    totalErrors: uniqueViolations.length,
    errors,
    guidance,
    errorSummary,
    metadata: {
      detection: {
        extractor: 'maven-checkstyle',
        confidence: detection.confidence,
        patterns: detection.patterns,
        reason: detection.reason,
      },
      confidence: 100,
      completeness: 100,
      issues: [],
    },
  };
}

/**
 * Extract relative path from absolute path
 * /Users/name/project/src/main/java/Foo.java -> src/main/java/Foo.java
 */
function extractRelativePath(absolutePath: string): string {
  // Common Java source roots
  const sourceRoots = ['src/main/java', 'src/test/java', 'src/main/kotlin', 'src/test/kotlin'];

  for (const root of sourceRoots) {
    const index = absolutePath.indexOf(root);
    if (index !== -1) {
      return absolutePath.slice(index);
    }
  }

  // Fallback: return last 3 path segments
  const segments = absolutePath.split('/');
  return segments.slice(-3).join('/');
}

/**
 * Deduplicate violations (both formats report same violations)
 */
function deduplicateViolations(violations: CheckstyleViolation[]): CheckstyleViolation[] {
  const seen = new Set<string>();
  const unique: CheckstyleViolation[] = [];

  for (const v of violations) {
    const key = `${v.file}:${v.line}:${v.column}:${v.rule}`;
    if (!seen.has(key)) {
      seen.add(key);
      unique.push(v);
    }
  }

  return unique;
}

/**
 * Group violations by file
 */
function groupByFile(violations: CheckstyleViolation[]): Map<string, CheckstyleViolation[]> {
  const groups = new Map<string, CheckstyleViolation[]>();

  for (const violation of violations) {
    const file = violation.file || 'unknown';
    if (!groups.has(file)) {
      groups.set(file, []);
    }
    const group = groups.get(file);
    if (group) {
      group.push(violation);
    }
  }

  return groups;
}
