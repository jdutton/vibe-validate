# vibe-validate Multi-Language Configuration Template
#
# This template demonstrates validation for heterogeneous projects with
# multiple programming languages and build systems in a single repository.
#
# Example project structure:
#   my-monorepo/
#   ├── services/
#   │   ├── user-api/          (Java + Maven)
#   │   └── ml-engine/         (Python + Poetry)
#   ├── apps/
#   │   └── web/               (TypeScript + npm)
#   ├── packages/
#   │   └── shared-types/      (TypeScript)
#   └── vibe-validate.config.yaml
#
# Key features:
# - Uses `cwd` field for each subsystem (relative to git root)
# - Parallel execution within phases for performance
# - Sequential phases where dependencies matter (e.g., build before test)
# - Language-agnostic: Replace commands with your actual tools

validation:
  phases:
    # ============================================================================
    # Phase 1: Linting (parallel across all languages)
    # ============================================================================
    # Run code quality checks for each subsystem concurrently.
    # All steps are independent, so parallelism maximizes speed.
    - name: lint
      parallel: true
      steps:
        # Java: Maven Checkstyle
        - name: lint-java-backend
          cwd: services/user-api
          command: mvn checkstyle:check
          # Alternative Java linters:
          # command: mvn spotless:check
          # command: ./gradlew checkstyleMain

        # TypeScript/JavaScript: ESLint
        - name: lint-node-frontend
          cwd: apps/web
          command: npm run lint
          # Alternative JS linters:
          # command: pnpm lint
          # command: yarn lint

        # Python: pylint or ruff
        - name: lint-python-ml
          cwd: services/ml-engine
          command: pylint src/
          # Alternative Python linters:
          # command: ruff check src/
          # command: flake8 src/

        # Go (if applicable)
        # - name: lint-go-service
        #   cwd: services/go-api
        #   command: golangci-lint run

        # Rust (if applicable)
        # - name: lint-rust-service
        #   cwd: services/rust-worker
        #   command: cargo clippy -- -D warnings

    # ============================================================================
    # Phase 2: Type Checking (parallel)
    # ============================================================================
    # Verify type safety across statically-typed or type-annotated codebases.
    - name: typecheck
      parallel: true
      steps:
        # TypeScript: tsc
        - name: typecheck-typescript
          cwd: apps/web
          command: tsc --noEmit

        # Python: mypy
        - name: typecheck-python
          cwd: services/ml-engine
          command: mypy src/
          # Alternative Python type checkers:
          # command: pyright src/
          # command: pyre check

        # Java: Typically done during compilation (mvn compile)
        # Go: Type checking is part of build (go build)
        # Rust: Type checking is part of build (cargo check)

    # ============================================================================
    # Phase 3: Build (sequential - dependencies matter)
    # ============================================================================
    # Build subsystems in dependency order. Shared libraries build first.
    - name: build
      steps:
        # Build shared type definitions first (used by other packages)
        - name: build-shared-types
          cwd: packages/shared-types
          command: npm run build
          # Generates .d.ts files consumed by apps/web

        # Build frontend (depends on shared-types)
        - name: build-frontend
          cwd: apps/web
          command: npm run build
          # Alternative frontend builds:
          # command: pnpm build
          # command: vite build

        # Build Java backend (package without tests for speed)
        - name: build-backend
          cwd: services/user-api
          command: mvn package -DskipTests
          # Alternative Java builds:
          # command: ./gradlew build -x test
          # command: mvn clean install -DskipTests

        # Python doesn't require explicit build, but you might:
        # - name: build-python-package
        #   cwd: services/ml-engine
        #   command: poetry build

    # ============================================================================
    # Phase 4: Testing (parallel - independent test suites)
    # ============================================================================
    # Run all test suites concurrently for maximum speed.
    - name: test
      parallel: true
      steps:
        # TypeScript/JavaScript: Vitest, Jest, or Mocha
        - name: test-frontend
          cwd: apps/web
          command: npm test
          # Alternative JS test runners:
          # command: vitest run
          # command: jest --ci

        # Java: JUnit via Maven or Gradle
        - name: test-backend
          cwd: services/user-api
          command: mvn test
          # Alternative Java testing:
          # command: ./gradlew test

        # Python: pytest with coverage
        - name: test-ml-engine
          cwd: services/ml-engine
          command: pytest --cov=src
          # Alternative Python testing:
          # command: poetry run pytest
          # command: python -m pytest

        # Go (if applicable)
        # - name: test-go-service
        #   cwd: services/go-api
        #   command: go test ./...

        # Rust (if applicable)
        # - name: test-rust-worker
        #   cwd: services/rust-worker
        #   command: cargo test

    # ============================================================================
    # Phase 5: Integration Tests (optional)
    # ============================================================================
    # Run cross-subsystem integration tests after unit tests pass.
    # - name: integration
    #   steps:
    #     - name: integration-tests
    #       cwd: tests/integration
    #       command: npm run test:integration
    #       env:
    #         DATABASE_URL: postgresql://localhost:5432/test
    #         REDIS_URL: redis://localhost:6379

# ==============================================================================
# Agent-Specific Settings (optional)
# ==============================================================================
# Customize behavior for AI coding assistants like Claude Code, Cursor, etc.
agent:
  # Maximum tokens for LLM-optimized error output
  maxTokens: 4000

  # Context about the project for AI assistants
  context: |
    Multi-language monorepo structure:
    - Backend API: Java 17 + Maven (services/user-api)
    - Frontend: TypeScript + React + Vite (apps/web)
    - ML Service: Python 3.11 + Poetry + PyTorch (services/ml-engine)
    - Shared Types: TypeScript library (packages/shared-types)

    Key dependencies:
    - Frontend depends on shared-types being built
    - Integration tests require backend and frontend running

    Build order:
    1. shared-types
    2. frontend, backend (parallel)
    3. Tests (parallel after builds)

# ==============================================================================
# Usage Examples
# ==============================================================================
#
# Run full validation:
#   vv validate
#
# Run specific phase:
#   vv validate --phase lint
#   vv validate --phase test
#
# Run ad-hoc command in subsystem:
#   vv run --cwd services/user-api "mvn verify"
#   vv run --cwd apps/web "npm run dev"
#
# Generate GitHub Actions workflow:
#   vv generate-workflow --output .github/workflows/ci.yml
#
# Check validation status without running:
#   vv validate --check
#   vv state
#
# Force re-run (ignore cache):
#   vv validate --force

# ==============================================================================
# Customization Tips
# ==============================================================================
#
# 1. Replace commands with your actual build tools:
#    - Maven → Gradle, Ant, or bare javac
#    - npm → pnpm, yarn, or bun
#    - pytest → unittest, nose, or tox
#
# 2. Adjust `cwd` paths to match your directory structure
#
# 3. Add environment variables per step:
#    steps:
#      - name: test-with-env
#        cwd: apps/web
#        command: npm test
#        env:
#          NODE_ENV: test
#          API_URL: http://localhost:3000
#
# 4. Add more phases as needed:
#    - security scanning (SAST, dependency checks)
#    - performance tests
#    - documentation generation
#
# 5. Use parallel: false for phases with dependencies:
#    phases:
#      - name: deploy-staging
#        parallel: false  # Sequential deployment
#        steps: [...]

# ==============================================================================
# Further Reading
# ==============================================================================
#
# - Heterogeneous Projects Guide: docs/heterogeneous-projects.md
# - Configuration Reference: docs/configuration-reference.md
# - CLI Reference: docs/cli-reference.md
# - Workflow Generation: docs/workflow-generation.md
