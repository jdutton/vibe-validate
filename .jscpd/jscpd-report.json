{
  "statistics": {
    "detectionDate": "2025-11-26T00:57:41.174Z",
    "formats": {
      "typescript": {
        "sources": {
          "packages/extractors/node_modules/zod/src/v4/core/tests/locales/tr.test.ts": {
            "lines": 68,
            "tokens": 1087,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 88,
            "duplicatedTokens": 1352,
            "percentage": 129.41,
            "percentageTokens": 124.38,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/core/tests/locales/ru.test.ts": {
            "lines": 127,
            "tokens": 1267,
            "sources": 1,
            "clones": 6,
            "duplicatedLines": 223,
            "duplicatedTokens": 2180,
            "percentage": 175.59,
            "percentageTokens": 172.06,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/core/tests/locales/en.test.ts": {
            "lines": 21,
            "tokens": 294,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 41,
            "duplicatedTokens": 559,
            "percentage": 195.24,
            "percentageTokens": 190.14,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/core/tests/locales/be.test.ts": {
            "lines": 123,
            "tokens": 1263,
            "sources": 1,
            "clones": 6,
            "duplicatedLines": 219,
            "duplicatedTokens": 2176,
            "percentage": 178.05,
            "percentageTokens": 172.29,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/mini/tests/string.test.ts": {
            "lines": 298,
            "tokens": 3744,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 298,
            "duplicatedTokens": 3744,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/mini/tests/recursive-types.test.ts": {
            "lines": 274,
            "tokens": 2264,
            "sources": 1,
            "clones": 8,
            "duplicatedLines": 415,
            "duplicatedTokens": 3237,
            "percentage": 151.46,
            "percentageTokens": 142.98,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/mini/tests/prototypes.test.ts": {
            "lines": 42,
            "tokens": 292,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 42,
            "duplicatedTokens": 292,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/mini/tests/object.test.ts": {
            "lines": 184,
            "tokens": 2129,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 184,
            "duplicatedTokens": 2129,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/mini/tests/number.test.ts": {
            "lines": 94,
            "tokens": 1597,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 94,
            "duplicatedTokens": 1597,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/mini/tests/index.test.ts": {
            "lines": 870,
            "tokens": 12625,
            "sources": 1,
            "clones": 16,
            "duplicatedLines": 1713,
            "duplicatedTokens": 24742,
            "percentage": 196.9,
            "percentageTokens": 195.98,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/mini/tests/functions.test.ts": {
            "lines": 42,
            "tokens": 112,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 42,
            "duplicatedTokens": 112,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/mini/tests/error.test.ts": {
            "lines": 21,
            "tokens": 240,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 21,
            "duplicatedTokens": 240,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/mini/tests/computed.test.ts": {
            "lines": 35,
            "tokens": 519,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 35,
            "duplicatedTokens": 519,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/mini/tests/checks.test.ts": {
            "lines": 143,
            "tokens": 1857,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 143,
            "duplicatedTokens": 1857,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/mini/tests/brand.test.ts": {
            "lines": 50,
            "tokens": 618,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 62,
            "duplicatedTokens": 792,
            "percentage": 124,
            "percentageTokens": 128.16,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/mini/tests/assignability.test.ts": {
            "lines": 128,
            "tokens": 1147,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 128,
            "duplicatedTokens": 1147,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/core/tests/index.test.ts": {
            "lines": 45,
            "tokens": 301,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 70,
            "duplicatedTokens": 499,
            "percentage": 155.56,
            "percentageTokens": 165.78,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/void.test.ts": {
            "lines": 11,
            "tokens": 146,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 11,
            "duplicatedTokens": 146,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/validations.test.ts": {
            "lines": 282,
            "tokens": 1170,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 282,
            "duplicatedTokens": 1170,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/union.test.ts": {
            "lines": 93,
            "tokens": 785,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 136,
            "duplicatedTokens": 1273,
            "percentage": 146.24,
            "percentageTokens": 162.17,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/tuple.test.ts": {
            "lines": 162,
            "tokens": 1438,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 198,
            "duplicatedTokens": 1812,
            "percentage": 122.22,
            "percentageTokens": 126.01,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/transform.test.ts": {
            "lines": 249,
            "tokens": 2046,
            "sources": 1,
            "clones": 9,
            "duplicatedLines": 407,
            "duplicatedTokens": 3585,
            "percentage": 163.45,
            "percentageTokens": 175.22,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/template-literal.test.ts": {
            "lines": 757,
            "tokens": 9329,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 757,
            "duplicatedTokens": 9329,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/stringbool.test.ts": {
            "lines": 65,
            "tokens": 998,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 89,
            "duplicatedTokens": 1448,
            "percentage": 136.92,
            "percentageTokens": 145.09,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/string.test.ts": {
            "lines": 880,
            "tokens": 7686,
            "sources": 1,
            "clones": 11,
            "duplicatedLines": 1172,
            "duplicatedTokens": 9789,
            "percentage": 133.18,
            "percentageTokens": 127.36,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/string-formats.test.ts": {
            "lines": 108,
            "tokens": 619,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 108,
            "duplicatedTokens": 619,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/standard-schema.test.ts": {
            "lines": 56,
            "tokens": 326,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 56,
            "duplicatedTokens": 326,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/set.test.ts": {
            "lines": 178,
            "tokens": 1754,
            "sources": 1,
            "clones": 7,
            "duplicatedLines": 258,
            "duplicatedTokens": 2826,
            "percentage": 144.94,
            "percentageTokens": 161.12,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/registries.test.ts": {
            "lines": 203,
            "tokens": 2192,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 223,
            "duplicatedTokens": 2350,
            "percentage": 109.85,
            "percentageTokens": 107.21,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/refine.test.ts": {
            "lines": 531,
            "tokens": 3602,
            "sources": 1,
            "clones": 8,
            "duplicatedLines": 627,
            "duplicatedTokens": 4432,
            "percentage": 118.08,
            "percentageTokens": 123.04,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/recursive-types.test.ts": {
            "lines": 355,
            "tokens": 2976,
            "sources": 1,
            "clones": 7,
            "duplicatedLines": 472,
            "duplicatedTokens": 3817,
            "percentage": 132.96,
            "percentageTokens": 128.26,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/record.test.ts": {
            "lines": 341,
            "tokens": 2072,
            "sources": 1,
            "clones": 8,
            "duplicatedLines": 600,
            "duplicatedTokens": 2922,
            "percentage": 175.95,
            "percentageTokens": 141.02,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/readonly.test.ts": {
            "lines": 251,
            "tokens": 3281,
            "sources": 1,
            "clones": 5,
            "duplicatedLines": 309,
            "duplicatedTokens": 3933,
            "percentage": 123.11,
            "percentageTokens": 119.87,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/prototypes.test.ts": {
            "lines": 22,
            "tokens": 160,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 22,
            "duplicatedTokens": 160,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/promise.test.ts": {
            "lines": 80,
            "tokens": 855,
            "sources": 1,
            "clones": 4,
            "duplicatedLines": 113,
            "duplicatedTokens": 1159,
            "percentage": 141.25,
            "percentageTokens": 135.56,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/primitive.test.ts": {
            "lines": 174,
            "tokens": 2595,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 197,
            "duplicatedTokens": 2908,
            "percentage": 113.22,
            "percentageTokens": 112.06,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/preprocess.test.ts": {
            "lines": 297,
            "tokens": 1524,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 308,
            "duplicatedTokens": 1646,
            "percentage": 103.7,
            "percentageTokens": 108.01,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/prefault.test.ts": {
            "lines": 36,
            "tokens": 413,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 36,
            "duplicatedTokens": 413,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/pipe.test.ts": {
            "lines": 80,
            "tokens": 567,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 80,
            "duplicatedTokens": 567,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/pickomit.test.ts": {
            "lines": 126,
            "tokens": 1858,
            "sources": 1,
            "clones": 5,
            "duplicatedLines": 218,
            "duplicatedTokens": 3044,
            "percentage": 173.02,
            "percentageTokens": 163.83,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/partial.test.ts": {
            "lines": 146,
            "tokens": 1760,
            "sources": 1,
            "clones": 10,
            "duplicatedLines": 300,
            "duplicatedTokens": 3444,
            "percentage": 205.48,
            "percentageTokens": 195.68,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/optional.test.ts": {
            "lines": 122,
            "tokens": 1615,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 122,
            "duplicatedTokens": 1615,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/object.test.ts": {
            "lines": 562,
            "tokens": 6473,
            "sources": 1,
            "clones": 14,
            "duplicatedLines": 832,
            "duplicatedTokens": 9166,
            "percentage": 148.04,
            "percentageTokens": 141.6,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/number.test.ts": {
            "lines": 246,
            "tokens": 2797,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 246,
            "duplicatedTokens": 2797,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/nullable.test.ts": {
            "lines": 21,
            "tokens": 254,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 21,
            "duplicatedTokens": 254,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/nonoptional.test.ts": {
            "lines": 85,
            "tokens": 509,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 121,
            "duplicatedTokens": 681,
            "percentage": 142.35,
            "percentageTokens": 133.79,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/nested-refine.test.ts": {
            "lines": 167,
            "tokens": 367,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 167,
            "duplicatedTokens": 367,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/nan.test.ts": {
            "lines": 20,
            "tokens": 271,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 31,
            "duplicatedTokens": 442,
            "percentage": 155,
            "percentageTokens": 163.1,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/map.test.ts": {
            "lines": 195,
            "tokens": 1149,
            "sources": 1,
            "clones": 5,
            "duplicatedLines": 255,
            "duplicatedTokens": 1684,
            "percentage": 130.77,
            "percentageTokens": 146.56,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/literal.test.ts": {
            "lines": 91,
            "tokens": 750,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 91,
            "duplicatedTokens": 750,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/lazy.test.ts": {
            "lines": 226,
            "tokens": 2061,
            "sources": 1,
            "clones": 6,
            "duplicatedLines": 321,
            "duplicatedTokens": 2630,
            "percentage": 142.04,
            "percentageTokens": 127.61,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/json.test.ts": {
            "lines": 107,
            "tokens": 230,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 107,
            "duplicatedTokens": 230,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/intersection.test.ts": {
            "lines": 170,
            "tokens": 1891,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 200,
            "duplicatedTokens": 2183,
            "percentage": 117.65,
            "percentageTokens": 115.44,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/instanceof.test.ts": {
            "lines": 33,
            "tokens": 406,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 55,
            "duplicatedTokens": 655,
            "percentage": 166.67,
            "percentageTokens": 161.33,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/index.test.ts": {
            "lines": 828,
            "tokens": 12192,
            "sources": 1,
            "clones": 11,
            "duplicatedLines": 1591,
            "duplicatedTokens": 23161,
            "percentage": 192.15,
            "percentageTokens": 189.97,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/generics.test.ts": {
            "lines": 71,
            "tokens": 717,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 71,
            "duplicatedTokens": 717,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/function.test.ts": {
            "lines": 267,
            "tokens": 2118,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 267,
            "duplicatedTokens": 2118,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/firstparty.test.ts": {
            "lines": 174,
            "tokens": 962,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 326,
            "duplicatedTokens": 1710,
            "percentage": 187.36,
            "percentageTokens": 177.75,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/file.test.ts": {
            "lines": 90,
            "tokens": 492,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 90,
            "duplicatedTokens": 492,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/error.test.ts": {
            "lines": 710,
            "tokens": 5148,
            "sources": 1,
            "clones": 9,
            "duplicatedLines": 836,
            "duplicatedTokens": 6453,
            "percentage": 117.75,
            "percentageTokens": 125.35,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/error-utils.test.ts": {
            "lines": 526,
            "tokens": 2377,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 543,
            "duplicatedTokens": 2491,
            "percentage": 103.23,
            "percentageTokens": 104.8,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/enum.test.ts": {
            "lines": 284,
            "tokens": 2708,
            "sources": 1,
            "clones": 5,
            "duplicatedLines": 347,
            "duplicatedTokens": 3352,
            "percentage": 122.18,
            "percentageTokens": 123.78,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/discriminated-unions.test.ts": {
            "lines": 618,
            "tokens": 5470,
            "sources": 1,
            "clones": 12,
            "duplicatedLines": 790,
            "duplicatedTokens": 7283,
            "percentage": 127.83,
            "percentageTokens": 133.14,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/description.test.ts": {
            "lines": 31,
            "tokens": 228,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 31,
            "duplicatedTokens": 228,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/default.test.ts": {
            "lines": 312,
            "tokens": 2281,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 312,
            "duplicatedTokens": 2281,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/datetime.test.ts": {
            "lines": 295,
            "tokens": 3809,
            "sources": 1,
            "clones": 6,
            "duplicatedLines": 405,
            "duplicatedTokens": 5347,
            "percentage": 137.29,
            "percentageTokens": 140.38,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/date.test.ts": {
            "lines": 30,
            "tokens": 323,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 58,
            "duplicatedTokens": 618,
            "percentage": 193.33,
            "percentageTokens": 191.33,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/custom.test.ts": {
            "lines": 39,
            "tokens": 381,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 51,
            "duplicatedTokens": 537,
            "percentage": 130.77,
            "percentageTokens": 140.94,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/continuability.test.ts": {
            "lines": 351,
            "tokens": 737,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 351,
            "duplicatedTokens": 737,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/coerce.test.ts": {
            "lines": 159,
            "tokens": 2478,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 286,
            "duplicatedTokens": 4778,
            "percentage": 179.87,
            "percentageTokens": 192.82,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/coalesce.test.ts": {
            "lines": 19,
            "tokens": 70,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/catch.test.ts": {
            "lines": 251,
            "tokens": 2387,
            "sources": 1,
            "clones": 5,
            "duplicatedLines": 370,
            "duplicatedTokens": 3731,
            "percentage": 147.41,
            "percentageTokens": 156.3,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/brand.test.ts": {
            "lines": 62,
            "tokens": 773,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 74,
            "duplicatedTokens": 947,
            "percentage": 119.35,
            "percentageTokens": 122.51,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/bigint.test.ts": {
            "lines": 53,
            "tokens": 859,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 104,
            "duplicatedTokens": 1690,
            "percentage": 196.23,
            "percentageTokens": 196.74,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/async-refinements.test.ts": {
            "lines": 67,
            "tokens": 605,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 82,
            "duplicatedTokens": 812,
            "percentage": 122.39,
            "percentageTokens": 134.21,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/async-parsing.test.ts": {
            "lines": 380,
            "tokens": 3955,
            "sources": 1,
            "clones": 7,
            "duplicatedLines": 708,
            "duplicatedTokens": 7421,
            "percentage": 186.32,
            "percentageTokens": 187.64,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/assignability.test.ts": {
            "lines": 209,
            "tokens": 2601,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 209,
            "duplicatedTokens": 2601,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/array.test.ts": {
            "lines": 263,
            "tokens": 1066,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 287,
            "duplicatedTokens": 1270,
            "percentage": 109.13,
            "percentageTokens": 119.14,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/tests/anyunknown.test.ts": {
            "lines": 25,
            "tokens": 285,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 25,
            "duplicatedTokens": 285,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod-to-json-schema/dist/types/parsers/union.d.ts": {
            "lines": 22,
            "tokens": 272,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 22,
            "duplicatedTokens": 272,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod-to-json-schema/dist/types/parsers/tuple.d.ts": {
            "lines": 12,
            "tokens": 147,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 12,
            "duplicatedTokens": 147,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod-to-json-schema/dist/types/parsers/string.d.ts": {
            "lines": 72,
            "tokens": 415,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 72,
            "duplicatedTokens": 415,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod-to-json-schema/dist/types/parsers/set.d.ts": {
            "lines": 12,
            "tokens": 136,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 12,
            "duplicatedTokens": 136,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod-to-json-schema/dist/types/parsers/record.d.ts": {
            "lines": 12,
            "tokens": 174,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 12,
            "duplicatedTokens": 174,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod-to-json-schema/dist/types/parsers/object.d.ts": {
            "lines": 9,
            "tokens": 116,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod-to-json-schema/dist/types/parsers/number.d.ts": {
            "lines": 12,
            "tokens": 136,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 12,
            "duplicatedTokens": 136,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod-to-json-schema/dist/types/parsers/nullable.d.ts": {
            "lines": 9,
            "tokens": 121,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod-to-json-schema/dist/types/parsers/map.d.ts": {
            "lines": 14,
            "tokens": 148,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 14,
            "duplicatedTokens": 148,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod-to-json-schema/dist/types/parsers/literal.d.ts": {
            "lines": 8,
            "tokens": 112,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod-to-json-schema/dist/types/parsers/date.d.ts": {
            "lines": 14,
            "tokens": 175,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 14,
            "duplicatedTokens": 175,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod-to-json-schema/dist/types/parsers/bigint.d.ts": {
            "lines": 13,
            "tokens": 139,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 13,
            "duplicatedTokens": 139,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod-to-json-schema/dist/types/parsers/array.d.ts": {
            "lines": 11,
            "tokens": 132,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 11,
            "duplicatedTokens": 132,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/mini/iso.ts": {
            "lines": 61,
            "tokens": 608,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 61,
            "duplicatedTokens": 608,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/mini/external.ts": {
            "lines": 39,
            "tokens": 212,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 49,
            "duplicatedTokens": 394,
            "percentage": 125.64,
            "percentageTokens": 185.85,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/mini/coerce.ts": {
            "lines": 21,
            "tokens": 344,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 21,
            "duplicatedTokens": 344,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/mini/checks.ts": {
            "lines": 31,
            "tokens": 249,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 56,
            "duplicatedTokens": 448,
            "percentage": 180.65,
            "percentageTokens": 179.92,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts": {
            "lines": 124,
            "tokens": 1325,
            "sources": 1,
            "clones": 111,
            "duplicatedLines": 5267,
            "duplicatedTokens": 53297,
            "percentage": 4247.58,
            "percentageTokens": 4022.42,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/zh-CN.ts": {
            "lines": 122,
            "tokens": 1300,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 26,
            "duplicatedTokens": 228,
            "percentage": 21.31,
            "percentageTokens": 17.54,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/vi.ts": {
            "lines": 124,
            "tokens": 1314,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 42,
            "duplicatedTokens": 344,
            "percentage": 33.87,
            "percentageTokens": 26.18,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/ur.ts": {
            "lines": 125,
            "tokens": 1326,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 26,
            "duplicatedTokens": 232,
            "percentage": 20.8,
            "percentageTokens": 17.5,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/ua.ts": {
            "lines": 125,
            "tokens": 1336,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 29,
            "duplicatedTokens": 254,
            "percentage": 23.2,
            "percentageTokens": 19.01,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/tr.ts": {
            "lines": 120,
            "tokens": 1313,
            "sources": 1,
            "clones": 9,
            "duplicatedLines": 468,
            "duplicatedTokens": 4873,
            "percentage": 390,
            "percentageTokens": 371.13,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/th.ts": {
            "lines": 125,
            "tokens": 1311,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 26,
            "duplicatedTokens": 228,
            "percentage": 20.8,
            "percentageTokens": 17.39,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/ta.ts": {
            "lines": 124,
            "tokens": 1327,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 39,
            "duplicatedTokens": 318,
            "percentage": 31.45,
            "percentageTokens": 23.96,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/sv.ts": {
            "lines": 126,
            "tokens": 1347,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 42,
            "duplicatedTokens": 344,
            "percentage": 33.33,
            "percentageTokens": 25.54,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/sl.ts": {
            "lines": 125,
            "tokens": 1326,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 42,
            "duplicatedTokens": 344,
            "percentage": 33.6,
            "percentageTokens": 25.94,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/ru.ts": {
            "lines": 183,
            "tokens": 1736,
            "sources": 1,
            "clones": 4,
            "duplicatedLines": 233,
            "duplicatedTokens": 2156,
            "percentage": 127.32,
            "percentageTokens": 124.19,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/pt.ts": {
            "lines": 122,
            "tokens": 1338,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 38,
            "duplicatedTokens": 321,
            "percentage": 31.15,
            "percentageTokens": 23.99,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/ps.ts": {
            "lines": 132,
            "tokens": 1353,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 28,
            "duplicatedTokens": 253,
            "percentage": 21.21,
            "percentageTokens": 18.7,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/pl.ts": {
            "lines": 125,
            "tokens": 1338,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 42,
            "duplicatedTokens": 344,
            "percentage": 33.6,
            "percentageTokens": 25.71,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/ota.ts": {
            "lines": 124,
            "tokens": 1323,
            "sources": 1,
            "clones": 4,
            "duplicatedLines": 73,
            "duplicatedTokens": 622,
            "percentage": 58.87,
            "percentageTokens": 47.01,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/no.ts": {
            "lines": 123,
            "tokens": 1320,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 42,
            "duplicatedTokens": 344,
            "percentage": 34.15,
            "percentageTokens": 26.06,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/nl.ts": {
            "lines": 125,
            "tokens": 1290,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 159,
            "duplicatedTokens": 1539,
            "percentage": 127.2,
            "percentageTokens": 119.3,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/ms.ts": {
            "lines": 123,
            "tokens": 1313,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 47,
            "duplicatedTokens": 382,
            "percentage": 38.21,
            "percentageTokens": 29.09,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/mk.ts": {
            "lines": 126,
            "tokens": 1329,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 29,
            "duplicatedTokens": 254,
            "percentage": 23.02,
            "percentageTokens": 19.11,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/ko.ts": {
            "lines": 130,
            "tokens": 1402,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 33,
            "duplicatedTokens": 286,
            "percentage": 25.38,
            "percentageTokens": 20.4,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/kh.ts": {
            "lines": 125,
            "tokens": 1311,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 26,
            "duplicatedTokens": 228,
            "percentage": 20.8,
            "percentageTokens": 17.39,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/ja.ts": {
            "lines": 121,
            "tokens": 1312,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 29,
            "duplicatedTokens": 254,
            "percentage": 23.97,
            "percentageTokens": 19.36,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/it.ts": {
            "lines": 124,
            "tokens": 1342,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 43,
            "duplicatedTokens": 351,
            "percentage": 34.68,
            "percentageTokens": 26.15,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/index.ts": {
            "lines": 38,
            "tokens": 661,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 114,
            "duplicatedTokens": 1983,
            "percentage": 300,
            "percentageTokens": 300,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/id.ts": {
            "lines": 124,
            "tokens": 1321,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 47,
            "duplicatedTokens": 383,
            "percentage": 37.9,
            "percentageTokens": 28.99,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/hu.ts": {
            "lines": 125,
            "tokens": 1324,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 42,
            "duplicatedTokens": 344,
            "percentage": 33.6,
            "percentageTokens": 25.98,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/he.ts": {
            "lines": 124,
            "tokens": 1342,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 33,
            "duplicatedTokens": 286,
            "percentage": 26.61,
            "percentageTokens": 21.31,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/fr.ts": {
            "lines": 123,
            "tokens": 1351,
            "sources": 1,
            "clones": 5,
            "duplicatedLines": 84,
            "duplicatedTokens": 697,
            "percentage": 68.29,
            "percentageTokens": 51.59,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/fr-CA.ts": {
            "lines": 125,
            "tokens": 1341,
            "sources": 1,
            "clones": 4,
            "duplicatedLines": 98,
            "duplicatedTokens": 911,
            "percentage": 78.4,
            "percentageTokens": 67.93,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/fi.ts": {
            "lines": 130,
            "tokens": 1383,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 160,
            "duplicatedTokens": 1640,
            "percentage": 123.08,
            "percentageTokens": 118.58,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/fa.ts": {
            "lines": 133,
            "tokens": 1354,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 33,
            "duplicatedTokens": 285,
            "percentage": 24.81,
            "percentageTokens": 21.05,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/es.ts": {
            "lines": 124,
            "tokens": 1336,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 29,
            "duplicatedTokens": 247,
            "percentage": 23.39,
            "percentageTokens": 18.49,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/eo.ts": {
            "lines": 124,
            "tokens": 1340,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 23,
            "duplicatedTokens": 227,
            "percentage": 18.55,
            "percentageTokens": 16.94,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/en.ts": {
            "lines": 126,
            "tokens": 1327,
            "sources": 1,
            "clones": 4,
            "duplicatedLines": 88,
            "duplicatedTokens": 754,
            "percentage": 69.84,
            "percentageTokens": 56.82,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/de.ts": {
            "lines": 123,
            "tokens": 1320,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 29,
            "duplicatedTokens": 254,
            "percentage": 23.58,
            "percentageTokens": 19.24,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/cs.ts": {
            "lines": 141,
            "tokens": 1419,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 42,
            "duplicatedTokens": 344,
            "percentage": 29.79,
            "percentageTokens": 24.24,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/ca.ts": {
            "lines": 126,
            "tokens": 1354,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 46,
            "duplicatedTokens": 376,
            "percentage": 36.51,
            "percentageTokens": 27.77,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/be.ts": {
            "lines": 183,
            "tokens": 1729,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 220,
            "duplicatedTokens": 2027,
            "percentage": 120.22,
            "percentageTokens": 117.24,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/az.ts": {
            "lines": 120,
            "tokens": 1313,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 70,
            "duplicatedTokens": 571,
            "percentage": 58.33,
            "percentageTokens": 43.49,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/locales/ar.ts": {
            "lines": 124,
            "tokens": 1344,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 33,
            "duplicatedTokens": 286,
            "percentage": 26.61,
            "percentageTokens": 21.28,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/core/zsf.ts": {
            "lines": 322,
            "tokens": 1236,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 322,
            "duplicatedTokens": 1236,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/core/util.ts": {
            "lines": 774,
            "tokens": 8783,
            "sources": 1,
            "clones": 4,
            "duplicatedLines": 820,
            "duplicatedTokens": 9871,
            "percentage": 105.94,
            "percentageTokens": 112.39,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/core/to-json-schema.ts": {
            "lines": 976,
            "tokens": 9224,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 1006,
            "duplicatedTokens": 9517,
            "percentage": 103.07,
            "percentageTokens": 103.18,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/core/standard-schema.ts": {
            "lines": 63,
            "tokens": 471,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 74,
            "duplicatedTokens": 578,
            "percentage": 117.46,
            "percentageTokens": 122.72,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/core/registries.ts": {
            "lines": 95,
            "tokens": 1113,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 95,
            "duplicatedTokens": 1113,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/core/regexes.ts": {
            "lines": 134,
            "tokens": 1471,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 134,
            "duplicatedTokens": 1471,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/core/parse.ts": {
            "lines": 93,
            "tokens": 1468,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 93,
            "duplicatedTokens": 1468,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/core/json-schema.ts": {
            "lines": 142,
            "tokens": 920,
            "sources": 1,
            "clones": 4,
            "duplicatedLines": 225,
            "duplicatedTokens": 1697,
            "percentage": 158.45,
            "percentageTokens": 184.46,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/core/index.ts": {
            "lines": 14,
            "tokens": 149,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 42,
            "duplicatedTokens": 447,
            "percentage": 300,
            "percentageTokens": 300,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/core/function.ts": {
            "lines": 175,
            "tokens": 2025,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 187,
            "duplicatedTokens": 2345,
            "percentage": 106.86,
            "percentageTokens": 115.8,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/core/errors.ts": {
            "lines": 423,
            "tokens": 4191,
            "sources": 1,
            "clones": 6,
            "duplicatedLines": 547,
            "duplicatedTokens": 5580,
            "percentage": 129.31,
            "percentageTokens": 133.14,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/core/doc.ts": {
            "lines": 43,
            "tokens": 540,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 43,
            "duplicatedTokens": 540,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/core/core.ts": {
            "lines": 133,
            "tokens": 1256,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 133,
            "duplicatedTokens": 1256,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/core/config.ts": {
            "lines": 14,
            "tokens": 122,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 14,
            "duplicatedTokens": 122,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/parse.ts": {
            "lines": 32,
            "tokens": 490,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 32,
            "duplicatedTokens": 490,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/iso.ts": {
            "lines": 89,
            "tokens": 645,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 89,
            "duplicatedTokens": 645,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/external.ts": {
            "lines": 49,
            "tokens": 297,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 49,
            "duplicatedTokens": 297,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/errors.ts": {
            "lines": 74,
            "tokens": 640,
            "sources": 1,
            "clones": 4,
            "duplicatedLines": 148,
            "duplicatedTokens": 1441,
            "percentage": 200,
            "percentageTokens": 225.16,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/compat.ts": {
            "lines": 65,
            "tokens": 493,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 65,
            "duplicatedTokens": 493,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/coerce.ts": {
            "lines": 26,
            "tokens": 466,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 26,
            "duplicatedTokens": 466,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v4/classic/checks.ts": {
            "lines": 29,
            "tokens": 233,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 54,
            "duplicatedTokens": 432,
            "percentage": 186.21,
            "percentageTokens": 185.41,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/void.test.ts": {
            "lines": 14,
            "tokens": 158,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 14,
            "duplicatedTokens": 158,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/validations.test.ts": {
            "lines": 132,
            "tokens": 1509,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 132,
            "duplicatedTokens": 1509,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/unions.test.ts": {
            "lines": 56,
            "tokens": 642,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 99,
            "duplicatedTokens": 1130,
            "percentage": 176.79,
            "percentageTokens": 176.01,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/tuple.test.ts": {
            "lines": 89,
            "tokens": 1024,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 100,
            "duplicatedTokens": 1200,
            "percentage": 112.36,
            "percentageTokens": 117.19,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/transformer.test.ts": {
            "lines": 232,
            "tokens": 2188,
            "sources": 1,
            "clones": 10,
            "duplicatedLines": 406,
            "duplicatedTokens": 3821,
            "percentage": 175,
            "percentageTokens": 174.63,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/string.test.ts": {
            "lines": 915,
            "tokens": 10044,
            "sources": 1,
            "clones": 14,
            "duplicatedLines": 1281,
            "duplicatedTokens": 13553,
            "percentage": 140,
            "percentageTokens": 134.94,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/standard-schema.test.ts": {
            "lines": 82,
            "tokens": 923,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 82,
            "duplicatedTokens": 923,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/set.test.ts": {
            "lines": 141,
            "tokens": 1843,
            "sources": 1,
            "clones": 5,
            "duplicatedLines": 201,
            "duplicatedTokens": 2617,
            "percentage": 142.55,
            "percentageTokens": 142,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/safeparse.test.ts": {
            "lines": 26,
            "tokens": 235,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 26,
            "duplicatedTokens": 235,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/refine.test.ts": {
            "lines": 312,
            "tokens": 3112,
            "sources": 1,
            "clones": 6,
            "duplicatedLines": 390,
            "duplicatedTokens": 3822,
            "percentage": 125,
            "percentageTokens": 122.81,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/recursive.test.ts": {
            "lines": 196,
            "tokens": 789,
            "sources": 1,
            "clones": 5,
            "duplicatedLines": 267,
            "duplicatedTokens": 1226,
            "percentage": 136.22,
            "percentageTokens": 155.39,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/record.test.ts": {
            "lines": 170,
            "tokens": 1320,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 205,
            "duplicatedTokens": 1548,
            "percentage": 120.59,
            "percentageTokens": 117.27,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/readonly.test.ts": {
            "lines": 193,
            "tokens": 2163,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 229,
            "duplicatedTokens": 2629,
            "percentage": 118.65,
            "percentageTokens": 121.54,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/promise.test.ts": {
            "lines": 89,
            "tokens": 896,
            "sources": 1,
            "clones": 4,
            "duplicatedLines": 122,
            "duplicatedTokens": 1200,
            "percentage": 137.08,
            "percentageTokens": 133.93,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/primitive.test.ts": {
            "lines": 439,
            "tokens": 4437,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 462,
            "duplicatedTokens": 4750,
            "percentage": 105.24,
            "percentageTokens": 107.05,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/preprocess.test.ts": {
            "lines": 185,
            "tokens": 1583,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 214,
            "duplicatedTokens": 1811,
            "percentage": 115.68,
            "percentageTokens": 114.4,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/pipeline.test.ts": {
            "lines": 28,
            "tokens": 341,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 28,
            "duplicatedTokens": 341,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/pickomit.test.ts": {
            "lines": 110,
            "tokens": 1492,
            "sources": 1,
            "clones": 5,
            "duplicatedLines": 202,
            "duplicatedTokens": 2678,
            "percentage": 183.64,
            "percentageTokens": 179.49,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/partials.test.ts": {
            "lines": 242,
            "tokens": 2682,
            "sources": 1,
            "clones": 8,
            "duplicatedLines": 374,
            "duplicatedTokens": 4126,
            "percentage": 154.55,
            "percentageTokens": 153.84,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/parser.test.ts": {
            "lines": 40,
            "tokens": 470,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 40,
            "duplicatedTokens": 470,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/parseUtil.test.ts": {
            "lines": 22,
            "tokens": 271,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 22,
            "duplicatedTokens": 271,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/optional.test.ts": {
            "lines": 41,
            "tokens": 509,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 95,
            "duplicatedTokens": 1134,
            "percentage": 231.71,
            "percentageTokens": 222.79,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/object.test.ts": {
            "lines": 433,
            "tokens": 4924,
            "sources": 1,
            "clones": 18,
            "duplicatedLines": 933,
            "duplicatedTokens": 9877,
            "percentage": 215.47,
            "percentageTokens": 200.59,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/object-in-es5-env.test.ts": {
            "lines": 28,
            "tokens": 289,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 28,
            "duplicatedTokens": 289,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/object-augmentation.test.ts": {
            "lines": 28,
            "tokens": 218,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 28,
            "duplicatedTokens": 218,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/number.test.ts": {
            "lines": 175,
            "tokens": 2362,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 175,
            "duplicatedTokens": 2362,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/nullable.test.ts": {
            "lines": 41,
            "tokens": 509,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 13,
            "duplicatedTokens": 116,
            "percentage": 31.71,
            "percentageTokens": 22.79,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/nativeEnum.test.ts": {
            "lines": 86,
            "tokens": 867,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 109,
            "duplicatedTokens": 1108,
            "percentage": 126.74,
            "percentageTokens": 127.8,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/nan.test.ts": {
            "lines": 20,
            "tokens": 250,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 31,
            "duplicatedTokens": 421,
            "percentage": 155,
            "percentageTokens": 168.4,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/mocker.test.ts": {
            "lines": 18,
            "tokens": 124,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 18,
            "duplicatedTokens": 124,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/map.test.ts": {
            "lines": 109,
            "tokens": 1283,
            "sources": 1,
            "clones": 7,
            "duplicatedLines": 199,
            "duplicatedTokens": 2110,
            "percentage": 182.57,
            "percentageTokens": 164.46,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/literal.test.ts": {
            "lines": 35,
            "tokens": 363,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 35,
            "duplicatedTokens": 363,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/language-server.test.ts": {
            "lines": 206,
            "tokens": 404,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 206,
            "duplicatedTokens": 404,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/language-server.source.ts": {
            "lines": 75,
            "tokens": 501,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 75,
            "duplicatedTokens": 501,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/intersection.test.ts": {
            "lines": 109,
            "tokens": 1178,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 139,
            "duplicatedTokens": 1470,
            "percentage": 127.52,
            "percentageTokens": 124.79,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/instanceof.test.ts": {
            "lines": 36,
            "tokens": 420,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 58,
            "duplicatedTokens": 669,
            "percentage": 161.11,
            "percentageTokens": 159.29,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/generics.test.ts": {
            "lines": 47,
            "tokens": 397,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 47,
            "duplicatedTokens": 397,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/function.test.ts": {
            "lines": 256,
            "tokens": 2756,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 256,
            "duplicatedTokens": 2756,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/firstpartyschematypes.test.ts": {
            "lines": 20,
            "tokens": 224,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 20,
            "duplicatedTokens": 224,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/firstparty.test.ts": {
            "lines": 86,
            "tokens": 621,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 86,
            "duplicatedTokens": 621,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/error.test.ts": {
            "lines": 550,
            "tokens": 5707,
            "sources": 1,
            "clones": 8,
            "duplicatedLines": 675,
            "duplicatedTokens": 7169,
            "percentage": 122.73,
            "percentageTokens": 125.62,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/enum.test.ts": {
            "lines": 79,
            "tokens": 1022,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 90,
            "duplicatedTokens": 1140,
            "percentage": 113.92,
            "percentageTokens": 111.55,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/discriminated-unions.test.ts": {
            "lines": 314,
            "tokens": 3661,
            "sources": 1,
            "clones": 10,
            "duplicatedLines": 464,
            "duplicatedTokens": 5194,
            "percentage": 147.77,
            "percentageTokens": 141.87,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/description.test.ts": {
            "lines": 32,
            "tokens": 395,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 32,
            "duplicatedTokens": 395,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/default.test.ts": {
            "lines": 111,
            "tokens": 1302,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 139,
            "duplicatedTokens": 1687,
            "percentage": 125.23,
            "percentageTokens": 129.57,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/deepmasking.test.ts": {
            "lines": 185,
            "tokens": 382,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 185,
            "duplicatedTokens": 382,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/date.test.ts": {
            "lines": 31,
            "tokens": 325,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 59,
            "duplicatedTokens": 620,
            "percentage": 190.32,
            "percentageTokens": 190.77,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/custom.test.ts": {
            "lines": 30,
            "tokens": 370,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 42,
            "duplicatedTokens": 526,
            "percentage": 140,
            "percentageTokens": 142.16,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/complex.test.ts": {
            "lines": 55,
            "tokens": 698,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 55,
            "duplicatedTokens": 698,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/coerce.test.ts": {
            "lines": 132,
            "tokens": 2372,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 259,
            "duplicatedTokens": 4672,
            "percentage": 196.21,
            "percentageTokens": 196.96,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/catch.test.ts": {
            "lines": 219,
            "tokens": 2536,
            "sources": 1,
            "clones": 5,
            "duplicatedLines": 342,
            "duplicatedTokens": 3949,
            "percentage": 156.16,
            "percentageTokens": 155.72,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/branded.test.ts": {
            "lines": 52,
            "tokens": 626,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 52,
            "duplicatedTokens": 626,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/bigint.test.ts": {
            "lines": 54,
            "tokens": 861,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 105,
            "duplicatedTokens": 1692,
            "percentage": 194.44,
            "percentageTokens": 196.52,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/base.test.ts": {
            "lines": 28,
            "tokens": 317,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 28,
            "duplicatedTokens": 317,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/async-refinements.test.ts": {
            "lines": 45,
            "tokens": 586,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 60,
            "duplicatedTokens": 793,
            "percentage": 133.33,
            "percentageTokens": 135.32,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/async-parsing.test.ts": {
            "lines": 387,
            "tokens": 4223,
            "sources": 1,
            "clones": 7,
            "duplicatedLines": 715,
            "duplicatedTokens": 7689,
            "percentage": 184.75,
            "percentageTokens": 182.07,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/array.test.ts": {
            "lines": 70,
            "tokens": 855,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 94,
            "duplicatedTokens": 1059,
            "percentage": 134.29,
            "percentageTokens": 123.86,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/anyunknown.test.ts": {
            "lines": 27,
            "tokens": 295,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 27,
            "duplicatedTokens": 295,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/all-errors.test.ts": {
            "lines": 156,
            "tokens": 1523,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 29,
            "duplicatedTokens": 259,
            "percentage": 18.59,
            "percentageTokens": 17.01,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/tests/Mocker.ts": {
            "lines": 53,
            "tokens": 559,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 53,
            "duplicatedTokens": 559,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/locales/en.ts": {
            "lines": 123,
            "tokens": 1230,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 123,
            "duplicatedTokens": 1230,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/helpers/util.ts": {
            "lines": 223,
            "tokens": 2528,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 258,
            "duplicatedTokens": 2938,
            "percentage": 115.7,
            "percentageTokens": 116.22,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/helpers/partialUtil.ts": {
            "lines": 33,
            "tokens": 318,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 33,
            "duplicatedTokens": 318,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/helpers/parseUtil.ts": {
            "lines": 175,
            "tokens": 1943,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 193,
            "duplicatedTokens": 2099,
            "percentage": 110.29,
            "percentageTokens": 108.03,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/helpers/enumUtil.ts": {
            "lines": 16,
            "tokens": 238,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 16,
            "duplicatedTokens": 238,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/benchmarks/union.ts": {
            "lines": 79,
            "tokens": 688,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 152,
            "duplicatedTokens": 1302,
            "percentage": 192.41,
            "percentageTokens": 189.24,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/benchmarks/string.ts": {
            "lines": 54,
            "tokens": 484,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 54,
            "duplicatedTokens": 484,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/benchmarks/realworld.ts": {
            "lines": 62,
            "tokens": 558,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 62,
            "duplicatedTokens": 558,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/benchmarks/primitives.ts": {
            "lines": 161,
            "tokens": 1440,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 161,
            "duplicatedTokens": 1440,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/benchmarks/object.ts": {
            "lines": 68,
            "tokens": 713,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 68,
            "duplicatedTokens": 713,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/benchmarks/ipv4.ts": {
            "lines": 56,
            "tokens": 473,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 56,
            "duplicatedTokens": 473,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/benchmarks/index.ts": {
            "lines": 58,
            "tokens": 486,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 58,
            "duplicatedTokens": 486,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/benchmarks/discriminatedUnion.ts": {
            "lines": 79,
            "tokens": 694,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 152,
            "duplicatedTokens": 1308,
            "percentage": 192.41,
            "percentageTokens": 188.47,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/benchmarks/datetime.ts": {
            "lines": 57,
            "tokens": 577,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 57,
            "duplicatedTokens": 577,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/schema/yaml-1.1/set.d.ts": {
            "lines": 27,
            "tokens": 390,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 27,
            "duplicatedTokens": 390,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/schema/yaml-1.1/pairs.d.ts": {
            "lines": 9,
            "tokens": 215,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/schema/yaml-1.1/omap.d.ts": {
            "lines": 21,
            "tokens": 245,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 21,
            "duplicatedTokens": 245,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/schema/yaml-1.1/merge.d.ts": {
            "lines": 8,
            "tokens": 150,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/tsx/dist/esm/api/index.d.mts": {
            "lines": 34,
            "tokens": 366,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 102,
            "duplicatedTokens": 1098,
            "percentage": 300,
            "percentageTokens": 300,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/tsx/dist/esm/api/index.d.cts": {
            "lines": 34,
            "tokens": 366,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 34,
            "duplicatedTokens": 366,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/tsx/dist/cjs/api/index.d.mts": {
            "lines": 34,
            "tokens": 382,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 102,
            "duplicatedTokens": 1146,
            "percentage": 300,
            "percentageTokens": 300,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/tsx/dist/cjs/api/index.d.cts": {
            "lines": 34,
            "tokens": 382,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 34,
            "duplicatedTokens": 382,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/validation/uniqueItems.ts": {
            "lines": 78,
            "tokens": 989,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/validation/required.ts": {
            "lines": 97,
            "tokens": 938,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/validation/pattern.ts": {
            "lines": 27,
            "tokens": 303,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/validation/multipleOf.ts": {
            "lines": 33,
            "tokens": 322,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/validation/limitProperties.ts": {
            "lines": 25,
            "tokens": 263,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/validation/limitNumber.ts": {
            "lines": 41,
            "tokens": 502,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/validation/limitLength.ts": {
            "lines": 29,
            "tokens": 331,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/validation/limitItems.ts": {
            "lines": 25,
            "tokens": 263,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/validation/limitContains.ts": {
            "lines": 15,
            "tokens": 133,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/validation/index.ts": {
            "lines": 48,
            "tokens": 345,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/validation/enum.ts": {
            "lines": 53,
            "tokens": 651,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/validation/dependentRequired.ts": {
            "lines": 22,
            "tokens": 126,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/validation/const.ts": {
            "lines": 27,
            "tokens": 274,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/unevaluated/unevaluatedProperties.ts": {
            "lines": 84,
            "tokens": 797,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/unevaluated/unevaluatedItems.ts": {
            "lines": 46,
            "tokens": 557,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/jtd/values.ts": {
            "lines": 57,
            "tokens": 545,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/jtd/union.ts": {
            "lines": 11,
            "tokens": 81,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/jtd/type.ts": {
            "lines": 74,
            "tokens": 877,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/jtd/ref.ts": {
            "lines": 75,
            "tokens": 767,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/jtd/properties.ts": {
            "lines": 183,
            "tokens": 1895,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/jtd/optionalProperties.ts": {
            "lines": 14,
            "tokens": 108,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/jtd/nullable.ts": {
            "lines": 20,
            "tokens": 239,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/jtd/metadata.ts": {
            "lines": 23,
            "tokens": 226,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/jtd/index.ts": {
            "lines": 36,
            "tokens": 254,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/jtd/error.ts": {
            "lines": 22,
            "tokens": 247,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/jtd/enum.ts": {
            "lines": 44,
            "tokens": 535,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/jtd/elements.ts": {
            "lines": 31,
            "tokens": 303,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/jtd/discriminator.ts": {
            "lines": 88,
            "tokens": 811,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/format/format.ts": {
            "lines": 119,
            "tokens": 1262,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/dynamic/recursiveRef.ts": {
            "lines": 9,
            "tokens": 76,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/dynamic/recursiveAnchor.ts": {
            "lines": 13,
            "tokens": 107,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/dynamic/index.ts": {
            "lines": 8,
            "tokens": 72,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/dynamic/dynamicRef.ts": {
            "lines": 50,
            "tokens": 491,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/dynamic/dynamicAnchor.ts": {
            "lines": 30,
            "tokens": 385,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/discriminator/types.ts": {
            "lines": 11,
            "tokens": 86,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/discriminator/index.ts": {
            "lines": 112,
            "tokens": 1296,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/core/ref.ts": {
            "lines": 128,
            "tokens": 1499,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/core/index.ts": {
            "lines": 15,
            "tokens": 84,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/core/id.ts": {
            "lines": 9,
            "tokens": 59,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/applicator/thenElse.ts": {
            "lines": 12,
            "tokens": 125,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/applicator/propertyNames.ts": {
            "lines": 49,
            "tokens": 392,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/applicator/properties.ts": {
            "lines": 56,
            "tokens": 583,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/applicator/prefixItems.ts": {
            "lines": 11,
            "tokens": 90,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/applicator/patternProperties.ts": {
            "lines": 90,
            "tokens": 822,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/applicator/oneOf.ts": {
            "lines": 81,
            "tokens": 668,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/applicator/not.ts": {
            "lines": 37,
            "tokens": 275,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/applicator/items2020.ts": {
            "lines": 35,
            "tokens": 323,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/applicator/items.ts": {
            "lines": 58,
            "tokens": 628,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/applicator/index.ts": {
            "lines": 52,
            "tokens": 389,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/applicator/if.ts": {
            "lines": 79,
            "tokens": 772,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/applicator/dependentSchemas.ts": {
            "lines": 10,
            "tokens": 78,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/applicator/dependencies.ts": {
            "lines": 111,
            "tokens": 1089,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/applicator/contains.ts": {
            "lines": 108,
            "tokens": 1157,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/applicator/anyOf.ts": {
            "lines": 13,
            "tokens": 106,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/applicator/allOf.ts": {
            "lines": 21,
            "tokens": 226,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/applicator/additionalProperties.ts": {
            "lines": 117,
            "tokens": 1149,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/applicator/additionalItems.ts": {
            "lines": 55,
            "tokens": 632,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/refs/json-schema-2020-12/index.ts": {
            "lines": 29,
            "tokens": 284,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 12,
            "duplicatedTokens": 114,
            "percentage": 41.38,
            "percentageTokens": 40.14,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/refs/json-schema-2019-09/index.ts": {
            "lines": 27,
            "tokens": 268,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 12,
            "duplicatedTokens": 114,
            "percentage": 44.44,
            "percentageTokens": 42.54,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/compile/validate/subschema.ts": {
            "lines": 134,
            "tokens": 1245,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/compile/validate/keyword.ts": {
            "lines": 170,
            "tokens": 1829,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/compile/validate/index.ts": {
            "lines": 581,
            "tokens": 6534,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/compile/validate/defaults.ts": {
            "lines": 31,
            "tokens": 388,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/compile/validate/dataType.ts": {
            "lines": 229,
            "tokens": 2350,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/compile/validate/boolSchema.ts": {
            "lines": 46,
            "tokens": 425,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/compile/validate/applicability.ts": {
            "lines": 21,
            "tokens": 246,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/compile/jtd/types.ts": {
            "lines": 15,
            "tokens": 100,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/compile/jtd/serialize.ts": {
            "lines": 265,
            "tokens": 2997,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 10,
            "duplicatedTokens": 118,
            "percentage": 3.77,
            "percentageTokens": 3.94,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/compile/jtd/parse.ts": {
            "lines": 410,
            "tokens": 4563,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 10,
            "duplicatedTokens": 118,
            "percentage": 2.44,
            "percentageTokens": 2.59,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/compile/codegen/scope.ts": {
            "lines": 214,
            "tokens": 2011,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/compile/codegen/index.ts": {
            "lines": 851,
            "tokens": 8267,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/compile/codegen/code.ts": {
            "lines": 168,
            "tokens": 1842,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/vocabularies/validation/uniqueItems.d.ts": {
            "lines": 8,
            "tokens": 82,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/vocabularies/validation/limitNumber.d.ts": {
            "lines": 10,
            "tokens": 124,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/vocabularies/validation/index.d.ts": {
            "lines": 15,
            "tokens": 223,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/vocabularies/jtd/type.d.ts": {
            "lines": 9,
            "tokens": 160,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/vocabularies/jtd/properties.d.ts": {
            "lines": 21,
            "tokens": 242,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/vocabularies/jtd/index.d.ts": {
            "lines": 9,
            "tokens": 139,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/vocabularies/jtd/error.d.ts": {
            "lines": 8,
            "tokens": 159,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/vocabularies/discriminator/types.d.ts": {
            "lines": 9,
            "tokens": 90,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/vocabularies/applicator/index.d.ts": {
            "lines": 12,
            "tokens": 219,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/vocabularies/applicator/dependencies.d.ts": {
            "lines": 20,
            "tokens": 246,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/compile/validate/subschema.d.ts": {
            "lines": 46,
            "tokens": 527,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/compile/validate/index.d.ts": {
            "lines": 41,
            "tokens": 681,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/compile/validate/dataType.d.ts": {
            "lines": 16,
            "tokens": 289,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/compile/codegen/scope.d.ts": {
            "lines": 78,
            "tokens": 791,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/compile/codegen/index.d.ts": {
            "lines": 78,
            "tokens": 1215,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/compile/codegen/code.d.ts": {
            "lines": 39,
            "tokens": 578,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod-to-json-schema/dist/types/zodToJsonSchema.d.ts": {
            "lines": 9,
            "tokens": 185,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod-to-json-schema/dist/types/parseTypes.d.ts": {
            "lines": 33,
            "tokens": 469,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 33,
            "duplicatedTokens": 469,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod-to-json-schema/dist/types/index.d.ts": {
            "lines": 39,
            "tokens": 360,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 39,
            "duplicatedTokens": 360,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod-to-json-schema/dist/types/errorMessages.d.ts": {
            "lines": 14,
            "tokens": 261,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 14,
            "duplicatedTokens": 261,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod-to-json-schema/dist/types/Refs.d.ts": {
            "lines": 16,
            "tokens": 183,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 16,
            "duplicatedTokens": 183,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod-to-json-schema/dist/types/Options.d.ts": {
            "lines": 36,
            "tokens": 540,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 36,
            "duplicatedTokens": 540,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/mini/schemas.d.ts": {
            "lines": 355,
            "tokens": 7699,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 709,
            "duplicatedTokens": 15374,
            "percentage": 199.72,
            "percentageTokens": 199.69,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/mini/schemas.d.cts": {
            "lines": 355,
            "tokens": 7699,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 709,
            "duplicatedTokens": 15374,
            "percentage": 199.72,
            "percentageTokens": 199.69,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/mini/iso.d.ts": {
            "lines": 21,
            "tokens": 308,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 41,
            "duplicatedTokens": 592,
            "percentage": 195.24,
            "percentageTokens": 192.21,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/mini/iso.d.cts": {
            "lines": 21,
            "tokens": 308,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 41,
            "duplicatedTokens": 592,
            "percentage": 195.24,
            "percentageTokens": 192.21,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/mini/external.d.ts": {
            "lines": 10,
            "tokens": 182,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/mini/external.d.cts": {
            "lines": 10,
            "tokens": 182,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 10,
            "duplicatedTokens": 182,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/locales/index.d.ts": {
            "lines": 38,
            "tokens": 661,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 38,
            "duplicatedTokens": 661,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/locales/index.d.cts": {
            "lines": 38,
            "tokens": 661,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 38,
            "duplicatedTokens": 661,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/core/util.d.ts": {
            "lines": 182,
            "tokens": 4164,
            "sources": 1,
            "clones": 5,
            "duplicatedLines": 407,
            "duplicatedTokens": 9358,
            "percentage": 223.63,
            "percentageTokens": 224.74,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/core/util.d.cts": {
            "lines": 182,
            "tokens": 4164,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 361,
            "duplicatedTokens": 8270,
            "percentage": 198.35,
            "percentageTokens": 198.61,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/core/to-json-schema.d.ts": {
            "lines": 87,
            "tokens": 798,
            "sources": 1,
            "clones": 4,
            "duplicatedLines": 202,
            "duplicatedTokens": 1848,
            "percentage": 232.18,
            "percentageTokens": 231.58,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/core/to-json-schema.d.cts": {
            "lines": 87,
            "tokens": 798,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 172,
            "duplicatedTokens": 1555,
            "percentage": 197.7,
            "percentageTokens": 194.86,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/core/standard-schema.d.ts": {
            "lines": 54,
            "tokens": 444,
            "sources": 1,
            "clones": 4,
            "duplicatedLines": 173,
            "duplicatedTokens": 1439,
            "percentage": 320.37,
            "percentageTokens": 324.1,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/core/standard-schema.d.cts": {
            "lines": 54,
            "tokens": 444,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 54,
            "duplicatedTokens": 444,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/core/registries.d.ts": {
            "lines": 34,
            "tokens": 635,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 67,
            "duplicatedTokens": 1242,
            "percentage": 197.06,
            "percentageTokens": 195.59,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/core/registries.d.cts": {
            "lines": 34,
            "tokens": 635,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 67,
            "duplicatedTokens": 1242,
            "percentage": 197.06,
            "percentageTokens": 195.59,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/core/regexes.d.ts": {
            "lines": 61,
            "tokens": 637,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 183,
            "duplicatedTokens": 1911,
            "percentage": 300,
            "percentageTokens": 300,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/core/regexes.d.cts": {
            "lines": 61,
            "tokens": 637,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 61,
            "duplicatedTokens": 637,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/core/parse.d.ts": {
            "lines": 24,
            "tokens": 499,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 45,
            "duplicatedTokens": 946,
            "percentage": 187.5,
            "percentageTokens": 189.58,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/core/parse.d.cts": {
            "lines": 24,
            "tokens": 499,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 45,
            "duplicatedTokens": 946,
            "percentage": 187.5,
            "percentageTokens": 189.58,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/core/json-schema.d.ts": {
            "lines": 86,
            "tokens": 822,
            "sources": 1,
            "clones": 6,
            "duplicatedLines": 341,
            "duplicatedTokens": 3243,
            "percentage": 396.51,
            "percentageTokens": 394.53,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/core/json-schema.d.cts": {
            "lines": 86,
            "tokens": 822,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 86,
            "duplicatedTokens": 822,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/core/index.d.ts": {
            "lines": 14,
            "tokens": 149,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 14,
            "duplicatedTokens": 149,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/core/index.d.cts": {
            "lines": 14,
            "tokens": 149,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 14,
            "duplicatedTokens": 149,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/core/function.d.ts": {
            "lines": 51,
            "tokens": 1094,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 111,
            "duplicatedTokens": 2454,
            "percentage": 217.65,
            "percentageTokens": 224.31,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/core/function.d.cts": {
            "lines": 51,
            "tokens": 1094,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 99,
            "duplicatedTokens": 2134,
            "percentage": 194.12,
            "percentageTokens": 195.06,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/core/errors.d.ts": {
            "lines": 207,
            "tokens": 2249,
            "sources": 1,
            "clones": 5,
            "duplicatedLines": 511,
            "duplicatedTokens": 5576,
            "percentage": 246.86,
            "percentageTokens": 247.93,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/core/errors.d.cts": {
            "lines": 207,
            "tokens": 2249,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 411,
            "duplicatedTokens": 4440,
            "percentage": 198.55,
            "percentageTokens": 197.42,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/core/doc.d.ts": {
            "lines": 13,
            "tokens": 148,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 39,
            "duplicatedTokens": 444,
            "percentage": 300,
            "percentageTokens": 300,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/core/doc.d.cts": {
            "lines": 13,
            "tokens": 148,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 13,
            "duplicatedTokens": 148,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/core/core.d.ts": {
            "lines": 48,
            "tokens": 629,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 94,
            "duplicatedTokens": 1215,
            "percentage": 195.83,
            "percentageTokens": 193.16,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/core/core.d.cts": {
            "lines": 48,
            "tokens": 629,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 94,
            "duplicatedTokens": 1215,
            "percentage": 195.83,
            "percentageTokens": 193.16,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/core/checks.d.ts": {
            "lines": 277,
            "tokens": 3216,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 551,
            "duplicatedTokens": 6378,
            "percentage": 198.92,
            "percentageTokens": 198.32,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/core/checks.d.cts": {
            "lines": 277,
            "tokens": 3216,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 551,
            "duplicatedTokens": 6378,
            "percentage": 198.92,
            "percentageTokens": 198.32,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/core/api.d.ts": {
            "lines": 283,
            "tokens": 8300,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 562,
            "duplicatedTokens": 16533,
            "percentage": 198.59,
            "percentageTokens": 199.19,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/core/api.d.cts": {
            "lines": 283,
            "tokens": 8300,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 562,
            "duplicatedTokens": 16533,
            "percentage": 198.59,
            "percentageTokens": 199.19,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/classic/schemas.d.ts": {
            "lines": 629,
            "tokens": 11305,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 1256,
            "duplicatedTokens": 22573,
            "percentage": 199.68,
            "percentageTokens": 199.67,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/classic/schemas.d.cts": {
            "lines": 629,
            "tokens": 11305,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 1256,
            "duplicatedTokens": 22573,
            "percentage": 199.68,
            "percentageTokens": 199.67,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/classic/parse.d.ts": {
            "lines": 22,
            "tokens": 419,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 43,
            "duplicatedTokens": 812,
            "percentage": 195.45,
            "percentageTokens": 193.79,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/classic/parse.d.cts": {
            "lines": 22,
            "tokens": 419,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 43,
            "duplicatedTokens": 812,
            "percentage": 195.45,
            "percentageTokens": 193.79,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/classic/iso.d.ts": {
            "lines": 21,
            "tokens": 296,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 41,
            "duplicatedTokens": 568,
            "percentage": 195.24,
            "percentageTokens": 191.89,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/classic/iso.d.cts": {
            "lines": 21,
            "tokens": 296,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 41,
            "duplicatedTokens": 568,
            "percentage": 195.24,
            "percentageTokens": 191.89,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/classic/external.d.ts": {
            "lines": 12,
            "tokens": 230,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 12,
            "duplicatedTokens": 230,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/classic/external.d.cts": {
            "lines": 12,
            "tokens": 230,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 12,
            "duplicatedTokens": 230,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/classic/errors.d.ts": {
            "lines": 29,
            "tokens": 311,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 19,
            "duplicatedTokens": 219,
            "percentage": 65.52,
            "percentageTokens": 70.42,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/classic/errors.d.cts": {
            "lines": 29,
            "tokens": 311,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 55,
            "duplicatedTokens": 582,
            "percentage": 189.66,
            "percentageTokens": 187.14,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/classic/compat.d.ts": {
            "lines": 45,
            "tokens": 460,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 82,
            "duplicatedTokens": 850,
            "percentage": 182.22,
            "percentageTokens": 184.78,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/classic/compat.d.cts": {
            "lines": 45,
            "tokens": 460,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 82,
            "duplicatedTokens": 850,
            "percentage": 182.22,
            "percentageTokens": 184.78,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/classic/coerce.d.ts": {
            "lines": 16,
            "tokens": 349,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 31,
            "duplicatedTokens": 674,
            "percentage": 193.75,
            "percentageTokens": 193.12,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v4/classic/coerce.d.cts": {
            "lines": 16,
            "tokens": 349,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 31,
            "duplicatedTokens": 674,
            "percentage": 193.75,
            "percentageTokens": 193.12,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v3/helpers/util.d.ts": {
            "lines": 84,
            "tokens": 1488,
            "sources": 1,
            "clones": 5,
            "duplicatedLines": 287,
            "duplicatedTokens": 4874,
            "percentage": 341.67,
            "percentageTokens": 327.55,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v3/helpers/util.d.cts": {
            "lines": 84,
            "tokens": 1488,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 84,
            "duplicatedTokens": 1488,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v3/helpers/parseUtil.d.ts": {
            "lines": 77,
            "tokens": 952,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 171,
            "duplicatedTokens": 2026,
            "percentage": 222.08,
            "percentageTokens": 212.82,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v3/helpers/parseUtil.d.cts": {
            "lines": 77,
            "tokens": 952,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 153,
            "duplicatedTokens": 1870,
            "percentage": 198.7,
            "percentageTokens": 196.43,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v3/helpers/errorUtil.d.ts": {
            "lines": 8,
            "tokens": 96,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v3/helpers/errorUtil.d.cts": {
            "lines": 8,
            "tokens": 96,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/standard-schema.ts": {
            "lines": 112,
            "tokens": 485,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 112,
            "duplicatedTokens": 485,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/errors.ts": {
            "lines": 12,
            "tokens": 85,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/src/v3/ZodError.ts": {
            "lines": 329,
            "tokens": 2949,
            "sources": 1,
            "clones": 9,
            "duplicatedLines": 775,
            "duplicatedTokens": 8029,
            "percentage": 235.56,
            "percentageTokens": 272.26,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/stringify/stringifyString.d.ts": {
            "lines": 8,
            "tokens": 119,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/stringify/stringifyComment.d.ts": {
            "lines": 9,
            "tokens": 78,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/stringify/stringifyCollection.d.ts": {
            "lines": 16,
            "tokens": 160,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 16,
            "duplicatedTokens": 160,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/stringify/stringify.d.ts": {
            "lines": 20,
            "tokens": 257,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 20,
            "duplicatedTokens": 257,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/stringify/foldFlowLines.d.ts": {
            "lines": 33,
            "tokens": 189,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 33,
            "duplicatedTokens": 189,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/schema/types.d.ts": {
            "lines": 91,
            "tokens": 499,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 91,
            "duplicatedTokens": 499,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/schema/tags.d.ts": {
            "lines": 47,
            "tokens": 424,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 47,
            "duplicatedTokens": 424,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/schema/json-schema.d.ts": {
            "lines": 68,
            "tokens": 626,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 68,
            "duplicatedTokens": 626,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/schema/Schema.d.ts": {
            "lines": 16,
            "tokens": 252,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 16,
            "duplicatedTokens": 252,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/parse/parser.d.ts": {
            "lines": 83,
            "tokens": 308,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 83,
            "duplicatedTokens": 308,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/parse/line-counter.d.ts": {
            "lines": 21,
            "tokens": 76,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/parse/lexer.d.ts": {
            "lines": 86,
            "tokens": 284,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 86,
            "duplicatedTokens": 284,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/parse/cst.d.ts": {
            "lines": 108,
            "tokens": 1022,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 108,
            "duplicatedTokens": 1022,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/parse/cst-visit.d.ts": {
            "lines": 38,
            "tokens": 224,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 38,
            "duplicatedTokens": 224,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/parse/cst-scalar.d.ts": {
            "lines": 63,
            "tokens": 415,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 63,
            "duplicatedTokens": 415,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/nodes/toJS.d.ts": {
            "lines": 28,
            "tokens": 190,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 28,
            "duplicatedTokens": 190,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/nodes/identity.d.ts": {
            "lines": 22,
            "tokens": 565,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 22,
            "duplicatedTokens": 565,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/nodes/YAMLSeq.d.ts": {
            "lines": 59,
            "tokens": 514,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 59,
            "duplicatedTokens": 514,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/nodes/YAMLMap.d.ts": {
            "lines": 52,
            "tokens": 702,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 52,
            "duplicatedTokens": 702,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/nodes/Scalar.d.ts": {
            "lines": 42,
            "tokens": 395,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 42,
            "duplicatedTokens": 395,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/nodes/Pair.d.ts": {
            "lines": 21,
            "tokens": 327,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 21,
            "duplicatedTokens": 327,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/nodes/Node.d.ts": {
            "lines": 52,
            "tokens": 681,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 52,
            "duplicatedTokens": 681,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/nodes/Collection.d.ts": {
            "lines": 72,
            "tokens": 450,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 72,
            "duplicatedTokens": 450,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/nodes/Alias.d.ts": {
            "lines": 28,
            "tokens": 321,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 28,
            "duplicatedTokens": 321,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/doc/directives.d.ts": {
            "lines": 48,
            "tokens": 283,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 48,
            "duplicatedTokens": 283,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/doc/createNode.d.ts": {
            "lines": 16,
            "tokens": 209,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 16,
            "duplicatedTokens": 209,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/doc/applyReviver.d.ts": {
            "lines": 8,
            "tokens": 62,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/doc/anchors.d.ts": {
            "lines": 23,
            "tokens": 209,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 23,
            "duplicatedTokens": 209,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/doc/Document.d.ts": {
            "lines": 140,
            "tokens": 1112,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 140,
            "duplicatedTokens": 1112,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/compose/resolve-props.d.ts": {
            "lines": 22,
            "tokens": 255,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 22,
            "duplicatedTokens": 255,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/compose/resolve-flow-scalar.d.ts": {
            "lines": 9,
            "tokens": 134,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/compose/resolve-block-scalar.d.ts": {
            "lines": 10,
            "tokens": 143,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 10,
            "duplicatedTokens": 143,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/compose/composer.d.ts": {
            "lines": 62,
            "tokens": 477,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 62,
            "duplicatedTokens": 477,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/compose/compose-node.d.ts": {
            "lines": 28,
            "tokens": 377,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 28,
            "duplicatedTokens": 377,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/compose/compose-collection.d.ts": {
            "lines": 10,
            "tokens": 167,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 10,
            "duplicatedTokens": 167,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/vitest/dist/chunks/worker.d.1GmBbd7G.d.ts": {
            "lines": 175,
            "tokens": 1716,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/vitest/dist/chunks/vite.d.CMLlLIFP.d.ts": {
            "lines": 24,
            "tokens": 196,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/vitest/dist/chunks/suite.d.FvehnV49.d.ts": {
            "lines": 9,
            "tokens": 124,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/vitest/dist/chunks/mocker.d.BE_2ls6u.d.ts": {
            "lines": 16,
            "tokens": 196,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/vitest/dist/chunks/global.d.MAmajcmJ.d.ts": {
            "lines": 135,
            "tokens": 1020,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/vitest/dist/chunks/environment.d.cL3nLXbE.d.ts": {
            "lines": 118,
            "tokens": 940,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/vitest/dist/chunks/coverage.d.S9RMNXIe.d.ts": {
            "lines": 34,
            "tokens": 220,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/vitest/dist/chunks/config.d.D2ROskhv.d.ts": {
            "lines": 219,
            "tokens": 1362,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/vitest/dist/chunks/benchmark.d.BwvBVTda.d.ts": {
            "lines": 23,
            "tokens": 276,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/metadata.ts": {
            "lines": 16,
            "tokens": 82,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/errors.ts": {
            "lines": 17,
            "tokens": 143,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/draft7.ts": {
            "lines": 16,
            "tokens": 104,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/draft2020.ts": {
            "lines": 22,
            "tokens": 141,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/vocabularies/code.ts": {
            "lines": 167,
            "tokens": 1837,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/types/jtd-schema.ts": {
            "lines": 272,
            "tokens": 2779,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/types/json-schema.ts": {
            "lines": 186,
            "tokens": 1754,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/types/index.ts": {
            "lines": 243,
            "tokens": 2073,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/standalone/instance.ts": {
            "lines": 35,
            "tokens": 423,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/standalone/index.ts": {
            "lines": 99,
            "tokens": 1288,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/runtime/validation_error.ts": {
            "lines": 12,
            "tokens": 106,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/runtime/ucs2length.ts": {
            "lines": 19,
            "tokens": 176,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/runtime/timestamp.ts": {
            "lines": 45,
            "tokens": 617,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/runtime/quote.ts": {
            "lines": 30,
            "tokens": 258,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/runtime/parseJson.ts": {
            "lines": 176,
            "tokens": 1589,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/refs/jtd-schema.ts": {
            "lines": 129,
            "tokens": 924,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/compile/util.ts": {
            "lines": 212,
            "tokens": 2532,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/compile/rules.ts": {
            "lines": 49,
            "tokens": 507,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/compile/resolve.ts": {
            "lines": 148,
            "tokens": 1576,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/compile/ref_error.ts": {
            "lines": 12,
            "tokens": 149,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/compile/names.ts": {
            "lines": 26,
            "tokens": 245,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/compile/index.ts": {
            "lines": 323,
            "tokens": 3369,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/compile/errors.ts": {
            "lines": 183,
            "tokens": 1861,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/vocabularies/errors.d.ts": {
            "lines": 8,
            "tokens": 157,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/vocabularies/code.d.ts": {
            "lines": 16,
            "tokens": 480,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/types/jtd-schema.d.ts": {
            "lines": 173,
            "tokens": 2709,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/types/json-schema.d.ts": {
            "lines": 124,
            "tokens": 1755,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/types/index.d.ts": {
            "lines": 182,
            "tokens": 2110,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/standalone/instance.d.ts": {
            "lines": 11,
            "tokens": 204,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/runtime/parseJson.d.ts": {
            "lines": 17,
            "tokens": 214,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/compile/util.d.ts": {
            "lines": 39,
            "tokens": 757,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/compile/rules.d.ts": {
            "lines": 27,
            "tokens": 273,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/compile/resolve.d.ts": {
            "lines": 11,
            "tokens": 239,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/compile/names.d.ts": {
            "lines": 19,
            "tokens": 142,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/compile/index.d.ts": {
            "lines": 79,
            "tokens": 876,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/compile/errors.d.ts": {
            "lines": 12,
            "tokens": 226,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/web-globals/fetch.d.ts": {
            "lines": 45,
            "tokens": 776,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/web-globals/events.d.ts": {
            "lines": 96,
            "tokens": 908,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/web-globals/domexception.d.ts": {
            "lines": 67,
            "tokens": 652,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 52,
            "duplicatedTokens": 458,
            "percentage": 77.61,
            "percentageTokens": 70.25,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/web-globals/abortcontroller.d.ts": {
            "lines": 33,
            "tokens": 358,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/ts5.6/index.d.ts": {
            "lines": 92,
            "tokens": 135,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/ts5.6/globals.typedarray.d.ts": {
            "lines": 33,
            "tokens": 243,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/ts5.6/buffer.buffer.d.ts": {
            "lines": 467,
            "tokens": 492,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/timers/promises.d.ts": {
            "lines": 107,
            "tokens": 236,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/stream/web.d.ts": {
            "lines": 532,
            "tokens": 5023,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/stream/promises.d.ts": {
            "lines": 89,
            "tokens": 791,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/stream/consumers.d.ts": {
            "lines": 37,
            "tokens": 239,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/readline/promises.d.ts": {
            "lines": 161,
            "tokens": 422,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/dns/promises.d.ts": {
            "lines": 478,
            "tokens": 1523,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 41,
            "duplicatedTokens": 201,
            "percentage": 8.58,
            "percentageTokens": 13.2,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/compatibility/iterators.d.ts": {
            "lines": 20,
            "tokens": 173,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/compatibility/indexable.d.ts": {
            "lines": 19,
            "tokens": 232,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/compatibility/index.d.ts": {
            "lines": 8,
            "tokens": 15,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/compatibility/disposable.d.ts": {
            "lines": 15,
            "tokens": 82,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/extractors/vitest/index.ts": {
            "lines": 671,
            "tokens": 4468,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/extractors/vitest/index.test.ts": {
            "lines": 444,
            "tokens": 2544,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 36,
            "duplicatedTokens": 368,
            "percentage": 8.11,
            "percentageTokens": 14.47,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/extractors/typescript/index.ts": {
            "lines": 173,
            "tokens": 1133,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 20,
            "duplicatedTokens": 232,
            "percentage": 11.56,
            "percentageTokens": 20.48,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/extractors/typescript/index.test.ts": {
            "lines": 233,
            "tokens": 1806,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 22,
            "duplicatedTokens": 153,
            "percentage": 9.44,
            "percentageTokens": 8.47,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/extractors/tap/index.ts": {
            "lines": 416,
            "tokens": 2672,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 39,
            "duplicatedTokens": 224,
            "percentage": 9.38,
            "percentageTokens": 8.38,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/extractors/tap/index.test.ts": {
            "lines": 116,
            "tokens": 794,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/extractors/playwright/index.ts": {
            "lines": 374,
            "tokens": 2088,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/extractors/playwright/index.test.ts": {
            "lines": 317,
            "tokens": 1746,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/extractors/mocha/index.ts": {
            "lines": 278,
            "tokens": 1523,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 19,
            "duplicatedTokens": 90,
            "percentage": 6.83,
            "percentageTokens": 5.91,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/extractors/mocha/index.test.ts": {
            "lines": 343,
            "tokens": 2098,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 26,
            "duplicatedTokens": 191,
            "percentage": 7.58,
            "percentageTokens": 9.1,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/extractors/maven-surefire/index.ts": {
            "lines": 363,
            "tokens": 2551,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/extractors/maven-surefire/index.test.ts": {
            "lines": 213,
            "tokens": 1853,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/extractors/maven-compiler/index.ts": {
            "lines": 332,
            "tokens": 2271,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/extractors/maven-compiler/index.test.ts": {
            "lines": 237,
            "tokens": 1884,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/extractors/maven-checkstyle/index.ts": {
            "lines": 320,
            "tokens": 2168,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/extractors/maven-checkstyle/index.test.ts": {
            "lines": 247,
            "tokens": 2134,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 22,
            "duplicatedTokens": 236,
            "percentage": 8.91,
            "percentageTokens": 11.06,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/extractors/junit/index.ts": {
            "lines": 310,
            "tokens": 2016,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/extractors/junit/index.test.ts": {
            "lines": 387,
            "tokens": 2097,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/extractors/jest/index.ts": {
            "lines": 337,
            "tokens": 2188,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/extractors/jest/index.test.ts": {
            "lines": 440,
            "tokens": 3064,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 12,
            "duplicatedTokens": 81,
            "percentage": 2.73,
            "percentageTokens": 2.64,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/extractors/jasmine/index.ts": {
            "lines": 289,
            "tokens": 1621,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 19,
            "duplicatedTokens": 90,
            "percentage": 6.57,
            "percentageTokens": 5.55,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/extractors/jasmine/index.test.ts": {
            "lines": 388,
            "tokens": 2131,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 26,
            "duplicatedTokens": 191,
            "percentage": 6.7,
            "percentageTokens": 8.96,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/extractors/generic/index.ts": {
            "lines": 152,
            "tokens": 951,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/extractors/generic/index.test.ts": {
            "lines": 74,
            "tokens": 578,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/extractors/eslint/index.ts": {
            "lines": 234,
            "tokens": 1718,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/extractors/eslint/index.test.ts": {
            "lines": 249,
            "tokens": 2200,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/extractors/ava/index.ts": {
            "lines": 600,
            "tokens": 4153,
            "sources": 1,
            "clones": 4,
            "duplicatedLines": 65,
            "duplicatedTokens": 414,
            "percentage": 10.83,
            "percentageTokens": 9.97,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/extractors/ava/index.test.ts": {
            "lines": 473,
            "tokens": 2799,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v3/standard-schema.d.ts": {
            "lines": 101,
            "tokens": 472,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 303,
            "duplicatedTokens": 1416,
            "percentage": 300,
            "percentageTokens": 300,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v3/standard-schema.d.cts": {
            "lines": 101,
            "tokens": 472,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 101,
            "duplicatedTokens": 472,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v3/ZodError.d.ts": {
            "lines": 163,
            "tokens": 1924,
            "sources": 1,
            "clones": 4,
            "duplicatedLines": 98,
            "duplicatedTokens": 1028,
            "percentage": 60.12,
            "percentageTokens": 53.43,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod/v3/ZodError.d.cts": {
            "lines": 163,
            "tokens": 1924,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 324,
            "duplicatedTokens": 3799,
            "percentage": 198.77,
            "percentageTokens": 197.45,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/visit.d.ts": {
            "lines": 101,
            "tokens": 693,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 101,
            "duplicatedTokens": 693,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/util.d.ts": {
            "lines": 15,
            "tokens": 231,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 15,
            "duplicatedTokens": 231,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/public-api.d.ts": {
            "lines": 43,
            "tokens": 496,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 43,
            "duplicatedTokens": 496,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/options.d.ts": {
            "lines": 343,
            "tokens": 886,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 343,
            "duplicatedTokens": 886,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/index.d.ts": {
            "lines": 24,
            "tokens": 416,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 24,
            "duplicatedTokens": 416,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/yaml/dist/errors.d.ts": {
            "lines": 20,
            "tokens": 365,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 20,
            "duplicatedTokens": 365,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/vitest/dist/workers.d.ts": {
            "lines": 39,
            "tokens": 466,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/vitest/dist/snapshot.d.ts": {
            "lines": 8,
            "tokens": 78,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/vitest/dist/runners.d.ts": {
            "lines": 45,
            "tokens": 494,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/vitest/dist/reporters.d.ts": {
            "lines": 24,
            "tokens": 296,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 18,
            "duplicatedTokens": 90,
            "percentage": 75,
            "percentageTokens": 30.41,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/vitest/dist/node.d.ts": {
            "lines": 157,
            "tokens": 2066,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/vitest/dist/index.d.ts": {
            "lines": 650,
            "tokens": 4818,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/vitest/dist/execute.d.ts": {
            "lines": 149,
            "tokens": 1612,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/vitest/dist/environments.d.ts": {
            "lines": 25,
            "tokens": 204,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/vitest/dist/coverage.d.ts": {
            "lines": 107,
            "tokens": 887,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 18,
            "duplicatedTokens": 90,
            "percentage": 16.82,
            "percentageTokens": 10.15,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/vitest/dist/config.d.ts": {
            "lines": 99,
            "tokens": 913,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/vitest/dist/browser.d.ts": {
            "lines": 33,
            "tokens": 427,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/tsserverlibrary.d.ts": {
            "lines": 16,
            "tokens": 20,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.webworker.iterable.d.ts": {
            "lines": 339,
            "tokens": 3734,
            "sources": 1,
            "clones": 9,
            "duplicatedLines": 661,
            "duplicatedTokens": 7326,
            "percentage": 194.99,
            "percentageTokens": 196.2,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.webworker.importscripts.d.ts": {
            "lines": 22,
            "tokens": 32,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.webworker.asynciterable.d.ts": {
            "lines": 40,
            "tokens": 218,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 60,
            "duplicatedTokens": 425,
            "percentage": 150,
            "percentageTokens": 194.95,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.scripthost.d.ts": {
            "lines": 321,
            "tokens": 1069,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 321,
            "duplicatedTokens": 1069,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.esnext.sharedmemory.d.ts": {
            "lines": 24,
            "tokens": 30,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.esnext.promise.d.ts": {
            "lines": 33,
            "tokens": 70,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.esnext.iterator.d.ts": {
            "lines": 147,
            "tokens": 844,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 147,
            "duplicatedTokens": 844,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.esnext.intl.d.ts": {
            "lines": 20,
            "tokens": 18,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.esnext.full.d.ts": {
            "lines": 23,
            "tokens": 17,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.esnext.float16.d.ts": {
            "lines": 444,
            "tokens": 1888,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 462,
            "duplicatedTokens": 1984,
            "percentage": 104.05,
            "percentageTokens": 105.08,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.esnext.error.d.ts": {
            "lines": 23,
            "tokens": 33,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.esnext.disposable.d.ts": {
            "lines": 192,
            "tokens": 661,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 192,
            "duplicatedTokens": 661,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.esnext.decorators.d.ts": {
            "lines": 27,
            "tokens": 53,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.esnext.d.ts": {
            "lines": 28,
            "tokens": 27,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.esnext.collection.d.ts": {
            "lines": 95,
            "tokens": 424,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 153,
            "duplicatedTokens": 774,
            "percentage": 161.05,
            "percentageTokens": 182.55,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.esnext.array.d.ts": {
            "lines": 34,
            "tokens": 145,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 34,
            "duplicatedTokens": 145,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es6.d.ts": {
            "lines": 22,
            "tokens": 15,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2024.string.d.ts": {
            "lines": 28,
            "tokens": 38,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2024.sharedmemory.d.ts": {
            "lines": 67,
            "tokens": 268,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 67,
            "duplicatedTokens": 268,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2024.regexp.d.ts": {
            "lines": 24,
            "tokens": 25,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2024.promise.d.ts": {
            "lines": 34,
            "tokens": 93,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 34,
            "duplicatedTokens": 93,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2024.object.d.ts": {
            "lines": 28,
            "tokens": 79,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2024.full.d.ts": {
            "lines": 23,
            "tokens": 17,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2024.d.ts": {
            "lines": 25,
            "tokens": 21,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2024.collection.d.ts": {
            "lines": 28,
            "tokens": 73,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2024.arraybuffer.d.ts": {
            "lines": 64,
            "tokens": 150,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 64,
            "duplicatedTokens": 150,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2023.intl.d.ts": {
            "lines": 55,
            "tokens": 546,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 55,
            "duplicatedTokens": 546,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2023.full.d.ts": {
            "lines": 23,
            "tokens": 17,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2023.d.ts": {
            "lines": 21,
            "tokens": 13,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2023.collection.d.ts": {
            "lines": 20,
            "tokens": 20,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2023.array.d.ts": {
            "lines": 923,
            "tokens": 3678,
            "sources": 1,
            "clones": 20,
            "duplicatedLines": 1755,
            "duplicatedTokens": 7418,
            "percentage": 190.14,
            "percentageTokens": 201.69,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2022.string.d.ts": {
            "lines": 24,
            "tokens": 33,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2022.regexp.d.ts": {
            "lines": 38,
            "tokens": 108,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 38,
            "duplicatedTokens": 108,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2022.object.d.ts": {
            "lines": 25,
            "tokens": 35,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2022.intl.d.ts": {
            "lines": 144,
            "tokens": 417,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 144,
            "duplicatedTokens": 417,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2022.full.d.ts": {
            "lines": 23,
            "tokens": 17,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2022.error.d.ts": {
            "lines": 74,
            "tokens": 481,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 74,
            "duplicatedTokens": 481,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2022.d.ts": {
            "lines": 24,
            "tokens": 19,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2022.array.d.ts": {
            "lines": 120,
            "tokens": 464,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 120,
            "duplicatedTokens": 464,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2021.weakref.d.ts": {
            "lines": 77,
            "tokens": 250,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 77,
            "duplicatedTokens": 250,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2021.string.d.ts": {
            "lines": 32,
            "tokens": 84,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 32,
            "duplicatedTokens": 84,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2021.promise.d.ts": {
            "lines": 47,
            "tokens": 186,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 47,
            "duplicatedTokens": 186,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2021.intl.d.ts": {
            "lines": 165,
            "tokens": 697,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 165,
            "duplicatedTokens": 697,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2021.full.d.ts": {
            "lines": 23,
            "tokens": 17,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2021.d.ts": {
            "lines": 22,
            "tokens": 15,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2020.symbol.wellknown.d.ts": {
            "lines": 40,
            "tokens": 105,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 40,
            "duplicatedTokens": 105,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2020.string.d.ts": {
            "lines": 43,
            "tokens": 114,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 43,
            "duplicatedTokens": 114,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2020.sharedmemory.d.ts": {
            "lines": 98,
            "tokens": 446,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 98,
            "duplicatedTokens": 446,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2020.promise.d.ts": {
            "lines": 46,
            "tokens": 183,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 46,
            "duplicatedTokens": 183,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2020.number.d.ts": {
            "lines": 27,
            "tokens": 44,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2020.intl.d.ts": {
            "lines": 473,
            "tokens": 1942,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 473,
            "duplicatedTokens": 1942,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2020.full.d.ts": {
            "lines": 23,
            "tokens": 17,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2020.date.d.ts": {
            "lines": 41,
            "tokens": 102,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 41,
            "duplicatedTokens": 102,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2020.d.ts": {
            "lines": 26,
            "tokens": 23,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2020.bigint.d.ts": {
            "lines": 764,
            "tokens": 3817,
            "sources": 1,
            "clones": 9,
            "duplicatedLines": 998,
            "duplicatedTokens": 4753,
            "percentage": 130.63,
            "percentageTokens": 124.52,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2019.symbol.d.ts": {
            "lines": 23,
            "tokens": 29,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2019.string.d.ts": {
            "lines": 36,
            "tokens": 64,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2019.object.d.ts": {
            "lines": 32,
            "tokens": 86,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 32,
            "duplicatedTokens": 86,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2019.intl.d.ts": {
            "lines": 22,
            "tokens": 32,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2019.full.d.ts": {
            "lines": 23,
            "tokens": 17,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2019.d.ts": {
            "lines": 23,
            "tokens": 17,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2019.array.d.ts": {
            "lines": 78,
            "tokens": 431,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 130,
            "duplicatedTokens": 701,
            "percentage": 166.67,
            "percentageTokens": 162.65,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2018.regexp.d.ts": {
            "lines": 36,
            "tokens": 89,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2018.promise.d.ts": {
            "lines": 29,
            "tokens": 53,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2018.intl.d.ts": {
            "lines": 82,
            "tokens": 551,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 82,
            "duplicatedTokens": 551,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2018.full.d.ts": {
            "lines": 23,
            "tokens": 17,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2018.d.ts": {
            "lines": 23,
            "tokens": 17,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2018.asynciterable.d.ts": {
            "lines": 52,
            "tokens": 319,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 52,
            "duplicatedTokens": 319,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2018.asyncgenerator.d.ts": {
            "lines": 76,
            "tokens": 321,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 76,
            "duplicatedTokens": 321,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2017.typedarrays.d.ts": {
            "lines": 52,
            "tokens": 202,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 52,
            "duplicatedTokens": 202,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2017.string.d.ts": {
            "lines": 44,
            "tokens": 60,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2017.sharedmemory.d.ts": {
            "lines": 134,
            "tokens": 873,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 134,
            "duplicatedTokens": 873,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2017.object.d.ts": {
            "lines": 48,
            "tokens": 205,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 48,
            "duplicatedTokens": 205,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2017.intl.d.ts": {
            "lines": 43,
            "tokens": 171,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 43,
            "duplicatedTokens": 171,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2017.full.d.ts": {
            "lines": 22,
            "tokens": 15,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2017.date.d.ts": {
            "lines": 30,
            "tokens": 71,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2017.d.ts": {
            "lines": 25,
            "tokens": 21,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2017.arraybuffer.d.ts": {
            "lines": 20,
            "tokens": 23,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2016.intl.d.ts": {
            "lines": 30,
            "tokens": 44,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2016.full.d.ts": {
            "lines": 22,
            "tokens": 15,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2016.d.ts": {
            "lines": 20,
            "tokens": 11,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2016.array.include.d.ts": {
            "lines": 115,
            "tokens": 425,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 115,
            "duplicatedTokens": 425,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2015.symbol.wellknown.d.ts": {
            "lines": 325,
            "tokens": 1501,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 325,
            "duplicatedTokens": 1501,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2015.symbol.d.ts": {
            "lines": 45,
            "tokens": 95,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 45,
            "duplicatedTokens": 95,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2015.reflect.d.ts": {
            "lines": 143,
            "tokens": 684,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 143,
            "duplicatedTokens": 684,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2015.proxy.d.ts": {
            "lines": 127,
            "tokens": 494,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 127,
            "duplicatedTokens": 494,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2015.promise.d.ts": {
            "lines": 80,
            "tokens": 319,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 80,
            "duplicatedTokens": 319,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2015.iterable.d.ts": {
            "lines": 604,
            "tokens": 3284,
            "sources": 1,
            "clones": 21,
            "duplicatedLines": 986,
            "duplicatedTokens": 4974,
            "percentage": 163.25,
            "percentageTokens": 151.46,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2015.generator.d.ts": {
            "lines": 76,
            "tokens": 308,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 76,
            "duplicatedTokens": 308,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2015.d.ts": {
            "lines": 27,
            "tokens": 25,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2015.core.d.ts": {
            "lines": 596,
            "tokens": 2319,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 596,
            "duplicatedTokens": 2319,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.es2015.collection.d.ts": {
            "lines": 146,
            "tokens": 945,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 146,
            "duplicatedTokens": 945,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.dom.iterable.d.ts": {
            "lines": 570,
            "tokens": 5144,
            "sources": 1,
            "clones": 9,
            "duplicatedLines": 892,
            "duplicatedTokens": 8736,
            "percentage": 156.49,
            "percentageTokens": 169.83,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.dom.asynciterable.d.ts": {
            "lines": 40,
            "tokens": 218,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 60,
            "duplicatedTokens": 425,
            "percentage": 150,
            "percentageTokens": 194.95,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.decorators.legacy.d.ts": {
            "lines": 21,
            "tokens": 155,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 21,
            "duplicatedTokens": 155,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.decorators.d.ts": {
            "lines": 383,
            "tokens": 1317,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 383,
            "duplicatedTokens": 1317,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/typescript/lib/lib.d.ts": {
            "lines": 21,
            "tokens": 13,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv-formats/src/limit.ts": {
            "lines": 98,
            "tokens": 1037,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv-formats/src/index.ts": {
            "lines": 61,
            "tokens": 603,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv-formats/src/formats.ts": {
            "lines": 268,
            "tokens": 2919,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv-formats/dist/limit.d.ts": {
            "lines": 9,
            "tokens": 126,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv-formats/dist/index.d.ts": {
            "lines": 14,
            "tokens": 171,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv-formats/dist/formats.d.ts": {
            "lines": 8,
            "tokens": 203,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/jtd.ts": {
            "lines": 131,
            "tokens": 1141,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 26,
            "duplicatedTokens": 122,
            "percentage": 19.85,
            "percentageTokens": 10.69,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/core.ts": {
            "lines": 890,
            "tokens": 8936,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/ajv.ts": {
            "lines": 69,
            "tokens": 564,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 49,
            "duplicatedTokens": 365,
            "percentage": 71.01,
            "percentageTokens": 64.72,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/2020.ts": {
            "lines": 74,
            "tokens": 584,
            "sources": 1,
            "clones": 4,
            "duplicatedLines": 62,
            "duplicatedTokens": 559,
            "percentage": 83.78,
            "percentageTokens": 95.72,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/lib/2019.ts": {
            "lines": 80,
            "tokens": 632,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 39,
            "duplicatedTokens": 316,
            "percentage": 48.75,
            "percentageTokens": 50,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/jtd.d.ts": {
            "lines": 46,
            "tokens": 644,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/core.d.ts": {
            "lines": 172,
            "tokens": 2444,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/ajv.d.ts": {
            "lines": 17,
            "tokens": 312,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/2020.d.ts": {
            "lines": 18,
            "tokens": 327,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 10,
            "duplicatedTokens": 229,
            "percentage": 55.56,
            "percentageTokens": 70.03,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/ajv/dist/2019.d.ts": {
            "lines": 18,
            "tokens": 327,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 10,
            "duplicatedTokens": 229,
            "percentage": 55.56,
            "percentageTokens": 70.03,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/zlib.d.ts": {
            "lines": 539,
            "tokens": 3289,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/worker_threads.d.ts": {
            "lines": 714,
            "tokens": 3455,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/wasi.d.ts": {
            "lines": 180,
            "tokens": 259,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/v8.d.ts": {
            "lines": 808,
            "tokens": 1587,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/url.d.ts": {
            "lines": 963,
            "tokens": 1776,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/tty.d.ts": {
            "lines": 207,
            "tokens": 759,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/trace_events.d.ts": {
            "lines": 196,
            "tokens": 149,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/timers.d.ts": {
            "lines": 285,
            "tokens": 940,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/string_decoder.d.ts": {
            "lines": 66,
            "tokens": 96,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/sea.d.ts": {
            "lines": 152,
            "tokens": 130,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/repl.d.ts": {
            "lines": 429,
            "tokens": 2364,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/readline.d.ts": {
            "lines": 588,
            "tokens": 2430,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/querystring.d.ts": {
            "lines": 151,
            "tokens": 348,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/punycode.d.ts": {
            "lines": 116,
            "tokens": 174,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/perf_hooks.d.ts": {
            "lines": 960,
            "tokens": 2443,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/path.d.ts": {
            "lines": 199,
            "tokens": 625,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/os.d.ts": {
            "lines": 505,
            "tokens": 2195,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/module.d.ts": {
            "lines": 538,
            "tokens": 1901,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/index.d.ts": {
            "lines": 92,
            "tokens": 135,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/https.d.ts": {
            "lines": 577,
            "tokens": 4760,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/globals.typedarray.d.ts": {
            "lines": 37,
            "tokens": 356,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/globals.d.ts": {
            "lines": 171,
            "tokens": 1239,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/events.d.ts": {
            "lines": 976,
            "tokens": 2083,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/domain.d.ts": {
            "lines": 169,
            "tokens": 244,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/dns.d.ts": {
            "lines": 870,
            "tokens": 4561,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 41,
            "duplicatedTokens": 201,
            "percentage": 4.71,
            "percentageTokens": 4.41,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/diagnostics_channel.d.ts": {
            "lines": 577,
            "tokens": 1227,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/dgram.d.ts": {
            "lines": 596,
            "tokens": 2334,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/constants.d.ts": {
            "lines": 20,
            "tokens": 137,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/console.d.ts": {
            "lines": 451,
            "tokens": 742,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/cluster.d.ts": {
            "lines": 576,
            "tokens": 3596,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/buffer.buffer.d.ts": {
            "lines": 470,
            "tokens": 632,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/@types/node/async_hooks.d.ts": {
            "lines": 604,
            "tokens": 1312,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/extractors/vitest/index.d.ts": {
            "lines": 16,
            "tokens": 36,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/extractors/typescript/index.d.ts": {
            "lines": 16,
            "tokens": 36,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/extractors/tap/index.d.ts": {
            "lines": 22,
            "tokens": 89,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/extractors/playwright/index.d.ts": {
            "lines": 16,
            "tokens": 36,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/extractors/mocha/index.d.ts": {
            "lines": 16,
            "tokens": 36,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/extractors/maven-surefire/index.d.ts": {
            "lines": 22,
            "tokens": 89,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/extractors/maven-compiler/index.d.ts": {
            "lines": 22,
            "tokens": 89,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/extractors/maven-checkstyle/index.d.ts": {
            "lines": 22,
            "tokens": 89,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/extractors/junit/index.d.ts": {
            "lines": 17,
            "tokens": 36,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/extractors/jest/index.d.ts": {
            "lines": 16,
            "tokens": 36,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/extractors/jasmine/index.d.ts": {
            "lines": 16,
            "tokens": 36,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/extractors/generic/index.d.ts": {
            "lines": 29,
            "tokens": 89,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/extractors/eslint/index.d.ts": {
            "lines": 17,
            "tokens": 36,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/extractors/ava/index.d.ts": {
            "lines": 22,
            "tokens": 89,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/test/helpers/schema-helpers.ts": {
            "lines": 74,
            "tokens": 257,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/test/helpers/assertion-helpers.ts": {
            "lines": 82,
            "tokens": 573,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/utils/test-framework-utils.ts": {
            "lines": 108,
            "tokens": 559,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/utils/guidance-generator.ts": {
            "lines": 147,
            "tokens": 614,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/utils/formatter-utils.ts": {
            "lines": 41,
            "tokens": 173,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/scripts/generate-result-schema.ts": {
            "lines": 26,
            "tokens": 169,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/zod-to-json-schema/createIndex.ts": {
            "lines": 31,
            "tokens": 256,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 31,
            "duplicatedTokens": 256,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/node_modules/vitest/globals.d.ts": {
            "lines": 19,
            "tokens": 283,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/utils/test-framework-utils.d.ts": {
            "lines": 38,
            "tokens": 98,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/utils/guidance-generator.d.ts": {
            "lines": 76,
            "tokens": 134,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/utils/formatter-utils.d.ts": {
            "lines": 28,
            "tokens": 39,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/scripts/generate-result-schema.d.ts": {
            "lines": 9,
            "tokens": 19,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/test/utils.test.ts": {
            "lines": 175,
            "tokens": 1333,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/test/test-helpers.ts": {
            "lines": 104,
            "tokens": 570,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/test/smart-extractor-fallback.test.ts": {
            "lines": 227,
            "tokens": 1353,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/test/sandboxed-extractor.test.ts": {
            "lines": 410,
            "tokens": 3568,
            "sources": 1,
            "clones": 14,
            "duplicatedLines": 260,
            "duplicatedTokens": 2080,
            "percentage": 63.41,
            "percentageTokens": 58.3,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/test/sandbox.test.ts": {
            "lines": 466,
            "tokens": 2415,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/test/sample-types.ts": {
            "lines": 163,
            "tokens": 859,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/test/sample-loader.ts": {
            "lines": 274,
            "tokens": 2278,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/test/sample-harness.test.ts": {
            "lines": 170,
            "tokens": 1517,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/test/registry-integration.test.ts": {
            "lines": 405,
            "tokens": 3433,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/test/plugin-loader.test.ts": {
            "lines": 172,
            "tokens": 1425,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/test/generate-quality-report.ts": {
            "lines": 327,
            "tokens": 3030,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/utils.ts": {
            "lines": 66,
            "tokens": 231,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/types.ts": {
            "lines": 154,
            "tokens": 494,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 79,
            "duplicatedTokens": 320,
            "percentage": 51.3,
            "percentageTokens": 64.78,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/smart-extractor.ts": {
            "lines": 287,
            "tokens": 1235,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/sandboxed-extractor.ts": {
            "lines": 204,
            "tokens": 1108,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/sandbox.ts": {
            "lines": 365,
            "tokens": 1553,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/result-schema.ts": {
            "lines": 177,
            "tokens": 876,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 31,
            "duplicatedTokens": 209,
            "percentage": 17.51,
            "percentageTokens": 23.86,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/result-schema-export.ts": {
            "lines": 38,
            "tokens": 99,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/plugin-loader.ts": {
            "lines": 255,
            "tokens": 1913,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/maven-utils.ts": {
            "lines": 37,
            "tokens": 144,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/index.ts": {
            "lines": 108,
            "tokens": 569,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 14,
            "duplicatedTokens": 238,
            "percentage": 12.96,
            "percentageTokens": 41.83,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/src/extractor-registry.ts": {
            "lines": 320,
            "tokens": 2088,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 55,
            "duplicatedTokens": 147,
            "percentage": 17.19,
            "percentageTokens": 7.04,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/vitest-extractor.d.ts": {
            "lines": 37,
            "tokens": 67,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/utils.d.ts": {
            "lines": 38,
            "tokens": 44,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/typescript-extractor.d.ts": {
            "lines": 24,
            "tokens": 37,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/types.d.ts": {
            "lines": 134,
            "tokens": 474,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 79,
            "duplicatedTokens": 320,
            "percentage": 58.96,
            "percentageTokens": 67.51,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/tap-extractor.d.ts": {
            "lines": 23,
            "tokens": 37,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/smart-extractor.d.ts": {
            "lines": 54,
            "tokens": 51,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/sandboxed-extractor.d.ts": {
            "lines": 45,
            "tokens": 126,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/sandbox.d.ts": {
            "lines": 160,
            "tokens": 400,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/result-schema.d.ts": {
            "lines": 348,
            "tokens": 2520,
            "sources": 1,
            "clones": 13,
            "duplicatedLines": 328,
            "duplicatedTokens": 2760,
            "percentage": 94.25,
            "percentageTokens": 109.52,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/result-schema-export.d.ts": {
            "lines": 28,
            "tokens": 32,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/plugin-loader.d.ts": {
            "lines": 81,
            "tokens": 325,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/playwright-extractor.d.ts": {
            "lines": 37,
            "tokens": 57,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/mocha-extractor.d.ts": {
            "lines": 22,
            "tokens": 37,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/maven-utils.d.ts": {
            "lines": 23,
            "tokens": 22,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/maven-surefire-extractor.d.ts": {
            "lines": 19,
            "tokens": 89,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/maven-compiler-extractor.d.ts": {
            "lines": 19,
            "tokens": 89,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/maven-checkstyle-extractor.d.ts": {
            "lines": 19,
            "tokens": 89,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/junit-extractor.d.ts": {
            "lines": 23,
            "tokens": 37,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/jest-extractor.d.ts": {
            "lines": 28,
            "tokens": 37,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/jasmine-extractor.d.ts": {
            "lines": 22,
            "tokens": 37,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/index.d.ts": {
            "lines": 54,
            "tokens": 513,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 14,
            "duplicatedTokens": 238,
            "percentage": 25.93,
            "percentageTokens": 46.39,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/generic-extractor.d.ts": {
            "lines": 34,
            "tokens": 37,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/extractor-registry.d.ts": {
            "lines": 103,
            "tokens": 342,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 55,
            "duplicatedTokens": 147,
            "percentage": 53.4,
            "percentageTokens": 42.98,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/eslint-extractor.d.ts": {
            "lines": 24,
            "tokens": 37,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/dist/ava-extractor.d.ts": {
            "lines": 23,
            "tokens": 37,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/extractors/test-generic-baseline.ts": {
            "lines": 49,
            "tokens": 563,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/core/tests/locales/tr.test.ts": {
            "lines": 68,
            "tokens": 1087,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 68,
            "duplicatedTokens": 1087,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/core/tests/locales/ru.test.ts": {
            "lines": 127,
            "tokens": 1267,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 127,
            "duplicatedTokens": 1267,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/core/tests/locales/en.test.ts": {
            "lines": 21,
            "tokens": 294,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 21,
            "duplicatedTokens": 294,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/core/tests/locales/be.test.ts": {
            "lines": 123,
            "tokens": 1263,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 123,
            "duplicatedTokens": 1263,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/mini/tests/string.test.ts": {
            "lines": 298,
            "tokens": 3744,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 298,
            "duplicatedTokens": 3744,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/mini/tests/recursive-types.test.ts": {
            "lines": 274,
            "tokens": 2264,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 274,
            "duplicatedTokens": 2264,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/mini/tests/prototypes.test.ts": {
            "lines": 42,
            "tokens": 292,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 42,
            "duplicatedTokens": 292,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/mini/tests/object.test.ts": {
            "lines": 184,
            "tokens": 2129,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 184,
            "duplicatedTokens": 2129,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/mini/tests/number.test.ts": {
            "lines": 94,
            "tokens": 1597,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 94,
            "duplicatedTokens": 1597,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/mini/tests/index.test.ts": {
            "lines": 870,
            "tokens": 12625,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 870,
            "duplicatedTokens": 12625,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/mini/tests/functions.test.ts": {
            "lines": 42,
            "tokens": 112,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 42,
            "duplicatedTokens": 112,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/mini/tests/error.test.ts": {
            "lines": 21,
            "tokens": 240,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 21,
            "duplicatedTokens": 240,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/mini/tests/computed.test.ts": {
            "lines": 35,
            "tokens": 519,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 35,
            "duplicatedTokens": 519,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/mini/tests/checks.test.ts": {
            "lines": 143,
            "tokens": 1857,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 143,
            "duplicatedTokens": 1857,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/mini/tests/brand.test.ts": {
            "lines": 50,
            "tokens": 618,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 50,
            "duplicatedTokens": 618,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/mini/tests/assignability.test.ts": {
            "lines": 128,
            "tokens": 1147,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 128,
            "duplicatedTokens": 1147,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/core/tests/index.test.ts": {
            "lines": 45,
            "tokens": 301,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 45,
            "duplicatedTokens": 301,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/void.test.ts": {
            "lines": 11,
            "tokens": 146,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 11,
            "duplicatedTokens": 146,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/validations.test.ts": {
            "lines": 282,
            "tokens": 1170,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 282,
            "duplicatedTokens": 1170,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/union.test.ts": {
            "lines": 93,
            "tokens": 785,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 93,
            "duplicatedTokens": 785,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/tuple.test.ts": {
            "lines": 162,
            "tokens": 1438,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 162,
            "duplicatedTokens": 1438,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/transform.test.ts": {
            "lines": 249,
            "tokens": 2046,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 249,
            "duplicatedTokens": 2046,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/template-literal.test.ts": {
            "lines": 757,
            "tokens": 9329,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 757,
            "duplicatedTokens": 9329,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/stringbool.test.ts": {
            "lines": 65,
            "tokens": 998,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 65,
            "duplicatedTokens": 998,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/string.test.ts": {
            "lines": 880,
            "tokens": 7686,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 880,
            "duplicatedTokens": 7686,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/string-formats.test.ts": {
            "lines": 108,
            "tokens": 619,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 108,
            "duplicatedTokens": 619,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/standard-schema.test.ts": {
            "lines": 56,
            "tokens": 326,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 56,
            "duplicatedTokens": 326,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/set.test.ts": {
            "lines": 178,
            "tokens": 1754,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 178,
            "duplicatedTokens": 1754,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/registries.test.ts": {
            "lines": 203,
            "tokens": 2192,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 203,
            "duplicatedTokens": 2192,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/refine.test.ts": {
            "lines": 531,
            "tokens": 3602,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 531,
            "duplicatedTokens": 3602,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/recursive-types.test.ts": {
            "lines": 355,
            "tokens": 2976,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 355,
            "duplicatedTokens": 2976,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/record.test.ts": {
            "lines": 341,
            "tokens": 2072,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 341,
            "duplicatedTokens": 2072,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/readonly.test.ts": {
            "lines": 251,
            "tokens": 3281,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 251,
            "duplicatedTokens": 3281,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/prototypes.test.ts": {
            "lines": 22,
            "tokens": 160,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 22,
            "duplicatedTokens": 160,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/promise.test.ts": {
            "lines": 80,
            "tokens": 855,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 80,
            "duplicatedTokens": 855,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/primitive.test.ts": {
            "lines": 174,
            "tokens": 2595,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 174,
            "duplicatedTokens": 2595,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/preprocess.test.ts": {
            "lines": 297,
            "tokens": 1524,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 297,
            "duplicatedTokens": 1524,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/prefault.test.ts": {
            "lines": 36,
            "tokens": 413,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 36,
            "duplicatedTokens": 413,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/pipe.test.ts": {
            "lines": 80,
            "tokens": 567,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 80,
            "duplicatedTokens": 567,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/pickomit.test.ts": {
            "lines": 126,
            "tokens": 1858,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 126,
            "duplicatedTokens": 1858,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/partial.test.ts": {
            "lines": 146,
            "tokens": 1760,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 146,
            "duplicatedTokens": 1760,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/optional.test.ts": {
            "lines": 122,
            "tokens": 1615,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 122,
            "duplicatedTokens": 1615,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/object.test.ts": {
            "lines": 562,
            "tokens": 6473,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 562,
            "duplicatedTokens": 6473,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/number.test.ts": {
            "lines": 246,
            "tokens": 2797,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 246,
            "duplicatedTokens": 2797,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/nullable.test.ts": {
            "lines": 21,
            "tokens": 254,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 21,
            "duplicatedTokens": 254,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/nonoptional.test.ts": {
            "lines": 85,
            "tokens": 509,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 85,
            "duplicatedTokens": 509,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/nested-refine.test.ts": {
            "lines": 167,
            "tokens": 367,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 167,
            "duplicatedTokens": 367,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/nan.test.ts": {
            "lines": 20,
            "tokens": 271,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 20,
            "duplicatedTokens": 271,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/map.test.ts": {
            "lines": 195,
            "tokens": 1149,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 195,
            "duplicatedTokens": 1149,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/literal.test.ts": {
            "lines": 91,
            "tokens": 750,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 91,
            "duplicatedTokens": 750,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/lazy.test.ts": {
            "lines": 226,
            "tokens": 2061,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 226,
            "duplicatedTokens": 2061,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/json.test.ts": {
            "lines": 107,
            "tokens": 230,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 107,
            "duplicatedTokens": 230,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/intersection.test.ts": {
            "lines": 170,
            "tokens": 1891,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 170,
            "duplicatedTokens": 1891,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/instanceof.test.ts": {
            "lines": 33,
            "tokens": 406,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 33,
            "duplicatedTokens": 406,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/index.test.ts": {
            "lines": 828,
            "tokens": 12192,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 828,
            "duplicatedTokens": 12192,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/generics.test.ts": {
            "lines": 71,
            "tokens": 717,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 71,
            "duplicatedTokens": 717,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/function.test.ts": {
            "lines": 267,
            "tokens": 2118,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 267,
            "duplicatedTokens": 2118,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/firstparty.test.ts": {
            "lines": 174,
            "tokens": 962,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 174,
            "duplicatedTokens": 962,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/file.test.ts": {
            "lines": 90,
            "tokens": 492,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 90,
            "duplicatedTokens": 492,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/error.test.ts": {
            "lines": 710,
            "tokens": 5148,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 710,
            "duplicatedTokens": 5148,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/error-utils.test.ts": {
            "lines": 526,
            "tokens": 2377,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 526,
            "duplicatedTokens": 2377,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/enum.test.ts": {
            "lines": 284,
            "tokens": 2708,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 284,
            "duplicatedTokens": 2708,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/discriminated-unions.test.ts": {
            "lines": 618,
            "tokens": 5470,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 618,
            "duplicatedTokens": 5470,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/description.test.ts": {
            "lines": 31,
            "tokens": 228,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 31,
            "duplicatedTokens": 228,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/default.test.ts": {
            "lines": 312,
            "tokens": 2281,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 312,
            "duplicatedTokens": 2281,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/datetime.test.ts": {
            "lines": 295,
            "tokens": 3809,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 295,
            "duplicatedTokens": 3809,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/date.test.ts": {
            "lines": 30,
            "tokens": 323,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 30,
            "duplicatedTokens": 323,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/custom.test.ts": {
            "lines": 39,
            "tokens": 381,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 39,
            "duplicatedTokens": 381,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/continuability.test.ts": {
            "lines": 351,
            "tokens": 737,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 351,
            "duplicatedTokens": 737,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/coerce.test.ts": {
            "lines": 159,
            "tokens": 2478,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 159,
            "duplicatedTokens": 2478,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/coalesce.test.ts": {
            "lines": 19,
            "tokens": 70,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/catch.test.ts": {
            "lines": 251,
            "tokens": 2387,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 251,
            "duplicatedTokens": 2387,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/brand.test.ts": {
            "lines": 62,
            "tokens": 773,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 62,
            "duplicatedTokens": 773,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/bigint.test.ts": {
            "lines": 53,
            "tokens": 859,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 53,
            "duplicatedTokens": 859,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/async-refinements.test.ts": {
            "lines": 67,
            "tokens": 605,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 67,
            "duplicatedTokens": 605,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/async-parsing.test.ts": {
            "lines": 380,
            "tokens": 3955,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 380,
            "duplicatedTokens": 3955,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/assignability.test.ts": {
            "lines": 209,
            "tokens": 2601,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 209,
            "duplicatedTokens": 2601,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/array.test.ts": {
            "lines": 263,
            "tokens": 1066,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 263,
            "duplicatedTokens": 1066,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/tests/anyunknown.test.ts": {
            "lines": 25,
            "tokens": 285,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 25,
            "duplicatedTokens": 285,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod-to-json-schema/dist/types/parsers/union.d.ts": {
            "lines": 22,
            "tokens": 272,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 22,
            "duplicatedTokens": 272,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod-to-json-schema/dist/types/parsers/tuple.d.ts": {
            "lines": 12,
            "tokens": 147,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 12,
            "duplicatedTokens": 147,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod-to-json-schema/dist/types/parsers/string.d.ts": {
            "lines": 72,
            "tokens": 415,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 72,
            "duplicatedTokens": 415,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod-to-json-schema/dist/types/parsers/set.d.ts": {
            "lines": 12,
            "tokens": 136,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 12,
            "duplicatedTokens": 136,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod-to-json-schema/dist/types/parsers/record.d.ts": {
            "lines": 12,
            "tokens": 174,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 12,
            "duplicatedTokens": 174,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod-to-json-schema/dist/types/parsers/object.d.ts": {
            "lines": 9,
            "tokens": 116,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod-to-json-schema/dist/types/parsers/number.d.ts": {
            "lines": 12,
            "tokens": 136,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 12,
            "duplicatedTokens": 136,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod-to-json-schema/dist/types/parsers/nullable.d.ts": {
            "lines": 9,
            "tokens": 121,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod-to-json-schema/dist/types/parsers/map.d.ts": {
            "lines": 14,
            "tokens": 148,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 14,
            "duplicatedTokens": 148,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod-to-json-schema/dist/types/parsers/literal.d.ts": {
            "lines": 8,
            "tokens": 112,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod-to-json-schema/dist/types/parsers/date.d.ts": {
            "lines": 14,
            "tokens": 175,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 14,
            "duplicatedTokens": 175,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod-to-json-schema/dist/types/parsers/bigint.d.ts": {
            "lines": 13,
            "tokens": 139,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 13,
            "duplicatedTokens": 139,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod-to-json-schema/dist/types/parsers/array.d.ts": {
            "lines": 11,
            "tokens": 132,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 11,
            "duplicatedTokens": 132,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/mini/iso.ts": {
            "lines": 61,
            "tokens": 608,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 61,
            "duplicatedTokens": 608,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/mini/external.ts": {
            "lines": 39,
            "tokens": 212,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 39,
            "duplicatedTokens": 212,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/mini/coerce.ts": {
            "lines": 21,
            "tokens": 344,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 21,
            "duplicatedTokens": 344,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/mini/checks.ts": {
            "lines": 31,
            "tokens": 249,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 31,
            "duplicatedTokens": 249,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/zh-TW.ts": {
            "lines": 124,
            "tokens": 1325,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 124,
            "duplicatedTokens": 1325,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/zh-CN.ts": {
            "lines": 122,
            "tokens": 1300,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 122,
            "duplicatedTokens": 1300,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/vi.ts": {
            "lines": 124,
            "tokens": 1314,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 124,
            "duplicatedTokens": 1314,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/ur.ts": {
            "lines": 125,
            "tokens": 1326,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 125,
            "duplicatedTokens": 1326,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/ua.ts": {
            "lines": 125,
            "tokens": 1336,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 125,
            "duplicatedTokens": 1336,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/tr.ts": {
            "lines": 120,
            "tokens": 1313,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 120,
            "duplicatedTokens": 1313,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/th.ts": {
            "lines": 125,
            "tokens": 1311,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 125,
            "duplicatedTokens": 1311,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/ta.ts": {
            "lines": 124,
            "tokens": 1327,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 124,
            "duplicatedTokens": 1327,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/sv.ts": {
            "lines": 126,
            "tokens": 1347,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 126,
            "duplicatedTokens": 1347,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/sl.ts": {
            "lines": 125,
            "tokens": 1326,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 125,
            "duplicatedTokens": 1326,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/ru.ts": {
            "lines": 183,
            "tokens": 1736,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 183,
            "duplicatedTokens": 1736,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/pt.ts": {
            "lines": 122,
            "tokens": 1338,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 122,
            "duplicatedTokens": 1338,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/ps.ts": {
            "lines": 132,
            "tokens": 1353,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 132,
            "duplicatedTokens": 1353,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/pl.ts": {
            "lines": 125,
            "tokens": 1338,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 125,
            "duplicatedTokens": 1338,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/ota.ts": {
            "lines": 124,
            "tokens": 1323,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 124,
            "duplicatedTokens": 1323,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/no.ts": {
            "lines": 123,
            "tokens": 1320,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 123,
            "duplicatedTokens": 1320,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/nl.ts": {
            "lines": 125,
            "tokens": 1290,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 125,
            "duplicatedTokens": 1290,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/ms.ts": {
            "lines": 123,
            "tokens": 1313,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 123,
            "duplicatedTokens": 1313,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/mk.ts": {
            "lines": 126,
            "tokens": 1329,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 126,
            "duplicatedTokens": 1329,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/ko.ts": {
            "lines": 130,
            "tokens": 1402,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 130,
            "duplicatedTokens": 1402,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/kh.ts": {
            "lines": 125,
            "tokens": 1311,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 125,
            "duplicatedTokens": 1311,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/ja.ts": {
            "lines": 121,
            "tokens": 1312,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 121,
            "duplicatedTokens": 1312,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/it.ts": {
            "lines": 124,
            "tokens": 1342,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 124,
            "duplicatedTokens": 1342,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/index.ts": {
            "lines": 38,
            "tokens": 661,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 38,
            "duplicatedTokens": 661,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/id.ts": {
            "lines": 124,
            "tokens": 1321,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 124,
            "duplicatedTokens": 1321,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/hu.ts": {
            "lines": 125,
            "tokens": 1324,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 125,
            "duplicatedTokens": 1324,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/he.ts": {
            "lines": 124,
            "tokens": 1342,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 124,
            "duplicatedTokens": 1342,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/fr.ts": {
            "lines": 123,
            "tokens": 1351,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 123,
            "duplicatedTokens": 1351,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/fr-CA.ts": {
            "lines": 125,
            "tokens": 1341,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 125,
            "duplicatedTokens": 1341,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/fi.ts": {
            "lines": 130,
            "tokens": 1383,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 130,
            "duplicatedTokens": 1383,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/fa.ts": {
            "lines": 133,
            "tokens": 1354,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 133,
            "duplicatedTokens": 1354,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/es.ts": {
            "lines": 124,
            "tokens": 1336,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 124,
            "duplicatedTokens": 1336,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/eo.ts": {
            "lines": 124,
            "tokens": 1340,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 124,
            "duplicatedTokens": 1340,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/en.ts": {
            "lines": 126,
            "tokens": 1327,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 126,
            "duplicatedTokens": 1327,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/de.ts": {
            "lines": 123,
            "tokens": 1320,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 123,
            "duplicatedTokens": 1320,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/cs.ts": {
            "lines": 141,
            "tokens": 1419,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 141,
            "duplicatedTokens": 1419,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/ca.ts": {
            "lines": 126,
            "tokens": 1354,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 126,
            "duplicatedTokens": 1354,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/be.ts": {
            "lines": 183,
            "tokens": 1729,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 183,
            "duplicatedTokens": 1729,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/az.ts": {
            "lines": 120,
            "tokens": 1313,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 120,
            "duplicatedTokens": 1313,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/locales/ar.ts": {
            "lines": 124,
            "tokens": 1344,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 124,
            "duplicatedTokens": 1344,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/core/zsf.ts": {
            "lines": 322,
            "tokens": 1236,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 322,
            "duplicatedTokens": 1236,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/core/util.ts": {
            "lines": 774,
            "tokens": 8783,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 774,
            "duplicatedTokens": 8783,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/core/to-json-schema.ts": {
            "lines": 976,
            "tokens": 9224,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 976,
            "duplicatedTokens": 9224,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/core/standard-schema.ts": {
            "lines": 63,
            "tokens": 471,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 63,
            "duplicatedTokens": 471,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/core/registries.ts": {
            "lines": 95,
            "tokens": 1113,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 95,
            "duplicatedTokens": 1113,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/core/regexes.ts": {
            "lines": 134,
            "tokens": 1471,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 134,
            "duplicatedTokens": 1471,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/core/parse.ts": {
            "lines": 93,
            "tokens": 1468,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 93,
            "duplicatedTokens": 1468,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/core/json-schema.ts": {
            "lines": 142,
            "tokens": 920,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 142,
            "duplicatedTokens": 920,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/core/index.ts": {
            "lines": 14,
            "tokens": 149,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 14,
            "duplicatedTokens": 149,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/core/function.ts": {
            "lines": 175,
            "tokens": 2025,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 175,
            "duplicatedTokens": 2025,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/core/errors.ts": {
            "lines": 423,
            "tokens": 4191,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 423,
            "duplicatedTokens": 4191,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/core/doc.ts": {
            "lines": 43,
            "tokens": 540,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 43,
            "duplicatedTokens": 540,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/core/core.ts": {
            "lines": 133,
            "tokens": 1256,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 133,
            "duplicatedTokens": 1256,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/core/config.ts": {
            "lines": 14,
            "tokens": 122,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 14,
            "duplicatedTokens": 122,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/parse.ts": {
            "lines": 32,
            "tokens": 490,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 32,
            "duplicatedTokens": 490,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/iso.ts": {
            "lines": 89,
            "tokens": 645,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 89,
            "duplicatedTokens": 645,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/external.ts": {
            "lines": 49,
            "tokens": 297,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 49,
            "duplicatedTokens": 297,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/errors.ts": {
            "lines": 74,
            "tokens": 640,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 74,
            "duplicatedTokens": 640,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/compat.ts": {
            "lines": 65,
            "tokens": 493,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 65,
            "duplicatedTokens": 493,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/coerce.ts": {
            "lines": 26,
            "tokens": 466,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 26,
            "duplicatedTokens": 466,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v4/classic/checks.ts": {
            "lines": 29,
            "tokens": 233,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 29,
            "duplicatedTokens": 233,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/void.test.ts": {
            "lines": 14,
            "tokens": 158,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 14,
            "duplicatedTokens": 158,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/validations.test.ts": {
            "lines": 132,
            "tokens": 1509,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 132,
            "duplicatedTokens": 1509,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/unions.test.ts": {
            "lines": 56,
            "tokens": 642,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 56,
            "duplicatedTokens": 642,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/tuple.test.ts": {
            "lines": 89,
            "tokens": 1024,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 89,
            "duplicatedTokens": 1024,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/transformer.test.ts": {
            "lines": 232,
            "tokens": 2188,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 232,
            "duplicatedTokens": 2188,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/string.test.ts": {
            "lines": 915,
            "tokens": 10044,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 915,
            "duplicatedTokens": 10044,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/standard-schema.test.ts": {
            "lines": 82,
            "tokens": 923,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 82,
            "duplicatedTokens": 923,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/set.test.ts": {
            "lines": 141,
            "tokens": 1843,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 141,
            "duplicatedTokens": 1843,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/safeparse.test.ts": {
            "lines": 26,
            "tokens": 235,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 26,
            "duplicatedTokens": 235,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/refine.test.ts": {
            "lines": 312,
            "tokens": 3112,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 312,
            "duplicatedTokens": 3112,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/recursive.test.ts": {
            "lines": 196,
            "tokens": 789,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 196,
            "duplicatedTokens": 789,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/record.test.ts": {
            "lines": 170,
            "tokens": 1320,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 170,
            "duplicatedTokens": 1320,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/readonly.test.ts": {
            "lines": 193,
            "tokens": 2163,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 193,
            "duplicatedTokens": 2163,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/promise.test.ts": {
            "lines": 89,
            "tokens": 896,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 89,
            "duplicatedTokens": 896,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/primitive.test.ts": {
            "lines": 439,
            "tokens": 4437,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 439,
            "duplicatedTokens": 4437,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/preprocess.test.ts": {
            "lines": 185,
            "tokens": 1583,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 185,
            "duplicatedTokens": 1583,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/pipeline.test.ts": {
            "lines": 28,
            "tokens": 341,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 28,
            "duplicatedTokens": 341,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/pickomit.test.ts": {
            "lines": 110,
            "tokens": 1492,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 110,
            "duplicatedTokens": 1492,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/partials.test.ts": {
            "lines": 242,
            "tokens": 2682,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 242,
            "duplicatedTokens": 2682,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/parser.test.ts": {
            "lines": 40,
            "tokens": 470,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 40,
            "duplicatedTokens": 470,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/parseUtil.test.ts": {
            "lines": 22,
            "tokens": 271,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 22,
            "duplicatedTokens": 271,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/optional.test.ts": {
            "lines": 41,
            "tokens": 509,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 41,
            "duplicatedTokens": 509,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/object.test.ts": {
            "lines": 433,
            "tokens": 4924,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 433,
            "duplicatedTokens": 4924,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/object-in-es5-env.test.ts": {
            "lines": 28,
            "tokens": 289,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 28,
            "duplicatedTokens": 289,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/object-augmentation.test.ts": {
            "lines": 28,
            "tokens": 218,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 28,
            "duplicatedTokens": 218,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/number.test.ts": {
            "lines": 175,
            "tokens": 2362,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 175,
            "duplicatedTokens": 2362,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/nullable.test.ts": {
            "lines": 41,
            "tokens": 509,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 41,
            "duplicatedTokens": 509,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/nativeEnum.test.ts": {
            "lines": 86,
            "tokens": 867,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 86,
            "duplicatedTokens": 867,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/nan.test.ts": {
            "lines": 20,
            "tokens": 250,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 20,
            "duplicatedTokens": 250,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/mocker.test.ts": {
            "lines": 18,
            "tokens": 124,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 18,
            "duplicatedTokens": 124,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/map.test.ts": {
            "lines": 109,
            "tokens": 1283,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 109,
            "duplicatedTokens": 1283,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/literal.test.ts": {
            "lines": 35,
            "tokens": 363,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 35,
            "duplicatedTokens": 363,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/language-server.test.ts": {
            "lines": 206,
            "tokens": 404,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 206,
            "duplicatedTokens": 404,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/language-server.source.ts": {
            "lines": 75,
            "tokens": 501,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 75,
            "duplicatedTokens": 501,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/intersection.test.ts": {
            "lines": 109,
            "tokens": 1178,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 109,
            "duplicatedTokens": 1178,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/instanceof.test.ts": {
            "lines": 36,
            "tokens": 420,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 36,
            "duplicatedTokens": 420,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/generics.test.ts": {
            "lines": 47,
            "tokens": 397,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 47,
            "duplicatedTokens": 397,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/function.test.ts": {
            "lines": 256,
            "tokens": 2756,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 256,
            "duplicatedTokens": 2756,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/firstpartyschematypes.test.ts": {
            "lines": 20,
            "tokens": 224,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 20,
            "duplicatedTokens": 224,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/firstparty.test.ts": {
            "lines": 86,
            "tokens": 621,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 86,
            "duplicatedTokens": 621,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/error.test.ts": {
            "lines": 550,
            "tokens": 5707,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 550,
            "duplicatedTokens": 5707,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/enum.test.ts": {
            "lines": 79,
            "tokens": 1022,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 79,
            "duplicatedTokens": 1022,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/discriminated-unions.test.ts": {
            "lines": 314,
            "tokens": 3661,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 314,
            "duplicatedTokens": 3661,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/description.test.ts": {
            "lines": 32,
            "tokens": 395,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 32,
            "duplicatedTokens": 395,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/default.test.ts": {
            "lines": 111,
            "tokens": 1302,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 111,
            "duplicatedTokens": 1302,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/deepmasking.test.ts": {
            "lines": 185,
            "tokens": 382,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 185,
            "duplicatedTokens": 382,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/date.test.ts": {
            "lines": 31,
            "tokens": 325,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 31,
            "duplicatedTokens": 325,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/custom.test.ts": {
            "lines": 30,
            "tokens": 370,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 30,
            "duplicatedTokens": 370,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/complex.test.ts": {
            "lines": 55,
            "tokens": 698,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 55,
            "duplicatedTokens": 698,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/coerce.test.ts": {
            "lines": 132,
            "tokens": 2372,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 132,
            "duplicatedTokens": 2372,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/catch.test.ts": {
            "lines": 219,
            "tokens": 2536,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 219,
            "duplicatedTokens": 2536,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/branded.test.ts": {
            "lines": 52,
            "tokens": 626,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 52,
            "duplicatedTokens": 626,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/bigint.test.ts": {
            "lines": 54,
            "tokens": 861,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 54,
            "duplicatedTokens": 861,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/base.test.ts": {
            "lines": 28,
            "tokens": 317,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 28,
            "duplicatedTokens": 317,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/async-refinements.test.ts": {
            "lines": 45,
            "tokens": 586,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 45,
            "duplicatedTokens": 586,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/async-parsing.test.ts": {
            "lines": 387,
            "tokens": 4223,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 387,
            "duplicatedTokens": 4223,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/array.test.ts": {
            "lines": 70,
            "tokens": 855,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 70,
            "duplicatedTokens": 855,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/anyunknown.test.ts": {
            "lines": 27,
            "tokens": 295,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 27,
            "duplicatedTokens": 295,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/all-errors.test.ts": {
            "lines": 156,
            "tokens": 1523,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 156,
            "duplicatedTokens": 1523,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/tests/Mocker.ts": {
            "lines": 53,
            "tokens": 559,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 53,
            "duplicatedTokens": 559,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/locales/en.ts": {
            "lines": 123,
            "tokens": 1230,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 123,
            "duplicatedTokens": 1230,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/helpers/util.ts": {
            "lines": 223,
            "tokens": 2528,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 223,
            "duplicatedTokens": 2528,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/helpers/partialUtil.ts": {
            "lines": 33,
            "tokens": 318,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 33,
            "duplicatedTokens": 318,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/helpers/parseUtil.ts": {
            "lines": 175,
            "tokens": 1943,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 175,
            "duplicatedTokens": 1943,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/helpers/enumUtil.ts": {
            "lines": 16,
            "tokens": 238,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 16,
            "duplicatedTokens": 238,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/benchmarks/union.ts": {
            "lines": 79,
            "tokens": 688,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 79,
            "duplicatedTokens": 688,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/benchmarks/string.ts": {
            "lines": 54,
            "tokens": 484,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 54,
            "duplicatedTokens": 484,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/benchmarks/realworld.ts": {
            "lines": 62,
            "tokens": 558,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 62,
            "duplicatedTokens": 558,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/benchmarks/primitives.ts": {
            "lines": 161,
            "tokens": 1440,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 161,
            "duplicatedTokens": 1440,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/benchmarks/object.ts": {
            "lines": 68,
            "tokens": 713,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 68,
            "duplicatedTokens": 713,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/benchmarks/ipv4.ts": {
            "lines": 56,
            "tokens": 473,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 56,
            "duplicatedTokens": 473,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/benchmarks/index.ts": {
            "lines": 58,
            "tokens": 486,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 58,
            "duplicatedTokens": 486,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/benchmarks/discriminatedUnion.ts": {
            "lines": 79,
            "tokens": 694,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 79,
            "duplicatedTokens": 694,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/benchmarks/datetime.ts": {
            "lines": 57,
            "tokens": 577,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 57,
            "duplicatedTokens": 577,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/schema/yaml-1.1/set.d.ts": {
            "lines": 27,
            "tokens": 390,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 27,
            "duplicatedTokens": 390,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/schema/yaml-1.1/pairs.d.ts": {
            "lines": 9,
            "tokens": 215,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/schema/yaml-1.1/omap.d.ts": {
            "lines": 21,
            "tokens": 245,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 21,
            "duplicatedTokens": 245,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/schema/yaml-1.1/merge.d.ts": {
            "lines": 8,
            "tokens": 150,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/tsx/dist/esm/api/index.d.mts": {
            "lines": 34,
            "tokens": 366,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 34,
            "duplicatedTokens": 366,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/tsx/dist/esm/api/index.d.cts": {
            "lines": 34,
            "tokens": 366,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 34,
            "duplicatedTokens": 366,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/tsx/dist/cjs/api/index.d.mts": {
            "lines": 34,
            "tokens": 382,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 34,
            "duplicatedTokens": 382,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/tsx/dist/cjs/api/index.d.cts": {
            "lines": 34,
            "tokens": 382,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 34,
            "duplicatedTokens": 382,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod-to-json-schema/dist/types/zodToJsonSchema.d.ts": {
            "lines": 9,
            "tokens": 185,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod-to-json-schema/dist/types/parseTypes.d.ts": {
            "lines": 33,
            "tokens": 469,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 33,
            "duplicatedTokens": 469,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod-to-json-schema/dist/types/index.d.ts": {
            "lines": 39,
            "tokens": 360,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 39,
            "duplicatedTokens": 360,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod-to-json-schema/dist/types/errorMessages.d.ts": {
            "lines": 14,
            "tokens": 261,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 14,
            "duplicatedTokens": 261,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod-to-json-schema/dist/types/Refs.d.ts": {
            "lines": 16,
            "tokens": 183,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 16,
            "duplicatedTokens": 183,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod-to-json-schema/dist/types/Options.d.ts": {
            "lines": 36,
            "tokens": 540,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 36,
            "duplicatedTokens": 540,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/mini/schemas.d.ts": {
            "lines": 355,
            "tokens": 7699,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 355,
            "duplicatedTokens": 7699,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/mini/schemas.d.cts": {
            "lines": 355,
            "tokens": 7699,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 355,
            "duplicatedTokens": 7699,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/mini/iso.d.ts": {
            "lines": 21,
            "tokens": 308,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 21,
            "duplicatedTokens": 308,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/mini/iso.d.cts": {
            "lines": 21,
            "tokens": 308,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 21,
            "duplicatedTokens": 308,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/mini/external.d.ts": {
            "lines": 10,
            "tokens": 182,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 10,
            "duplicatedTokens": 182,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/mini/external.d.cts": {
            "lines": 10,
            "tokens": 182,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 10,
            "duplicatedTokens": 182,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/locales/index.d.ts": {
            "lines": 38,
            "tokens": 661,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 38,
            "duplicatedTokens": 661,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/locales/index.d.cts": {
            "lines": 38,
            "tokens": 661,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 38,
            "duplicatedTokens": 661,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/core/util.d.ts": {
            "lines": 182,
            "tokens": 4164,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 182,
            "duplicatedTokens": 4164,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/core/util.d.cts": {
            "lines": 182,
            "tokens": 4164,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 182,
            "duplicatedTokens": 4164,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/core/to-json-schema.d.ts": {
            "lines": 87,
            "tokens": 798,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 87,
            "duplicatedTokens": 798,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/core/to-json-schema.d.cts": {
            "lines": 87,
            "tokens": 798,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 87,
            "duplicatedTokens": 798,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/core/standard-schema.d.ts": {
            "lines": 54,
            "tokens": 444,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 54,
            "duplicatedTokens": 444,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/core/standard-schema.d.cts": {
            "lines": 54,
            "tokens": 444,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 54,
            "duplicatedTokens": 444,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/core/registries.d.ts": {
            "lines": 34,
            "tokens": 635,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 34,
            "duplicatedTokens": 635,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/core/registries.d.cts": {
            "lines": 34,
            "tokens": 635,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 34,
            "duplicatedTokens": 635,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/core/regexes.d.ts": {
            "lines": 61,
            "tokens": 637,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 61,
            "duplicatedTokens": 637,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/core/regexes.d.cts": {
            "lines": 61,
            "tokens": 637,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 61,
            "duplicatedTokens": 637,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/core/parse.d.ts": {
            "lines": 24,
            "tokens": 499,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 24,
            "duplicatedTokens": 499,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/core/parse.d.cts": {
            "lines": 24,
            "tokens": 499,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 24,
            "duplicatedTokens": 499,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/core/json-schema.d.ts": {
            "lines": 86,
            "tokens": 822,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 86,
            "duplicatedTokens": 822,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/core/json-schema.d.cts": {
            "lines": 86,
            "tokens": 822,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 86,
            "duplicatedTokens": 822,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/core/index.d.ts": {
            "lines": 14,
            "tokens": 149,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 14,
            "duplicatedTokens": 149,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/core/index.d.cts": {
            "lines": 14,
            "tokens": 149,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 14,
            "duplicatedTokens": 149,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/core/function.d.ts": {
            "lines": 51,
            "tokens": 1094,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 51,
            "duplicatedTokens": 1094,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/core/function.d.cts": {
            "lines": 51,
            "tokens": 1094,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 51,
            "duplicatedTokens": 1094,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/core/errors.d.ts": {
            "lines": 207,
            "tokens": 2249,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 207,
            "duplicatedTokens": 2249,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/core/errors.d.cts": {
            "lines": 207,
            "tokens": 2249,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 207,
            "duplicatedTokens": 2249,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/core/doc.d.ts": {
            "lines": 13,
            "tokens": 148,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 13,
            "duplicatedTokens": 148,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/core/doc.d.cts": {
            "lines": 13,
            "tokens": 148,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 13,
            "duplicatedTokens": 148,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/core/core.d.ts": {
            "lines": 48,
            "tokens": 629,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 48,
            "duplicatedTokens": 629,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/core/core.d.cts": {
            "lines": 48,
            "tokens": 629,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 48,
            "duplicatedTokens": 629,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/core/checks.d.ts": {
            "lines": 277,
            "tokens": 3216,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 277,
            "duplicatedTokens": 3216,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/core/checks.d.cts": {
            "lines": 277,
            "tokens": 3216,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 277,
            "duplicatedTokens": 3216,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/core/api.d.ts": {
            "lines": 283,
            "tokens": 8300,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 283,
            "duplicatedTokens": 8300,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/core/api.d.cts": {
            "lines": 283,
            "tokens": 8300,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 283,
            "duplicatedTokens": 8300,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/classic/schemas.d.ts": {
            "lines": 629,
            "tokens": 11305,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 629,
            "duplicatedTokens": 11305,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/classic/schemas.d.cts": {
            "lines": 629,
            "tokens": 11305,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 629,
            "duplicatedTokens": 11305,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/classic/parse.d.ts": {
            "lines": 22,
            "tokens": 419,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 22,
            "duplicatedTokens": 419,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/classic/parse.d.cts": {
            "lines": 22,
            "tokens": 419,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 22,
            "duplicatedTokens": 419,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/classic/iso.d.ts": {
            "lines": 21,
            "tokens": 296,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 21,
            "duplicatedTokens": 296,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/classic/iso.d.cts": {
            "lines": 21,
            "tokens": 296,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 21,
            "duplicatedTokens": 296,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/classic/external.d.ts": {
            "lines": 12,
            "tokens": 230,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 12,
            "duplicatedTokens": 230,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/classic/external.d.cts": {
            "lines": 12,
            "tokens": 230,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 12,
            "duplicatedTokens": 230,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/classic/errors.d.ts": {
            "lines": 29,
            "tokens": 311,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 29,
            "duplicatedTokens": 311,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/classic/errors.d.cts": {
            "lines": 29,
            "tokens": 311,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 29,
            "duplicatedTokens": 311,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/classic/compat.d.ts": {
            "lines": 45,
            "tokens": 460,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 45,
            "duplicatedTokens": 460,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/classic/compat.d.cts": {
            "lines": 45,
            "tokens": 460,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 45,
            "duplicatedTokens": 460,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/classic/coerce.d.ts": {
            "lines": 16,
            "tokens": 349,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 16,
            "duplicatedTokens": 349,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v4/classic/coerce.d.cts": {
            "lines": 16,
            "tokens": 349,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 16,
            "duplicatedTokens": 349,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v3/helpers/util.d.ts": {
            "lines": 84,
            "tokens": 1488,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 84,
            "duplicatedTokens": 1488,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v3/helpers/util.d.cts": {
            "lines": 84,
            "tokens": 1488,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 84,
            "duplicatedTokens": 1488,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v3/helpers/parseUtil.d.ts": {
            "lines": 77,
            "tokens": 952,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 77,
            "duplicatedTokens": 952,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v3/helpers/parseUtil.d.cts": {
            "lines": 77,
            "tokens": 952,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 77,
            "duplicatedTokens": 952,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v3/helpers/errorUtil.d.ts": {
            "lines": 8,
            "tokens": 96,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v3/helpers/errorUtil.d.cts": {
            "lines": 8,
            "tokens": 96,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/standard-schema.ts": {
            "lines": 112,
            "tokens": 485,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 112,
            "duplicatedTokens": 485,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/errors.ts": {
            "lines": 12,
            "tokens": 85,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/src/v3/ZodError.ts": {
            "lines": 329,
            "tokens": 2949,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 329,
            "duplicatedTokens": 2949,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/stringify/stringifyString.d.ts": {
            "lines": 8,
            "tokens": 119,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/stringify/stringifyComment.d.ts": {
            "lines": 9,
            "tokens": 78,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/stringify/stringifyCollection.d.ts": {
            "lines": 16,
            "tokens": 160,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 16,
            "duplicatedTokens": 160,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/stringify/stringify.d.ts": {
            "lines": 20,
            "tokens": 257,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 20,
            "duplicatedTokens": 257,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/stringify/foldFlowLines.d.ts": {
            "lines": 33,
            "tokens": 189,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 33,
            "duplicatedTokens": 189,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/schema/types.d.ts": {
            "lines": 91,
            "tokens": 499,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 91,
            "duplicatedTokens": 499,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/schema/tags.d.ts": {
            "lines": 47,
            "tokens": 424,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 47,
            "duplicatedTokens": 424,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/schema/json-schema.d.ts": {
            "lines": 68,
            "tokens": 626,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 68,
            "duplicatedTokens": 626,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/schema/Schema.d.ts": {
            "lines": 16,
            "tokens": 252,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 16,
            "duplicatedTokens": 252,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/parse/parser.d.ts": {
            "lines": 83,
            "tokens": 308,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 83,
            "duplicatedTokens": 308,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/parse/line-counter.d.ts": {
            "lines": 21,
            "tokens": 76,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/parse/lexer.d.ts": {
            "lines": 86,
            "tokens": 284,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 86,
            "duplicatedTokens": 284,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/parse/cst.d.ts": {
            "lines": 108,
            "tokens": 1022,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 108,
            "duplicatedTokens": 1022,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/parse/cst-visit.d.ts": {
            "lines": 38,
            "tokens": 224,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 38,
            "duplicatedTokens": 224,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/parse/cst-scalar.d.ts": {
            "lines": 63,
            "tokens": 415,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 63,
            "duplicatedTokens": 415,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/nodes/toJS.d.ts": {
            "lines": 28,
            "tokens": 190,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 28,
            "duplicatedTokens": 190,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/nodes/identity.d.ts": {
            "lines": 22,
            "tokens": 565,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 22,
            "duplicatedTokens": 565,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/nodes/YAMLSeq.d.ts": {
            "lines": 59,
            "tokens": 514,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 59,
            "duplicatedTokens": 514,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/nodes/YAMLMap.d.ts": {
            "lines": 52,
            "tokens": 702,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 52,
            "duplicatedTokens": 702,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/nodes/Scalar.d.ts": {
            "lines": 42,
            "tokens": 395,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 42,
            "duplicatedTokens": 395,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/nodes/Pair.d.ts": {
            "lines": 21,
            "tokens": 327,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 21,
            "duplicatedTokens": 327,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/nodes/Node.d.ts": {
            "lines": 52,
            "tokens": 681,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 52,
            "duplicatedTokens": 681,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/nodes/Collection.d.ts": {
            "lines": 72,
            "tokens": 450,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 72,
            "duplicatedTokens": 450,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/nodes/Alias.d.ts": {
            "lines": 28,
            "tokens": 321,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 28,
            "duplicatedTokens": 321,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/doc/directives.d.ts": {
            "lines": 48,
            "tokens": 283,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 48,
            "duplicatedTokens": 283,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/doc/createNode.d.ts": {
            "lines": 16,
            "tokens": 209,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 16,
            "duplicatedTokens": 209,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/doc/applyReviver.d.ts": {
            "lines": 8,
            "tokens": 62,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/doc/anchors.d.ts": {
            "lines": 23,
            "tokens": 209,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 23,
            "duplicatedTokens": 209,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/doc/Document.d.ts": {
            "lines": 140,
            "tokens": 1112,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 140,
            "duplicatedTokens": 1112,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/compose/resolve-props.d.ts": {
            "lines": 22,
            "tokens": 255,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 22,
            "duplicatedTokens": 255,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/compose/resolve-flow-scalar.d.ts": {
            "lines": 9,
            "tokens": 134,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/compose/resolve-block-scalar.d.ts": {
            "lines": 10,
            "tokens": 143,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 10,
            "duplicatedTokens": 143,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/compose/composer.d.ts": {
            "lines": 62,
            "tokens": 477,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 62,
            "duplicatedTokens": 477,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/compose/compose-node.d.ts": {
            "lines": 28,
            "tokens": 377,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 28,
            "duplicatedTokens": 377,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/compose/compose-collection.d.ts": {
            "lines": 10,
            "tokens": 167,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 10,
            "duplicatedTokens": 167,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v3/standard-schema.d.ts": {
            "lines": 101,
            "tokens": 472,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 101,
            "duplicatedTokens": 472,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v3/standard-schema.d.cts": {
            "lines": 101,
            "tokens": 472,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 101,
            "duplicatedTokens": 472,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v3/ZodError.d.ts": {
            "lines": 163,
            "tokens": 1924,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 163,
            "duplicatedTokens": 1924,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod/v3/ZodError.d.cts": {
            "lines": 163,
            "tokens": 1924,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 163,
            "duplicatedTokens": 1924,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/visit.d.ts": {
            "lines": 101,
            "tokens": 693,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 101,
            "duplicatedTokens": 693,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/util.d.ts": {
            "lines": 15,
            "tokens": 231,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 15,
            "duplicatedTokens": 231,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/public-api.d.ts": {
            "lines": 43,
            "tokens": 496,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 43,
            "duplicatedTokens": 496,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/options.d.ts": {
            "lines": 343,
            "tokens": 886,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 343,
            "duplicatedTokens": 886,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/index.d.ts": {
            "lines": 24,
            "tokens": 416,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 24,
            "duplicatedTokens": 416,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/yaml/dist/errors.d.ts": {
            "lines": 20,
            "tokens": 365,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 20,
            "duplicatedTokens": 365,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/tsserverlibrary.d.ts": {
            "lines": 16,
            "tokens": 20,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.webworker.iterable.d.ts": {
            "lines": 339,
            "tokens": 3734,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 339,
            "duplicatedTokens": 3734,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.webworker.importscripts.d.ts": {
            "lines": 22,
            "tokens": 32,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.webworker.asynciterable.d.ts": {
            "lines": 40,
            "tokens": 218,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 40,
            "duplicatedTokens": 218,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.scripthost.d.ts": {
            "lines": 321,
            "tokens": 1069,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 321,
            "duplicatedTokens": 1069,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.esnext.sharedmemory.d.ts": {
            "lines": 24,
            "tokens": 30,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.esnext.promise.d.ts": {
            "lines": 33,
            "tokens": 70,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.esnext.iterator.d.ts": {
            "lines": 147,
            "tokens": 844,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 147,
            "duplicatedTokens": 844,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.esnext.intl.d.ts": {
            "lines": 20,
            "tokens": 18,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.esnext.full.d.ts": {
            "lines": 23,
            "tokens": 17,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.esnext.float16.d.ts": {
            "lines": 444,
            "tokens": 1888,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 444,
            "duplicatedTokens": 1888,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.esnext.error.d.ts": {
            "lines": 23,
            "tokens": 33,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.esnext.disposable.d.ts": {
            "lines": 192,
            "tokens": 661,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 192,
            "duplicatedTokens": 661,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.esnext.decorators.d.ts": {
            "lines": 27,
            "tokens": 53,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.esnext.d.ts": {
            "lines": 28,
            "tokens": 27,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.esnext.collection.d.ts": {
            "lines": 95,
            "tokens": 424,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 95,
            "duplicatedTokens": 424,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.esnext.array.d.ts": {
            "lines": 34,
            "tokens": 145,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 34,
            "duplicatedTokens": 145,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es6.d.ts": {
            "lines": 22,
            "tokens": 15,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2024.string.d.ts": {
            "lines": 28,
            "tokens": 38,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2024.sharedmemory.d.ts": {
            "lines": 67,
            "tokens": 268,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 67,
            "duplicatedTokens": 268,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2024.regexp.d.ts": {
            "lines": 24,
            "tokens": 25,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2024.promise.d.ts": {
            "lines": 34,
            "tokens": 93,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 34,
            "duplicatedTokens": 93,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2024.object.d.ts": {
            "lines": 28,
            "tokens": 79,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2024.full.d.ts": {
            "lines": 23,
            "tokens": 17,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2024.d.ts": {
            "lines": 25,
            "tokens": 21,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2024.collection.d.ts": {
            "lines": 28,
            "tokens": 73,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2024.arraybuffer.d.ts": {
            "lines": 64,
            "tokens": 150,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 64,
            "duplicatedTokens": 150,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2023.intl.d.ts": {
            "lines": 55,
            "tokens": 546,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 55,
            "duplicatedTokens": 546,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2023.full.d.ts": {
            "lines": 23,
            "tokens": 17,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2023.d.ts": {
            "lines": 21,
            "tokens": 13,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2023.collection.d.ts": {
            "lines": 20,
            "tokens": 20,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2023.array.d.ts": {
            "lines": 923,
            "tokens": 3678,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 923,
            "duplicatedTokens": 3678,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2022.string.d.ts": {
            "lines": 24,
            "tokens": 33,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2022.regexp.d.ts": {
            "lines": 38,
            "tokens": 108,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 38,
            "duplicatedTokens": 108,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2022.object.d.ts": {
            "lines": 25,
            "tokens": 35,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2022.intl.d.ts": {
            "lines": 144,
            "tokens": 417,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 144,
            "duplicatedTokens": 417,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2022.full.d.ts": {
            "lines": 23,
            "tokens": 17,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2022.error.d.ts": {
            "lines": 74,
            "tokens": 481,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 74,
            "duplicatedTokens": 481,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2022.d.ts": {
            "lines": 24,
            "tokens": 19,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2022.array.d.ts": {
            "lines": 120,
            "tokens": 464,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 120,
            "duplicatedTokens": 464,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2021.weakref.d.ts": {
            "lines": 77,
            "tokens": 250,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 77,
            "duplicatedTokens": 250,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2021.string.d.ts": {
            "lines": 32,
            "tokens": 84,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 32,
            "duplicatedTokens": 84,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2021.promise.d.ts": {
            "lines": 47,
            "tokens": 186,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 47,
            "duplicatedTokens": 186,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2021.intl.d.ts": {
            "lines": 165,
            "tokens": 697,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 165,
            "duplicatedTokens": 697,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2021.full.d.ts": {
            "lines": 23,
            "tokens": 17,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2021.d.ts": {
            "lines": 22,
            "tokens": 15,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2020.symbol.wellknown.d.ts": {
            "lines": 40,
            "tokens": 105,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 40,
            "duplicatedTokens": 105,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2020.string.d.ts": {
            "lines": 43,
            "tokens": 114,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 43,
            "duplicatedTokens": 114,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2020.sharedmemory.d.ts": {
            "lines": 98,
            "tokens": 446,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 98,
            "duplicatedTokens": 446,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2020.promise.d.ts": {
            "lines": 46,
            "tokens": 183,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 46,
            "duplicatedTokens": 183,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2020.number.d.ts": {
            "lines": 27,
            "tokens": 44,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2020.intl.d.ts": {
            "lines": 473,
            "tokens": 1942,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 473,
            "duplicatedTokens": 1942,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2020.full.d.ts": {
            "lines": 23,
            "tokens": 17,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2020.date.d.ts": {
            "lines": 41,
            "tokens": 102,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 41,
            "duplicatedTokens": 102,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2020.d.ts": {
            "lines": 26,
            "tokens": 23,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2020.bigint.d.ts": {
            "lines": 764,
            "tokens": 3817,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 764,
            "duplicatedTokens": 3817,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2019.symbol.d.ts": {
            "lines": 23,
            "tokens": 29,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2019.string.d.ts": {
            "lines": 36,
            "tokens": 64,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2019.object.d.ts": {
            "lines": 32,
            "tokens": 86,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 32,
            "duplicatedTokens": 86,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2019.intl.d.ts": {
            "lines": 22,
            "tokens": 32,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2019.full.d.ts": {
            "lines": 23,
            "tokens": 17,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2019.d.ts": {
            "lines": 23,
            "tokens": 17,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2019.array.d.ts": {
            "lines": 78,
            "tokens": 431,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 78,
            "duplicatedTokens": 431,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2018.regexp.d.ts": {
            "lines": 36,
            "tokens": 89,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2018.promise.d.ts": {
            "lines": 29,
            "tokens": 53,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2018.intl.d.ts": {
            "lines": 82,
            "tokens": 551,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 82,
            "duplicatedTokens": 551,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2018.full.d.ts": {
            "lines": 23,
            "tokens": 17,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2018.d.ts": {
            "lines": 23,
            "tokens": 17,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2018.asynciterable.d.ts": {
            "lines": 52,
            "tokens": 319,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 52,
            "duplicatedTokens": 319,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2018.asyncgenerator.d.ts": {
            "lines": 76,
            "tokens": 321,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 76,
            "duplicatedTokens": 321,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2017.typedarrays.d.ts": {
            "lines": 52,
            "tokens": 202,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 52,
            "duplicatedTokens": 202,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2017.string.d.ts": {
            "lines": 44,
            "tokens": 60,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2017.sharedmemory.d.ts": {
            "lines": 134,
            "tokens": 873,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 134,
            "duplicatedTokens": 873,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2017.object.d.ts": {
            "lines": 48,
            "tokens": 205,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 48,
            "duplicatedTokens": 205,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2017.intl.d.ts": {
            "lines": 43,
            "tokens": 171,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 43,
            "duplicatedTokens": 171,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2017.full.d.ts": {
            "lines": 22,
            "tokens": 15,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2017.date.d.ts": {
            "lines": 30,
            "tokens": 71,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2017.d.ts": {
            "lines": 25,
            "tokens": 21,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2017.arraybuffer.d.ts": {
            "lines": 20,
            "tokens": 23,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2016.intl.d.ts": {
            "lines": 30,
            "tokens": 44,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2016.full.d.ts": {
            "lines": 22,
            "tokens": 15,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2016.d.ts": {
            "lines": 20,
            "tokens": 11,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2016.array.include.d.ts": {
            "lines": 115,
            "tokens": 425,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 115,
            "duplicatedTokens": 425,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2015.symbol.wellknown.d.ts": {
            "lines": 325,
            "tokens": 1501,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 325,
            "duplicatedTokens": 1501,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2015.symbol.d.ts": {
            "lines": 45,
            "tokens": 95,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 45,
            "duplicatedTokens": 95,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2015.reflect.d.ts": {
            "lines": 143,
            "tokens": 684,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 143,
            "duplicatedTokens": 684,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2015.proxy.d.ts": {
            "lines": 127,
            "tokens": 494,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 127,
            "duplicatedTokens": 494,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2015.promise.d.ts": {
            "lines": 80,
            "tokens": 319,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 80,
            "duplicatedTokens": 319,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2015.iterable.d.ts": {
            "lines": 604,
            "tokens": 3284,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 604,
            "duplicatedTokens": 3284,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2015.generator.d.ts": {
            "lines": 76,
            "tokens": 308,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 76,
            "duplicatedTokens": 308,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2015.d.ts": {
            "lines": 27,
            "tokens": 25,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2015.core.d.ts": {
            "lines": 596,
            "tokens": 2319,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 596,
            "duplicatedTokens": 2319,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.es2015.collection.d.ts": {
            "lines": 146,
            "tokens": 945,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 146,
            "duplicatedTokens": 945,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.dom.iterable.d.ts": {
            "lines": 570,
            "tokens": 5144,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 570,
            "duplicatedTokens": 5144,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.dom.asynciterable.d.ts": {
            "lines": 40,
            "tokens": 218,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 40,
            "duplicatedTokens": 218,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.decorators.legacy.d.ts": {
            "lines": 21,
            "tokens": 155,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 21,
            "duplicatedTokens": 155,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.decorators.d.ts": {
            "lines": 383,
            "tokens": 1317,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 383,
            "duplicatedTokens": 1317,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/typescript/lib/lib.d.ts": {
            "lines": 21,
            "tokens": 13,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/src/scripts/generate-schema.ts": {
            "lines": 25,
            "tokens": 169,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/node_modules/zod-to-json-schema/createIndex.ts": {
            "lines": 31,
            "tokens": 256,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 31,
            "duplicatedTokens": 256,
            "percentage": 100,
            "percentageTokens": 100,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/test/schema.test.ts": {
            "lines": 965,
            "tokens": 7872,
            "sources": 1,
            "clones": 20,
            "duplicatedLines": 232,
            "duplicatedTokens": 1978,
            "percentage": 24.04,
            "percentageTokens": 25.13,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/test/loader.test.ts": {
            "lines": 152,
            "tokens": 978,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/test/git-helpers.test.ts": {
            "lines": 131,
            "tokens": 1285,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/src/schema.ts": {
            "lines": 371,
            "tokens": 2026,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 13,
            "duplicatedTokens": 129,
            "percentage": 3.5,
            "percentageTokens": 6.37,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/src/schema-export.ts": {
            "lines": 33,
            "tokens": 99,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/src/loader.ts": {
            "lines": 88,
            "tokens": 455,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/src/index.ts": {
            "lines": 63,
            "tokens": 203,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/src/git-helpers.ts": {
            "lines": 75,
            "tokens": 193,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/src/constants.ts": {
            "lines": 43,
            "tokens": 93,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/dist/schema-export.d.ts": {
            "lines": 23,
            "tokens": 32,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/dist/loader.d.ts": {
            "lines": 29,
            "tokens": 83,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/dist/index.d.ts": {
            "lines": 27,
            "tokens": 167,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/dist/git-helpers.d.ts": {
            "lines": 63,
            "tokens": 89,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "packages/config/dist/constants.d.ts": {
            "lines": 39,
            "tokens": 79,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          }
        },
        "total": {
          "lines": 155636,
          "tokens": 1350600,
          "sources": 1221,
          "clones": 777,
          "duplicatedLines": 63635,
          "duplicatedTokens": 641927,
          "percentage": 40.89,
          "percentageTokens": 47.53,
          "newDuplicatedLines": 0,
          "newClones": 0
        }
      }
    },
    "total": {
      "lines": 155636,
      "tokens": 1350600,
      "sources": 1221,
      "clones": 777,
      "duplicatedLines": 63635,
      "duplicatedTokens": 641927,
      "percentage": 40.89,
      "percentageTokens": 47.53,
      "newDuplicatedLines": 0,
      "newClones": 0
    }
  },
  "duplicates": [
    {
      "format": "typescript",
      "lines": 15,
      "fragment": ",\n    cases: [\n      { count: 1, expected: \"1 \" },\n      { count: 2, expected: \"2 \" },\n      { count: 5, expected: \"5 \" },\n      { count: 11, expected: \"11 \" },\n      { count: 21, expected: \"21 \" },\n      { count: 22, expected: \"22 \" },\n      { count: 25, expected: \"25 \" },\n      { count: 101, expected: \"101 \" },\n      { count: 111, expected: \"111 \" },\n    ],\n  },\n  {\n    type: \"string\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/tests/locales/ru.test.ts",
        "start": 88,
        "end": 102,
        "startLoc": {
          "line": 88,
          "column": 6,
          "position": 756
        },
        "endLoc": {
          "line": 102,
          "column": 9,
          "position": 932
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/tests/locales/ru.test.ts",
        "start": 74,
        "end": 88,
        "startLoc": {
          "line": 74,
          "column": 8,
          "position": 579
        },
        "endLoc": {
          "line": 88,
          "column": 6,
          "position": 755
        }
      }
    },
    {
      "format": "typescript",
      "lines": 21,
      "fragment": ";\n\ntest(\"parsedType\", () => {\n  expect(parsedType(\"string\")).toBe(\"string\");\n  expect(parsedType(1)).toBe(\"number\");\n  expect(parsedType(true)).toBe(\"boolean\");\n  expect(parsedType(null)).toBe(\"null\");\n  expect(parsedType(undefined)).toBe(\"undefined\");\n  expect(parsedType([])).toBe(\"array\");\n  expect(parsedType({})).toBe(\"object\");\n  expect(parsedType(new Date())).toBe(\"Date\");\n  expect(parsedType(new Map())).toBe(\"Map\");\n  expect(parsedType(new Set())).toBe(\"Set\");\n  expect(parsedType(new Error())).toBe(\"Error\");\n\n  const nullPrototype = Object.create(null);\n  expect(parsedType(nullPrototype)).toBe(\"object\");\n\n  const doubleNullPrototype = Object.create(Object.create(null));\n  expect(parsedType(doubleNullPrototype)).toBe(\"object\");\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/tests/locales/en.test.ts",
        "start": 2,
        "end": 22,
        "startLoc": {
          "line": 2,
          "column": 25,
          "position": 27
        },
        "endLoc": {
          "line": 22,
          "column": 2,
          "position": 292
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/tests/locales/tr.test.ts",
        "start": 3,
        "end": 24,
        "startLoc": {
          "line": 3,
          "column": 25,
          "position": 40
        },
        "endLoc": {
          "line": 24,
          "column": 7,
          "position": 307
        }
      }
    },
    {
      "format": "typescript",
      "lines": 33,
      "fragment": "().localeError;\n\n  describe(\"pluralization rules\", () => {\n    for (const { type, cases } of TEST_CASES) {\n      describe(`${type} pluralization`, () => {\n        for (const { count, expected } of cases) {\n          it(`correctly pluralizes ${count} ${type}`, () => {\n            const error = localeError({\n              code: \"too_small\",\n              minimum: count,\n              type: \"number\",\n              inclusive: true,\n              path: [],\n              origin: type,\n              input: count - 1,\n            });\n            expect(error).toContain(expected);\n          });\n        }\n      });\n    }\n\n    it(\"handles negative numbers correctly\", () => {\n      const error = localeError({\n        code: \"too_small\",\n        minimum: -2,\n        type: \"number\",\n        inclusive: true,\n        path: [],\n        origin: \"array\",\n        input: -3,\n      });\n      expect(error).toContain(\"-2 \"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/tests/locales/be.test.ts",
        "start": 5,
        "end": 37,
        "startLoc": {
          "line": 5,
          "column": 3,
          "position": 49
        },
        "endLoc": {
          "line": 37,
          "column": 14,
          "position": 339
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/tests/locales/ru.test.ts",
        "start": 5,
        "end": 39,
        "startLoc": {
          "line": 5,
          "column": 3,
          "position": 49
        },
        "endLoc": {
          "line": 39,
          "column": 14,
          "position": 341
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ");\n    });\n\n    it(\"handles zero correctly\", () => {\n      const error = localeError({\n        code: \"too_small\",\n        minimum: 0,\n        type: \"number\",\n        inclusive: true,\n        path: [],\n        origin: \"array\",\n        input: -1,\n      });\n      expect(error).toContain(\"0 \"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/tests/locales/be.test.ts",
        "start": 37,
        "end": 50,
        "startLoc": {
          "line": 37,
          "column": 14,
          "position": 340
        },
        "endLoc": {
          "line": 50,
          "column": 14,
          "position": 437
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/tests/locales/ru.test.ts",
        "start": 39,
        "end": 53,
        "startLoc": {
          "line": 39,
          "column": 14,
          "position": 342
        },
        "endLoc": {
          "line": 53,
          "column": 14,
          "position": 440
        }
      }
    },
    {
      "format": "typescript",
      "lines": 24,
      "fragment": ");\n    });\n\n    it(\"handles bigint values correctly\", () => {\n      const error = localeError({\n        code: \"too_small\",\n        minimum: BigInt(21),\n        type: \"number\",\n        inclusive: true,\n        path: [],\n        origin: \"array\",\n        input: BigInt(20),\n      });\n      expect(error).toContain(\"21 \");\n    });\n  });\n});\n\nconst TEST_CASES = [\n  {\n    type: \"array\",\n    cases: [\n      { count: 1, expected: \"1 \" },\n      { count: 2, expected: \"2 \"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/tests/locales/be.test.ts",
        "start": 50,
        "end": 73,
        "startLoc": {
          "line": 50,
          "column": 14,
          "position": 438
        },
        "endLoc": {
          "line": 73,
          "column": 13,
          "position": 612
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/tests/locales/ru.test.ts",
        "start": 53,
        "end": 77,
        "startLoc": {
          "line": 53,
          "column": 14,
          "position": 441
        },
        "endLoc": {
          "line": 77,
          "column": 13,
          "position": 616
        }
      }
    },
    {
      "format": "typescript",
      "lines": 15,
      "fragment": ",\n    cases: [\n      { count: 1, expected: \"1 \" },\n      { count: 2, expected: \"2 \" },\n      { count: 5, expected: \"5 \" },\n      { count: 11, expected: \"11 \" },\n      { count: 21, expected: \"21 \" },\n      { count: 22, expected: \"22 \" },\n      { count: 25, expected: \"25 \" },\n      { count: 101, expected: \"101 \" },\n      { count: 111, expected: \"111 \" },\n    ],\n  },\n  {\n    type: \"string\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/tests/locales/be.test.ts",
        "start": 84,
        "end": 98,
        "startLoc": {
          "line": 84,
          "column": 6,
          "position": 752
        },
        "endLoc": {
          "line": 98,
          "column": 9,
          "position": 928
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/tests/locales/be.test.ts",
        "start": 70,
        "end": 84,
        "startLoc": {
          "line": 70,
          "column": 8,
          "position": 575
        },
        "endLoc": {
          "line": 84,
          "column": 6,
          "position": 751
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, 123)).toEqual(123);\n  expect(z.parse(a, true)).toEqual(true);\n  expect(z.parse(a, null)).toEqual(null);\n  expect(z.parse(a, undefined)).toEqual(undefined);\n  z.parse(a, {});\n  z.parse(a, []);\n  z.parse(a, Symbol());\n  z.parse(a, new Date());\n});\n\ntest(\"z.never\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/index.test.ts",
        "start": 194,
        "end": 206,
        "startLoc": {
          "line": 194,
          "column": 8,
          "position": 2821
        },
        "endLoc": {
          "line": 206,
          "column": 10,
          "position": 2988
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/index.test.ts",
        "start": 181,
        "end": 193,
        "startLoc": {
          "line": 181,
          "column": 4,
          "position": 2634
        },
        "endLoc": {
          "line": 193,
          "column": 12,
          "position": 2801
        }
      }
    },
    {
      "format": "typescript",
      "lines": 17,
      "fragment": "(NativeEnum);\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<NativeEnum>();\n  expect(z.parse(a, NativeEnum.A)).toEqual(NativeEnum.A);\n  expect(z.parse(a, NativeEnum.B)).toEqual(NativeEnum.B);\n  expect(z.parse(a, NativeEnum.C)).toEqual(NativeEnum.C);\n  expect(() => z.parse(a, \"D\")).toThrow();\n  expect(() => z.parse(a, 123)).toThrow();\n\n  // test a.enum\n  a;\n  // expect(a.enum.A).toEqual(NativeEnum.A);\n  // expect(a.enum.B).toEqual(NativeEnum.B);\n  // expect(a.enum.C).toEqual(NativeEnum.C);\n});\n\ntest(\"z.literal\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/index.test.ts",
        "start": 407,
        "end": 423,
        "startLoc": {
          "line": 407,
          "column": 11,
          "position": 6353
        },
        "endLoc": {
          "line": 423,
          "column": 12,
          "position": 6535
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/index.test.ts",
        "start": 385,
        "end": 401,
        "startLoc": {
          "line": 385,
          "column": 5,
          "position": 6117
        },
        "endLoc": {
          "line": 401,
          "column": 15,
          "position": 6299
        }
      }
    },
    {
      "format": "typescript",
      "lines": 26,
      "fragment": ");\n});\n\ntest(\"async validation\", async () => {\n  const testTuple = z\n    .tuple([z.string().refine(async () => true), z.number().refine(async () => true)])\n    .refine(async () => true);\n  expectTypeOf<typeof testTuple._output>().toEqualTypeOf<[string, number]>();\n\n  const val = await testTuple.parseAsync([\"asdf\", 1234]);\n  expect(val).toEqual(val);\n\n  const r1 = await testTuple.safeParseAsync([\"asdf\", \"asdf\"]);\n  expect(r1.success).toEqual(false);\n  expect(r1.error!).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"expected\": \"number\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          1\n        ],\n        \"message\": \"Invalid input: expected number, received string\"\n      }\n    ]]\n  `",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/tuple.test.ts",
        "start": 51,
        "end": 76,
        "startLoc": {
          "line": 51,
          "column": 4,
          "position": 277
        },
        "endLoc": {
          "line": 76,
          "column": 4,
          "position": 475
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/tests/index.test.ts",
        "start": 19,
        "end": 45,
        "startLoc": {
          "line": 19,
          "column": 4,
          "position": 97
        },
        "endLoc": {
          "line": 45,
          "column": 4,
          "position": 295
        }
      }
    },
    {
      "format": "typescript",
      "lines": 12,
      "fragment": "(data, ctx) => {\n      const i = strs.indexOf(data);\n      if (i === -1) {\n        ctx.addIssue({\n          input: data,\n          code: \"custom\",\n          message: `${data} is not one of our allowed strings`,\n        });\n      }\n      return data.length;\n    })\n    .",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/transform.test.ts",
        "start": 35,
        "end": 46,
        "startLoc": {
          "line": 35,
          "column": 2,
          "position": 270
        },
        "endLoc": {
          "line": 46,
          "column": 2,
          "position": 363
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/transform.test.ts",
        "start": 6,
        "end": 16,
        "startLoc": {
          "line": 6,
          "column": 2,
          "position": 75
        },
        "endLoc": {
          "line": 16,
          "column": 2,
          "position": 166
        }
      }
    },
    {
      "format": "typescript",
      "lines": 25,
      "fragment": "();\n\n  expect(z.parse(a, \"true\")).toEqual(true);\n  expect(z.parse(a, \"yes\")).toEqual(true);\n  expect(z.parse(a, \"1\")).toEqual(true);\n  expect(z.parse(a, \"on\")).toEqual(true);\n  expect(z.parse(a, \"y\")).toEqual(true);\n  expect(z.parse(a, \"enabled\")).toEqual(true);\n  expect(z.parse(a, \"TRUE\")).toEqual(true);\n\n  expect(z.parse(a, \"false\")).toEqual(false);\n  expect(z.parse(a, \"no\")).toEqual(false);\n  expect(z.parse(a, \"0\")).toEqual(false);\n  expect(z.parse(a, \"off\")).toEqual(false);\n  expect(z.parse(a, \"n\")).toEqual(false);\n  expect(z.parse(a, \"disabled\")).toEqual(false);\n  expect(z.parse(a, \"FALSE\")).toEqual(false);\n\n  expect(z.safeParse(a, \"other\")).toMatchObject({ success: false });\n  expect(z.safeParse(a, \"\")).toMatchObject({ success: false });\n  expect(z.safeParse(a, undefined)).toMatchObject({ success: false });\n  expect(z.safeParse(a, {})).toMatchObject({ success: false });\n  expect(z.safeParse(a, true)).toMatchObject({ success: false });\n  expect(z.safeParse(a, false)).toMatchObject({ success: false });\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/stringbool.test.ts",
        "start": 9,
        "end": 33,
        "startLoc": {
          "line": 9,
          "column": 2,
          "position": 121
        },
        "endLoc": {
          "line": 33,
          "column": 2,
          "position": 571
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/index.test.ts",
        "start": 747,
        "end": 772,
        "startLoc": {
          "line": 747,
          "column": 11,
          "position": 10772
        },
        "endLoc": {
          "line": 772,
          "column": 6,
          "position": 11224
        }
      }
    },
    {
      "format": "typescript",
      "lines": 19,
      "fragment": ");\n  expect(result).toMatchObject({ success: false });\n\n  expect(result.error!.issues[0].message).toEqual(\"custom error\");\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"origin\": \"string\",\n        \"code\": \"invalid_format\",\n        \"format\": \"nanoid\",\n        \"pattern\": \"/^[a-zA-Z0-9_-]{21}$/\",\n        \"path\": [],\n        \"message\": \"custom error\"\n      }\n    ]]\n  `);\n});\n\ntest(\"good uuid\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/string.test.ts",
        "start": 423,
        "end": 441,
        "startLoc": {
          "line": 423,
          "column": 17,
          "position": 3402
        },
        "endLoc": {
          "line": 441,
          "column": 12,
          "position": 3468
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/string.test.ts",
        "start": 402,
        "end": 420,
        "startLoc": {
          "line": 402,
          "column": 25,
          "position": 3286
        },
        "endLoc": {
          "line": 420,
          "column": 13,
          "position": 3352
        }
      }
    },
    {
      "format": "typescript",
      "lines": 11,
      "fragment": "expect(() => {\n    minTwo.parse(new Set([\"a\", \"b\"]));\n    minTwo.parse(new Set([\"a\", \"b\", \"c\"]));\n    maxTwo.parse(new Set([\"a\", \"b\"]));\n    maxTwo.parse(new Set([\"a\"]));\n    justTwo.parse(new Set([\"a\", \"b\"]));\n    nonEmpty.parse(new Set([\"a\"]));\n    nonEmptyMax.parse(new Set([\"a\"]));\n  }).not.toThrow();\n\n  const",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/set.test.ts",
        "start": 50,
        "end": 60,
        "startLoc": {
          "line": 50,
          "column": 3,
          "position": 722
        },
        "endLoc": {
          "line": 60,
          "column": 6,
          "position": 871
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/set.test.ts",
        "start": 24,
        "end": 33,
        "startLoc": {
          "line": 24,
          "column": 3,
          "position": 335
        },
        "endLoc": {
          "line": 33,
          "column": 2,
          "position": 482
        }
      }
    },
    {
      "format": "typescript",
      "lines": 11,
      "fragment": ");\n  myReg.add(mySchema, {\n    defaulter: (arg, _test) => {\n      return arg.length;\n    },\n  });\n\n  expect(myReg.get(mySchema)!.defaulter(\"hello\", true)).toEqual(5);\n});\n\ntest(\"test .clear()\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/registries.test.ts",
        "start": 187,
        "end": 197,
        "startLoc": {
          "line": 187,
          "column": 7,
          "position": 2022
        },
        "endLoc": {
          "line": 197,
          "column": 16,
          "position": 2101
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/registries.test.ts",
        "start": 172,
        "end": 182,
        "startLoc": {
          "line": 172,
          "column": 2,
          "position": 1862
        },
        "endLoc": {
          "line": 182,
          "column": 33,
          "position": 1941
        }
      }
    },
    {
      "format": "typescript",
      "lines": 15,
      "fragment": ",\n          });\n        }\n      })\n      .refine((_) => false);\n\n    const result = schema.safeParse(\"\");\n    expect(result.success).toEqual(false);\n    if (!result.success) {\n      expect(result.error.issues.length).toEqual(1);\n      expect(result.error.issues[0].message).toEqual(\"BAD\");\n    }\n  });\n\n  test(\"should abort early with abort flag\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/refine.test.ts",
        "start": 141,
        "end": 155,
        "startLoc": {
          "line": 141,
          "column": 6,
          "position": 1302
        },
        "endLoc": {
          "line": 155,
          "column": 37,
          "position": 1423
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/refine.test.ts",
        "start": 119,
        "end": 133,
        "startLoc": {
          "line": 119,
          "column": 6,
          "position": 1100
        },
        "endLoc": {
          "line": 133,
          "column": 38,
          "position": 1221
        }
      }
    },
    {
      "format": "typescript",
      "lines": 16,
      "fragment": ": true,\n          message: \"Too many items \",\n        });\n      }\n\n      if (val.length !== new Set(val).size) {\n        ctx.addIssue({\n          input: val,\n          code: \"custom\",\n          message: `No duplicates allowed.`,\n        });\n      }\n    });\n\n    // Should fail with too many items and duplicates\n    const result = await",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/refine.test.ts",
        "start": 229,
        "end": 244,
        "startLoc": {
          "line": 229,
          "column": 10,
          "position": 2201
        },
        "endLoc": {
          "line": 244,
          "column": 6,
          "position": 2296
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/refine.test.ts",
        "start": 193,
        "end": 208,
        "startLoc": {
          "line": 193,
          "column": 6,
          "position": 1856
        },
        "endLoc": {
          "line": 208,
          "column": 8,
          "position": 1951
        }
      }
    },
    {
      "format": "typescript",
      "lines": 26,
      "fragment": ";\n\ntest(\"recursion with z.lazy\", () => {\n  const data = {\n    name: \"I\",\n    subcategories: [\n      {\n        name: \"A\",\n        subcategories: [\n          {\n            name: \"1\",\n            subcategories: [\n              {\n                name: \"a\",\n                subcategories: [],\n              },\n            ],\n          },\n        ],\n      },\n    ],\n  };\n\n  const Category = z.object({\n    name: z.string(),\n    get subcategories() {",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/recursive-types.test.ts",
        "start": 2,
        "end": 27,
        "startLoc": {
          "line": 2,
          "column": 9,
          "position": 30
        },
        "endLoc": {
          "line": 27,
          "column": 2,
          "position": 177
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/recursive-types.test.ts",
        "start": 2,
        "end": 27,
        "startLoc": {
          "line": 2,
          "column": 14,
          "position": 30
        },
        "endLoc": {
          "line": 27,
          "column": 2,
          "position": 176
        }
      }
    },
    {
      "format": "typescript",
      "lines": 21,
      "fragment": ");\n});\n\ntest(\"recursion involving union type\", () => {\n  const data = {\n    value: 1,\n    next: {\n      value: 2,\n      next: {\n        value: 3,\n        next: {\n          value: 4,\n          next: null,\n        },\n      },\n    },\n  };\n\n  const LL = z.object({\n    value: z.number(),\n    get next() {",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/recursive-types.test.ts",
        "start": 37,
        "end": 57,
        "startLoc": {
          "line": 37,
          "column": 5,
          "position": 281
        },
        "endLoc": {
          "line": 57,
          "column": 2,
          "position": 411
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/recursive-types.test.ts",
        "start": 38,
        "end": 58,
        "startLoc": {
          "line": 38,
          "column": 2,
          "position": 285
        },
        "endLoc": {
          "line": 58,
          "column": 2,
          "position": 414
        }
      }
    },
    {
      "format": "typescript",
      "lines": 23,
      "fragment": ");\n    },\n  });\n  const testData = {\n    val: 1,\n    b: {\n      val: 5,\n      a: {\n        val: 3,\n        b: {\n          val: 4,\n          a: {\n            val: 2,\n            b: {\n              val: 1,\n            },\n          },\n        },\n      },\n    },\n  };\n\n  type",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/recursive-types.test.ts",
        "start": 82,
        "end": 104,
        "startLoc": {
          "line": 82,
          "column": 2,
          "position": 612
        },
        "endLoc": {
          "line": 104,
          "column": 5,
          "position": 731
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/recursive-types.test.ts",
        "start": 83,
        "end": 105,
        "startLoc": {
          "line": 83,
          "column": 6,
          "position": 633
        },
        "endLoc": {
          "line": 105,
          "column": 6,
          "position": 752
        }
      }
    },
    {
      "format": "typescript",
      "lines": 22,
      "fragment": ");\n\n  expect(() => Alazy.parse({ val: \"asdf\" })).toThrow();\n});\n\ntest(\"pick and omit with getter\", () => {\n  const Category = z.strictObject({\n    name: z.string(),\n    get subcategories() {\n      return z.array(Category);\n    },\n  });\n\n  type Category = z.infer<typeof Category>;\n\n  interface _Category {\n    name: string;\n    subcategories: _Category[];\n  }\n  expectTypeOf<Category>().toEqualTypeOf<_Category>();\n\n  const PickedCategory = Category",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/recursive-types.test.ts",
        "start": 117,
        "end": 138,
        "startLoc": {
          "line": 117,
          "column": 2,
          "position": 866
        },
        "endLoc": {
          "line": 138,
          "column": 9,
          "position": 1037
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/recursive-types.test.ts",
        "start": 119,
        "end": 139,
        "startLoc": {
          "line": 119,
          "column": 2,
          "position": 893
        },
        "endLoc": {
          "line": 139,
          "column": 2,
          "position": 1063
        }
      }
    },
    {
      "format": "typescript",
      "lines": 16,
      "fragment": ");\n\n  const picked = { name: \"test\" };\n  const omitted = { name: \"test\" };\n\n  PickedCategory.parse(picked);\n  OmittedCategory.parse(omitted);\n\n  expect(() => PickedCategory.parse({ name: \"test\", subcategories: [] })).toThrow();\n  expect(() => OmittedCategory.parse({ name: \"test\", subcategories: [] })).toThrow();\n});\n\ntest(\"deferred self-recursion\", () => {\n  const Feature = z.object({\n    title: z.string(),\n    get features(): z.ZodOptional",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/recursive-types.test.ts",
        "start": 139,
        "end": 154,
        "startLoc": {
          "line": 139,
          "column": 2,
          "position": 1071
        },
        "endLoc": {
          "line": 154,
          "column": 12,
          "position": 1250
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/recursive-types.test.ts",
        "start": 150,
        "end": 165,
        "startLoc": {
          "line": 150,
          "column": 2,
          "position": 1203
        },
        "endLoc": {
          "line": 165,
          "column": 16,
          "position": 1382
        }
      }
    },
    {
      "format": "typescript",
      "lines": 15,
      "fragment": "});\n  type Output = z.output<typeof Output>;\n\n  type _Feature = {\n    title: string;\n    features?: _Feature[] | undefined;\n  };\n\n  type _Output = {\n    id: number;\n    name: string;\n    features: _Feature[];\n  };\n\n  // expectTypeOf<Feature>().toEqualTypeOf<_Feature>();",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/recursive-types.test.ts",
        "start": 166,
        "end": 180,
        "startLoc": {
          "line": 166,
          "column": 3,
          "position": 1365
        },
        "endLoc": {
          "line": 180,
          "column": 54,
          "position": 1460
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/recursive-types.test.ts",
        "start": 175,
        "end": 190,
        "startLoc": {
          "line": 175,
          "column": 3,
          "position": 1492
        },
        "endLoc": {
          "line": 190,
          "column": 13,
          "position": 1588
        }
      }
    },
    {
      "format": "typescript",
      "lines": 38,
      "fragment": "({\n    Tuna: \"asdf\",\n    Salmon: \"asdf\",\n  });\n\n  expect(schema.safeParse({ Tuna: \"asdf\", Salmon: \"asdf\", Trout: \"asdf\" })).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"unrecognized_keys\",\n        \"keys\": [\n          \"Trout\"\n        ],\n        \"path\": [],\n        \"message\": \"Unrecognized key: \\\\\"Trout\\\\\"\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(schema.safeParse({ Tuna: \"asdf\" })).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"Salmon\"\n        ],\n        \"message\": \"Invalid input: expected string, received undefined\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"pipe exhaustiveness\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/record.test.ts",
        "start": 69,
        "end": 106,
        "startLoc": {
          "line": 69,
          "column": 6,
          "position": 560
        },
        "endLoc": {
          "line": 106,
          "column": 22,
          "position": 650
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/record.test.ts",
        "start": 30,
        "end": 67,
        "startLoc": {
          "line": 30,
          "column": 8,
          "position": 424
        },
        "endLoc": {
          "line": 67,
          "column": 25,
          "position": 514
        }
      }
    },
    {
      "format": "typescript",
      "lines": 38,
      "fragment": "})).toEqual({\n    Tuna: \"asdf\",\n    Salmon: \"asdf\",\n  });\n\n  expect(schema.safeParse({ Tuna: \"asdf\", Salmon: \"asdf\", Trout: \"asdf\" })).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"unrecognized_keys\",\n        \"keys\": [\n          \"Trout\"\n        ],\n        \"path\": [],\n        \"message\": \"Unrecognized key: \\\\\"Trout\\\\\"\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(schema.safeParse({ Tuna: \"asdf\" })).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"Salmon\"\n        ],\n        \"message\": \"Invalid input: expected string, received undefined\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"union exhaustiveness\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/record.test.ts",
        "start": 108,
        "end": 145,
        "startLoc": {
          "line": 108,
          "column": 2,
          "position": 721
        },
        "endLoc": {
          "line": 145,
          "column": 23,
          "position": 816
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/record.test.ts",
        "start": 29,
        "end": 67,
        "startLoc": {
          "line": 29,
          "column": 5,
          "position": 417
        },
        "endLoc": {
          "line": 67,
          "column": 25,
          "position": 514
        }
      }
    },
    {
      "format": "typescript",
      "lines": 39,
      "fragment": "), z.string());\n  expect(schema.parse({ Tuna: \"asdf\", Salmon: \"asdf\" })).toEqual({\n    Tuna: \"asdf\",\n    Salmon: \"asdf\",\n  });\n\n  expect(schema.safeParse({ Tuna: \"asdf\", Salmon: \"asdf\", Trout: \"asdf\" })).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"unrecognized_keys\",\n        \"keys\": [\n          \"Trout\"\n        ],\n        \"path\": [],\n        \"message\": \"Unrecognized key: \\\\\"Trout\\\\\"\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(schema.safeParse({ Tuna: \"asdf\" })).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"Salmon\"\n        ],\n        \"message\": \"Invalid input: expected string, received undefined\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"string record parse - pass\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/record.test.ts",
        "start": 146,
        "end": 184,
        "startLoc": {
          "line": 146,
          "column": 2,
          "position": 857
        },
        "endLoc": {
          "line": 184,
          "column": 29,
          "position": 983
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/record.test.ts",
        "start": 107,
        "end": 67,
        "startLoc": {
          "line": 107,
          "column": 2,
          "position": 690
        },
        "endLoc": {
          "line": 67,
          "column": 25,
          "position": 514
        }
      }
    },
    {
      "format": "typescript",
      "lines": 12,
      "fragment": ")\n    )\n  ).toBe(true);\n  expect(\n    Object.isFrozen(\n      await z\n        .set(z.promise(z.string()))\n        .readonly()\n        .parseAsync(new Set([Promise.resolve(\"a\")]))\n    )\n  ).toBe(true);\n  expect(Object.isFrozen(await z.record",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/readonly.test.ts",
        "start": 155,
        "end": 166,
        "startLoc": {
          "line": 155,
          "column": 2,
          "position": 1726
        },
        "endLoc": {
          "line": 166,
          "column": 7,
          "position": 1819
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/readonly.test.ts",
        "start": 135,
        "end": 144,
        "startLoc": {
          "line": 135,
          "column": 2,
          "position": 1437
        },
        "endLoc": {
          "line": 144,
          "column": 8,
          "position": 1526
        }
      }
    },
    {
      "format": "typescript",
      "lines": 12,
      "fragment": ", () => {\n  const object = z.object({\n    name: z.string(),\n    age: z.number().optional(),\n    field: z.string().optional().default(\"asdf\"),\n    nullableField: z.number().nullable(),\n    nullishField: z.string().nullish(),\n  });\n\n  const requiredObject = object.required();\n\n  type",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/partial.test.ts",
        "start": 57,
        "end": 68,
        "startLoc": {
          "line": 57,
          "column": 21,
          "position": 680
        },
        "endLoc": {
          "line": 68,
          "column": 5,
          "position": 800
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/partial.test.ts",
        "start": 34,
        "end": 44,
        "startLoc": {
          "line": 34,
          "column": 11,
          "position": 328
        },
        "endLoc": {
          "line": 44,
          "column": 7,
          "position": 447
        }
      }
    },
    {
      "format": "typescript",
      "lines": 19,
      "fragment": "().nonoptional();\n  expectTypeOf<typeof schema._input>().toEqualTypeOf<string>();\n  expectTypeOf<typeof schema._output>().toEqualTypeOf<string>();\n\n  const result = schema.safeParse(undefined);\n  expect(result.success).toBe(false);\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"invalid_type\",\n        \"expected\": \"nonoptional\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected nonoptional, received undefined\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/nonoptional.test.ts",
        "start": 27,
        "end": 45,
        "startLoc": {
          "line": 27,
          "column": 9,
          "position": 176
        },
        "endLoc": {
          "line": 45,
          "column": 4,
          "position": 262
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/nonoptional.test.ts",
        "start": 5,
        "end": 23,
        "startLoc": {
          "line": 5,
          "column": 7,
          "position": 55
        },
        "endLoc": {
          "line": 23,
          "column": 4,
          "position": 141
        }
      }
    },
    {
      "format": "typescript",
      "lines": 25,
      "fragment": ");\n\n  const testData = {\n    val: 1,\n    b: {\n      val: 5,\n      a: {\n        val: 3,\n        b: {\n          val: 4,\n          a: {\n            val: 2,\n            b: {\n              val: 1,\n            },\n          },\n        },\n      },\n    },\n  };\n\n  Alazy.parse(testData);\n  Blazy.parse(testData.b);\n\n  expect",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/lazy.test.ts",
        "start": 148,
        "end": 172,
        "startLoc": {
          "line": 148,
          "column": 3,
          "position": 1275
        },
        "endLoc": {
          "line": 172,
          "column": 7,
          "position": 1407
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/recursive-types.test.ts",
        "start": 85,
        "end": 108,
        "startLoc": {
          "line": 85,
          "column": 2,
          "position": 642
        },
        "endLoc": {
          "line": 108,
          "column": 5,
          "position": 773
        }
      }
    },
    {
      "format": "typescript",
      "lines": 268,
      "fragment": ";\nimport type { util } from \"zod/v4/core\";\n\ntest(\"z.boolean\", () => {\n  const a = z.boolean();\n  expect(z.parse(a, true)).toEqual(true);\n  expect(z.parse(a, false)).toEqual(false);\n  expect(() => z.parse(a, 123)).toThrow();\n  expect(() => z.parse(a, \"true\")).toThrow();\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<boolean>();\n});\n\ntest(\"z.bigint\", () => {\n  const a = z.bigint();\n  expect(z.parse(a, BigInt(123))).toEqual(BigInt(123));\n  expect(() => z.parse(a, 123)).toThrow();\n  expect(() => z.parse(a, \"123\")).toThrow();\n});\n\ntest(\"z.symbol\", () => {\n  const a = z.symbol();\n  const sym = Symbol();\n  expect(z.parse(a, sym)).toEqual(sym);\n  expect(() => z.parse(a, \"symbol\")).toThrow();\n});\n\ntest(\"z.date\", () => {\n  const a = z.date();\n  const date = new Date();\n  expect(z.parse(a, date)).toEqual(date);\n  expect(() => z.parse(a, \"date\")).toThrow();\n});\n\ntest(\"z.coerce.string\", () => {\n  const a = z.coerce.string();\n  expect(z.parse(a, 123)).toEqual(\"123\");\n  expect(z.parse(a, true)).toEqual(\"true\");\n  expect(z.parse(a, null)).toEqual(\"null\");\n  expect(z.parse(a, undefined)).toEqual(\"undefined\");\n});\n\ntest(\"z.coerce.number\", () => {\n  const a = z.coerce.number();\n  expect(z.parse(a, \"123\")).toEqual(123);\n  expect(z.parse(a, \"123.45\")).toEqual(123.45);\n  expect(z.parse(a, true)).toEqual(1);\n  expect(z.parse(a, false)).toEqual(0);\n  expect(() => z.parse(a, \"abc\")).toThrow();\n});\n\ntest(\"z.coerce.boolean\", () => {\n  const a = z.coerce.boolean();\n  // test booleans\n  expect(z.parse(a, true)).toEqual(true);\n  expect(z.parse(a, false)).toEqual(false);\n  expect(z.parse(a, \"true\")).toEqual(true);\n  expect(z.parse(a, \"false\")).toEqual(true);\n  expect(z.parse(a, 1)).toEqual(true);\n  expect(z.parse(a, 0)).toEqual(false);\n  expect(z.parse(a, {})).toEqual(true);\n  expect(z.parse(a, [])).toEqual(true);\n  expect(z.parse(a, undefined)).toEqual(false);\n  expect(z.parse(a, null)).toEqual(false);\n  expect(z.parse(a, \"\")).toEqual(false);\n});\n\ntest(\"z.coerce.bigint\", () => {\n  const a = z.coerce.bigint();\n  expect(z.parse(a, \"123\")).toEqual(BigInt(123));\n  expect(z.parse(a, 123)).toEqual(BigInt(123));\n  expect(() => z.parse(a, \"abc\")).toThrow();\n});\n\ntest(\"z.coerce.date\", () => {\n  const a = z.coerce.date();\n  const date = new Date();\n  expect(z.parse(a, date.toISOString())).toEqual(date);\n  expect(z.parse(a, date.getTime())).toEqual(date);\n  expect(() => z.parse(a, \"invalid date\")).toThrow();\n});\n\ntest(\"z.iso.datetime\", () => {\n  const d1 = \"2021-01-01T00:00:00Z\";\n  const d2 = \"2021-01-01T00:00:00.123Z\";\n  const d3 = \"2021-01-01T00:00:00\";\n  const d4 = \"2021-01-01T00:00:00+07:00\";\n  const d5 = \"bad data\";\n\n  // local: false, offset: false, precision: null\n  const a = z.iso.datetime();\n  expect(z.safeParse(a, d1).success).toEqual(true);\n  expect(z.safeParse(a, d2).success).toEqual(true);\n  expect(z.safeParse(a, d3).success).toEqual(false);\n  expect(z.safeParse(a, d4).success).toEqual(false);\n  expect(z.safeParse(a, d5).success).toEqual(false);\n\n  const b = z.iso.datetime({ local: true });\n  expect(z.safeParse(b, d1).success).toEqual(true);\n  expect(z.safeParse(b, d2).success).toEqual(true);\n  expect(z.safeParse(b, d3).success).toEqual(true);\n  expect(z.safeParse(b, d4).success).toEqual(false);\n  expect(z.safeParse(b, d5).success).toEqual(false);\n\n  const c = z.iso.datetime({ offset: true });\n  expect(z.safeParse(c, d1).success).toEqual(true);\n  expect(z.safeParse(c, d2).success).toEqual(true);\n  expect(z.safeParse(c, d3).success).toEqual(false);\n  expect(z.safeParse(c, d4).success).toEqual(true);\n  expect(z.safeParse(c, d5).success).toEqual(false);\n\n  const d = z.iso.datetime({ precision: 3 });\n  expect(z.safeParse(d, d1).success).toEqual(false);\n  expect(z.safeParse(d, d2).success).toEqual(true);\n  expect(z.safeParse(d, d3).success).toEqual(false);\n  expect(z.safeParse(d, d4).success).toEqual(false);\n  expect(z.safeParse(d, d5).success).toEqual(false);\n});\n\ntest(\"z.iso.date\", () => {\n  const d1 = \"2021-01-01\";\n  const d2 = \"bad data\";\n\n  const a = z.iso.date();\n  expect(z.safeParse(a, d1).success).toEqual(true);\n  expect(z.safeParse(a, d2).success).toEqual(false);\n\n  const b = z.string().check(z.iso.date());\n  expect(z.safeParse(b, d1).success).toEqual(true);\n  expect(z.safeParse(b, d2).success).toEqual(false);\n});\n\ntest(\"z.iso.time\", () => {\n  const d1 = \"00:00:00\";\n  const d2 = \"00:00:00.123\";\n  const d3 = \"bad data\";\n\n  const a = z.iso.time();\n  expect(z.safeParse(a, d1).success).toEqual(true);\n  expect(z.safeParse(a, d2).success).toEqual(true);\n  expect(z.safeParse(a, d3).success).toEqual(false);\n\n  const b = z.iso.time({ precision: 3 });\n  expect(z.safeParse(b, d1).success).toEqual(false);\n  expect(z.safeParse(b, d2).success).toEqual(true);\n  expect(z.safeParse(b, d3).success).toEqual(false);\n\n  const c = z.string().check(z.iso.time());\n  expect(z.safeParse(c, d1).success).toEqual(true);\n  expect(z.safeParse(c, d2).success).toEqual(true);\n  expect(z.safeParse(c, d3).success).toEqual(false);\n});\n\ntest(\"z.iso.duration\", () => {\n  const d1 = \"P3Y6M4DT12H30M5S\";\n  const d2 = \"bad data\";\n\n  const a = z.iso.duration();\n  expect(z.safeParse(a, d1).success).toEqual(true);\n  expect(z.safeParse(a, d2).success).toEqual(false);\n\n  const b = z.string().check(z.iso.duration());\n  expect(z.safeParse(b, d1).success).toEqual(true);\n  expect(z.safeParse(b, d2).success).toEqual(false);\n});\n\ntest(\"z.undefined\", () => {\n  const a = z.undefined();\n  expect(z.parse(a, undefined)).toEqual(undefined);\n  expect(() => z.parse(a, \"undefined\")).toThrow();\n});\n\ntest(\"z.null\", () => {\n  const a = z.null();\n  expect(z.parse(a, null)).toEqual(null);\n  expect(() => z.parse(a, \"null\")).toThrow();\n});\n\ntest(\"z.any\", () => {\n  const a = z.any();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, 123)).toEqual(123);\n  expect(z.parse(a, true)).toEqual(true);\n  expect(z.parse(a, null)).toEqual(null);\n  expect(z.parse(a, undefined)).toEqual(undefined);\n  z.parse(a, {});\n  z.parse(a, []);\n  z.parse(a, Symbol());\n  z.parse(a, new Date());\n});\n\ntest(\"z.unknown\", () => {\n  const a = z.unknown();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, 123)).toEqual(123);\n  expect(z.parse(a, true)).toEqual(true);\n  expect(z.parse(a, null)).toEqual(null);\n  expect(z.parse(a, undefined)).toEqual(undefined);\n  z.parse(a, {});\n  z.parse(a, []);\n  z.parse(a, Symbol());\n  z.parse(a, new Date());\n});\n\ntest(\"z.never\", () => {\n  const a = z.never();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n});\n\ntest(\"z.void\", () => {\n  const a = z.void();\n  expect(z.parse(a, undefined)).toEqual(undefined);\n  expect(() => z.parse(a, null)).toThrow();\n});\n\ntest(\"z.array\", () => {\n  const a = z.array(z.string());\n  expect(z.parse(a, [\"hello\", \"world\"])).toEqual([\"hello\", \"world\"]);\n  expect(() => z.parse(a, [123])).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n});\n\ntest(\"z.union\", () => {\n  const a = z.union([z.string(), z.number()]);\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, 123)).toEqual(123);\n  expect(() => z.parse(a, true)).toThrow();\n});\n\ntest(\"z.intersection\", () => {\n  const a = z.intersection(z.object({ a: z.string() }), z.object({ b: z.number() }));\n  expect(z.parse(a, { a: \"hello\", b: 123 })).toEqual({ a: \"hello\", b: 123 });\n  expect(() => z.parse(a, { a: \"hello\" })).toThrow();\n  expect(() => z.parse(a, { b: 123 })).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n});\n\ntest(\"z.tuple\", () => {\n  const a = z.tuple([z.string(), z.number()]);\n  expect(z.parse(a, [\"hello\", 123])).toEqual([\"hello\", 123]);\n  expect(() => z.parse(a, [\"hello\", \"world\"])).toThrow();\n  expect(() => z.parse(a, [123, 456])).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n\n  // tuple with rest\n  const b = z.tuple([z.string(), z.number(), z.optional(z.string())], z.boolean());\n  type b = z.output<typeof b>;\n\n  expectTypeOf<b>().toEqualTypeOf<[string, number, string?, ...boolean[]]>();\n  const datas = [\n    [\"hello\", 123],\n    [\"hello\", 123, \"world\"],\n    [\"hello\", 123, \"world\", true],\n    [\"hello\", 123, \"world\", true, false, true],\n  ];\n  for (const data of datas) {\n    expect(z.parse(b, data)).toEqual(data);\n  }\n\n  expect(() => z.parse(b, [\"hello\", 123, 123])).toThrow();\n  expect(() => z.parse(b, [\"hello\", 123, \"world\", 123])).toThrow();\n\n  // tuple with readonly args\n  const cArgs = [z.string(), z.number(), z.optional(z.string())] as const;\n  const c = z.tuple(cArgs, z.boolean());\n  type c = z.output<typeof c>;\n  expectTypeOf<c>().toEqualTypeOf<[string, number, string?, ...boolean[]]>();\n  // type c = z.output<typeof c>;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/index.test.ts",
        "start": 2,
        "end": 269,
        "startLoc": {
          "line": 2,
          "column": 9,
          "position": 30
        },
        "endLoc": {
          "line": 269,
          "column": 32,
          "position": 4082
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/index.test.ts",
        "start": 2,
        "end": 269,
        "startLoc": {
          "line": 2,
          "column": 14,
          "position": 30
        },
        "endLoc": {
          "line": 269,
          "column": 2,
          "position": 4081
        }
      }
    },
    {
      "format": "typescript",
      "lines": 32,
      "fragment": "});\n\ntest(\"z.record\", () => {\n  // record schema with enum keys\n  const a = z.record(z.string(), z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<Record<string, string>>();\n\n  const b = z.record(z.union([z.string(), z.number(), z.symbol()]), z.string());\n  type b = z.output<typeof b>;\n  expectTypeOf<b>().toEqualTypeOf<Record<string | number | symbol, string>>();\n  expect(z.parse(b, { a: \"hello\", 1: \"world\", [Symbol.for(\"asdf\")]: \"symbol\" })).toEqual({\n    a: \"hello\",\n    1: \"world\",\n    [Symbol.for(\"asdf\")]: \"symbol\",\n  });\n\n  // enum keys\n  const c = z.record(z.enum([\"a\", \"b\", \"c\"]), z.string());\n  type c = z.output<typeof c>;\n  expectTypeOf<c>().toEqualTypeOf<Record<\"a\" | \"b\" | \"c\", string>>();\n  expect(z.parse(c, { a: \"hello\", b: \"world\", c: \"world\" })).toEqual({\n    a: \"hello\",\n    b: \"world\",\n    c: \"world\",\n  });\n  // missing keys\n  expect(() => z.parse(c, { a: \"hello\", b: \"world\" })).toThrow();\n  // extra keys\n  expect(() => z.parse(c, { a: \"hello\", b: \"world\", c: \"world\", d: \"world\" })).toThrow();\n\n  // partial enum",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/index.test.ts",
        "start": 270,
        "end": 301,
        "startLoc": {
          "line": 270,
          "column": 1,
          "position": 4084
        },
        "endLoc": {
          "line": 301,
          "column": 16,
          "position": 4581
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/index.test.ts",
        "start": 269,
        "end": 299,
        "startLoc": {
          "line": 269,
          "column": 1,
          "position": 4081
        },
        "endLoc": {
          "line": 299,
          "column": 2,
          "position": 4576
        }
      }
    },
    {
      "format": "typescript",
      "lines": 76,
      "fragment": "();\n});\n\ntest(\"z.map\", () => {\n  const a = z.map(z.string(), z.number());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<Map<string, number>>();\n  expect(z.parse(a, new Map([[\"hello\", 123]]))).toEqual(new Map([[\"hello\", 123]]));\n  expect(() => z.parse(a, new Map([[\"hello\", \"world\"]]))).toThrow();\n  expect(() => z.parse(a, new Map([[1243, \"world\"]]))).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n\n  const r1 = z.safeParse(a, new Map([[123, 123]]));\n  expect(r1.error?.issues[0].code).toEqual(\"invalid_type\");\n  expect(r1.error?.issues[0].path).toEqual([123]);\n\n  const r2: any = z.safeParse(a, new Map([[BigInt(123), 123]]));\n  expect(r2.error!.issues[0].code).toEqual(\"invalid_key\");\n  expect(r2.error!.issues[0].path).toEqual([]);\n\n  const r3: any = z.safeParse(a, new Map([[\"hello\", \"world\"]]));\n  expect(r3.error!.issues[0].code).toEqual(\"invalid_type\");\n  expect(r3.error!.issues[0].path).toEqual([\"hello\"]);\n});\n\ntest(\"z.map invalid_element\", () => {\n  const a = z.map(z.bigint(), z.number());\n  const r1 = z.safeParse(a, new Map([[BigInt(123), BigInt(123)]]));\n\n  expect(r1.error!.issues[0].code).toEqual(\"invalid_element\");\n  expect(r1.error!.issues[0].path).toEqual([]);\n});\n\ntest(\"z.map async\", async () => {\n  const a = z.map(z.string().check(z.refine(async () => true)), z.number().check(z.refine(async () => true)));\n  const d1 = new Map([[\"hello\", 123]]);\n  expect(await z.parseAsync(a, d1)).toEqual(d1);\n\n  await expect(z.parseAsync(a, new Map([[123, 123]]))).rejects.toThrow();\n  await expect(z.parseAsync(a, new Map([[\"hi\", \"world\"]]))).rejects.toThrow();\n  await expect(z.parseAsync(a, new Map([[1243, \"world\"]]))).rejects.toThrow();\n  await expect(z.parseAsync(a, \"hello\")).rejects.toThrow();\n\n  const r = await z.safeParseAsync(a, new Map([[123, 123]]));\n  expect(r.success).toEqual(false);\n  expect(r.error!.issues[0].code).toEqual(\"invalid_type\");\n  expect(r.error!.issues[0].path).toEqual([123]);\n});\n\ntest(\"z.set\", () => {\n  const a = z.set(z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<Set<string>>();\n  expect(z.parse(a, new Set([\"hello\", \"world\"]))).toEqual(new Set([\"hello\", \"world\"]));\n  expect(() => z.parse(a, new Set([123]))).toThrow();\n  expect(() => z.parse(a, [\"hello\", \"world\"])).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n\n  const b = z.set(z.number());\n  expect(z.parse(b, new Set([1, 2, 3]))).toEqual(new Set([1, 2, 3]));\n  expect(() => z.parse(b, new Set([\"hello\"]))).toThrow();\n  expect(() => z.parse(b, [1, 2, 3])).toThrow();\n  expect(() => z.parse(b, 123)).toThrow();\n});\n\ntest(\"z.enum\", () => {\n  const a = z.enum([\"A\", \"B\", \"C\"]);\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<\"A\" | \"B\" | \"C\">();\n  expect(z.parse(a, \"A\")).toEqual(\"A\");\n  expect(z.parse(a, \"B\")).toEqual(\"B\");\n  expect(z.parse(a, \"C\")).toEqual(\"C\");\n  expect(() => z.parse(a, \"D\")).toThrow();\n  expect(() => z.parse(a, 123)).toThrow();\n\n  expect",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/index.test.ts",
        "start": 304,
        "end": 379,
        "startLoc": {
          "line": 304,
          "column": 3,
          "position": 4662
        },
        "endLoc": {
          "line": 379,
          "column": 7,
          "position": 6135
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/index.test.ts",
        "start": 298,
        "end": 373,
        "startLoc": {
          "line": 298,
          "column": 8,
          "position": 4572
        },
        "endLoc": {
          "line": 373,
          "column": 34,
          "position": 6045
        }
      }
    },
    {
      "format": "typescript",
      "lines": 20,
      "fragment": "});\n\ntest(\"z.enum - native\", () => {\n  enum NativeEnum {\n    A = \"A\",\n    B = \"B\",\n    C = \"C\",\n  }\n  const a = z.enum(NativeEnum);\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<NativeEnum>();\n  expect(z.parse(a, NativeEnum.A)).toEqual(NativeEnum.A);\n  expect(z.parse(a, NativeEnum.B)).toEqual(NativeEnum.B);\n  expect(z.parse(a, NativeEnum.C)).toEqual(NativeEnum.C);\n  expect(() => z.parse(a, \"D\")).toThrow();\n  expect(() => z.parse(a, 123)).toThrow();\n\n  // test a.enum\n  a;\n  expect",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/index.test.ts",
        "start": 383,
        "end": 402,
        "startLoc": {
          "line": 383,
          "column": 1,
          "position": 6204
        },
        "endLoc": {
          "line": 402,
          "column": 7,
          "position": 6432
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/index.test.ts",
        "start": 377,
        "end": 396,
        "startLoc": {
          "line": 377,
          "column": 1,
          "position": 6056
        },
        "endLoc": {
          "line": 396,
          "column": 43,
          "position": 6284
        }
      }
    },
    {
      "format": "typescript",
      "lines": 25,
      "fragment": "});\n\ntest(\"z.nativeEnum\", () => {\n  enum NativeEnum {\n    A = \"A\",\n    B = \"B\",\n    C = \"C\",\n  }\n  const a = z.nativeEnum(NativeEnum);\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<NativeEnum>();\n  expect(z.parse(a, NativeEnum.A)).toEqual(NativeEnum.A);\n  expect(z.parse(a, NativeEnum.B)).toEqual(NativeEnum.B);\n  expect(z.parse(a, NativeEnum.C)).toEqual(NativeEnum.C);\n  expect(() => z.parse(a, \"D\")).toThrow();\n  expect(() => z.parse(a, 123)).toThrow();\n\n  // test a.enum\n  a;\n  expect(a.enum.A).toEqual(NativeEnum.A);\n  expect(a.enum.B).toEqual(NativeEnum.B);\n  expect(a.enum.C).toEqual(NativeEnum.C);\n});\n\ntest(\"z.literal\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/index.test.ts",
        "start": 405,
        "end": 429,
        "startLoc": {
          "line": 405,
          "column": 1,
          "position": 6485
        },
        "endLoc": {
          "line": 429,
          "column": 12,
          "position": 6773
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/index.test.ts",
        "start": 399,
        "end": 407,
        "startLoc": {
          "line": 399,
          "column": 1,
          "position": 6292
        },
        "endLoc": {
          "line": 407,
          "column": 15,
          "position": 6492
        }
      }
    },
    {
      "format": "typescript",
      "lines": 185,
      "fragment": ");\n});\n\ntest(\"z.file\", () => {\n  const a = z.file();\n  const file = new File([\"content\"], \"filename.txt\", { type: \"text/plain\" });\n  expect(z.parse(a, file)).toEqual(file);\n  expect(() => z.parse(a, \"file\")).toThrow();\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.transform\", () => {\n  const a = z.pipe(\n    z.string(),\n    z.transform((val) => val.toUpperCase())\n  );\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n  expect(z.parse(a, \"hello\")).toEqual(\"HELLO\");\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.transform async\", async () => {\n  const a = z.pipe(\n    z.string(),\n    z.transform(async (val) => val.toUpperCase())\n  );\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n  expect(await z.parseAsync(a, \"hello\")).toEqual(\"HELLO\");\n  await expect(() => z.parseAsync(a, 123)).rejects.toThrow();\n});\n\ntest(\"z.preprocess\", () => {\n  const a = z.pipe(\n    z.transform((val) => String(val).toUpperCase()),\n    z.string()\n  );\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n  expect(z.parse(a, 123)).toEqual(\"123\");\n  expect(z.parse(a, true)).toEqual(\"TRUE\");\n  expect(z.parse(a, BigInt(1234))).toEqual(\"1234\");\n  // expect(() => z.parse(a, Symbol(\"asdf\"))).toThrow();\n});\n\n// test(\"z.preprocess async\", () => {\n//   const a = z.preprocess(async (val) => String(val), z.string());\n//   type a = z.output<typeof a>;\n//   expectTypeOf<a>().toEqualTypeOf<string>();\n//   expect(z.parse(a, 123)).toEqual(\"123\");\n//   expect(z.parse(a, true)).toEqual(\"true\");\n//   expect(() => z.parse(a, {})).toThrow();\n// });\n\ntest(\"z.optional\", () => {\n  const a = z.optional(z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string | undefined>();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, undefined)).toEqual(undefined);\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.nullable\", () => {\n  const a = z.nullable(z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string | null>();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, null)).toEqual(null);\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.default\", () => {\n  const a = z._default(z.string(), \"default\");\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n  expect(z.parse(a, undefined)).toEqual(\"default\");\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(() => z.parse(a, 123)).toThrow();\n\n  const b = z._default(z.string(), () => \"default\");\n  expect(z.parse(b, undefined)).toEqual(\"default\");\n  expect(z.parse(b, \"hello\")).toEqual(\"hello\");\n  expect(() => z.parse(b, 123)).toThrow();\n});\n\ntest(\"z.catch\", () => {\n  const a = z.catch(z.string(), \"default\");\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, 123)).toEqual(\"default\");\n\n  const b = z.catch(z.string(), () => \"default\");\n  expect(z.parse(b, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(b, 123)).toEqual(\"default\");\n\n  const c = z.catch(z.string(), (ctx) => {\n    return `${ctx.error.issues.length}issues`;\n  });\n  expect(z.parse(c, 1234)).toEqual(\"1issues\");\n});\n\ntest(\"z.nan\", () => {\n  const a = z.nan();\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<number>();\n  expect(z.parse(a, Number.NaN)).toEqual(Number.NaN);\n  expect(() => z.parse(a, 123)).toThrow();\n  expect(() => z.parse(a, \"NaN\")).toThrow();\n});\n\ntest(\"z.pipe\", () => {\n  const a = z.pipe(\n    z.pipe(\n      z.string(),\n      z.transform((val) => val.length)\n    ),\n    z.number()\n  );\n  type a_in = z.input<typeof a>;\n  expectTypeOf<a_in>().toEqualTypeOf<string>();\n  type a_out = z.output<typeof a>;\n  expectTypeOf<a_out>().toEqualTypeOf<number>();\n\n  expect(z.parse(a, \"123\")).toEqual(3);\n  expect(z.parse(a, \"hello\")).toEqual(5);\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.readonly\", () => {\n  const a = z.readonly(z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<Readonly<string>>();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.templateLiteral\", () => {\n  const a = z.templateLiteral([z.string(), z.number()]);\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<`${string}${number}`>();\n  expect(z.parse(a, \"hello123\")).toEqual(\"hello123\");\n  expect(() => z.parse(a, \"hello\")).toThrow();\n  expect(() => z.parse(a, 123)).toThrow();\n\n  // multipart\n  const b = z.templateLiteral([z.string(), z.number(), z.string()]);\n  type b = z.output<typeof b>;\n  expectTypeOf<b>().toEqualTypeOf<`${string}${number}${string}`>();\n  expect(z.parse(b, \"hello123world\")).toEqual(\"hello123world\");\n  expect(z.parse(b, \"123\")).toEqual(\"123\");\n  expect(() => z.parse(b, \"hello\")).toThrow();\n  expect(() => z.parse(b, 123)).toThrow();\n\n  // include boolean\n  const c = z.templateLiteral([z.string(), z.boolean()]);\n  type c = z.output<typeof c>;\n  expectTypeOf<c>().toEqualTypeOf<`${string}${boolean}`>();\n  expect(z.parse(c, \"hellotrue\")).toEqual(\"hellotrue\");\n  expect(z.parse(c, \"hellofalse\")).toEqual(\"hellofalse\");\n  expect(() => z.parse(c, \"hello\")).toThrow();\n  expect(() => z.parse(c, 123)).toThrow();\n\n  // include literal prefix\n  const d = z.templateLiteral([z.literal(\"hello\"), z.number()]);\n  type d = z.output<typeof d>;\n  expectTypeOf<d>().toEqualTypeOf<`hello${number}`>();\n  expect(z.parse(d, \"hello123\")).toEqual(\"hello123\");\n  expect(() => z.parse(d, 123)).toThrow();\n  expect(() => z.parse(d, \"world123\")).toThrow();\n\n  // include literal union\n  const e = z.templateLiteral([z.literal([\"aa\", \"bb\"]), z.number()]);\n  type e = z.output<typeof e>;\n  expectTypeOf<e>().toEqualTypeOf<`aa${number}` | `bb${number}`>();\n  expect(z.parse(e, \"aa123\")).toEqual(\"aa123\");\n  expect(z.parse(e, \"bb123\")).toEqual(\"bb123\");\n  expect(() => z.parse(e, \"cc123\")).toThrow();\n  expect(() => z.parse(e, 123)).toThrow();\n});\n\n// this returns both a schema and a check\ntest(\"z.custom schema\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/index.test.ts",
        "start": 435,
        "end": 619,
        "startLoc": {
          "line": 435,
          "column": 2,
          "position": 6896
        },
        "endLoc": {
          "line": 619,
          "column": 18,
          "position": 9495
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/index.test.ts",
        "start": 431,
        "end": 615,
        "startLoc": {
          "line": 431,
          "column": 6,
          "position": 6674
        },
        "endLoc": {
          "line": 615,
          "column": 11,
          "position": 9273
        }
      }
    },
    {
      "format": "typescript",
      "lines": 95,
      "fragment": "const a = z.any().check(\n    z.check<string>((ctx) => {\n      if (typeof ctx.value === \"string\") return;\n      ctx.issues.push({\n        code: \"custom\",\n        origin: \"custom\",\n        message: \"Expected a string\",\n        input: ctx.value,\n      });\n    })\n  );\n  expect(z.safeParse(a, \"hello\")).toMatchObject({\n    success: true,\n    data: \"hello\",\n  });\n  expect(z.safeParse(a, 123)).toMatchObject({\n    success: false,\n    error: { issues: [{ code: \"custom\", message: \"Expected a string\" }] },\n  });\n});\n\ntest(\"z.instanceof\", () => {\n  class A {}\n\n  const a = z.instanceof(A);\n  expect(z.parse(a, new A())).toBeInstanceOf(A);\n  expect(() => z.parse(a, {})).toThrow();\n});\n\ntest(\"z.refine\", () => {\n  const a = z.number().check(\n    z.refine((val) => val > 3),\n    z.refine((val) => val < 10)\n  );\n  expect(z.parse(a, 5)).toEqual(5);\n  expect(() => z.parse(a, 2)).toThrow();\n  expect(() => z.parse(a, 11)).toThrow();\n  expect(() => z.parse(a, \"hi\")).toThrow();\n});\n\n// test(\"z.superRefine\", () => {\n//   const a = z.number([\n//     z.superRefine((val, ctx) => {\n//       if (val < 3) {\n//         return ctx.addIssue({\n//           code: \"custom\",\n//           origin: \"custom\",\n//           message: \"Too small\",\n//           input: val,\n//         });\n//       }\n//       if (val > 10) {\n//         return ctx.addIssue(\"Too big\");\n//       }\n//     }),\n//   ]);\n\n//   expect(z.parse(a, 5)).toEqual(5);\n//   expect(() => z.parse(a, 2)).toThrow();\n//   expect(() => z.parse(a, 11)).toThrow();\n//   expect(() => z.parse(a, \"hi\")).toThrow();\n// });\n\ntest(\"z.transform\", () => {\n  const a = z.transform((val: number) => {\n    return `${val}`;\n  });\n  type a_in = z.input<typeof a>;\n  expectTypeOf<a_in>().toEqualTypeOf<number>();\n  type a_out = z.output<typeof a>;\n  expectTypeOf<a_out>().toEqualTypeOf<string>();\n  expect(z.parse(a, 123)).toEqual(\"123\");\n});\n\ntest(\"z.$brand()\", () => {\n  const a = z.string().brand<\"my-brand\">();\n  type a = z.output<typeof a>;\n  const branded = (_: a) => {};\n  // @ts-expect-error\n  branded(\"asdf\");\n});\n\ntest(\"z.lazy\", () => {\n  const a = z.lazy(() => z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\n// schema that validates JSON-like data\ntest(\"z.json\", () => {\n  const a = z.json();\n  type a = z.output<typeof a>;\n  expectTypeOf",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/index.test.ts",
        "start": 635,
        "end": 729,
        "startLoc": {
          "line": 635,
          "column": 3,
          "position": 9661
        },
        "endLoc": {
          "line": 729,
          "column": 13,
          "position": 10552
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/index.test.ts",
        "start": 631,
        "end": 725,
        "startLoc": {
          "line": 631,
          "column": 3,
          "position": 9469
        },
        "endLoc": {
          "line": 725,
          "column": 2,
          "position": 10360
        }
      }
    },
    {
      "format": "typescript",
      "lines": 21,
      "fragment": ";\n  expectTypeOf<a>().toEqualTypeOf<util.JSONType>();\n\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, 123)).toEqual(123);\n  expect(z.parse(a, true)).toEqual(true);\n  expect(z.parse(a, null)).toEqual(null);\n  expect(z.parse(a, {})).toEqual({});\n  expect(z.parse(a, { a: \"hello\" })).toEqual({ a: \"hello\" });\n  expect(z.parse(a, [1, 2, 3])).toEqual([1, 2, 3]);\n  expect(z.parse(a, [{ a: \"hello\" }])).toEqual([{ a: \"hello\" }]);\n\n  // fail cases\n  expect(() => z.parse(a, new Date())).toThrow();\n  expect(() => z.parse(a, Symbol())).toThrow();\n  expect(() => z.parse(a, { a: new Date() })).toThrow();\n  expect(() => z.parse(a, undefined)).toThrow();\n  expect(() => z.parse(a, { a: undefined })).toThrow();\n});\n\n// promise",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/index.test.ts",
        "start": 728,
        "end": 748,
        "startLoc": {
          "line": 728,
          "column": 2,
          "position": 10549
        },
        "endLoc": {
          "line": 748,
          "column": 11,
          "position": 10933
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/index.test.ts",
        "start": 725,
        "end": 746,
        "startLoc": {
          "line": 725,
          "column": 7,
          "position": 10365
        },
        "endLoc": {
          "line": 746,
          "column": 5,
          "position": 10750
        }
      }
    },
    {
      "format": "typescript",
      "lines": 35,
      "fragment": ");\n});\n\n// promise\ntest(\"z.promise\", async () => {\n  const a = z.promise(z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n\n  expect(await z.safeParseAsync(a, Promise.resolve(\"hello\"))).toMatchObject({\n    success: true,\n    data: \"hello\",\n  });\n  expect(await z.safeParseAsync(a, Promise.resolve(123))).toMatchObject({\n    success: false,\n  });\n\n  const b = z.string();\n  expect(() => z.parse(b, Promise.resolve(\"hello\"))).toThrow();\n});\n// test(\"type assertions\", () => {\n//   const schema = z.pipe(\n//     z.string(),\n//     z.transform((val) => val.length)\n//   );\n//   schema.assertInput<string>();\n//   // @ts-expect-error\n//   schema.assertInput<number>();\n\n//   schema.assertOutput<number>();\n//   // @ts-expect-error\n//   schema.assertOutput<string>();\n// });\n\ntest(\"isPlainObject\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/index.test.ts",
        "start": 745,
        "end": 779,
        "startLoc": {
          "line": 745,
          "column": 2,
          "position": 10925
        },
        "endLoc": {
          "line": 779,
          "column": 16,
          "position": 11159
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/index.test.ts",
        "start": 785,
        "end": 820,
        "startLoc": {
          "line": 785,
          "column": 2,
          "position": 11423
        },
        "endLoc": {
          "line": 820,
          "column": 26,
          "position": 11658
        }
      }
    },
    {
      "format": "typescript",
      "lines": 16,
      "fragment": ").def.type satisfies \"nullable\";\n  z.null().def.type satisfies \"null\";\n  z.any().def.type satisfies \"any\";\n  z.unknown().def.type satisfies \"unknown\";\n  z.never().def.type satisfies \"never\";\n  z.void().def.type satisfies \"void\";\n  z.array(z.string()).def.type satisfies \"array\";\n  z.object({ key: z.string() }).def.type satisfies \"object\";\n  z.union([z.string(), z.number()]).def.type satisfies \"union\";\n  z.intersection(z.string(), z.number()).def.type satisfies \"intersection\";\n  z.tuple([z.string(), z.number()]).def.type satisfies \"tuple\";\n  z.record(z.string(), z.number()).def.type satisfies \"record\";\n  z.map(z.string(), z.number()).def.type satisfies \"map\";\n  z.set(z.string()).def.type satisfies \"set\";\n  z.literal(\"example\").def.type satisfies \"literal\";\n  z",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/index.test.ts",
        "start": 799,
        "end": 814,
        "startLoc": {
          "line": 799,
          "column": 2,
          "position": 11509
        },
        "endLoc": {
          "line": 814,
          "column": 2,
          "position": 11832
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/index.test.ts",
        "start": 840,
        "end": 855,
        "startLoc": {
          "line": 840,
          "column": 2,
          "position": 11921
        },
        "endLoc": {
          "line": 855,
          "column": 13,
          "position": 12244
        }
      }
    },
    {
      "format": "typescript",
      "lines": 77,
      "fragment": ":\n      break;\n    case \"bigint\":\n      break;\n    case \"boolean\":\n      break;\n    case \"date\":\n      break;\n    case \"symbol\":\n      break;\n    case \"undefined\":\n      break;\n    case \"null\":\n      break;\n    case \"any\":\n      break;\n    case \"unknown\":\n      break;\n    case \"never\":\n      break;\n    case \"void\":\n      break;\n    case \"array\":\n      break;\n    case \"object\":\n      break;\n    case \"union\":\n      break;\n    case \"intersection\":\n      break;\n    case \"tuple\":\n      break;\n    case \"record\":\n      break;\n    case \"map\":\n      break;\n    case \"set\":\n      break;\n    case \"literal\":\n      break;\n    case \"enum\":\n      break;\n    case \"promise\":\n      break;\n    case \"optional\":\n      break;\n    case \"nonoptional\":\n      break;\n    case \"nullable\":\n      break;\n    case \"default\":\n      break;\n    case \"prefault\":\n      break;\n    case \"template_literal\":\n      break;\n    case \"custom\":\n      break;\n    case \"transform\":\n      break;\n    case \"readonly\":\n      break;\n    case \"nan\":\n      break;\n    case \"pipe\":\n      break;\n    case \"success\":\n      break;\n    case \"catch\":\n      break;\n    case \"file\":\n      break;\n    case \"lazy\":\n      break;\n\n    default:\n      expectTypeOf(type",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/firstparty.test.ts",
        "start": 97,
        "end": 173,
        "startLoc": {
          "line": 97,
          "column": 6,
          "position": 572
        },
        "endLoc": {
          "line": 173,
          "column": 5,
          "position": 946
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/firstparty.test.ts",
        "start": 11,
        "end": 86,
        "startLoc": {
          "line": 11,
          "column": 9,
          "position": 116
        },
        "endLoc": {
          "line": 86,
          "column": 4,
          "position": 489
        }
      }
    },
    {
      "format": "typescript",
      "lines": 16,
      "fragment": ")\n    .safeParse(2);\n  expect(result.success).toBe(false);\n  expect(result.error!.issues.length).toEqual(1);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"override\"\n      }\n    ]]\n  `);\n});\n\ntest(\"array minimum\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/error.test.ts",
        "start": 149,
        "end": 164,
        "startLoc": {
          "line": 149,
          "column": 2,
          "position": 994
        },
        "endLoc": {
          "line": 164,
          "column": 16,
          "position": 1058
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/error.test.ts",
        "start": 129,
        "end": 144,
        "startLoc": {
          "line": 129,
          "column": 11,
          "position": 877
        },
        "endLoc": {
          "line": 144,
          "column": 31,
          "position": 941
        }
      }
    },
    {
      "format": "typescript",
      "lines": 12,
      "fragment": ", () => {\n  expect(\n    z\n      .discriminatedUnion(\"type\", [\n        z.object({ type: z.literal(\"a\"), a: z.string() }),\n        z.object({ type: z.literal(\"b\"), b: z.string() }),\n      ])\n      .parse({ type: \"a\", a: \"abc\" })\n  ).toEqual({ type: \"a\", a: \"abc\" });\n});\n\ntest(\"valid - optional discriminator (object)\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/discriminated-unions.test.ts",
        "start": 43,
        "end": 54,
        "startLoc": {
          "line": 43,
          "column": 49,
          "position": 747
        },
        "endLoc": {
          "line": 54,
          "column": 42,
          "position": 887
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/discriminated-unions.test.ts",
        "start": 32,
        "end": 43,
        "startLoc": {
          "line": 32,
          "column": 23,
          "position": 606
        },
        "endLoc": {
          "line": 43,
          "column": 49,
          "position": 746
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "{ name: \"hello again\" }));\n\n  // number branding\n  const numberSchema = z.number().brand<42>();\n  type NumberSchema = z.infer<typeof numberSchema>;\n  expectTypeOf<NumberSchema>().toEqualTypeOf<number & { [z.$brand]: { 42: true } }>();\n\n  // symbol branding\n  const MyBrand: unique symbol = Symbol(\"hello\");\n  type MyBrand = typeof MyBrand;\n  const symbolBrand = z.number().brand<\"sup\">().brand<typeof MyBrand>();\n  type SymbolBrand = z.infer<typeof symbolBrand>;\n  // number & { [z.BRAND]: { sup: true, [MyBrand]: true } }",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/brand.test.ts",
        "start": 24,
        "end": 36,
        "startLoc": {
          "line": 24,
          "column": 2,
          "position": 260
        },
        "endLoc": {
          "line": 36,
          "column": 58,
          "position": 434
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/brand.test.ts",
        "start": 24,
        "end": 36,
        "startLoc": {
          "line": 24,
          "column": 2,
          "position": 268
        },
        "endLoc": {
          "line": 36,
          "column": 59,
          "position": 442
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "},\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"(NaN)\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-CN.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 11,
          "position": 297
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 6,
          "position": 297
        }
      }
    },
    {
      "format": "typescript",
      "lines": 15,
      "fragment": ";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-CN.ts",
        "start": 29,
        "end": 43,
        "startLoc": {
          "line": 29,
          "column": 11,
          "position": 355
        },
        "endLoc": {
          "line": 43,
          "column": 5,
          "position": 461
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 29,
        "end": 43,
        "startLoc": {
          "line": 29,
          "column": 7,
          "position": 355
        },
        "endLoc": {
          "line": 43,
          "column": 5,
          "position": 461
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "},\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"s\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/vi.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 5,
          "position": 301
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 9,
          "position": 301
        }
      }
    },
    {
      "format": "typescript",
      "lines": 18,
      "fragment": ";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"u vo\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/vi.ts",
        "start": 26,
        "end": 43,
        "startLoc": {
          "line": 26,
          "column": 7,
          "position": 333
        },
        "endLoc": {
          "line": 43,
          "column": 10,
          "position": 461
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 26,
        "end": 43,
        "startLoc": {
          "line": 26,
          "column": 8,
          "position": 333
        },
        "endLoc": {
          "line": 43,
          "column": 5,
          "position": 461
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ngy gi ISO\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/vi.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 16,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 15,
          "position": 559
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 7,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 11,
          "position": 559
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "},\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/ur.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 7,
          "position": 301
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 9,
          "position": 301
        }
      }
    },
    {
      "format": "typescript",
      "lines": 15,
      "fragment": ";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \" \"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/ur.ts",
        "start": 29,
        "end": 43,
        "startLoc": {
          "line": 29,
          "column": 5,
          "position": 355
        },
        "endLoc": {
          "line": 43,
          "column": 8,
          "position": 461
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 29,
        "end": 43,
        "startLoc": {
          "line": 29,
          "column": 7,
          "position": 355
        },
        "endLoc": {
          "line": 43,
          "column": 5,
          "position": 461
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "},\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/ua.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 8,
          "position": 301
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 9,
          "position": 301
        }
      }
    },
    {
      "format": "typescript",
      "lines": 18,
      "fragment": ";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \" \"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/ua.ts",
        "start": 26,
        "end": 43,
        "startLoc": {
          "line": 26,
          "column": 8,
          "position": 333
        },
        "endLoc": {
          "line": 43,
          "column": 14,
          "position": 461
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 26,
        "end": 43,
        "startLoc": {
          "line": 26,
          "column": 8,
          "position": 333
        },
        "endLoc": {
          "line": 43,
          "column": 5,
          "position": 461
        }
      }
    },
    {
      "format": "typescript",
      "lines": 24,
      "fragment": "const parsedType = (data: any): string => {\n  const t = typeof data;\n\n  switch (t) {\n    case \"number\": {\n      return Number.isNaN(data) ? \"NaN\" : \"number\";\n    }\n    case \"object\": {\n      if (Array.isArray(data)) {\n        return \"array\";\n      }\n      if (data === null) {\n        return \"null\";\n      }\n\n      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n        return data.constructor.name;\n      }\n    }\n  }\n  return t;\n};\n\nconst error",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/tr.ts",
        "start": 5,
        "end": 28,
        "startLoc": {
          "line": 5,
          "column": 2,
          "position": 46
        },
        "endLoc": {
          "line": 28,
          "column": 6,
          "position": 229
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 17,
        "end": 40,
        "startLoc": {
          "line": 17,
          "column": 3,
          "position": 235
        },
        "endLoc": {
          "line": 40,
          "column": 6,
          "position": 420
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO tarih ve saat\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/tr.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 17,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 20,
          "position": 559
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 7,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 11,
          "position": 559
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "},\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \" (NaN)\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/th.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 21,
          "position": 297
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 6,
          "position": 297
        }
      }
    },
    {
      "format": "typescript",
      "lines": 15,
      "fragment": ";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/th.ts",
        "start": 29,
        "end": 43,
        "startLoc": {
          "line": 29,
          "column": 18,
          "position": 355
        },
        "endLoc": {
          "line": 43,
          "column": 16,
          "position": 461
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 29,
        "end": 43,
        "startLoc": {
          "line": 29,
          "column": 7,
          "position": 355
        },
        "endLoc": {
          "line": 43,
          "column": 5,
          "position": 461
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "},\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \" \"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/ta.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 15,
          "position": 297
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 6,
          "position": 297
        }
      }
    },
    {
      "format": "typescript",
      "lines": 15,
      "fragment": ";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/ta.ts",
        "start": 29,
        "end": 43,
        "startLoc": {
          "line": 29,
          "column": 9,
          "position": 355
        },
        "endLoc": {
          "line": 43,
          "column": 10,
          "position": 461
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 29,
        "end": 43,
        "startLoc": {
          "line": 29,
          "column": 7,
          "position": 355
        },
        "endLoc": {
          "line": 43,
          "column": 5,
          "position": 461
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO  \"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/ta.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 20,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 17,
          "position": 559
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 7,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 11,
          "position": 559
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "},\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"antal\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/sv.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 8,
          "position": 301
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 9,
          "position": 301
        }
      }
    },
    {
      "format": "typescript",
      "lines": 18,
      "fragment": ";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"reguljrt uttryck\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/sv.ts",
        "start": 26,
        "end": 43,
        "startLoc": {
          "line": 26,
          "column": 8,
          "position": 333
        },
        "endLoc": {
          "line": 43,
          "column": 20,
          "position": 461
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 26,
        "end": 43,
        "startLoc": {
          "line": 26,
          "column": 8,
          "position": 333
        },
        "endLoc": {
          "line": 43,
          "column": 5,
          "position": 461
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO-datum och tid\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/sv.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 15,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 20,
          "position": 559
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 7,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 11,
          "position": 559
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "},\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"tevilo\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/sl.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 10,
          "position": 301
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 9,
          "position": 301
        }
      }
    },
    {
      "format": "typescript",
      "lines": 18,
      "fragment": ";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"vnos\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/sl.ts",
        "start": 26,
        "end": 43,
        "startLoc": {
          "line": 26,
          "column": 9,
          "position": 333
        },
        "endLoc": {
          "line": 43,
          "column": 7,
          "position": 461
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 26,
        "end": 43,
        "startLoc": {
          "line": 26,
          "column": 8,
          "position": 333
        },
        "endLoc": {
          "line": 43,
          "column": 5,
          "position": 461
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO datum in as\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/sl.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 18,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 19,
          "position": 559
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 7,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 11,
          "position": 559
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": "| null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/ru.ts",
        "start": 69,
        "end": 82,
        "startLoc": {
          "line": 69,
          "column": 2,
          "position": 513
        },
        "endLoc": {
          "line": 82,
          "column": 9,
          "position": 635
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 13,
        "end": 26,
        "startLoc": {
          "line": 13,
          "column": 2,
          "position": 210
        },
        "endLoc": {
          "line": 26,
          "column": 8,
          "position": 332
        }
      }
    },
    {
      "format": "typescript",
      "lines": 18,
      "fragment": ";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/ru.ts",
        "start": 82,
        "end": 99,
        "startLoc": {
          "line": 82,
          "column": 9,
          "position": 636
        },
        "endLoc": {
          "line": 99,
          "column": 7,
          "position": 764
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 26,
        "end": 43,
        "startLoc": {
          "line": 26,
          "column": 8,
          "position": 333
        },
        "endLoc": {
          "line": 43,
          "column": 5,
          "position": 461
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "},\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"nmero\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/pt.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 9,
          "position": 301
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 9,
          "position": 301
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"padro\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/pt.ts",
        "start": 29,
        "end": 42,
        "startLoc": {
          "line": 29,
          "column": 7,
          "position": 355
        },
        "endLoc": {
          "line": 42,
          "column": 9,
          "position": 460
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 29,
        "end": 43,
        "startLoc": {
          "line": 29,
          "column": 7,
          "position": 355
        },
        "endLoc": {
          "line": 43,
          "column": 5,
          "position": 461
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"data e hora ISO\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/pt.ts",
        "start": 43,
        "end": 56,
        "startLoc": {
          "line": 43,
          "column": 21,
          "position": 468
        },
        "endLoc": {
          "line": 56,
          "column": 18,
          "position": 558
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 7,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 11,
          "position": 559
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "},\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/ps.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 6,
          "position": 301
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 9,
          "position": 301
        }
      }
    },
    {
      "format": "typescript",
      "lines": 17,
      "fragment": ";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/ps.ts",
        "start": 26,
        "end": 42,
        "startLoc": {
          "line": 26,
          "column": 6,
          "position": 333
        },
        "endLoc": {
          "line": 42,
          "column": 8,
          "position": 460
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 26,
        "end": 43,
        "startLoc": {
          "line": 26,
          "column": 8,
          "position": 333
        },
        "endLoc": {
          "line": 43,
          "column": 5,
          "position": 461
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "},\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"liczba\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/pl.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 9,
          "position": 301
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 9,
          "position": 301
        }
      }
    },
    {
      "format": "typescript",
      "lines": 18,
      "fragment": ";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"wyraenie\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/pl.ts",
        "start": 26,
        "end": 43,
        "startLoc": {
          "line": 26,
          "column": 10,
          "position": 333
        },
        "endLoc": {
          "line": 43,
          "column": 12,
          "position": 461
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 26,
        "end": 43,
        "startLoc": {
          "line": 26,
          "column": 8,
          "position": 333
        },
        "endLoc": {
          "line": 43,
          "column": 5,
          "position": 461
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"data i godzina w formacie ISO\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/pl.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 14,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 32,
          "position": 559
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 7,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 11,
          "position": 559
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "},\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"numara\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/ota.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 9,
          "position": 301
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 9,
          "position": 301
        }
      }
    },
    {
      "format": "typescript",
      "lines": 15,
      "fragment": ";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"giren\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/ota.ts",
        "start": 29,
        "end": 43,
        "startLoc": {
          "line": 29,
          "column": 7,
          "position": 355
        },
        "endLoc": {
          "line": 43,
          "column": 8,
          "position": 461
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 29,
        "end": 43,
        "startLoc": {
          "line": 29,
          "column": 7,
          "position": 355
        },
        "endLoc": {
          "line": 43,
          "column": 5,
          "position": 461
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO hengm\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/ota.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 12,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 14,
          "position": 559
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 7,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 11,
          "position": 559
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "},\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"tall\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/no.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 7,
          "position": 301
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 9,
          "position": 301
        }
      }
    },
    {
      "format": "typescript",
      "lines": 18,
      "fragment": ";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"input\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/no.ts",
        "start": 26,
        "end": 43,
        "startLoc": {
          "line": 26,
          "column": 8,
          "position": 333
        },
        "endLoc": {
          "line": 43,
          "column": 8,
          "position": 461
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 26,
        "end": 43,
        "startLoc": {
          "line": 26,
          "column": 8,
          "position": 333
        },
        "endLoc": {
          "line": 43,
          "column": 5,
          "position": 461
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO dato- og klokkeslett\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/no.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 16,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 27,
          "position": 559
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 7,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 11,
          "position": 559
        }
      }
    },
    {
      "format": "typescript",
      "lines": 22,
      "fragment": ";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"invoer\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/nl.ts",
        "start": 22,
        "end": 43,
        "startLoc": {
          "line": 22,
          "column": 8,
          "position": 266
        },
        "endLoc": {
          "line": 43,
          "column": 9,
          "position": 425
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 22,
        "end": 43,
        "startLoc": {
          "line": 22,
          "column": 9,
          "position": 302
        },
        "endLoc": {
          "line": 43,
          "column": 5,
          "position": 461
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO datum en tijd\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/nl.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 13,
          "position": 433
        },
        "endLoc": {
          "line": 57,
          "column": 20,
          "position": 523
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 7,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 11,
          "position": 559
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "},\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"nombor\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/ms.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 9,
          "position": 301
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 9,
          "position": 301
        }
      }
    },
    {
      "format": "typescript",
      "lines": 23,
      "fragment": ";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"input\",\n    email: \"alamat e-mel\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/ms.ts",
        "start": 22,
        "end": 44,
        "startLoc": {
          "line": 22,
          "column": 9,
          "position": 302
        },
        "endLoc": {
          "line": 44,
          "column": 15,
          "position": 468
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 22,
        "end": 44,
        "startLoc": {
          "line": 22,
          "column": 9,
          "position": 302
        },
        "endLoc": {
          "line": 44,
          "column": 16,
          "position": 468
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"tarikh masa ISO\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/ms.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 15,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 18,
          "position": 559
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 7,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 11,
          "position": 559
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "},\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/mk.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 7,
          "position": 301
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 9,
          "position": 301
        }
      }
    },
    {
      "format": "typescript",
      "lines": 18,
      "fragment": ";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/mk.ts",
        "start": 26,
        "end": 43,
        "startLoc": {
          "line": 26,
          "column": 7,
          "position": 333
        },
        "endLoc": {
          "line": 43,
          "column": 7,
          "position": 461
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 26,
        "end": 43,
        "startLoc": {
          "line": 26,
          "column": 8,
          "position": 333
        },
        "endLoc": {
          "line": 43,
          "column": 5,
          "position": 461
        }
      }
    },
    {
      "format": "typescript",
      "lines": 34,
      "fragment": "},\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"number\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/ko.ts",
        "start": 10,
        "end": 43,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 43,
          "column": 5,
          "position": 461
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 10,
        "end": 43,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 43,
          "column": 5,
          "position": 461
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "},\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \" (NaN)\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/kh.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 20,
          "position": 297
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 6,
          "position": 297
        }
      }
    },
    {
      "format": "typescript",
      "lines": 15,
      "fragment": ";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/kh.ts",
        "start": 29,
        "end": 43,
        "startLoc": {
          "line": 29,
          "column": 20,
          "position": 355
        },
        "endLoc": {
          "line": 43,
          "column": 17,
          "position": 461
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 29,
        "end": 43,
        "startLoc": {
          "line": 29,
          "column": 7,
          "position": 355
        },
        "endLoc": {
          "line": 43,
          "column": 5,
          "position": 461
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "},\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/ja.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 5,
          "position": 301
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 9,
          "position": 301
        }
      }
    },
    {
      "format": "typescript",
      "lines": 18,
      "fragment": ";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/ja.ts",
        "start": 26,
        "end": 43,
        "startLoc": {
          "line": 26,
          "column": 5,
          "position": 333
        },
        "endLoc": {
          "line": 43,
          "column": 6,
          "position": 461
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 26,
        "end": 43,
        "startLoc": {
          "line": 26,
          "column": 8,
          "position": 333
        },
        "endLoc": {
          "line": 43,
          "column": 5,
          "position": 461
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "},\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"numero\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/it.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 9,
          "position": 301
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 9,
          "position": 301
        }
      }
    },
    {
      "format": "typescript",
      "lines": 19,
      "fragment": ";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"input\",\n    email: \"indirizzo email\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/it.ts",
        "start": 26,
        "end": 44,
        "startLoc": {
          "line": 26,
          "column": 10,
          "position": 333
        },
        "endLoc": {
          "line": 44,
          "column": 18,
          "position": 468
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 26,
        "end": 44,
        "startLoc": {
          "line": 26,
          "column": 8,
          "position": 333
        },
        "endLoc": {
          "line": 44,
          "column": 16,
          "position": 468
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"data e ora ISO\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/it.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 18,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 17,
          "position": 559
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 7,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 11,
          "position": 559
        }
      }
    },
    {
      "format": "typescript",
      "lines": 35,
      "fragment": "},\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"number\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"input\",\n    email: \"alamat email\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/id.ts",
        "start": 10,
        "end": 44,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 44,
          "column": 15,
          "position": 468
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 10,
        "end": 44,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 44,
          "column": 16,
          "position": 468
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"tanggal dan waktu format ISO\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/id.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 15,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 31,
          "position": 559
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 7,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 11,
          "position": 559
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "},\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"szm\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/hu.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 7,
          "position": 301
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 9,
          "position": 301
        }
      }
    },
    {
      "format": "typescript",
      "lines": 18,
      "fragment": ";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"bemenet\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/hu.ts",
        "start": 26,
        "end": 43,
        "startLoc": {
          "line": 26,
          "column": 7,
          "position": 333
        },
        "endLoc": {
          "line": 43,
          "column": 10,
          "position": 461
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 26,
        "end": 43,
        "startLoc": {
          "line": 26,
          "column": 8,
          "position": 333
        },
        "endLoc": {
          "line": 43,
          "column": 5,
          "position": 461
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO idblyeg\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/hu.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 12,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 16,
          "position": 559
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 7,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 11,
          "position": 559
        }
      }
    },
    {
      "format": "typescript",
      "lines": 34,
      "fragment": "},\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"number\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/he.ts",
        "start": 10,
        "end": 43,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 43,
          "column": 6,
          "position": 461
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 10,
        "end": 43,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 43,
          "column": 5,
          "position": 461
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "},\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"nombre\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/fr.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 9,
          "position": 301
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 9,
          "position": 301
        }
      }
    },
    {
      "format": "typescript",
      "lines": 18,
      "fragment": ";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"entre\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/fr.ts",
        "start": 26,
        "end": 43,
        "startLoc": {
          "line": 26,
          "column": 10,
          "position": 333
        },
        "endLoc": {
          "line": 43,
          "column": 9,
          "position": 461
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 26,
        "end": 43,
        "startLoc": {
          "line": 26,
          "column": 8,
          "position": 333
        },
        "endLoc": {
          "line": 43,
          "column": 5,
          "position": 461
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"date et heure ISO\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/fr.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 17,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 20,
          "position": 559
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 7,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 11,
          "position": 559
        }
      }
    },
    {
      "format": "typescript",
      "lines": 44,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"caractres\", verb: \"avoir\" },\n    file: { unit: \"octets\", verb: \"avoir\" },\n    array: { unit: \"lments\", verb: \"avoir\" },\n    set: { unit: \"lments\", verb: \"avoir\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"number\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"entre\",\n    email: \"adresse courriel\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/fr-CA.ts",
        "start": 1,
        "end": 44,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 44,
          "column": 19,
          "position": 468
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 44,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 44,
          "column": 17,
          "position": 468
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"date-heure ISO\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/fr-CA.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 19,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 17,
          "position": 559
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 7,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 11,
          "position": 559
        }
      }
    },
    {
      "format": "typescript",
      "lines": 20,
      "fragment": ",\n    date: \"date ISO\",\n    time: \"heure ISO\",\n    duration: \"dure ISO\",\n    ipv4: \"adresse IPv4\",\n    ipv6: \"adresse IPv6\",\n    cidrv4: \"plage IPv4\",\n    cidrv6: \"plage IPv6\",\n    base64: \"chane encode en base64\",\n    base64url: \"chane encode en base64url\",\n    json_string: \"chane JSON\",\n    e164: \"numro E.164\",\n    jwt: \"JWT\",\n    template_literal: \"entre\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Entre invalide : attendu ",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/fr-CA.ts",
        "start": 57,
        "end": 76,
        "startLoc": {
          "line": 57,
          "column": 17,
          "position": 560
        },
        "endLoc": {
          "line": 76,
          "column": 28,
          "position": 689
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/fr.ts",
        "start": 57,
        "end": 76,
        "startLoc": {
          "line": 57,
          "column": 20,
          "position": 560
        },
        "endLoc": {
          "line": 76,
          "column": 20,
          "position": 689
        }
      }
    },
    {
      "format": "typescript",
      "lines": 24,
      "fragment": "${_issue.pattern}`;\n        return `${Nouns[_issue.format] ?? issue.format} invalide`;\n      }\n      case \"not_multiple_of\":\n        return `Nombre invalide : doit tre un multiple de ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `Cl${issue.keys.length > 1 ? \"s\" : \"\"} non reconnue${issue.keys.length > 1 ? \"s\" : \"\"} : ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Cl invalide dans ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Entre invalide\";\n      case \"invalid_element\":\n        return `Valeur invalide dans ${issue.origin}`;\n      default:\n        return `Entre invalide`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/fr-CA.ts",
        "start": 103,
        "end": 126,
        "startLoc": {
          "line": 103,
          "column": 47,
          "position": 1117
        },
        "endLoc": {
          "line": 126,
          "column": 2,
          "position": 1341
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/fr.ts",
        "start": 101,
        "end": 124,
        "startLoc": {
          "line": 101,
          "column": 48,
          "position": 1127
        },
        "endLoc": {
          "line": 124,
          "column": 2,
          "position": 1351
        }
      }
    },
    {
      "format": "typescript",
      "lines": 31,
      "fragment": ": string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"number\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"snnllinen lauseke\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/fi.ts",
        "start": 17,
        "end": 47,
        "startLoc": {
          "line": 17,
          "column": 8,
          "position": 284
        },
        "endLoc": {
          "line": 47,
          "column": 23,
          "position": 541
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 13,
        "end": 43,
        "startLoc": {
          "line": 13,
          "column": 5,
          "position": 204
        },
        "endLoc": {
          "line": 43,
          "column": 5,
          "position": 461
        }
      }
    },
    {
      "format": "typescript",
      "lines": 17,
      "fragment": "},\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/fa.ts",
        "start": 10,
        "end": 26,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 26,
          "column": 8,
          "position": 332
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 10,
        "end": 26,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 26,
          "column": 6,
          "position": 332
        }
      }
    },
    {
      "format": "typescript",
      "lines": 18,
      "fragment": ";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/fa.ts",
        "start": 26,
        "end": 43,
        "startLoc": {
          "line": 26,
          "column": 8,
          "position": 333
        },
        "endLoc": {
          "line": 43,
          "column": 8,
          "position": 461
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 26,
        "end": 43,
        "startLoc": {
          "line": 26,
          "column": 8,
          "position": 333
        },
        "endLoc": {
          "line": 43,
          "column": 5,
          "position": 461
        }
      }
    },
    {
      "format": "typescript",
      "lines": 17,
      "fragment": "},\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"nmero\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"arreglo\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/es.ts",
        "start": 10,
        "end": 26,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 26,
          "column": 10,
          "position": 332
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 10,
        "end": 26,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 26,
          "column": 8,
          "position": 332
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"fecha y hora ISO\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/es.ts",
        "start": 43,
        "end": 56,
        "startLoc": {
          "line": 43,
          "column": 34,
          "position": 462
        },
        "endLoc": {
          "line": 56,
          "column": 19,
          "position": 552
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 7,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 11,
          "position": 559
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ";\n      }\n\n      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n        return data.constructor.name;\n      }\n    }\n  }\n  return t;\n};\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"karaktrojn\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/eo.ts",
        "start": 17,
        "end": 30,
        "startLoc": {
          "line": 17,
          "column": 12,
          "position": 166
        },
        "endLoc": {
          "line": 30,
          "column": 13,
          "position": 290
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/tr.ts",
        "start": 17,
        "end": 30,
        "startLoc": {
          "line": 17,
          "column": 7,
          "position": 166
        },
        "endLoc": {
          "line": 30,
          "column": 11,
          "position": 290
        }
      }
    },
    {
      "format": "typescript",
      "lines": 11,
      "fragment": "},\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"enigo\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/eo.ts",
        "start": 33,
        "end": 43,
        "startLoc": {
          "line": 33,
          "column": 2,
          "position": 358
        },
        "endLoc": {
          "line": 43,
          "column": 8,
          "position": 461
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/tr.ts",
        "start": 33,
        "end": 43,
        "startLoc": {
          "line": 33,
          "column": 2,
          "position": 358
        },
        "endLoc": {
          "line": 43,
          "column": 8,
          "position": 461
        }
      }
    },
    {
      "format": "typescript",
      "lines": 30,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nexport const parsedType = (data: any): string => {\n  const t = typeof data;\n\n  switch (t) {\n    case \"number\": {\n      return Number.isNaN(data) ? \"NaN\" : \"number\";\n    }\n    case \"object\": {\n      if (Array.isArray(data)) {\n        return \"array\";\n      }\n      if (data === null) {\n        return \"null\";\n      }\n\n      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n        return data.constructor.name;\n      }\n    }\n  }\n  return t;\n};\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"characters\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/en.ts",
        "start": 1,
        "end": 30,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 30,
          "column": 13,
          "position": 290
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/tr.ts",
        "start": 1,
        "end": 30,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 30,
          "column": 11,
          "position": 290
        }
      }
    },
    {
      "format": "typescript",
      "lines": 11,
      "fragment": "},\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"input\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/en.ts",
        "start": 33,
        "end": 43,
        "startLoc": {
          "line": 33,
          "column": 2,
          "position": 358
        },
        "endLoc": {
          "line": 43,
          "column": 8,
          "position": 461
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/tr.ts",
        "start": 33,
        "end": 43,
        "startLoc": {
          "line": 33,
          "column": 2,
          "position": 358
        },
        "endLoc": {
          "line": 43,
          "column": 8,
          "position": 461
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO datetime\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/en.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 16,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 15,
          "position": 559
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 7,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 11,
          "position": 559
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "},\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"Zahl\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/de.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 7,
          "position": 301
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 9,
          "position": 301
        }
      }
    },
    {
      "format": "typescript",
      "lines": 18,
      "fragment": ";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"Eingabe\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/de.ts",
        "start": 26,
        "end": 43,
        "startLoc": {
          "line": 26,
          "column": 8,
          "position": 333
        },
        "endLoc": {
          "line": 43,
          "column": 10,
          "position": 461
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 26,
        "end": 43,
        "startLoc": {
          "line": 26,
          "column": 8,
          "position": 333
        },
        "endLoc": {
          "line": 43,
          "column": 5,
          "position": 461
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "},\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"slo\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/cs.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 8,
          "position": 301
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 10,
        "end": 22,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 22,
          "column": 9,
          "position": 301
        }
      }
    },
    {
      "format": "typescript",
      "lines": 18,
      "fragment": ";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"regulrn vraz\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/cs.ts",
        "start": 44,
        "end": 61,
        "startLoc": {
          "line": 44,
          "column": 7,
          "position": 435
        },
        "endLoc": {
          "line": 61,
          "column": 18,
          "position": 563
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 26,
        "end": 43,
        "startLoc": {
          "line": 26,
          "column": 8,
          "position": 333
        },
        "endLoc": {
          "line": 43,
          "column": 5,
          "position": 461
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"datum a as ve formtu ISO\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/cs.ts",
        "start": 62,
        "end": 75,
        "startLoc": {
          "line": 62,
          "column": 19,
          "position": 571
        },
        "endLoc": {
          "line": 75,
          "column": 29,
          "position": 661
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 7,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 11,
          "position": 559
        }
      }
    },
    {
      "format": "typescript",
      "lines": 34,
      "fragment": "},\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"number\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"entrada\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/ca.ts",
        "start": 10,
        "end": 43,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 43,
          "column": 10,
          "position": 461
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 10,
        "end": 43,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 43,
          "column": 5,
          "position": 461
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"data i hora ISO\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/ca.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 21,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 18,
          "position": 559
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 44,
        "end": 57,
        "startLoc": {
          "line": 44,
          "column": 7,
          "position": 469
        },
        "endLoc": {
          "line": 57,
          "column": 11,
          "position": 559
        }
      }
    },
    {
      "format": "typescript",
      "lines": 21,
      "fragment": "(count: number, one: string, few: string, many: string): string {\n  const absCount = Math.abs(count);\n  const lastDigit = absCount % 10;\n  const lastTwoDigits = absCount % 100;\n\n  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {\n    return many;\n  }\n\n  if (lastDigit === 1) {\n    return one;\n  }\n\n  if (lastDigit >= 2 && lastDigit <= 4) {\n    return few;\n  }\n\n  return many;\n}\n\ninterface BelarusianSizable",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/be.ts",
        "start": 5,
        "end": 25,
        "startLoc": {
          "line": 5,
          "column": 20,
          "position": 47
        },
        "endLoc": {
          "line": 25,
          "column": 18,
          "position": 217
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/ru.ts",
        "start": 5,
        "end": 25,
        "startLoc": {
          "line": 5,
          "column": 17,
          "position": 47
        },
        "endLoc": {
          "line": 25,
          "column": 15,
          "position": 217
        }
      }
    },
    {
      "format": "typescript",
      "lines": 18,
      "fragment": ";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/be.ts",
        "start": 82,
        "end": 99,
        "startLoc": {
          "line": 82,
          "column": 8,
          "position": 636
        },
        "endLoc": {
          "line": 99,
          "column": 7,
          "position": 764
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 26,
        "end": 43,
        "startLoc": {
          "line": 26,
          "column": 8,
          "position": 333
        },
        "endLoc": {
          "line": 43,
          "column": 5,
          "position": 461
        }
      }
    },
    {
      "format": "typescript",
      "lines": 35,
      "fragment": ", verb: \"olmaldr\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"number\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"input\",\n    email: \"email address\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/az.ts",
        "start": 10,
        "end": 44,
        "startLoc": {
          "line": 10,
          "column": 10,
          "position": 168
        },
        "endLoc": {
          "line": 44,
          "column": 16,
          "position": 468
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/ota.ts",
        "start": 10,
        "end": 44,
        "startLoc": {
          "line": 10,
          "column": 8,
          "position": 168
        },
        "endLoc": {
          "line": 44,
          "column": 16,
          "position": 468
        }
      }
    },
    {
      "format": "typescript",
      "lines": 37,
      "fragment": "const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"input\",\n    email: \"email address\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO datetime\",\n    date: \"ISO date\",\n    time: \"ISO time\",\n    duration: \"ISO duration\",\n    ipv4: \"IPv4 address\",\n    ipv6: \"IPv6 address\",\n    cidrv4: \"IPv4 range\",\n    cidrv6: \"IPv6 range\",\n    base64: \"base64-encoded string\",\n    base64url: \"base64url-encoded string\",\n    json_string: \"JSON string\",\n    e164: \"E.164 number\",\n    jwt: \"JWT\",\n    template_literal: \"input\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Yanl dyr: gzlniln ",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/az.ts",
        "start": 40,
        "end": 76,
        "startLoc": {
          "line": 40,
          "column": 3,
          "position": 418
        },
        "endLoc": {
          "line": 76,
          "column": 27,
          "position": 689
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/en.ts",
        "start": 40,
        "end": 76,
        "startLoc": {
          "line": 40,
          "column": 3,
          "position": 418
        },
        "endLoc": {
          "line": 76,
          "column": 26,
          "position": 689
        }
      }
    },
    {
      "format": "typescript",
      "lines": 34,
      "fragment": "},\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"number\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/ar.ts",
        "start": 10,
        "end": 43,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 43,
          "column": 7,
          "position": 461
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 10,
        "end": 43,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 175
        },
        "endLoc": {
          "line": 43,
          "column": 5,
          "position": 461
        }
      }
    },
    {
      "format": "typescript",
      "lines": 26,
      "fragment": ",\n  _positive as positive,\n  _negative as negative,\n  _nonpositive as nonpositive,\n  _nonnegative as nonnegative,\n  _multipleOf as multipleOf,\n  _maxSize as maxSize,\n  _minSize as minSize,\n  _size as size,\n  _maxLength as maxLength,\n  _minLength as minLength,\n  _length as length,\n  _regex as regex,\n  _lowercase as lowercase,\n  _uppercase as uppercase,\n  _includes as includes,\n  _startsWith as startsWith,\n  _endsWith as endsWith,\n  _property as property,\n  _mime as mime,\n  _overwrite as overwrite,\n  _normalize as normalize,\n  _trim as trim,\n  _toLowerCase as toLowerCase,\n  _toUpperCase as toUpperCase,\n} from \"../core/index.js\";",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/checks.ts",
        "start": 5,
        "end": 30,
        "startLoc": {
          "line": 5,
          "column": 4,
          "position": 34
        },
        "endLoc": {
          "line": 30,
          "column": 2,
          "position": 233
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/checks.ts",
        "start": 7,
        "end": 32,
        "startLoc": {
          "line": 7,
          "column": 8,
          "position": 50
        },
        "endLoc": {
          "line": 32,
          "column": 2,
          "position": 249
        }
      }
    },
    {
      "format": "typescript",
      "lines": 27,
      "fragment": ";\n\ntest(\"function parsing\", () => {\n  const schema = z.union([z.string().refine(() => false), z.number().refine(() => false)]);\n  const result = schema.safeParse(\"asdf\");\n  expect(result.success).toEqual(false);\n});\n\ntest(\"union 2\", () => {\n  const result = z.union([z.number(), z.string().refine(() => false)]).safeParse(\"a\");\n  expect(result.success).toEqual(false);\n});\n\ntest(\"return valid over invalid\", () => {\n  const schema = z.union([\n    z.object({\n      email: z.string().email(),\n    }),\n    z.string(),\n  ]);\n  expect(schema.parse(\"asdf\")).toEqual(\"asdf\");\n  expect(schema.parse({ email: \"asdlkjf@lkajsdf.com\" })).toEqual({\n    email: \"asdlkjf@lkajsdf.com\",\n  });\n});\n\ntest(\"return dirty result over aborted\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/unions.test.ts",
        "start": 4,
        "end": 30,
        "startLoc": {
          "line": 4,
          "column": 9,
          "position": 30
        },
        "endLoc": {
          "line": 30,
          "column": 35,
          "position": 324
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/union.test.ts",
        "start": 3,
        "end": 29,
        "startLoc": {
          "line": 3,
          "column": 9,
          "position": 31
        },
        "endLoc": {
          "line": 29,
          "column": 37,
          "position": 325
        }
      }
    },
    {
      "format": "typescript",
      "lines": 18,
      "fragment": ");\n  }\n});\n\ntest(\"options getter\", async () => {\n  const union = z.union([z.string(), z.number()]);\n  union.options[0].parse(\"asdf\");\n  union.options[1].parse(1234);\n  await union.options[0].parseAsync(\"asdf\");\n  await union.options[1].parseAsync(1234);\n});\n\ntest(\"readonly union\", async () => {\n  const options = [z.string(), z.number()] as const;\n  const union = z.union(options);\n  union.parse(\"asdf\");\n  union.parse(12);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/unions.test.ts",
        "start": 40,
        "end": 57,
        "startLoc": {
          "line": 40,
          "column": 2,
          "position": 448
        },
        "endLoc": {
          "line": 57,
          "column": 2,
          "position": 642
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/union.test.ts",
        "start": 58,
        "end": 75,
        "startLoc": {
          "line": 58,
          "column": 6,
          "position": 417
        },
        "endLoc": {
          "line": 75,
          "column": 2,
          "position": 611
        }
      }
    },
    {
      "format": "typescript",
      "lines": 12,
      "fragment": "});\n\ntest(\"tuple with rest schema\", () => {\n  const myTuple = z.tuple([z.string(), z.number()]).rest(z.boolean());\n  expect(myTuple.parse([\"asdf\", 1234, true, false, true])).toEqual([\"asdf\", 1234, true, false, true]);\n\n  expect(myTuple.parse([\"asdf\", 1234])).toEqual([\"asdf\", 1234]);\n\n  expect(() => myTuple.parse([\"asdf\", 1234, \"asdf\"])).toThrow();\n  type t1 = z.output<typeof myTuple>;\n\n  util",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/tuple.test.ts",
        "start": 67,
        "end": 78,
        "startLoc": {
          "line": 67,
          "column": 1,
          "position": 765
        },
        "endLoc": {
          "line": 78,
          "column": 5,
          "position": 941
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/tuple.test.ts",
        "start": 146,
        "end": 157,
        "startLoc": {
          "line": 146,
          "column": 1,
          "position": 1163
        },
        "endLoc": {
          "line": 157,
          "column": 13,
          "position": 1339
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": ");\n});\n\ntest(\"transform ctx.addIssue with parseAsync\", async () => {\n  const strs = [\"foo\", \"bar\"];\n\n  const result = await z\n    .string()\n    .transform(async (data, ctx) => {\n      const i = strs.indexOf(data);\n      if (i === -1) {\n        ctx.addIssue({\n          code",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/transformer.test.ts",
        "start": 41,
        "end": 53,
        "startLoc": {
          "line": 41,
          "column": 3,
          "position": 313
        },
        "endLoc": {
          "line": 53,
          "column": 5,
          "position": 422
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/transform.test.ts",
        "start": 27,
        "end": 39,
        "startLoc": {
          "line": 27,
          "column": 4,
          "position": 209
        },
        "endLoc": {
          "line": 39,
          "column": 6,
          "position": 318
        }
      }
    },
    {
      "format": "typescript",
      "lines": 11,
      "fragment": "(data, ctx) => {\n      const i = strs.indexOf(data);\n      if (i === -1) {\n        ctx.addIssue({\n          code: \"custom\",\n          message: `${data} is not one of our allowed strings`,\n        });\n      }\n      return data.length;\n    })\n    .safeParseAsync",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/transformer.test.ts",
        "start": 49,
        "end": 59,
        "startLoc": {
          "line": 49,
          "column": 2,
          "position": 374
        },
        "endLoc": {
          "line": 59,
          "column": 15,
          "position": 461
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/transformer.test.ts",
        "start": 18,
        "end": 28,
        "startLoc": {
          "line": 18,
          "column": 2,
          "position": 160
        },
        "endLoc": {
          "line": 28,
          "column": 6,
          "position": 247
        }
      }
    },
    {
      "format": "typescript",
      "lines": 39,
      "fragment": ");\n  const arg = foo.safeParse(undefined);\n  if (!arg.success) {\n    expect(arg.error.issues[0].message).toEqual(\"bad\");\n  }\n});\n\ntest(\"basic transformations\", () => {\n  const r1 = z\n    .string()\n    .transform((data) => data.length)\n    .parse(\"asdf\");\n  expect(r1).toEqual(4);\n});\n\ntest(\"coercion\", () => {\n  const numToString = z.number().transform((n) => String(n));\n  const data = z\n    .object({\n      id: numToString,\n    })\n    .parse({ id: 5 });\n\n  expect(data).toEqual({ id: \"5\" });\n});\n\ntest(\"async coercion\", async () => {\n  const numToString = z.number().transform(async (n) => String(n));\n  const data = await z\n    .object({\n      id: numToString,\n    })\n    .parseAsync({ id: 5 });\n\n  expect(data).toEqual({ id: \"5\" });\n});\n\ntest(\"sync coercion async error\", async () => {\n  expect",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/transformer.test.ts",
        "start": 88,
        "end": 126,
        "startLoc": {
          "line": 88,
          "column": 5,
          "position": 696
        },
        "endLoc": {
          "line": 126,
          "column": 7,
          "position": 1055
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/transform.test.ts",
        "start": 78,
        "end": 116,
        "startLoc": {
          "line": 78,
          "column": 2,
          "position": 535
        },
        "endLoc": {
          "line": 116,
          "column": 6,
          "position": 894
        }
      }
    },
    {
      "format": "typescript",
      "lines": 48,
      "fragment": "expect(() =>\n    z\n      .object({\n        id: asyncNumberToString,\n      })\n      .parse({ id: 5 })\n  ).toThrow();\n  // expect(data).toEqual({ id: '5' });\n});\n\ntest(\"default\", () => {\n  const data = z.string().default(\"asdf\").parse(undefined); // => \"asdf\"\n  expect(data).toEqual(\"asdf\");\n});\n\ntest(\"dynamic default\", () => {\n  const data = z\n    .string()\n    .default(() => \"string\")\n    .parse(undefined); // => \"asdf\"\n  expect(data).toEqual(\"string\");\n});\n\ntest(\"default when property is null or undefined\", () => {\n  const data = z\n    .object({\n      foo: z.boolean().nullable().default(true),\n      bar: z.boolean().default(true),\n    })\n    .parse({ foo: null });\n\n  expect(data).toEqual({ foo: null, bar: true });\n});\n\ntest(\"default with falsy values\", () => {\n  const schema = z.object({\n    emptyStr: z.string().default(\"def\"),\n    zero: z.number().default(5),\n    falseBoolean: z.boolean().default(true),\n  });\n  const input = { emptyStr: \"\", zero: 0, falseBoolean: true };\n  const output = schema.parse(input);\n  // defaults are not supposed to be used\n  expect(output).toEqual(input);\n});\n\ntest(\"object typing\", () => {\n  const t1",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/transformer.test.ts",
        "start": 126,
        "end": 173,
        "startLoc": {
          "line": 126,
          "column": 3,
          "position": 1055
        },
        "endLoc": {
          "line": 173,
          "column": 3,
          "position": 1503
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/transform.test.ts",
        "start": 117,
        "end": 164,
        "startLoc": {
          "line": 117,
          "column": 3,
          "position": 924
        },
        "endLoc": {
          "line": 164,
          "column": 15,
          "position": 1372
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": ");\n});\n\ntest(\"transform method overloads\", () => {\n  const t1 = z.string().transform((val) => val.toUpperCase());\n  expect(t1.parse(\"asdf\")).toEqual(\"ASDF\");\n\n  const t2 = z.string().transform((val) => val.length);\n  expect(t2.parse(\"asdf\")).toEqual(4);\n});\n\ntest(\"multiple transformers\", () => {\n  const doubler",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/transformer.test.ts",
        "start": 181,
        "end": 193,
        "startLoc": {
          "line": 181,
          "column": 5,
          "position": 1599
        },
        "endLoc": {
          "line": 193,
          "column": 8,
          "position": 1730
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/transform.test.ts",
        "start": 174,
        "end": 186,
        "startLoc": {
          "line": 174,
          "column": 2,
          "position": 1501
        },
        "endLoc": {
          "line": 186,
          "column": 15,
          "position": 1632
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": "const doubler = stringToNumber.transform((val) => {\n    return val * 2;\n  });\n  expect(doubler.parse(\"5\")).toEqual(10);\n});\n\ntest(\"short circuit on dirty\", () => {\n  const schema = z\n    .string()\n    .refine(() => false)\n    .transform((val) => val.toUpperCase());\n  const result = schema.safeParse(\"asdf\");\n  expect(result.success).toEqual(false);\n  if",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/transformer.test.ts",
        "start": 193,
        "end": 206,
        "startLoc": {
          "line": 193,
          "column": 3,
          "position": 1728
        },
        "endLoc": {
          "line": 206,
          "column": 3,
          "position": 1870
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/transform.test.ts",
        "start": 188,
        "end": 202,
        "startLoc": {
          "line": 188,
          "column": 3,
          "position": 1661
        },
        "endLoc": {
          "line": 202,
          "column": 7,
          "position": 1804
        }
      }
    },
    {
      "format": "typescript",
      "lines": 15,
      "fragment": "const result2 = schema.safeParse(1234);\n  expect(result2.success).toEqual(false);\n  if (!result2.success) {\n    expect(result2.error.issues[0].code).toEqual(z.ZodIssueCode.invalid_type);\n  }\n});\n\ntest(\"async short circuit on dirty\", async () => {\n  const schema = z\n    .string()\n    .refine(() => false)\n    .transform((val) => val.toUpperCase());\n  const result = await schema.spa(\"asdf\");\n  expect(result.success).toEqual(false);\n  if",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/transformer.test.ts",
        "start": 210,
        "end": 224,
        "startLoc": {
          "line": 210,
          "column": 3,
          "position": 1911
        },
        "endLoc": {
          "line": 224,
          "column": 3,
          "position": 2075
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/transform.test.ts",
        "start": 212,
        "end": 227,
        "startLoc": {
          "line": 212,
          "column": 3,
          "position": 1819
        },
        "endLoc": {
          "line": 227,
          "column": 7,
          "position": 1984
        }
      }
    },
    {
      "format": "typescript",
      "lines": 133,
      "fragment": ");\n  expect(() => startsWith.parse(\"x\")).toThrow();\n  expect(() => endsWith.parse(\"x\")).toThrow();\n});\n\ntest(\"email validations\", () => {\n  const validEmails = [\n    `email@domain.com`,\n    `firstname.lastname@domain.com`,\n    `email@subdomain.domain.com`,\n    `firstname+lastname@domain.com`,\n    `1234567890@domain.com`,\n    `email@domain-one.com`,\n    `_______@domain.com`,\n    `email@domain.name`,\n    `email@domain.co.jp`,\n    `firstname-lastname@domain.com`,\n    `very.common@example.com`,\n    `disposable.style.email.with+symbol@example.com`,\n    `other.email-with-hyphen@example.com`,\n    `fully-qualified-domain@example.com`,\n    `user.name+tag+sorting@example.com`,\n    `x@example.com`,\n    `mojojojo@asdf.example.com`,\n    `example-indeed@strange-example.com`,\n    `example@s.example`,\n    `user-@example.org`,\n    `user@my-example.com`,\n    `a@b.cd`,\n    `work+user@mail.com`,\n    `tom@test.te-st.com`,\n    `something@subdomain.domain-with-hyphens.tld`,\n    `common'name@domain.com`,\n    `francois@etu.inp-n7.fr`,\n  ];\n  const invalidEmails = [\n    // no \"printable characters\"\n    // `user%example.com@example.org`,\n    // `mailhost!username@example.org`,\n    // `test/test@test.com`,\n\n    // double @\n    `francois@@etu.inp-n7.fr`,\n    // do not support quotes\n    `\"email\"@domain.com`,\n    `\"e asdf sadf ?<>ail\"@domain.com`,\n    `\" \"@example.org`,\n    `\"john..doe\"@example.org`,\n    `\"very.(),:;<>[]\\\".VERY.\\\"very@\\\\ \\\"very\\\".unusual\"@strange.example.com`,\n    // do not support comma\n    `a,b@domain.com`,\n\n    // do not support IPv4\n    `email@123.123.123.123`,\n    `email@[123.123.123.123]`,\n    `postmaster@123.123.123.123`,\n    `user@[68.185.127.196]`,\n    `ipv4@[85.129.96.247]`,\n    `valid@[79.208.229.53]`,\n    `valid@[255.255.255.255]`,\n    `valid@[255.0.55.2]`,\n    `valid@[255.0.55.2]`,\n\n    // do not support ipv6\n    `hgrebert0@[IPv6:4dc8:ac7:ce79:8878:1290:6098:5c50:1f25]`,\n    `bshapiro4@[IPv6:3669:c709:e981:4884:59a3:75d1:166b:9ae]`,\n    `jsmith@[IPv6:2001:db8::1]`,\n    `postmaster@[IPv6:2001:0db8:85a3:0000:0000:8a2e:0370:7334]`,\n    `postmaster@[IPv6:2001:0db8:85a3:0000:0000:8a2e:0370:192.168.1.1]`,\n\n    // microsoft test cases\n    `plainaddress`,\n    `#@%^%#$@#$@#.com`,\n    `@domain.com`,\n    `Joe Smith &lt;email@domain.com&gt;`,\n    `email.domain.com`,\n    `email@domain@domain.com`,\n    `.email@domain.com`,\n    `email.@domain.com`,\n    `email..email@domain.com`,\n    `@domain.com`,\n    `email@domain.com (Joe Smith)`,\n    `email@domain`,\n    `email@-domain.com`,\n    `email@111.222.333.44444`,\n    `email@domain..com`,\n    `Abc.example.com`,\n    `A@b@c@example.com`,\n    `colin..hacks@domain.com`,\n    `a\"b(c)d,e:f;g<h>i[j\\k]l@example.com`,\n    `just\"not\"right@example.com`,\n    `this is\"not\\allowed@example.com`,\n    `this\\ still\\\"not\\\\allowed@example.com`,\n\n    // random\n    `i_like_underscore@but_its_not_allowed_in_this_part.example.com`,\n    `QA[icon]CHOCOLATE[icon]@test.com`,\n    `invalid@-start.com`,\n    `invalid@end.com-`,\n    `a.b@c.d`,\n    `invalid@[1.1.1.-1]`,\n    `invalid@[68.185.127.196.55]`,\n    `temp@[192.168.1]`,\n    `temp@[9.18.122.]`,\n    `double..point@test.com`,\n    `asdad@test..com`,\n    `asdad@hghg...sd...au`,\n    `asdad@hghg........au`,\n    `invalid@[256.2.2.48]`,\n    `invalid@[256.2.2.48]`,\n    `invalid@[999.465.265.1]`,\n    `jkibbey4@[IPv6:82c4:19a8::70a9:2aac:557::ea69:d985:28d]`,\n    `mlivesay3@[9952:143f:b4df:2179:49a1:5e82:b92e:6b6]`,\n    `gbacher0@[IPv6:bc37:4d3f:5048:2e26:37cc:248e:df8e:2f7f:af]`,\n    `invalid@[IPv6:5348:4ed3:5d38:67fb:e9b:acd2:c13:192.168.256.1]`,\n    `test@.com`,\n    `aaaaaaaaaaaaaaalongemailthatcausesregexDoSvulnerability@test.c`,\n  ];\n  const emailSchema = z.string().email();\n\n  expect(\n    validEmails.every((email) => {\n      return emailSchema.safeParse(email).success;\n    })\n  ).toBe(true);\n  expect(\n    invalidEmails.every((email) => {\n      return emailSchema.safeParse(email).success === false;\n    })\n  ).toBe(true);\n});\n\nconst",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/string.test.ts",
        "start": 36,
        "end": 168,
        "startLoc": {
          "line": 36,
          "column": 2,
          "position": 470
        },
        "endLoc": {
          "line": 168,
          "column": 6,
          "position": 1078
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/string.test.ts",
        "start": 40,
        "end": 173,
        "startLoc": {
          "line": 40,
          "column": 12,
          "position": 490
        },
        "endLoc": {
          "line": 173,
          "column": 5,
          "position": 1099
        }
      }
    },
    {
      "format": "typescript",
      "lines": 11,
      "fragment": ".parse(d3)).toThrow();\n\n  // missing typ is fine\n  const d4 = makeJwt({ alg: \"HS256\" }, {});\n  jwt.parse(d4);\n\n  // type isn't JWT\n  const d5 = makeJwt({ typ: \"SUP\", alg: \"HS256\" }, { foo: \"bar\" });\n  expect(() => jwt.parse(d5)).toThrow();\n\n  // Custom error message",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/string.test.ts",
        "start": 276,
        "end": 286,
        "startLoc": {
          "line": 276,
          "column": 11,
          "position": 2051
        },
        "endLoc": {
          "line": 286,
          "column": 24,
          "position": 2163
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/string.test.ts",
        "start": 292,
        "end": 301,
        "startLoc": {
          "line": 292,
          "column": 9,
          "position": 2127
        },
        "endLoc": {
          "line": 301,
          "column": 2,
          "position": 2237
        }
      }
    },
    {
      "format": "typescript",
      "lines": 32,
      "fragment": ");\n  }\n  try {\n    z.string().url(\"badurl\").parse(\"https\");\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"badurl\");\n  }\n  try {\n    z.string().url({ message: \"badurl\" }).parse(\"https\");\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"badurl\");\n  }\n});\n\ntest(\"emoji validations\", () => {\n  const emoji = z.string().emoji();\n\n  emoji.parse(\"\");\n  emoji.parse(\"\");\n  emoji.parse(\"\");\n  emoji.parse(\"\");\n  emoji.parse(\"\");\n  emoji.parse(\n    \"##**00112233445566778899\"\n  );\n  expect(() => emoji.parse(\":-)\")).toThrow();\n  expect(() => emoji.parse(\" is an emoji\")).toThrow();\n  expect(() => emoji.parse(\"stuff\")).toThrow();\n  expect(() => emoji.parse(\"stuff\")).toThrow();\n});\n\ntest(\"uuid\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/string.test.ts",
        "start": 309,
        "end": 340,
        "startLoc": {
          "line": 309,
          "column": 14,
          "position": 2446
        },
        "endLoc": {
          "line": 340,
          "column": 7,
          "position": 2772
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/string.test.ts",
        "start": 365,
        "end": 396,
        "startLoc": {
          "line": 365,
          "column": 14,
          "position": 2883
        },
        "endLoc": {
          "line": 396,
          "column": 9,
          "position": 3209
        }
      }
    },
    {
      "format": "typescript",
      "lines": 30,
      "fragment": "});\n\ntest(\"cuid2\", () => {\n  const cuid2 = z.string().cuid2();\n  const validStrings = [\n    \"a\", // short string\n    \"tz4a98xxat96iws9zmbrgj3a\", // normal string\n    \"kf5vz6ssxe4zjcb409rjgo747tc5qjazgptvotk6\", // longer than require(\"@paralleldrive/cuid2\").bigLength\n  ];\n  for (const s of validStrings) {\n    cuid2.parse(s);\n  }\n\n  const invalidStrings = [\n    \"\", // empty string\n    \"tz4a98xxat96iws9zMbrgj3a\", // include uppercase\n    \"tz4a98xxat96iws-zmbrgj3a\", // involve symbols\n  ];\n  const results = invalidStrings.map((s) => cuid2.safeParse(s));\n  expect(results.every((r) => !r.success)).toEqual(true);\n  if (!results[0].success) {\n    expect(results[0].error.issues[0].message).toEqual(\"Invalid cuid2\");\n  }\n});\n\ntest(\"ulid\", () => {\n  const ulid = z.string().ulid();\n  ulid.parse(\"01ARZ3NDEKTSV4RRFFQ69G5FAV\");\n  const result = ulid.safeParse(\"invalidulid\");\n  expect(result.",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/string.test.ts",
        "start": 395,
        "end": 424,
        "startLoc": {
          "line": 395,
          "column": 1,
          "position": 3383
        },
        "endLoc": {
          "line": 424,
          "column": 2,
          "position": 3665
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/string.test.ts",
        "start": 522,
        "end": 551,
        "startLoc": {
          "line": 522,
          "column": 1,
          "position": 4088
        },
        "endLoc": {
          "line": 551,
          "column": 2,
          "position": 4370
        }
      }
    },
    {
      "format": "typescript",
      "lines": 16,
      "fragment": ");\n});\n\ntest(\"regex\", () => {\n  z.string()\n    .regex(/^moo+$/)\n    .parse(\"mooooo\");\n  expect(() => z.string().uuid().parse(\"purr\")).toThrow();\n});\n\ntest(\"regexp error message\", () => {\n  const result = z\n    .string()\n    .regex(/^moo+$/)\n    .safeParse(\"boooo\");\n  if",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/string.test.ts",
        "start": 431,
        "end": 446,
        "startLoc": {
          "line": 431,
          "column": 5,
          "position": 3766
        },
        "endLoc": {
          "line": 446,
          "column": 3,
          "position": 3885
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/string.test.ts",
        "start": 612,
        "end": 627,
        "startLoc": {
          "line": 612,
          "column": 4,
          "position": 4727
        },
        "endLoc": {
          "line": 627,
          "column": 7,
          "position": 4846
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "expect(() => z.string().uuid().parse(\"purr\")).toThrow();\n});\n\ntest(\"regex lastIndex reset\", () => {\n  const schema = z.string().regex(/^\\d+$/g);\n  expect(schema.safeParse(\"123\").success).toEqual(true);\n  expect(schema.safeParse(\"123\").success).toEqual(true);\n  expect(schema.safeParse(\"123\").success).toEqual(true);\n  expect(schema.safeParse(\"123\").success).toEqual(true);\n  expect(schema.safeParse(\"123\").success).toEqual(true);\n});\n\ntest(\"checks getters\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/string.test.ts",
        "start": 452,
        "end": 464,
        "startLoc": {
          "line": 452,
          "column": 3,
          "position": 3940
        },
        "endLoc": {
          "line": 464,
          "column": 17,
          "position": 4106
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/string.test.ts",
        "start": 661,
        "end": 673,
        "startLoc": {
          "line": 661,
          "column": 3,
          "position": 4968
        },
        "endLoc": {
          "line": 673,
          "column": 9,
          "position": 5134
        }
      }
    },
    {
      "format": "typescript",
      "lines": 11,
      "fragment": ");\n});\n\ntest(\"min max getters\", () => {\n  expect(z.string().min(5).minLength).toEqual(5);\n  expect(z.string().min(5).min(10).minLength).toEqual(10);\n  expect(z.string().minLength).toEqual(null);\n\n  expect(z.string().max(5).maxLength).toEqual(5);\n  expect(z.string().max(5).max(1).maxLength).toEqual(1);\n  expect(z.string().maxLength",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/string.test.ts",
        "start": 553,
        "end": 563,
        "startLoc": {
          "line": 553,
          "column": 5,
          "position": 5903
        },
        "endLoc": {
          "line": 563,
          "column": 10,
          "position": 6053
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/string.test.ts",
        "start": 700,
        "end": 710,
        "startLoc": {
          "line": 700,
          "column": 11,
          "position": 5678
        },
        "endLoc": {
          "line": 710,
          "column": 4,
          "position": 5828
        }
      }
    },
    {
      "format": "typescript",
      "lines": 18,
      "fragment": ");\n  expect(z.string().maxLength).toEqual(null);\n});\n\ntest(\"trim\", () => {\n  expect(z.string().trim().min(2).parse(\" 12 \")).toEqual(\"12\");\n\n  // ordering of methods is respected\n  expect(z.string().min(2).trim().parse(\" 1 \")).toEqual(\"1\");\n  expect(() => z.string().trim().min(2).parse(\" 1 \")).toThrow();\n});\n\ntest(\"lowerCase\", () => {\n  expect(z.string().toLowerCase().parse(\"ASDF\")).toEqual(\"asdf\");\n  expect(z.string().toUpperCase().parse(\"asdf\")).toEqual(\"ASDF\");\n});\n\ntest",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/string.test.ts",
        "start": 562,
        "end": 579,
        "startLoc": {
          "line": 562,
          "column": 2,
          "position": 6041
        },
        "endLoc": {
          "line": 579,
          "column": 5,
          "position": 6249
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/string.test.ts",
        "start": 710,
        "end": 727,
        "startLoc": {
          "line": 710,
          "column": 2,
          "position": 5844
        },
        "endLoc": {
          "line": 727,
          "column": 33,
          "position": 6052
        }
      }
    },
    {
      "format": "typescript",
      "lines": 57,
      "fragment": "});\n\ntest(\"date parsing\", () => {\n  const date = z.string().date();\n  date.parse(\"1970-01-01\");\n  date.parse(\"2022-01-31\");\n  date.parse(\"2022-03-31\");\n  date.parse(\"2022-04-30\");\n  date.parse(\"2022-05-31\");\n  date.parse(\"2022-06-30\");\n  date.parse(\"2022-07-31\");\n  date.parse(\"2022-08-31\");\n  date.parse(\"2022-09-30\");\n  date.parse(\"2022-10-31\");\n  date.parse(\"2022-11-30\");\n  date.parse(\"2022-12-31\");\n\n  date.parse(\"2000-02-29\");\n  date.parse(\"2400-02-29\");\n  expect(() => date.parse(\"2022-02-29\")).toThrow();\n  expect(() => date.parse(\"2100-02-29\")).toThrow();\n  expect(() => date.parse(\"2200-02-29\")).toThrow();\n  expect(() => date.parse(\"2300-02-29\")).toThrow();\n  expect(() => date.parse(\"2500-02-29\")).toThrow();\n\n  expect(() => date.parse(\"\")).toThrow();\n  expect(() => date.parse(\"foo\")).toThrow();\n  expect(() => date.parse(\"200-01-01\")).toThrow();\n  expect(() => date.parse(\"20000-01-01\")).toThrow();\n  expect(() => date.parse(\"2000-0-01\")).toThrow();\n  expect(() => date.parse(\"2000-011-01\")).toThrow();\n  expect(() => date.parse(\"2000-01-0\")).toThrow();\n  expect(() => date.parse(\"2000-01-011\")).toThrow();\n  expect(() => date.parse(\"2000/01/01\")).toThrow();\n  expect(() => date.parse(\"01-01-2022\")).toThrow();\n  expect(() => date.parse(\"01/01/2022\")).toThrow();\n  expect(() => date.parse(\"2000-01-01 00:00:00Z\")).toThrow();\n  expect(() => date.parse(\"2020-10-14T17:42:29+00:00\")).toThrow();\n  expect(() => date.parse(\"2020-10-14T17:42:29Z\")).toThrow();\n  expect(() => date.parse(\"2020-10-14T17:42:29\")).toThrow();\n  expect(() => date.parse(\"2020-10-14T17:42:29.123Z\")).toThrow();\n\n  expect(() => date.parse(\"2000-00-12\")).toThrow();\n  expect(() => date.parse(\"2000-12-00\")).toThrow();\n  expect(() => date.parse(\"2000-01-32\")).toThrow();\n  expect(() => date.parse(\"2000-13-01\")).toThrow();\n  expect(() => date.parse(\"2000-21-01\")).toThrow();\n\n  expect(() => date.parse(\"2000-02-30\")).toThrow();\n  expect(() => date.parse(\"2000-02-31\")).toThrow();\n  expect(() => date.parse(\"2000-04-31\")).toThrow();\n  expect(() => date.parse(\"2000-06-31\")).toThrow();\n  expect(() => date.parse(\"2000-09-31\")).toThrow();\n  expect(() => date.parse(\"2000-11-31\")).toThrow();\n});\n\ntest(\"time\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/string.test.ts",
        "start": 669,
        "end": 725,
        "startLoc": {
          "line": 669,
          "column": 1,
          "position": 7538
        },
        "endLoc": {
          "line": 725,
          "column": 7,
          "position": 8382
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/datetime.test.ts",
        "start": 130,
        "end": 186,
        "startLoc": {
          "line": 130,
          "column": 1,
          "position": 1785
        },
        "endLoc": {
          "line": 186,
          "column": 15,
          "position": 2629
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": ");\n});\n\ntest(\"time parsing\", () => {\n  const time = z.string().time();\n  time.parse(\"00:00:00\");\n  time.parse(\"23:00:00\");\n  time.parse(\"00:59:00\");\n  time.parse(\"00:00:59\");\n  time.parse(\"23:59:59\");\n  time.parse(\"09:52:31\");\n  time.parse(\"23:59:59.9999999\");\n  time.parse(\"23:59\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/string.test.ts",
        "start": 727,
        "end": 739,
        "startLoc": {
          "line": 727,
          "column": 5,
          "position": 8421
        },
        "endLoc": {
          "line": 739,
          "column": 8,
          "position": 8527
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/datetime.test.ts",
        "start": 183,
        "end": 195,
        "startLoc": {
          "line": 183,
          "column": 2,
          "position": 2619
        },
        "endLoc": {
          "line": 195,
          "column": 8,
          "position": 2725
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ");\n  expect(() => time.parse(\"\")).toThrow();\n  expect(() => time.parse(\"foo\")).toThrow();\n  expect(() => time.parse(\"00:00:00Z\")).toThrow();\n  expect(() => time.parse(\"0:00:00\")).toThrow();\n  expect(() => time.parse(\"00:0:00\")).toThrow();\n  expect(() => time.parse(\"00:00:0\")).toThrow();\n  expect(() => time.parse(\"00:00:00.000+00:00\")).toThrow();\n\n  expect(() => time.parse(\"24:00:00\")).toThrow();\n  expect(() => time.parse(\"00:60:00\")).toThrow();\n  expect(() => time.parse(\"00:00:60\")).toThrow();\n  expect(() => time.parse(\"24:60:60\")).toThrow();\n  expect",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/string.test.ts",
        "start": 739,
        "end": 752,
        "startLoc": {
          "line": 739,
          "column": 8,
          "position": 8528
        },
        "endLoc": {
          "line": 752,
          "column": 7,
          "position": 8764
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/datetime.test.ts",
        "start": 195,
        "end": 208,
        "startLoc": {
          "line": 195,
          "column": 8,
          "position": 2726
        },
        "endLoc": {
          "line": 208,
          "column": 6,
          "position": 2962
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ")).toThrow();\n\n  const time2 = z.string().time({ precision: 2 });\n  time2.parse(\"00:00:00.00\");\n  time2.parse(\"09:52:31.12\");\n  time2.parse(\"23:59:59.99\");\n  expect(() => time2.parse(\"\")).toThrow();\n  expect(() => time2.parse(\"foo\")).toThrow();\n  expect(() => time2.parse(\"00:00:00\")).toThrow();\n  expect(() => time2.parse(\"00:00:00.00Z\")).toThrow();\n  expect(() => time2.parse(\"00:00:00.0\")).toThrow();\n  expect(() => time2.parse(\"00:00:00.000\")).toThrow();\n  expect(() => time2.parse(\"00:00:00.00+00:00\")).toThrow();\n  expect",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/string.test.ts",
        "start": 752,
        "end": 765,
        "startLoc": {
          "line": 752,
          "column": 8,
          "position": 8776
        },
        "endLoc": {
          "line": 765,
          "column": 7,
          "position": 8986
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/datetime.test.ts",
        "start": 206,
        "end": 220,
        "startLoc": {
          "line": 206,
          "column": 11,
          "position": 2952
        },
        "endLoc": {
          "line": 220,
          "column": 6,
          "position": 3163
        }
      }
    },
    {
      "format": "typescript",
      "lines": 17,
      "fragment": "];\n\n  for (const val of validDurations) {\n    const result = duration.safeParse(val);\n    if (!result.success) {\n      throw Error(`Valid duration could not be parsed: ${val}`);\n    }\n  }\n\n  for (const val of invalidDurations) {\n    const result = duration.safeParse(val);\n\n    if (result.success) {\n      throw Error(`Invalid duration was successful parsed: ${val}`);\n    }\n\n    expect(result.error.issues[0].message).toEqual(\"Invalid duration\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/string.test.ts",
        "start": 817,
        "end": 833,
        "startLoc": {
          "line": 817,
          "column": 7,
          "position": 9240
        },
        "endLoc": {
          "line": 833,
          "column": 19,
          "position": 9382
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/datetime.test.ts",
        "start": 264,
        "end": 280,
        "startLoc": {
          "line": 264,
          "column": 3,
          "position": 3400
        },
        "endLoc": {
          "line": 280,
          "column": 23,
          "position": 3542
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": ";\n\nconst stringSet = z.set(z.string());\ntype stringSet = z.infer<typeof stringSet>;\n\nconst minTwo = z.set(z.string()).min(2);\nconst maxTwo = z.set(z.string()).max(2);\nconst justTwo = z.set(z.string()).size(2);\nconst nonEmpty = z.set(z.string()).nonempty();\nconst nonEmptyMax = z.set(z.string()).nonempty().max(2);\n\ntest(\"type inference\", () => {\n  util",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/set.test.ts",
        "start": 6,
        "end": 18,
        "startLoc": {
          "line": 6,
          "column": 21,
          "position": 56
        },
        "endLoc": {
          "line": 18,
          "column": 5,
          "position": 226
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/set.test.ts",
        "start": 2,
        "end": 14,
        "startLoc": {
          "line": 2,
          "column": 9,
          "position": 30
        },
        "endLoc": {
          "line": 14,
          "column": 13,
          "position": 200
        }
      }
    },
    {
      "format": "typescript",
      "lines": 15,
      "fragment": "expect(() => {\n    minTwo.parse(new Set([\"a\", \"b\"]));\n    minTwo.parse(new Set([\"a\", \"b\", \"c\"]));\n    maxTwo.parse(new Set([\"a\", \"b\"]));\n    maxTwo.parse(new Set([\"a\"]));\n    justTwo.parse(new Set([\"a\", \"b\"]));\n    nonEmpty.parse(new Set([\"a\"]));\n    nonEmptyMax.parse(new Set([\"a\"]));\n  }).not.toThrow();\n});\n\ntest(\"valid parse async\", async () => {\n  const result = await stringSet.spa(new Set([\"first\", \"second\"]));\n  expect(result.success).toEqual(true);\n  if",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/set.test.ts",
        "start": 30,
        "end": 44,
        "startLoc": {
          "line": 30,
          "column": 3,
          "position": 371
        },
        "endLoc": {
          "line": 44,
          "column": 3,
          "position": 579
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/set.test.ts",
        "start": 24,
        "end": 38,
        "startLoc": {
          "line": 24,
          "column": 3,
          "position": 335
        },
        "endLoc": {
          "line": 38,
          "column": 7,
          "position": 543
        }
      }
    },
    {
      "format": "typescript",
      "lines": 25,
      "fragment": "});\n\ntest(\"valid parse: size-related methods\", () => {\n  expect(() => {\n    minTwo.parse(new Set([\"a\", \"b\"]));\n    minTwo.parse(new Set([\"a\", \"b\", \"c\"]));\n    maxTwo.parse(new Set([\"a\", \"b\"]));\n    maxTwo.parse(new Set([\"a\"]));\n    justTwo.parse(new Set([\"a\", \"b\"]));\n    nonEmpty.parse(new Set([\"a\"]));\n    nonEmptyMax.parse(new Set([\"a\"]));\n  }).not.toThrow();\n\n  const sizeZeroResult = stringSet.parse(new Set());\n  expect(sizeZeroResult.size).toBe(0);\n\n  const sizeTwoResult = minTwo.parse(new Set([\"a\", \"b\"]));\n  expect(sizeTwoResult.size).toBe(2);\n});\n\ntest(\"failing when parsing empty set in nonempty \", () => {\n  const result = nonEmpty.safeParse(new Set());\n  expect(result.success).toEqual(false);\n\n  if",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/set.test.ts",
        "start": 57,
        "end": 81,
        "startLoc": {
          "line": 57,
          "column": 1,
          "position": 762
        },
        "endLoc": {
          "line": 81,
          "column": 3,
          "position": 1053
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/set.test.ts",
        "start": 47,
        "end": 70,
        "startLoc": {
          "line": 47,
          "column": 1,
          "position": 704
        },
        "endLoc": {
          "line": 70,
          "column": 7,
          "position": 994
        }
      }
    },
    {
      "format": "typescript",
      "lines": 11,
      "fragment": "});\n\ntest(\"doesnt throw when an empty set is given\", () => {\n  const result = stringSet.safeParse(new Set([]));\n  expect(result.success).toEqual(true);\n});\n\ntest(\"throws when a Map is given\", () => {\n  const result = stringSet.safeParse(new Map([]));\n  expect(result.success).toEqual(false);\n  if",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/set.test.ts",
        "start": 105,
        "end": 115,
        "startLoc": {
          "line": 105,
          "column": 1,
          "position": 1343
        },
        "endLoc": {
          "line": 115,
          "column": 3,
          "position": 1448
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/set.test.ts",
        "start": 86,
        "end": 96,
        "startLoc": {
          "line": 86,
          "column": 1,
          "position": 1228
        },
        "endLoc": {
          "line": 96,
          "column": 7,
          "position": 1333
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": ", () => {\n  const obj1 = z.object({\n    first: z.string(),\n    second: z.string(),\n  });\n  const obj2 = obj1.partial().strict();\n\n  const obj3 = obj2.refine((data) => data.first || data.second, \"Either first or second should be filled in.\");\n\n  expect(obj1 === (obj2 as any)).toEqual(false);\n  expect(obj2 === (obj3 as any)).toEqual(false);\n\n  expect",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/refine.test.ts",
        "start": 8,
        "end": 20,
        "startLoc": {
          "line": 8,
          "column": 13,
          "position": 62
        },
        "endLoc": {
          "line": 20,
          "column": 7,
          "position": 209
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/refine.test.ts",
        "start": 5,
        "end": 15,
        "startLoc": {
          "line": 5,
          "column": 52,
          "position": 49
        },
        "endLoc": {
          "line": 15,
          "column": 2,
          "position": 194
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": ", async () => {\n  const validationSchema = z\n    .object({\n      email: z.string().email(),\n      password: z.string(),\n      confirmPassword: z.string(),\n    })\n    .refine(\n      (data) => Promise.resolve().then(() => data.password === data.confirmPassword),\n      \"Both password and confirmation must match\"\n    );\n\n  await",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/refine.test.ts",
        "start": 60,
        "end": 72,
        "startLoc": {
          "line": 60,
          "column": 21,
          "position": 665
        },
        "endLoc": {
          "line": 72,
          "column": 6,
          "position": 778
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/refine.test.ts",
        "start": 78,
        "end": 90,
        "startLoc": {
          "line": 78,
          "column": 44,
          "position": 771
        },
        "endLoc": {
          "line": 90,
          "column": 39,
          "position": 884
        }
      }
    },
    {
      "format": "typescript",
      "lines": 21,
      "fragment": "(val, ctx) => {\n    if (val.length > 3) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.too_big,\n        maximum: 3,\n        type: \"array\",\n        inclusive: true,\n        exact: true,\n        message: \"Too many items \",\n      });\n    }\n\n    if (val.length !== new Set(val).size) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: `No duplicates allowed.`,\n      });\n    }\n  });\n\n  const result = await",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/refine.test.ts",
        "start": 150,
        "end": 170,
        "startLoc": {
          "line": 150,
          "column": 2,
          "position": 1554
        },
        "endLoc": {
          "line": 170,
          "column": 6,
          "position": 1710
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/refine.test.ts",
        "start": 121,
        "end": 141,
        "startLoc": {
          "line": 121,
          "column": 2,
          "position": 1281
        },
        "endLoc": {
          "line": 141,
          "column": 8,
          "position": 1437
        }
      }
    },
    {
      "format": "typescript",
      "lines": 15,
      "fragment": ", () => {\n  const objectSchema = z\n    .object({\n      length: z.number(),\n      size: z.number(),\n    })\n    .refine(({ length }) => length > 5, {\n      path: [\"length\"],\n      message: \"length greater than 5\",\n    })\n    .refine(({ size }) => size > 7, {\n      path: [\"size\"],\n      message: \"size greater than 7\",\n    });\n  const",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/refine.test.ts",
        "start": 243,
        "end": 257,
        "startLoc": {
          "line": 243,
          "column": 22,
          "position": 2466
        },
        "endLoc": {
          "line": 257,
          "column": 6,
          "position": 2604
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/refine.test.ts",
        "start": 301,
        "end": 316,
        "startLoc": {
          "line": 301,
          "column": 56,
          "position": 2833
        },
        "endLoc": {
          "line": 316,
          "column": 30,
          "position": 2972
        }
      }
    },
    {
      "format": "typescript",
      "lines": 28,
      "fragment": ";\n\ninterface Category {\n  name: string;\n  subcategories: Category[];\n}\n\nconst testCategory: Category = {\n  name: \"I\",\n  subcategories: [\n    {\n      name: \"A\",\n      subcategories: [\n        {\n          name: \"1\",\n          subcategories: [\n            {\n              name: \"a\",\n              subcategories: [],\n            },\n          ],\n        },\n      ],\n    },\n  ],\n};\n\ntest(\"recursion with z.late.object\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/recursive.test.ts",
        "start": 4,
        "end": 31,
        "startLoc": {
          "line": 4,
          "column": 9,
          "position": 27
        },
        "endLoc": {
          "line": 31,
          "column": 31,
          "position": 159
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/lazy.test.ts",
        "start": 59,
        "end": 86,
        "startLoc": {
          "line": 59,
          "column": 2,
          "position": 671
        },
        "endLoc": {
          "line": 86,
          "column": 24,
          "position": 803
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": ";\n\ntest(\"recursion with z.lazy\", () => {\n  const Category: z.ZodType<Category> = z.lazy(() =>\n    z.object({\n      name: z.string(),\n      subcategories: z.array(Category),\n    })\n  );\n  Category.parse(testCategory);\n});\n\ntest",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/recursive.test.ts",
        "start": 37,
        "end": 49,
        "startLoc": {
          "line": 37,
          "column": 2,
          "position": 238
        },
        "endLoc": {
          "line": 49,
          "column": 5,
          "position": 329
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/lazy.test.ts",
        "start": 84,
        "end": 96,
        "startLoc": {
          "line": 84,
          "column": 2,
          "position": 798
        },
        "endLoc": {
          "line": 96,
          "column": 5,
          "position": 889
        }
      }
    },
    {
      "format": "typescript",
      "lines": 20,
      "fragment": ");\n});\n\ntype LinkedList = null | { value: number; next: LinkedList };\n\nconst linkedListExample = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: null,\n      },\n    },\n  },\n};\n\ntest(\"recursion involving union type\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/recursive.test.ts",
        "start": 50,
        "end": 69,
        "startLoc": {
          "line": 50,
          "column": 7,
          "position": 363
        },
        "endLoc": {
          "line": 69,
          "column": 33,
          "position": 477
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/lazy.test.ts",
        "start": 93,
        "end": 112,
        "startLoc": {
          "line": 93,
          "column": 13,
          "position": 881
        },
        "endLoc": {
          "line": 112,
          "column": 29,
          "position": 995
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ", () => {\n  const LinkedListSchema: z.ZodType<LinkedList> = z.lazy(() =>\n    z.union([\n      z.null(),\n      z.object({\n        value: z.number(),\n        next: LinkedListSchema,\n      }),\n    ])\n  );\n  LinkedListSchema.parse(linkedListExample);\n});\n\n// interface A {",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/recursive.test.ts",
        "start": 69,
        "end": 82,
        "startLoc": {
          "line": 69,
          "column": 33,
          "position": 478
        },
        "endLoc": {
          "line": 82,
          "column": 17,
          "position": 578
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/lazy.test.ts",
        "start": 112,
        "end": 125,
        "startLoc": {
          "line": 112,
          "column": 29,
          "position": 996
        },
        "endLoc": {
          "line": 125,
          "column": 10,
          "position": 1096
        }
      }
    },
    {
      "format": "typescript",
      "lines": 36,
      "fragment": "z.object({\n      a: z.string(),\n    })\n  );\n\n  const data = JSON.parse(`\n    {\n      \"__proto__\": {\n        \"a\": \"evil\"\n      },\n      \"b\": {\n        \"a\": \"good\"\n      }\n    }\n  `);\n\n  const obj1 = rec.parse(data);\n  expect(obj1.a).toBeUndefined();\n\n  const obj2 = rec.safeParse(data);\n  expect(obj2.success).toBe(true);\n  if (obj2.success) {\n    expect(obj2.data.a).toBeUndefined();\n  }\n\n  const obj3 = await rec.parseAsync(data);\n  expect(obj3.a).toBeUndefined();\n\n  const obj4 = await rec.safeParseAsync(data);\n  expect(obj4.success).toBe(true);\n  if (obj4.success) {\n    expect(obj4.data.a).toBeUndefined();\n  }\n});\n\ntest(\"dont parse undefined values\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/record.test.ts",
        "start": 130,
        "end": 165,
        "startLoc": {
          "line": 130,
          "column": 5,
          "position": 1026
        },
        "endLoc": {
          "line": 165,
          "column": 30,
          "position": 1254
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/record.test.ts",
        "start": 218,
        "end": 253,
        "startLoc": {
          "line": 218,
          "column": 5,
          "position": 1202
        },
        "endLoc": {
          "line": 253,
          "column": 31,
          "position": 1430
        }
      }
    },
    {
      "format": "typescript",
      "lines": 15,
      "fragment": "() => {\n  expect(Object.isFrozen(z.array(z.string()).readonly().parse([\"a\"]))).toBe(true);\n  expect(Object.isFrozen(z.tuple([z.string(), z.number()]).readonly().parse([\"a\", 1]))).toBe(true);\n  expect(\n    Object.isFrozen(\n      z\n        .map(z.string(), z.date())\n        .readonly()\n        .parse(new Map([[\"a\", new Date()]]))\n    )\n  ).toBe(true);\n  expect(\n    Object.isFrozen(\n      z\n        .set",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/readonly.test.ts",
        "start": 144,
        "end": 158,
        "startLoc": {
          "line": 144,
          "column": 2,
          "position": 1275
        },
        "endLoc": {
          "line": 158,
          "column": 4,
          "position": 1455
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/readonly.test.ts",
        "start": 121,
        "end": 133,
        "startLoc": {
          "line": 121,
          "column": 2,
          "position": 1118
        },
        "endLoc": {
          "line": 133,
          "column": 7,
          "position": 1293
        }
      }
    },
    {
      "format": "typescript",
      "lines": 23,
      "fragment": "(Promise.resolve(\"a\")))).toBe(true);\n});\n\ntest(\"async object freezing\", async () => {\n  expect(Object.isFrozen(await z.array(z.string()).readonly().parseAsync([\"a\"]))).toBe(true);\n  expect(Object.isFrozen(await z.tuple([z.string(), z.number()]).readonly().parseAsync([\"a\", 1]))).toBe(true);\n  expect(\n    Object.isFrozen(\n      await z\n        .map(z.string(), z.date())\n        .readonly()\n        .parseAsync(new Map([[\"a\", new Date()]]))\n    )\n  ).toBe(true);\n  expect(\n    Object.isFrozen(\n      await z\n        .set(z.promise(z.string()))\n        .readonly()\n        .parseAsync(new Set([Promise.resolve(\"a\")]))\n    )\n  ).toBe(true);\n  expect(Object.isFrozen(await z.record(z.string())",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/readonly.test.ts",
        "start": 166,
        "end": 188,
        "startLoc": {
          "line": 166,
          "column": 6,
          "position": 1685
        },
        "endLoc": {
          "line": 188,
          "column": 2,
          "position": 1971
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/readonly.test.ts",
        "start": 144,
        "end": 166,
        "startLoc": {
          "line": 144,
          "column": 11,
          "position": 1540
        },
        "endLoc": {
          "line": 166,
          "column": 2,
          "position": 1826
        }
      }
    },
    {
      "format": "typescript",
      "lines": 12,
      "fragment": ";\n\nconst promSchema = z.promise(\n  z.object({\n    name: z.string(),\n    age: z.number(),\n  })\n);\n\ntest(\"promise inference\", () => {\n  type promSchemaType = z.infer<typeof promSchema>;\n  util",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/promise.test.ts",
        "start": 5,
        "end": 16,
        "startLoc": {
          "line": 5,
          "column": 21,
          "position": 43
        },
        "endLoc": {
          "line": 16,
          "column": 5,
          "position": 124
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/promise.test.ts",
        "start": 2,
        "end": 13,
        "startLoc": {
          "line": 2,
          "column": 9,
          "position": 30
        },
        "endLoc": {
          "line": 13,
          "column": 13,
          "position": 111
        }
      }
    },
    {
      "format": "typescript",
      "lines": 11,
      "fragment": "(async () => {\n    return { name: \"jimmy\", age: 14 };\n  });\n  await expect(validatedFunction()).resolves.toEqual({\n    name: \"jimmy\",\n    age: 14,\n  });\n});\n\ntest(\"async function fail\", async () => {\n  const validatedFunction = asyncFunction.implement",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/promise.test.ts",
        "start": 65,
        "end": 75,
        "startLoc": {
          "line": 65,
          "column": 10,
          "position": 627
        },
        "endLoc": {
          "line": 75,
          "column": 10,
          "position": 724
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/promise.test.ts",
        "start": 56,
        "end": 66,
        "startLoc": {
          "line": 56,
          "column": 15,
          "position": 584
        },
        "endLoc": {
          "line": 66,
          "column": 15,
          "position": 681
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": ");\n});\n\ntest(\"async promise parsing\", () => {\n  const res = z.promise(z.number()).parseAsync(Promise.resolve(12));\n  expect(res).toBeInstanceOf(Promise);\n});\n\ntest(\"resolves\", () => {\n  const foo = z.literal(\"foo\");\n  const res = z.promise(foo);\n  expect(res.unwrap()).toEqual(foo);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/promise.test.ts",
        "start": 78,
        "end": 90,
        "startLoc": {
          "line": 78,
          "column": 9,
          "position": 770
        },
        "endLoc": {
          "line": 90,
          "column": 2,
          "position": 896
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/promise.test.ts",
        "start": 69,
        "end": 81,
        "startLoc": {
          "line": 69,
          "column": 10,
          "position": 729
        },
        "endLoc": {
          "line": 81,
          "column": 2,
          "position": 855
        }
      }
    },
    {
      "format": "typescript",
      "lines": 24,
      "fragment": ");\nconst stringSchema = z.string();\nconst numberSchema = z.number();\nconst bigintSchema = z.bigint();\nconst booleanSchema = z.boolean();\nconst dateSchema = z.date();\nconst symbolSchema = z.symbol();\n\nconst nullSchema = z.null();\nconst undefinedSchema = z.undefined();\nconst stringSchemaOptional = z.string().optional();\nconst stringSchemaNullable = z.string().nullable();\nconst numberSchemaOptional = z.number().optional();\nconst numberSchemaNullable = z.number().nullable();\nconst bigintSchemaOptional = z.bigint().optional();\nconst bigintSchemaNullable = z.bigint().nullable();\nconst booleanSchemaOptional = z.boolean().optional();\nconst booleanSchemaNullable = z.boolean().nullable();\nconst dateSchemaOptional = z.date().optional();\nconst dateSchemaNullable = z.date().nullable();\nconst symbolSchemaOptional = z.symbol().optional();\nconst symbolSchemaNullable = z.symbol().nullable();\n\nconst",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/primitive.test.ts",
        "start": 13,
        "end": 36,
        "startLoc": {
          "line": 13,
          "column": 9,
          "position": 141
        },
        "endLoc": {
          "line": 36,
          "column": 6,
          "position": 454
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/primitive.test.ts",
        "start": 7,
        "end": 30,
        "startLoc": {
          "line": 7,
          "column": 2,
          "position": 89
        },
        "endLoc": {
          "line": 30,
          "column": 5,
          "position": 402
        }
      }
    },
    {
      "format": "typescript",
      "lines": 19,
      "fragment": ")\n    .safeParseAsync(\"asdf\");\n\n  expect(JSON.parse(JSON.stringify(result))).toEqual({\n    success: false,\n    error: {\n      issues: [\n        {\n          code: \"custom\",\n          message: \"asdf is not one of our allowed strings\",\n          path: [],\n        },\n      ],\n      name: \"ZodError\",\n    },\n  });\n});\n\ntest(\"z.NEVER in preprocess\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/preprocess.test.ts",
        "start": 108,
        "end": 126,
        "startLoc": {
          "line": 108,
          "column": 2,
          "position": 852
        },
        "endLoc": {
          "line": 126,
          "column": 24,
          "position": 958
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/transformer.test.ts",
        "start": 58,
        "end": 76,
        "startLoc": {
          "line": 58,
          "column": 2,
          "position": 457
        },
        "endLoc": {
          "line": 76,
          "column": 23,
          "position": 563
        }
      }
    },
    {
      "format": "typescript",
      "lines": 12,
      "fragment": ");\n});\ntest(\"preprocess as the second property of object\", () => {\n  const schema = z.object({\n    nonEmptyStr: z.string().min(1),\n    positiveNum: z.preprocess((v) => Number(v), z.number().positive()),\n  });\n  const result = schema.safeParse({\n    nonEmptyStr: \"\",\n    positiveNum: \"\",\n  });\n  expect(result.success",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/preprocess.test.ts",
        "start": 139,
        "end": 150,
        "startLoc": {
          "line": 139,
          "column": 6,
          "position": 1139
        },
        "endLoc": {
          "line": 150,
          "column": 8,
          "position": 1261
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/preprocess.test.ts",
        "start": 196,
        "end": 209,
        "startLoc": {
          "line": 196,
          "column": 4,
          "position": 1094
        },
        "endLoc": {
          "line": 209,
          "column": 6,
          "position": 1218
        }
      }
    },
    {
      "format": "typescript",
      "lines": 12,
      "fragment": ";\n\nconst fish = z.object({\n  name: z.string(),\n  age: z.number(),\n  nested: z.object({}),\n});\n\ntest(\"pick type inference\", () => {\n  const nameonlyFish = fish.pick({ name: true });\n  type nameonlyFish = z.infer<typeof nameonlyFish>;\n  util",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/pickomit.test.ts",
        "start": 5,
        "end": 16,
        "startLoc": {
          "line": 5,
          "column": 21,
          "position": 43
        },
        "endLoc": {
          "line": 16,
          "column": 5,
          "position": 150
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/pickomit.test.ts",
        "start": 2,
        "end": 13,
        "startLoc": {
          "line": 2,
          "column": 9,
          "position": 30
        },
        "endLoc": {
          "line": 13,
          "column": 13,
          "position": 137
        }
      }
    },
    {
      "format": "typescript",
      "lines": 33,
      "fragment": ");\n});\n\ntest(\"pick parse - success\", () => {\n  const nameonlyFish = fish.pick({ name: true });\n  nameonlyFish.parse({ name: \"bob\" });\n\n  // @ts-expect-error checking runtime picks `name` only.\n  const anotherNameonlyFish = fish.pick({ name: true, age: false });\n  anotherNameonlyFish.parse({ name: \"bob\" });\n});\n\ntest(\"pick parse - fail\", () => {\n  fish.pick({ name: true }).parse({ name: \"12\" } as any);\n  fish.pick({ name: true }).parse({ name: \"bob\", age: 12 } as any);\n  fish.pick({ age: true }).parse({ age: 12 } as any);\n\n  const nameonlyFish = fish.pick({ name: true }).strict();\n  const bad1 = () => nameonlyFish.parse({ name: 12 } as any);\n  const bad2 = () => nameonlyFish.parse({ name: \"bob\", age: 12 } as any);\n  const bad3 = () => nameonlyFish.parse({ age: 12 } as any);\n\n  // @ts-expect-error checking runtime picks `name` only.\n  const anotherNameonlyFish = fish.pick({ name: true, age: false }).strict();\n  const bad4 = () => anotherNameonlyFish.parse({ name: \"bob\", age: 12 } as any);\n\n  expect(bad1).toThrow();\n  expect(bad2).toThrow();\n  expect(bad3).toThrow();\n  expect(bad4).toThrow();\n});\n\ntest(\"omit type inference\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/pickomit.test.ts",
        "start": 16,
        "end": 48,
        "startLoc": {
          "line": 16,
          "column": 5,
          "position": 168
        },
        "endLoc": {
          "line": 48,
          "column": 22,
          "position": 644
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/pickomit.test.ts",
        "start": 13,
        "end": 45,
        "startLoc": {
          "line": 13,
          "column": 2,
          "position": 156
        },
        "endLoc": {
          "line": 45,
          "column": 25,
          "position": 632
        }
      }
    },
    {
      "format": "typescript",
      "lines": 29,
      "fragment": ");\n});\n\ntest(\"omit parse - success\", () => {\n  const nonameFish = fish.omit({ name: true });\n  nonameFish.parse({ age: 12, nested: {} });\n\n  // @ts-expect-error checking runtime omits `name` only.\n  const anotherNonameFish = fish.omit({ name: true, age: false });\n  anotherNonameFish.parse({ age: 12, nested: {} });\n});\n\ntest(\"omit parse - fail\", () => {\n  const nonameFish = fish.omit({ name: true });\n  const bad1 = () => nonameFish.parse({ name: 12 } as any);\n  const bad2 = () => nonameFish.parse({ age: 12 } as any);\n  const bad3 = () => nonameFish.parse({} as any);\n\n  // @ts-expect-error checking runtime omits `name` only.\n  const anotherNonameFish = fish.omit({ name: true, age: false });\n  const bad4 = () => anotherNonameFish.parse({ nested: {} } as any);\n\n  expect(bad1).toThrow();\n  expect(bad2).toThrow();\n  expect(bad3).toThrow();\n  expect(bad4).toThrow();\n});\n\ntest(\"nonstrict inference\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/pickomit.test.ts",
        "start": 51,
        "end": 79,
        "startLoc": {
          "line": 51,
          "column": 5,
          "position": 719
        },
        "endLoc": {
          "line": 79,
          "column": 22,
          "position": 1081
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/pickomit.test.ts",
        "start": 58,
        "end": 86,
        "startLoc": {
          "line": 58,
          "column": 2,
          "position": 883
        },
        "endLoc": {
          "line": 86,
          "column": 25,
          "position": 1245
        }
      }
    },
    {
      "format": "typescript",
      "lines": 22,
      "fragment": ");\n});\n\ntest(\"nonstrict parsing - pass\", () => {\n  const laxfish = fish.passthrough().pick({ name: true });\n  laxfish.parse({ name: \"asdf\", whatever: \"asdf\" });\n  laxfish.parse({ name: \"asdf\", age: 12, nested: {} });\n});\n\ntest(\"nonstrict parsing - fail\", () => {\n  const laxfish = fish.passthrough().pick({ name: true });\n  const bad = () => laxfish.parse({ whatever: \"asdf\" } as any);\n  expect(bad).toThrow();\n});\n\ntest(\"pick/omit/required/partial - do not allow unknown keys\", () => {\n  const schema = z.object({\n    name: z.string(),\n    age: z.number(),\n  });\n\n  // @ts-expect-error",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/pickomit.test.ts",
        "start": 82,
        "end": 103,
        "startLoc": {
          "line": 82,
          "column": 5,
          "position": 1174
        },
        "endLoc": {
          "line": 103,
          "column": 20,
          "position": 1415
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/pickomit.test.ts",
        "start": 96,
        "end": 117,
        "startLoc": {
          "line": 96,
          "column": 2,
          "position": 1457
        },
        "endLoc": {
          "line": 117,
          "column": 7,
          "position": 1698
        }
      }
    },
    {
      "format": "typescript",
      "lines": 15,
      "fragment": ";\n\nconst nested = z.object({\n  name: z.string(),\n  age: z.number(),\n  outer: z.object({\n    inner: z.string(),\n  }),\n  array: z.array(z.object({ asdf: z.string() })),\n});\n\ntest(\"shallow inference\", () => {\n  const shallow = nested.partial();\n  type shallow = z.infer<typeof shallow>;\n  type",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/partials.test.ts",
        "start": 6,
        "end": 20,
        "startLoc": {
          "line": 6,
          "column": 21,
          "position": 59
        },
        "endLoc": {
          "line": 20,
          "column": 5,
          "position": 199
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/partial.test.ts",
        "start": 2,
        "end": 17,
        "startLoc": {
          "line": 2,
          "column": 9,
          "position": 30
        },
        "endLoc": {
          "line": 17,
          "column": 13,
          "position": 171
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": ");\n});\n\ntest(\"shallow partial parse\", () => {\n  const shallow = nested.partial();\n  shallow.parse({});\n  shallow.parse({\n    name: \"asdf\",\n    age: 23143,\n  });\n});\n\ntest(\"deep partial inference\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/partials.test.ts",
        "start": 26,
        "end": 38,
        "startLoc": {
          "line": 26,
          "column": 5,
          "position": 283
        },
        "endLoc": {
          "line": 38,
          "column": 25,
          "position": 360
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/partial.test.ts",
        "start": 22,
        "end": 34,
        "startLoc": {
          "line": 22,
          "column": 2,
          "position": 250
        },
        "endLoc": {
          "line": 34,
          "column": 11,
          "position": 327
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ");\n});\n\ntest(\"required\", () => {\n  const object = z.object({\n    name: z.string(),\n    age: z.number().optional(),\n    field: z.string().optional().default(\"asdf\"),\n    nullableField: z.number().nullable(),\n    nullishField: z.string().nullish(),\n  });\n\n  const requiredObject = object.required();\n  expect(requiredObject.shape.name).toBeInstanceOf(z.ZodString",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/partials.test.ts",
        "start": 123,
        "end": 136,
        "startLoc": {
          "line": 123,
          "column": 5,
          "position": 1275
        },
        "endLoc": {
          "line": 136,
          "column": 10,
          "position": 1418
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/partial.test.ts",
        "start": 31,
        "end": 44,
        "startLoc": {
          "line": 31,
          "column": 2,
          "position": 317
        },
        "endLoc": {
          "line": 44,
          "column": 15,
          "position": 460
        }
      }
    },
    {
      "format": "typescript",
      "lines": 23,
      "fragment": ").toBeInstanceOf(z.ZodNullable);\n});\n\ntest(\"required inference\", () => {\n  const object = z.object({\n    name: z.string(),\n    age: z.number().optional(),\n    field: z.string().optional().default(\"asdf\"),\n    nullableField: z.number().nullable(),\n    nullishField: z.string().nullish(),\n  });\n\n  const requiredObject = object.required();\n\n  type required = z.infer<typeof requiredObject>;\n  type expected = {\n    name: string;\n    age: number;\n    field: string;\n    nullableField: number | null;\n    nullishField: string | null;\n  };\n  util",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/partials.test.ts",
        "start": 140,
        "end": 162,
        "startLoc": {
          "line": 140,
          "column": 13,
          "position": 1484
        },
        "endLoc": {
          "line": 162,
          "column": 5,
          "position": 1695
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/partial.test.ts",
        "start": 54,
        "end": 76,
        "startLoc": {
          "line": 54,
          "column": 2,
          "position": 662
        },
        "endLoc": {
          "line": 76,
          "column": 13,
          "position": 873
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ");\n});\n\ntest(\"required with mask\", () => {\n  const object = z.object({\n    name: z.string(),\n    age: z.number().optional(),\n    field: z.string().optional().default(\"asdf\"),\n    country: z.string().optional(),\n  });\n\n  const requiredObject = object.required({ age: true });\n  expect(requiredObject.shape.name).toBeInstanceOf(z.ZodString);\n  expect(requiredObject.shape.age).toBeInstanceOf(z.ZodNumber",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/partials.test.ts",
        "start": 162,
        "end": 175,
        "startLoc": {
          "line": 162,
          "column": 5,
          "position": 1706
        },
        "endLoc": {
          "line": 175,
          "column": 10,
          "position": 1860
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/partial.test.ts",
        "start": 76,
        "end": 89,
        "startLoc": {
          "line": 76,
          "column": 2,
          "position": 885
        },
        "endLoc": {
          "line": 89,
          "column": 15,
          "position": 1039
        }
      }
    },
    {
      "format": "typescript",
      "lines": 17,
      "fragment": ");\n  expect(requiredObject.shape.field).toBeInstanceOf(z.ZodDefault);\n  expect(requiredObject.shape.country).toBeInstanceOf(z.ZodOptional);\n});\n\ntest(\"required with mask -- ignore falsy values\", () => {\n  const object = z.object({\n    name: z.string(),\n    age: z.number().optional(),\n    field: z.string().optional().default(\"asdf\"),\n    country: z.string().optional(),\n  });\n\n  // @ts-expect-error\n  const requiredObject = object.required({ age: true, country: false });\n  expect(requiredObject.shape.name).toBeInstanceOf(z.ZodString);\n  expect(requiredObject.shape.age).toBeInstanceOf(z.ZodNumber",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/partials.test.ts",
        "start": 175,
        "end": 191,
        "startLoc": {
          "line": 175,
          "column": 10,
          "position": 1861
        },
        "endLoc": {
          "line": 191,
          "column": 10,
          "position": 2060
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/partial.test.ts",
        "start": 89,
        "end": 105,
        "startLoc": {
          "line": 89,
          "column": 15,
          "position": 1040
        },
        "endLoc": {
          "line": 105,
          "column": 15,
          "position": 1239
        }
      }
    },
    {
      "format": "typescript",
      "lines": 43,
      "fragment": ");\n  expect(requiredObject.shape.field).toBeInstanceOf(z.ZodDefault);\n  expect(requiredObject.shape.country).toBeInstanceOf(z.ZodOptional);\n});\n\ntest(\"partial with mask\", async () => {\n  const object = z.object({\n    name: z.string(),\n    age: z.number().optional(),\n    field: z.string().optional().default(\"asdf\"),\n    country: z.string(),\n  });\n\n  const masked = object.partial({ age: true, field: true, name: true }).strict();\n\n  expect(masked.shape.name).toBeInstanceOf(z.ZodOptional);\n  expect(masked.shape.age).toBeInstanceOf(z.ZodOptional);\n  expect(masked.shape.field).toBeInstanceOf(z.ZodOptional);\n  expect(masked.shape.country).toBeInstanceOf(z.ZodString);\n\n  masked.parse({ country: \"US\" });\n  await masked.parseAsync({ country: \"US\" });\n});\n\ntest(\"partial with mask -- ignore falsy values\", async () => {\n  const object = z.object({\n    name: z.string(),\n    age: z.number().optional(),\n    field: z.string().optional().default(\"asdf\"),\n    country: z.string(),\n  });\n\n  // @ts-expect-error\n  const masked = object.partial({ name: true, country: false }).strict();\n\n  expect(masked.shape.name).toBeInstanceOf(z.ZodOptional);\n  expect(masked.shape.age).toBeInstanceOf(z.ZodOptional);\n  expect(masked.shape.field).toBeInstanceOf(z.ZodDefault);\n  expect(masked.shape.country).toBeInstanceOf(z.ZodString);\n\n  masked.parse({ country: \"US\" });\n  await masked.parseAsync({ country: \"US\" });\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/partials.test.ts",
        "start": 191,
        "end": 233,
        "startLoc": {
          "line": 191,
          "column": 10,
          "position": 2061
        },
        "endLoc": {
          "line": 233,
          "column": 2,
          "position": 2581
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/partial.test.ts",
        "start": 105,
        "end": 147,
        "startLoc": {
          "line": 105,
          "column": 15,
          "position": 1240
        },
        "endLoc": {
          "line": 147,
          "column": 2,
          "position": 1760
        }
      }
    },
    {
      "format": "typescript",
      "lines": 18,
      "fragment": ";\n\nconst Test = z.object({\n  f1: z.number(),\n  f2: z.string().optional(),\n  f3: z.string().nullable(),\n  f4: z.array(z.object({ t: z.union([z.string(), z.boolean()]) })),\n});\n\ntest(\"object type inference\", () => {\n  type TestType = {\n    f1: number;\n    f2?: string | undefined;\n    f3: string | null;\n    f4: { t: string | boolean }[];\n  };\n\n  util",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/object.test.ts",
        "start": 5,
        "end": 22,
        "startLoc": {
          "line": 5,
          "column": 21,
          "position": 43
        },
        "endLoc": {
          "line": 22,
          "column": 5,
          "position": 223
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/object.test.ts",
        "start": 3,
        "end": 20,
        "startLoc": {
          "line": 3,
          "column": 14,
          "position": 43
        },
        "endLoc": {
          "line": 20,
          "column": 13,
          "position": 223
        }
      }
    },
    {
      "format": "typescript",
      "lines": 44,
      "fragment": ");\n});\n\ntest(\"unknown throw\", () => {\n  const asdf: unknown = 35;\n  expect(() => Test.parse(asdf)).toThrow();\n});\n\ntest(\"shape() should return schema of particular key\", () => {\n  const f1Schema = Test.shape.f1;\n  const f2Schema = Test.shape.f2;\n  const f3Schema = Test.shape.f3;\n  const f4Schema = Test.shape.f4;\n\n  expect(f1Schema).toBeInstanceOf(z.ZodNumber);\n  expect(f2Schema).toBeInstanceOf(z.ZodOptional);\n  expect(f3Schema).toBeInstanceOf(z.ZodNullable);\n  expect(f4Schema).toBeInstanceOf(z.ZodArray);\n});\n\ntest(\"correct parsing\", () => {\n  Test.parse({\n    f1: 12,\n    f2: \"string\",\n    f3: \"string\",\n    f4: [\n      {\n        t: \"string\",\n      },\n    ],\n  });\n\n  Test.parse({\n    f1: 12,\n    f3: null,\n    f4: [\n      {\n        t: false,\n      },\n    ],\n  });\n});\n\ntest(\"incorrect #1\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/object.test.ts",
        "start": 22,
        "end": 65,
        "startLoc": {
          "line": 22,
          "column": 5,
          "position": 241
        },
        "endLoc": {
          "line": 65,
          "column": 15,
          "position": 557
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/object.test.ts",
        "start": 20,
        "end": 63,
        "startLoc": {
          "line": 20,
          "column": 2,
          "position": 241
        },
        "endLoc": {
          "line": 63,
          "column": 23,
          "position": 557
        }
      }
    },
    {
      "format": "typescript",
      "lines": 15,
      "fragment": ");\n});\n\nconst data = {\n  points: 2314,\n  unknown: \"asdf\",\n};\n\ntest(\"strip by default\", () => {\n  const val = z.object({ points: z.number() }).parse(data);\n  expect(val).toEqual({ points: 2314 });\n});\n\ntest(\"unknownkeys override\", () => {\n  const val = z.object({ points: z.number() }).strict().passthrough().strip().nonstrict",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/object.test.ts",
        "start": 73,
        "end": 87,
        "startLoc": {
          "line": 73,
          "column": 2,
          "position": 649
        },
        "endLoc": {
          "line": 87,
          "column": 10,
          "position": 799
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/object.test.ts",
        "start": 83,
        "end": 97,
        "startLoc": {
          "line": 83,
          "column": 2,
          "position": 829
        },
        "endLoc": {
          "line": 97,
          "column": 12,
          "position": 979
        }
      }
    },
    {
      "format": "typescript",
      "lines": 32,
      "fragment": "().parse(data);\n\n  expect(val).toEqual(data);\n});\n\ntest(\"passthrough unknown\", () => {\n  const val = z.object({ points: z.number() }).passthrough().parse(data);\n\n  expect(val).toEqual(data);\n});\n\ntest(\"strip unknown\", () => {\n  const val = z.object({ points: z.number() }).strip().parse(data);\n\n  expect(val).toEqual({ points: 2314 });\n});\n\ntest(\"strict\", () => {\n  const val = z.object({ points: z.number() }).strict().safeParse(data);\n\n  expect(val.success).toEqual(false);\n});\n\ntest(\"catchall inference\", () => {\n  const o1 = z\n    .object({\n      first: z.string(),\n    })\n    .catchall(z.number());\n\n  const d1 = o1.parse({ first: \"asdf\", num: 1243 });\n  util",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/object.test.ts",
        "start": 87,
        "end": 118,
        "startLoc": {
          "line": 87,
          "column": 10,
          "position": 800
        },
        "endLoc": {
          "line": 118,
          "column": 5,
          "position": 1115
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/object.test.ts",
        "start": 97,
        "end": 128,
        "startLoc": {
          "line": 97,
          "column": 12,
          "position": 980
        },
        "endLoc": {
          "line": 128,
          "column": 64,
          "position": 1295
        }
      }
    },
    {
      "format": "typescript",
      "lines": 37,
      "fragment": ");\n});\n\ntest(\"catchall overrides strict\", () => {\n  const o1 = z.object({ first: z.string().optional() }).strict().catchall(z.number());\n\n  // should run fine\n  // setting a catchall overrides the unknownKeys behavior\n  o1.parse({\n    asdf: 1234,\n  });\n\n  // should only run catchall validation\n  // against unknown keys\n  o1.parse({\n    first: \"asdf\",\n    asdf: 1234,\n  });\n});\n\ntest(\"catchall overrides strict\", () => {\n  const o1 = z\n    .object({\n      first: z.string(),\n    })\n    .strict()\n    .catchall(z.number());\n\n  // should run fine\n  // setting a catchall overrides the unknownKeys behavior\n  o1.parse({\n    first: \"asdf\",\n    asdf: 1234,\n  });\n});\n\ntest(\"test that optional keys are unset\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/object.test.ts",
        "start": 119,
        "end": 155,
        "startLoc": {
          "line": 119,
          "column": 5,
          "position": 1155
        },
        "endLoc": {
          "line": 155,
          "column": 36,
          "position": 1382
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/object.test.ts",
        "start": 129,
        "end": 165,
        "startLoc": {
          "line": 129,
          "column": 2,
          "position": 1317
        },
        "endLoc": {
          "line": 165,
          "column": 26,
          "position": 1544
        }
      }
    },
    {
      "format": "typescript",
      "lines": 11,
      "fragment": ", async () => {\n  const SNamedEntity = z.object({\n    id: z.string(),\n    set: z.string().optional(),\n    unset: z.string().optional(),\n  });\n  const result = await SNamedEntity.parse({\n    id: \"asdf\",\n    set: undefined,\n  });\n  // eslint-disable-next-line ban/ban",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/object.test.ts",
        "start": 155,
        "end": 165,
        "startLoc": {
          "line": 155,
          "column": 36,
          "position": 1383
        },
        "endLoc": {
          "line": 165,
          "column": 36,
          "position": 1488
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/object.test.ts",
        "start": 165,
        "end": 175,
        "startLoc": {
          "line": 165,
          "column": 26,
          "position": 1545
        },
        "endLoc": {
          "line": 175,
          "column": 7,
          "position": 1650
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ", async () => {\n  const result = z.object({ name: z.string() }).catchall(z.number()).parse({ name: \"Foo\", validExtraKey: 61 });\n\n  expect(result).toEqual({ name: \"Foo\", validExtraKey: 61 });\n\n  const result2 = z\n    .object({ name: z.string() })\n    .catchall(z.number())\n    .safeParse({ name: \"Foo\", validExtraKey: 61, invalid: \"asdf\" });\n\n  expect(result2.success).toEqual(false);\n});\n\ntest(\"test nonexistent keys\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/object.test.ts",
        "start": 169,
        "end": 182,
        "startLoc": {
          "line": 169,
          "column": 24,
          "position": 1520
        },
        "endLoc": {
          "line": 182,
          "column": 24,
          "position": 1698
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/object.test.ts",
        "start": 178,
        "end": 191,
        "startLoc": {
          "line": 178,
          "column": 19,
          "position": 1679
        },
        "endLoc": {
          "line": 191,
          "column": 19,
          "position": 1857
        }
      }
    },
    {
      "format": "typescript",
      "lines": 26,
      "fragment": ", async () => {\n  const Schema = z.union([z.object({ a: z.string() }), z.object({ b: z.number() })]);\n  const obj = { a: \"A\" };\n  const result = await Schema.spa(obj); // Works with 1.11.10, breaks with 2.0.0-beta.21\n  expect(result.success).toBe(true);\n});\n\ntest(\"test async union\", async () => {\n  const Schema2 = z.union([\n    z.object({\n      ty: z.string(),\n    }),\n    z.object({\n      ty: z.number(),\n    }),\n  ]);\n\n  const obj = { ty: \"A\" };\n  const result = await Schema2.spa(obj); // Works with 1.11.10, breaks with 2.0.0-beta.21\n  expect(result.success).toEqual(true);\n});\n\ntest(\"test inferred merged type\", async () => {\n  const asdf = z.object({ a: z.string() }).merge(z.object({ a: z.number() }));\n  type asdf = z.infer<typeof asdf>;\n  util",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/object.test.ts",
        "start": 182,
        "end": 207,
        "startLoc": {
          "line": 182,
          "column": 24,
          "position": 1699
        },
        "endLoc": {
          "line": 207,
          "column": 5,
          "position": 2030
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/object.test.ts",
        "start": 191,
        "end": 217,
        "startLoc": {
          "line": 191,
          "column": 19,
          "position": 1858
        },
        "endLoc": {
          "line": 217,
          "column": 13,
          "position": 2190
        }
      }
    },
    {
      "format": "typescript",
      "lines": 12,
      "fragment": ");\n});\n\ntest(\"inferred type for unknown/any keys\", () => {\n  const myType = z.object({\n    anyOptional: z.any().optional(),\n    anyRequired: z.any(),\n    unknownOptional: z.unknown().optional(),\n    unknownRequired: z.unknown(),\n  });\n  type myType = z.infer<typeof myType>;\n  util",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/object.test.ts",
        "start": 254,
        "end": 265,
        "startLoc": {
          "line": 254,
          "column": 5,
          "position": 2771
        },
        "endLoc": {
          "line": 265,
          "column": 5,
          "position": 2879
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/object.test.ts",
        "start": 273,
        "end": 284,
        "startLoc": {
          "line": 273,
          "column": 2,
          "position": 3102
        },
        "endLoc": {
          "line": 284,
          "column": 13,
          "position": 3210
        }
      }
    },
    {
      "format": "typescript",
      "lines": 29,
      "fragment": ", async () => {\n  const strictObj = z.strictObject({\n    name: z.string(),\n  });\n\n  const syncResult = strictObj.safeParse({ name: \"asdf\", unexpected: 13 });\n  expect(syncResult.success).toEqual(false);\n\n  const asyncResult = await strictObj.spa({ name: \"asdf\", unexpected: 13 });\n  expect(asyncResult.success).toEqual(false);\n});\n\ntest(\"object with refine\", async () => {\n  const schema = z\n    .object({\n      a: z.string().default(\"foo\"),\n      b: z.number(),\n    })\n    .refine(() => true);\n  expect(schema.parse({ b: 5 })).toEqual({ b: 5, a: \"foo\" });\n  const result = await schema.parseAsync({ b: 5 });\n  expect(result).toEqual({ b: 5, a: \"foo\" });\n});\n\ntest(\"intersection of object with date\", async () => {\n  const schema = z.object({\n    a: z.date(),\n  });\n  expect(schema",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/object.test.ts",
        "start": 285,
        "end": 313,
        "startLoc": {
          "line": 285,
          "column": 15,
          "position": 3074
        },
        "endLoc": {
          "line": 313,
          "column": 7,
          "position": 3417
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/object.test.ts",
        "start": 292,
        "end": 320,
        "startLoc": {
          "line": 292,
          "column": 15,
          "position": 3266
        },
        "endLoc": {
          "line": 320,
          "column": 2,
          "position": 3609
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": "schema).parse({ a: new Date(1637353595983) })).toEqual({\n    a: new Date(1637353595983),\n  });\n  const result = await schema.parseAsync({ a: new Date(1637353595983) });\n  expect(result).toEqual({ a: new Date(1637353595983) });\n});\n\ntest(\"intersection of object with refine with date\", async () => {\n  const schema = z\n    .object({\n      a: z.date(),\n    })\n    .refine(() => true);\n  expect(schema",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/object.test.ts",
        "start": 313,
        "end": 326,
        "startLoc": {
          "line": 313,
          "column": 2,
          "position": 3421
        },
        "endLoc": {
          "line": 326,
          "column": 7,
          "position": 3581
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/object.test.ts",
        "start": 320,
        "end": 333,
        "startLoc": {
          "line": 320,
          "column": 2,
          "position": 3616
        },
        "endLoc": {
          "line": 333,
          "column": 2,
          "position": 3776
        }
      }
    },
    {
      "format": "typescript",
      "lines": 32,
      "fragment": ");\n  expect(schema.and(schema).parse({ a: new Date(1637353595983) })).toEqual({\n    a: new Date(1637353595983),\n  });\n  const result = await schema.parseAsync({ a: new Date(1637353595983) });\n  expect(result).toEqual({ a: new Date(1637353595983) });\n});\n\ntest(\"constructor key\", () => {\n  const person = z\n    .object({\n      name: z.string(),\n    })\n    .strict();\n\n  expect(() =>\n    person.parse({\n      name: \"bob dylan\",\n      constructor: 61,\n    })\n  ).toThrow();\n});\n\ntest(\"constructor key\", () => {\n  const Example = z.object({\n    prop: z.string(),\n    opt: z.number().optional(),\n    arr: z.string().array(),\n  });\n\n  type Example = z.infer<typeof Example>;\n  util",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/object.test.ts",
        "start": 325,
        "end": 356,
        "startLoc": {
          "line": 325,
          "column": 5,
          "position": 3575
        },
        "endLoc": {
          "line": 356,
          "column": 5,
          "position": 3871
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/object.test.ts",
        "start": 312,
        "end": 363,
        "startLoc": {
          "line": 312,
          "column": 2,
          "position": 3411
        },
        "endLoc": {
          "line": 363,
          "column": 13,
          "position": 4069
        }
      }
    },
    {
      "format": "typescript",
      "lines": 17,
      "fragment": ");\n});\n\nconst personToExtend = z.object({\n  firstName: z.string(),\n  lastName: z.string(),\n});\n\ntest(\"extend() should return schema with new key\", () => {\n  const PersonWithNickname = personToExtend.extend({ nickName: z.string() });\n  type PersonWithNickname = z.infer<typeof PersonWithNickname>;\n\n  const expected = { firstName: \"f\", nickName: \"n\", lastName: \"l\" };\n  const actual = PersonWithNickname.parse(expected);\n\n  expect(actual).toEqual(expected);\n  util",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/object.test.ts",
        "start": 380,
        "end": 396,
        "startLoc": {
          "line": 380,
          "column": 5,
          "position": 4106
        },
        "endLoc": {
          "line": 396,
          "column": 5,
          "position": 4267
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/object.test.ts",
        "start": 390,
        "end": 406,
        "startLoc": {
          "line": 390,
          "column": 10,
          "position": 4376
        },
        "endLoc": {
          "line": 406,
          "column": 13,
          "position": 4537
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ");\n});\n\ntest(\"extend() should have power to override existing key\", () => {\n  const PersonWithNumberAsLastName = personToExtend.extend({\n    lastName: z.number(),\n  });\n  type PersonWithNumberAsLastName = z.infer<typeof PersonWithNumberAsLastName>;\n\n  const expected = { firstName: \"f\", lastName: 42 };\n  const actual = PersonWithNumberAsLastName.parse(expected);\n\n  expect(actual).toEqual(expected);\n  util",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/object.test.ts",
        "start": 397,
        "end": 410,
        "startLoc": {
          "line": 397,
          "column": 5,
          "position": 4322
        },
        "endLoc": {
          "line": 410,
          "column": 5,
          "position": 4441
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/object.test.ts",
        "start": 407,
        "end": 420,
        "startLoc": {
          "line": 407,
          "column": 2,
          "position": 4594
        },
        "endLoc": {
          "line": 420,
          "column": 13,
          "position": 4713
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\nfunction checkErrors(a: z.ZodTypeAny, bad: any) {\n  let expected: any;\n  try {\n    a.parse(bad);\n  } catch (error) {\n    expected = (error as z.ZodError).formErrors;\n  }\n  try {\n    a.nullable",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/nullable.test.ts",
        "start": 1,
        "end": 14,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 14,
          "column": 9,
          "position": 116
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/optional.test.ts",
        "start": 1,
        "end": 14,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 14,
          "column": 9,
          "position": 116
        }
      }
    },
    {
      "format": "typescript",
      "lines": 12,
      "fragment": ", () => {\n  const Fruits: { Apple: \"apple\"; Banana: \"banana\" } = {\n    Apple: \"apple\",\n    Banana: \"banana\",\n  };\n  const fruitEnum = z.nativeEnum(Fruits);\n  type fruitEnum = z.infer<typeof fruitEnum>;\n  fruitEnum.parse(\"apple\");\n  fruitEnum.parse(\"banana\");\n  fruitEnum.parse(Fruits.Apple);\n  fruitEnum.parse(Fruits.Banana);\n  util",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/nativeEnum.test.ts",
        "start": 7,
        "end": 18,
        "startLoc": {
          "line": 7,
          "column": 30,
          "position": 49
        },
        "endLoc": {
          "line": 18,
          "column": 5,
          "position": 174
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/enum.test.ts",
        "start": 12,
        "end": 23,
        "startLoc": {
          "line": 12,
          "column": 25,
          "position": 134
        },
        "endLoc": {
          "line": 23,
          "column": 13,
          "position": 259
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": ", () => {\n  const FruitValues = {\n    Apple: 10,\n    Banana: 20,\n    // @ts-ignore\n  } as const;\n  const fruitEnum = z.nativeEnum(FruitValues);\n  type fruitEnum = z.infer<typeof fruitEnum>;\n  fruitEnum.parse(10);\n  fruitEnum.parse(20);\n  fruitEnum.parse(FruitValues.Apple);\n  fruitEnum.parse(FruitValues.Banana);\n  util",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/nativeEnum.test.ts",
        "start": 36,
        "end": 48,
        "startLoc": {
          "line": 36,
          "column": 47,
          "position": 342
        },
        "endLoc": {
          "line": 48,
          "column": 5,
          "position": 458
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/enum.test.ts",
        "start": 47,
        "end": 59,
        "startLoc": {
          "line": 47,
          "column": 42,
          "position": 484
        },
        "endLoc": {
          "line": 59,
          "column": 13,
          "position": 600
        }
      }
    },
    {
      "format": "typescript",
      "lines": 12,
      "fragment": ");\n});\n\ntest(\"failing validations\", () => {\n  expect(() => schema.parse(5)).toThrow();\n  expect(() => schema.parse(\"John\")).toThrow();\n  expect(() => schema.parse(true)).toThrow();\n  expect(() => schema.parse(null)).toThrow();\n  expect(() => schema.parse(undefined)).toThrow();\n  expect(() => schema.parse({})).toThrow();\n  expect(() => schema.parse([])).toThrow();\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/nan.test.ts",
        "start": 10,
        "end": 21,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 79
        },
        "endLoc": {
          "line": 21,
          "column": 2,
          "position": 250
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/nan.test.ts",
        "start": 10,
        "end": 21,
        "startLoc": {
          "line": 10,
          "column": 2,
          "position": 100
        },
        "endLoc": {
          "line": 21,
          "column": 2,
          "position": 271
        }
      }
    },
    {
      "format": "typescript",
      "lines": 12,
      "fragment": ");\n});\n\ntest(\"valid parse\", () => {\n  const result = stringMap.safeParse(\n    new Map([\n      [\"first\", \"foo\"],\n      [\"second\", \"bar\"],\n    ])\n  );\n  expect(result.success).toEqual(true);\n  if",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/map.test.ts",
        "start": 12,
        "end": 23,
        "startLoc": {
          "line": 12,
          "column": 5,
          "position": 130
        },
        "endLoc": {
          "line": 23,
          "column": 3,
          "position": 210
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/map.test.ts",
        "start": 8,
        "end": 19,
        "startLoc": {
          "line": 8,
          "column": 2,
          "position": 105
        },
        "endLoc": {
          "line": 19,
          "column": 7,
          "position": 185
        }
      }
    },
    {
      "format": "typescript",
      "lines": 16,
      "fragment": "(\n    new Map([\n      [\"first\", \"foo\"],\n      [\"second\", \"bar\"],\n    ])\n  );\n  expect(result.success).toEqual(true);\n  if (result.success) {\n    expect(result.data.has(\"first\")).toEqual(true);\n    expect(result.data.has(\"second\")).toEqual(true);\n    expect(result.data.get(\"first\")).toEqual(\"foo\");\n    expect(result.data.get(\"second\")).toEqual(\"bar\");\n  }\n});\n\ntest(\"throws when a Set is given\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/map.test.ts",
        "start": 32,
        "end": 47,
        "startLoc": {
          "line": 32,
          "column": 4,
          "position": 330
        },
        "endLoc": {
          "line": 47,
          "column": 29,
          "position": 476
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/map.test.ts",
        "start": 16,
        "end": 31,
        "startLoc": {
          "line": 16,
          "column": 10,
          "position": 160
        },
        "endLoc": {
          "line": 31,
          "column": 20,
          "position": 306
        }
      }
    },
    {
      "format": "typescript",
      "lines": 12,
      "fragment": "});\n\ntest(\"throws when a Set is given\", () => {\n  const result = stringMap.safeParse(new Set([]));\n  expect(result.success).toEqual(false);\n  if (result.success === false) {\n    expect(result.error.issues.length).toEqual(1);\n    expect(result.error.issues[0].code).toEqual(ZodIssueCode.invalid_type);\n  }\n});\n\ntest(\"throws when the given map has invalid key and invalid input\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/map.test.ts",
        "start": 45,
        "end": 56,
        "startLoc": {
          "line": 45,
          "column": 1,
          "position": 469
        },
        "endLoc": {
          "line": 56,
          "column": 62,
          "position": 587
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/map.test.ts",
        "start": 52,
        "end": 121,
        "startLoc": {
          "line": 52,
          "column": 1,
          "position": 335
        },
        "endLoc": {
          "line": 121,
          "column": 46,
          "position": 1513
        }
      }
    },
    {
      "format": "typescript",
      "lines": 19,
      "fragment": ");\n  }\n});\n\ntest(\"throws when the given map has multiple invalid entries\", () => {\n  // const result = stringMap.safeParse(new Map([[42, Symbol()]]));\n\n  const result = stringMap.safeParse(\n    new Map([\n      [1, \"foo\"],\n      [\"bar\", 2],\n    ] as [any, any][]) as Map<any, any>\n  );\n\n  // const result = stringMap.safeParse(new Map([[42, Symbol()]]));\n  expect(result.success).toEqual(false);\n  if (result.success === false) {\n    expect(result.error.issues.length).toEqual(2);\n    expect(result.error.issues[",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/map.test.ts",
        "start": 64,
        "end": 82,
        "startLoc": {
          "line": 64,
          "column": 2,
          "position": 768
        },
        "endLoc": {
          "line": 82,
          "column": 2,
          "position": 920
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/map.test.ts",
        "start": 87,
        "end": 105,
        "startLoc": {
          "line": 87,
          "column": 6,
          "position": 548
        },
        "endLoc": {
          "line": 105,
          "column": 2,
          "position": 700
        }
      }
    },
    {
      "format": "typescript",
      "lines": 21,
      "fragment": ");\n  }\n});\n\ntest(\"dirty\", async () => {\n  const map = z.map(\n    z.string().refine((val) => val === val.toUpperCase(), {\n      message: \"Keys must be uppercase\",\n    }),\n    z.string()\n  );\n  const result = await map.spa(\n    new Map([\n      [\"first\", \"foo\"],\n      [\"second\", \"bar\"],\n    ])\n  );\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues.length).toEqual(2);\n    expect(result.error.",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/map.test.ts",
        "start": 85,
        "end": 105,
        "startLoc": {
          "line": 85,
          "column": 2,
          "position": 1007
        },
        "endLoc": {
          "line": 105,
          "column": 2,
          "position": 1192
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/map.test.ts",
        "start": 124,
        "end": 144,
        "startLoc": {
          "line": 124,
          "column": 6,
          "position": 705
        },
        "endLoc": {
          "line": 144,
          "column": 2,
          "position": 890
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": ".properties).toEqual({ is_animal: true, jumped: true });\n});\n\ntest(\"deep intersection of arrays\", async () => {\n  const Author = z.object({\n    posts: z.array(\n      z.object({\n        post_id: z.number(),\n      })\n    ),\n  });\n  const Registry = z\n    .object",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/intersection.test.ts",
        "start": 41,
        "end": 53,
        "startLoc": {
          "line": 41,
          "column": 4,
          "position": 464
        },
        "endLoc": {
          "line": 53,
          "column": 7,
          "position": 570
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/intersection.test.ts",
        "start": 61,
        "end": 72,
        "startLoc": {
          "line": 61,
          "column": 2,
          "position": 902
        },
        "endLoc": {
          "line": 72,
          "column": 13,
          "position": 1006
        }
      }
    },
    {
      "format": "typescript",
      "lines": 19,
      "fragment": ");\n\n  const posts = [\n    { post_id: 1, title: \"Novels\" },\n    { post_id: 2, title: \"Fairy tales\" },\n  ];\n  const cat = Registry.parse({ posts });\n  expect(cat.posts).toEqual(posts);\n  const asyncCat = await Registry.parseAsync({ posts });\n  expect(asyncCat.posts).toEqual(posts);\n});\n\ntest(\"invalid intersection types\", async () => {\n  const numberIntersection = z.intersection(\n    z.number(),\n    z.number().transform((x) => x + 1)\n  );\n\n  const",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/intersection.test.ts",
        "start": 60,
        "end": 78,
        "startLoc": {
          "line": 60,
          "column": 7,
          "position": 618
        },
        "endLoc": {
          "line": 78,
          "column": 6,
          "position": 804
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/intersection.test.ts",
        "start": 81,
        "end": 99,
        "startLoc": {
          "line": 81,
          "column": 3,
          "position": 1060
        },
        "endLoc": {
          "line": 99,
          "column": 7,
          "position": 1246
        }
      }
    },
    {
      "format": "typescript",
      "lines": 23,
      "fragment": ";\n\ntest(\"instanceof\", async () => {\n  class Test {}\n  class Subtest extends Test {}\n  abstract class AbstractBar {\n    constructor(public val: string) {}\n  }\n  class Bar extends AbstractBar {}\n\n  const TestSchema = z.instanceof(Test);\n  const SubtestSchema = z.instanceof(Subtest);\n  const AbstractSchema = z.instanceof(AbstractBar);\n  const BarSchema = z.instanceof(Bar);\n\n  TestSchema.parse(new Test());\n  TestSchema.parse(new Subtest());\n  SubtestSchema.parse(new Subtest());\n  AbstractSchema.parse(new Bar(\"asdf\"));\n  const bar = BarSchema.parse(new Bar(\"asdf\"));\n  expect(bar.val).toEqual(\"asdf\");\n\n  await expect(() => SubtestSchema.parse(new Test())).toThrow(/Input not instance of Subtest/",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/instanceof.test.ts",
        "start": 5,
        "end": 27,
        "startLoc": {
          "line": 5,
          "column": 21,
          "position": 43
        },
        "endLoc": {
          "line": 27,
          "column": 32,
          "position": 292
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/instanceof.test.ts",
        "start": 2,
        "end": 24,
        "startLoc": {
          "line": 2,
          "column": 9,
          "position": 30
        },
        "endLoc": {
          "line": 24,
          "column": 2,
          "position": 279
        }
      }
    },
    {
      "format": "typescript",
      "lines": 16,
      "fragment": "});\n\ntest(\"custom path\", () => {\n  const schema = z\n    .object({\n      password: z.string(),\n      confirm: z.string(),\n    })\n    .refine((val) => val.confirm === val.password, { path: [\"confirm\"] });\n\n  const result = schema.safeParse({\n    password: \"peanuts\",\n    confirm: \"qeanuts\",\n  });\n\n  expect(result.success).toEqual",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/error.test.ts",
        "start": 209,
        "end": 224,
        "startLoc": {
          "line": 209,
          "column": 1,
          "position": 1971
        },
        "endLoc": {
          "line": 224,
          "column": 8,
          "position": 2105
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/error.test.ts",
        "start": 274,
        "end": 289,
        "startLoc": {
          "line": 274,
          "column": 1,
          "position": 1683
        },
        "endLoc": {
          "line": 289,
          "column": 5,
          "position": 1817
        }
      }
    },
    {
      "format": "typescript",
      "lines": 16,
      "fragment": "});\n\ntest(\"custom path\", () => {\n  const schema = z\n    .object({\n      password: z.string().min(6),\n      confirm: z.string().min(6),\n    })\n    .refine((val) => val.confirm === val.password);\n\n  const result = schema.safeParse({\n    password: \"qwer\",\n    confirm: \"asdf\",\n  });\n\n  expect(result.success).toEqual",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/error.test.ts",
        "start": 232,
        "end": 247,
        "startLoc": {
          "line": 232,
          "column": 1,
          "position": 2196
        },
        "endLoc": {
          "line": 247,
          "column": 8,
          "position": 2328
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/error.test.ts",
        "start": 294,
        "end": 309,
        "startLoc": {
          "line": 294,
          "column": 1,
          "position": 1891
        },
        "endLoc": {
          "line": 309,
          "column": 5,
          "position": 2023
        }
      }
    },
    {
      "format": "typescript",
      "lines": 19,
      "fragment": "});\n\nconst schema = z.object({\n  inner: z.object({\n    name: z\n      .string()\n      .refine((val) => val.length > 5)\n      .array()\n      .refine((val) => val.length <= 1),\n  }),\n});\n\ntest(\"no abort early on refinements\", () => {\n  const invalidItem = {\n    inner: { name: [\"aasd\", \"asdfasdfasfd\"] },\n  };\n\n  const result1 = schema.safeParse(invalidItem);\n  expect(result1.success).toEqual",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/error.test.ts",
        "start": 251,
        "end": 269,
        "startLoc": {
          "line": 251,
          "column": 1,
          "position": 2367
        },
        "endLoc": {
          "line": 269,
          "column": 8,
          "position": 2529
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/error.test.ts",
        "start": 311,
        "end": 329,
        "startLoc": {
          "line": 311,
          "column": 1,
          "position": 2048
        },
        "endLoc": {
          "line": 329,
          "column": 5,
          "position": 2210
        }
      }
    },
    {
      "format": "typescript",
      "lines": 12,
      "fragment": "});\ntest(\"formatting\", () => {\n  const invalidItem = {\n    inner: { name: [\"aasd\", \"asdfasdfasfd\"] },\n  };\n  const invalidArray = {\n    inner: { name: [\"asdfasdf\", \"asdfasdfasfd\"] },\n  };\n  const result1 = schema.safeParse(invalidItem);\n  const result2 = schema.safeParse(invalidArray);\n\n  expect(result1.success).toEqual",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/error.test.ts",
        "start": 273,
        "end": 284,
        "startLoc": {
          "line": 273,
          "column": 1,
          "position": 2568
        },
        "endLoc": {
          "line": 284,
          "column": 8,
          "position": 2687
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/error.test.ts",
        "start": 345,
        "end": 357,
        "startLoc": {
          "line": 345,
          "column": 1,
          "position": 2389
        },
        "endLoc": {
          "line": 357,
          "column": 5,
          "position": 2509
        }
      }
    },
    {
      "format": "typescript",
      "lines": 22,
      "fragment": "});\n\ntest(\"formatting with nullable and optional fields\", () => {\n  const nameSchema = z.string().refine((val) => val.length > 5);\n  const schema = z.object({\n    nullableObject: z.object({ name: nameSchema }).nullable(),\n    nullableArray: z.array(nameSchema).nullable(),\n    nullableTuple: z.tuple([nameSchema, nameSchema, z.number()]).nullable(),\n    optionalObject: z.object({ name: nameSchema }).optional(),\n    optionalArray: z.array(nameSchema).optional(),\n    optionalTuple: z.tuple([nameSchema, nameSchema, z.number()]).optional(),\n  });\n  const invalidItem = {\n    nullableObject: { name: \"abcd\" },\n    nullableArray: [\"abcd\"],\n    nullableTuple: [\"abcd\", \"abcd\", 1],\n    optionalObject: { name: \"abcd\" },\n    optionalArray: [\"abcd\"],\n    optionalTuple: [\"abcd\", \"abcd\", 1],\n  };\n  const result = schema.safeParse(invalidItem);\n  expect(result.success).toEqual",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/error.test.ts",
        "start": 314,
        "end": 335,
        "startLoc": {
          "line": 314,
          "column": 1,
          "position": 3091
        },
        "endLoc": {
          "line": 335,
          "column": 8,
          "position": 3403
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/error.test.ts",
        "start": 379,
        "end": 400,
        "startLoc": {
          "line": 379,
          "column": 1,
          "position": 2865
        },
        "endLoc": {
          "line": 400,
          "column": 5,
          "position": 3177
        }
      }
    },
    {
      "format": "typescript",
      "lines": 17,
      "fragment": ".format();\n    expect(error._errors).toEqual([]);\n    expect(error.nullableObject?._errors).toEqual([]);\n    expect(error.nullableObject?.name?._errors).toEqual([\"Invalid input\"]);\n    expect(error.nullableArray?._errors).toEqual([]);\n    expect(error.nullableArray?.[0]?._errors).toEqual([\"Invalid input\"]);\n    expect(error.nullableTuple?._errors).toEqual([]);\n    expect(error.nullableTuple?.[0]?._errors).toEqual([\"Invalid input\"]);\n    expect(error.nullableTuple?.[1]?._errors).toEqual([\"Invalid input\"]);\n    expect(error.optionalObject?._errors).toEqual([]);\n    expect(error.optionalObject?.name?._errors).toEqual([\"Invalid input\"]);\n    expect(error.optionalArray?._errors).toEqual([]);\n    expect(error.optionalArray?.[0]?._errors).toEqual([\"Invalid input\"]);\n    expect(error.optionalTuple?._errors).toEqual([]);\n    expect(error.optionalTuple?.[0]?._errors).toEqual([\"Invalid input\"]);\n    expect(error.optionalTuple?.[1]?._errors).toEqual([\"Invalid input\"]);\n  }",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/error.test.ts",
        "start": 338,
        "end": 354,
        "startLoc": {
          "line": 338,
          "column": 6,
          "position": 3451
        },
        "endLoc": {
          "line": 354,
          "column": 2,
          "position": 3769
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/error.test.ts",
        "start": 401,
        "end": 418,
        "startLoc": {
          "line": 401,
          "column": 2,
          "position": 3204
        },
        "endLoc": {
          "line": 418,
          "column": 7,
          "position": 3523
        }
      }
    },
    {
      "format": "typescript",
      "lines": 30,
      "fragment": "});\n\ntest(\"enum with message returns the custom error message\", () => {\n  const schema = z.enum([\"apple\", \"banana\"], {\n    message: \"the value provided is invalid\",\n  });\n\n  const result1 = schema.safeParse(\"berries\");\n  expect(result1.success).toEqual(false);\n  if (!result1.success) {\n    expect(result1.error.issues[0].message).toEqual(\"the value provided is invalid\");\n  }\n\n  const result2 = schema.safeParse(undefined);\n  expect(result2.success).toEqual(false);\n  if (!result2.success) {\n    expect(result2.error.issues[0].message).toEqual(\"the value provided is invalid\");\n  }\n\n  const result3 = schema.safeParse(\"banana\");\n  expect(result3.success).toEqual(true);\n\n  const result4 = schema.safeParse(null);\n  expect(result4.success).toEqual(false);\n  if (!result4.success) {\n    expect(result4.error.issues[0].message).toEqual(\"the value provided is invalid\");\n  }\n});\n\ntest(\"when the message is falsy, it is used as is provided\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/error.test.ts",
        "start": 499,
        "end": 528,
        "startLoc": {
          "line": 499,
          "column": 1,
          "position": 5285
        },
        "endLoc": {
          "line": 528,
          "column": 55,
          "position": 5570
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/enum.test.ts",
        "start": 249,
        "end": 278,
        "startLoc": {
          "line": 249,
          "column": 1,
          "position": 2354
        },
        "endLoc": {
          "line": 278,
          "column": 26,
          "position": 2639
        }
      }
    },
    {
      "format": "typescript",
      "lines": 12,
      "fragment": ");\n});\n\ntest(\"get options\", () => {\n  expect(z.enum([\"tuna\", \"trout\"]).options).toEqual([\"tuna\", \"trout\"]);\n});\n\ntest(\"readonly enum\", () => {\n  const HTTP_SUCCESS = [\"200\", \"201\"] as const;\n  const arg = z.enum(HTTP_SUCCESS);\n  type arg = z.infer<typeof arg>;\n  util",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/enum.test.ts",
        "start": 17,
        "end": 28,
        "startLoc": {
          "line": 17,
          "column": 5,
          "position": 206
        },
        "endLoc": {
          "line": 28,
          "column": 5,
          "position": 324
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/enum.test.ts",
        "start": 85,
        "end": 96,
        "startLoc": {
          "line": 85,
          "column": 6,
          "position": 808
        },
        "endLoc": {
          "line": 96,
          "column": 13,
          "position": 926
        }
      }
    },
    {
      "format": "typescript",
      "lines": 12,
      "fragment": ", () => {\n  expect(\n    z\n      .discriminatedUnion(\"type\", [\n        z.object({ type: z.literal(\"a\"), a: z.string() }),\n        z.object({ type: z.literal(\"b\"), b: z.string() }),\n      ])\n      .parse({ type: \"a\", a: \"abc\" })\n  ).toEqual({ type: \"a\", a: \"abc\" });\n});\n\ntest(\"valid - discriminator value of various primitive types\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/discriminated-unions.test.ts",
        "start": 6,
        "end": 17,
        "startLoc": {
          "line": 6,
          "column": 8,
          "position": 36
        },
        "endLoc": {
          "line": 17,
          "column": 57,
          "position": 176
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/discriminated-unions.test.ts",
        "start": 32,
        "end": 43,
        "startLoc": {
          "line": 32,
          "column": 23,
          "position": 606
        },
        "endLoc": {
          "line": 43,
          "column": 49,
          "position": 746
        }
      }
    },
    {
      "format": "typescript",
      "lines": 12,
      "fragment": ");\n});\n\ntest(\"invalid - null\", () => {\n  try {\n    z.discriminatedUnion(\"type\", [\n      z.object({ type: z.literal(\"a\"), a: z.string() }),\n      z.object({ type: z.literal(\"b\"), b: z.string() }),\n    ]).parse(null);\n    throw new Error();\n  } catch (e: any) {\n    expect",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/discriminated-unions.test.ts",
        "start": 62,
        "end": 73,
        "startLoc": {
          "line": 62,
          "column": 2,
          "position": 1013
        },
        "endLoc": {
          "line": 73,
          "column": 7,
          "position": 1145
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/discriminated-unions.test.ts",
        "start": 111,
        "end": 122,
        "startLoc": {
          "line": 111,
          "column": 9,
          "position": 1844
        },
        "endLoc": {
          "line": 122,
          "column": 5,
          "position": 1976
        }
      }
    },
    {
      "format": "typescript",
      "lines": 15,
      "fragment": "await z\n      .discriminatedUnion(\"type\", [\n        z.object({\n          type: z.literal(\"a\"),\n          a: z\n            .string()\n            .refine(async () => true)\n            .transform(async (val) => Number(val)),\n        }),\n        z.object({\n          type: z.literal(\"b\"),\n          b: z.string(),\n        }),\n      ])\n      .",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/discriminated-unions.test.ts",
        "start": 150,
        "end": 164,
        "startLoc": {
          "line": 150,
          "column": 5,
          "position": 1965
        },
        "endLoc": {
          "line": 164,
          "column": 2,
          "position": 2087
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/discriminated-unions.test.ts",
        "start": 287,
        "end": 299,
        "startLoc": {
          "line": 287,
          "column": 2,
          "position": 2656
        },
        "endLoc": {
          "line": 299,
          "column": 2,
          "position": 2774
        }
      }
    },
    {
      "format": "typescript",
      "lines": 15,
      "fragment": "z\n      .discriminatedUnion(\"type\", [\n        z.object({\n          type: z.literal(\"a\"),\n          a: z\n            .string()\n            .refine(async () => true)\n            .transform(async (val) => val),\n        }),\n        z.object({\n          type: z.literal(\"b\"),\n          b: z.string(),\n        }),\n      ])\n      .",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/discriminated-unions.test.ts",
        "start": 170,
        "end": 184,
        "startLoc": {
          "line": 170,
          "column": 2,
          "position": 2155
        },
        "endLoc": {
          "line": 184,
          "column": 2,
          "position": 2272
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/discriminated-unions.test.ts",
        "start": 307,
        "end": 319,
        "startLoc": {
          "line": 307,
          "column": 2,
          "position": 2872
        },
        "endLoc": {
          "line": 319,
          "column": 2,
          "position": 2985
        }
      }
    },
    {
      "format": "typescript",
      "lines": 12,
      "fragment": ", () => {\n  const schema = z.discriminatedUnion(\"type\", [\n    z.object({\n      type: z.literal(\"foo\").default(\"foo\"),\n      a: z.string(),\n    }),\n    z.object({\n      type: z.literal(\"custom\"),\n      method: z.string(),\n    }),\n    z.object({\n      type: z.preprocess",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/discriminated-unions.test.ts",
        "start": 199,
        "end": 210,
        "startLoc": {
          "line": 199,
          "column": 48,
          "position": 2393
        },
        "endLoc": {
          "line": 210,
          "column": 11,
          "position": 2506
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/discriminated-unions.test.ts",
        "start": 346,
        "end": 357,
        "startLoc": {
          "line": 346,
          "column": 42,
          "position": 3070
        },
        "endLoc": {
          "line": 357,
          "column": 8,
          "position": 3183
        }
      }
    },
    {
      "format": "typescript",
      "lines": 32,
      "fragment": "),\n      c: z.string(),\n    }),\n  ]);\n  expect(schema.parse({ type: \"foo\", a: \"foo\" })).toEqual({\n    type: \"foo\",\n    a: \"foo\",\n  });\n});\n\ntest(\"enum and nativeEnum\", () => {\n  enum MyEnum {\n    d = 0,\n    e = \"e\",\n  }\n\n  const schema = z.discriminatedUnion(\"key\", [\n    z.object({\n      key: z.literal(\"a\"),\n      // Add other properties specific to this option\n    }),\n    z.object({\n      key: z.enum([\"b\", \"c\"]),\n      // Add other properties specific to this option\n    }),\n    z.object({\n      key: z.nativeEnum(MyEnum),\n      // Add other properties specific to this option\n    }),\n  ]);\n\n  // type schema = z.infer<typeof schema>;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/discriminated-unions.test.ts",
        "start": 210,
        "end": 241,
        "startLoc": {
          "line": 210,
          "column": 2,
          "position": 2526
        },
        "endLoc": {
          "line": 241,
          "column": 41,
          "position": 2750
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/discriminated-unions.test.ts",
        "start": 357,
        "end": 388,
        "startLoc": {
          "line": 357,
          "column": 4,
          "position": 3197
        },
        "endLoc": {
          "line": 388,
          "column": 5,
          "position": 3421
        }
      }
    },
    {
      "format": "typescript",
      "lines": 16,
      "fragment": "schema.parse({ key: \"a\" });\n  schema.parse({ key: \"b\" });\n  schema.parse({ key: \"c\" });\n  schema.parse({ key: MyEnum.d });\n  schema.parse({ key: MyEnum.e });\n  schema.parse({ key: \"e\" });\n});\n\ntest(\"branded\", () => {\n  const schema = z.discriminatedUnion(\"key\", [\n    z.object({\n      key: z.literal(\"a\"),\n      // Add other properties specific to this option\n    }),\n    z.object({\n      key: z.literal(\"b\").brand",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/discriminated-unions.test.ts",
        "start": 243,
        "end": 258,
        "startLoc": {
          "line": 243,
          "column": 3,
          "position": 2754
        },
        "endLoc": {
          "line": 258,
          "column": 6,
          "position": 2931
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/discriminated-unions.test.ts",
        "start": 391,
        "end": 406,
        "startLoc": {
          "line": 391,
          "column": 3,
          "position": 3496
        },
        "endLoc": {
          "line": 406,
          "column": 6,
          "position": 3673
        }
      }
    },
    {
      "format": "typescript",
      "lines": 22,
      "fragment": "schema.parse({ key: \"a\" });\n  schema.parse({ key: \"b\" });\n  expect(() => {\n    schema.parse({ key: \"c\" });\n  }).toThrow();\n});\n\ntest(\"optional and nullable\", () => {\n  const schema = z.discriminatedUnion(\"key\", [\n    z.object({\n      key: z.literal(\"a\").optional(),\n      a: z.literal(true),\n    }),\n    z.object({\n      key: z.literal(\"b\").nullable(),\n      b: z.literal(true),\n      // Add other properties specific to this option\n    }),\n  ]);\n\n  type schema = z.infer<typeof schema>;\n  z",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/discriminated-unions.test.ts",
        "start": 265,
        "end": 286,
        "startLoc": {
          "line": 265,
          "column": 3,
          "position": 2956
        },
        "endLoc": {
          "line": 286,
          "column": 2,
          "position": 3162
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/discriminated-unions.test.ts",
        "start": 414,
        "end": 435,
        "startLoc": {
          "line": 414,
          "column": 3,
          "position": 3759
        },
        "endLoc": {
          "line": 435,
          "column": 13,
          "position": 3965
        }
      }
    },
    {
      "format": "typescript",
      "lines": 23,
      "fragment": ");\n\n  schema.parse({ key: \"a\", a: true });\n  schema.parse({ key: undefined, a: true });\n  schema.parse({ key: \"b\", b: true });\n  schema.parse({ key: null, b: true });\n  expect(() => {\n    schema.parse({ key: null, a: true });\n  }).toThrow();\n  expect(() => {\n    schema.parse({ key: \"b\", a: true });\n  }).toThrow();\n\n  const value = schema.parse({ key: null, b: true });\n\n  if (!(\"key\" in value)) value.a;\n  if (value.key === undefined) value.a;\n  if (value.key === \"a\") value.a;\n  if (value.key === \"b\") value.b;\n  if (value.key === null) value.b;\n});\n\ntest(\"readonly array of options\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/discriminated-unions.test.ts",
        "start": 286,
        "end": 308,
        "startLoc": {
          "line": 286,
          "column": 5,
          "position": 3214
        },
        "endLoc": {
          "line": 308,
          "column": 28,
          "position": 3516
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/discriminated-unions.test.ts",
        "start": 435,
        "end": 457,
        "startLoc": {
          "line": 435,
          "column": 2,
          "position": 4016
        },
        "endLoc": {
          "line": 457,
          "column": 26,
          "position": 4318
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": ");\n  expect(outer.parse(undefined)).toEqual({ inner: \"asdf\" });\n  expect(outer.parse({})).toEqual({ inner: \"asdf\" });\n  expect(outer.parse({ inner: undefined })).toEqual({ inner: \"asdf\" });\n});\n\ntest(\"chained defaults\", () => {\n  const stringWithDefault = z.string().default(\"inner\").default(\"outer\");\n  const result = stringWithDefault.parse(undefined);\n  expect(result).toEqual(\"outer\");\n});\n\ntest(\"factory\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/default.test.ts",
        "start": 77,
        "end": 89,
        "startLoc": {
          "line": 77,
          "column": 5,
          "position": 902
        },
        "endLoc": {
          "line": 89,
          "column": 10,
          "position": 1060
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/catch.test.ts",
        "start": 108,
        "end": 103,
        "startLoc": {
          "line": 108,
          "column": 2,
          "position": 1398
        },
        "endLoc": {
          "line": 103,
          "column": 21,
          "position": 1181
        }
      }
    },
    {
      "format": "typescript",
      "lines": 29,
      "fragment": ";\n\nconst beforeBenchmarkDate = new Date(2022, 10, 4);\nconst benchmarkDate = new Date(2022, 10, 5);\nconst afterBenchmarkDate = new Date(2022, 10, 6);\n\nconst minCheck = z.date().min(benchmarkDate);\nconst maxCheck = z.date().max(benchmarkDate);\n\ntest(\"passing validations\", () => {\n  minCheck.parse(benchmarkDate);\n  minCheck.parse(afterBenchmarkDate);\n\n  maxCheck.parse(benchmarkDate);\n  maxCheck.parse(beforeBenchmarkDate);\n});\n\ntest(\"failing validations\", () => {\n  expect(() => minCheck.parse(beforeBenchmarkDate)).toThrow();\n  expect(() => maxCheck.parse(afterBenchmarkDate)).toThrow();\n});\n\ntest(\"min max getters\", () => {\n  expect(minCheck.minDate).toEqual(benchmarkDate);\n  expect(minCheck.min(afterBenchmarkDate).minDate).toEqual(afterBenchmarkDate);\n\n  expect(maxCheck.maxDate).toEqual(benchmarkDate);\n  expect(maxCheck.max(beforeBenchmarkDate).maxDate).toEqual(beforeBenchmarkDate);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/date.test.ts",
        "start": 4,
        "end": 32,
        "startLoc": {
          "line": 4,
          "column": 9,
          "position": 30
        },
        "endLoc": {
          "line": 32,
          "column": 2,
          "position": 325
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/date.test.ts",
        "start": 3,
        "end": 31,
        "startLoc": {
          "line": 3,
          "column": 9,
          "position": 28
        },
        "endLoc": {
          "line": 31,
          "column": 2,
          "position": 323
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": ";\n\ntest(\"passing validations\", () => {\n  const example1 = z.custom<number>((x) => typeof x === \"number\");\n  example1.parse(1234);\n  expect(() => example1.parse({})).toThrow();\n});\n\ntest(\"string params\", () => {\n  const example1 = z.custom<number>((x) => typeof x !== \"number\", \"customerr\");\n  const result = example1.safeParse(1234);\n  expect(result.success).toEqual(false);\n  // @ts-ignore",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/custom.test.ts",
        "start": 4,
        "end": 16,
        "startLoc": {
          "line": 4,
          "column": 9,
          "position": 30
        },
        "endLoc": {
          "line": 16,
          "column": 14,
          "position": 186
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/custom.test.ts",
        "start": 3,
        "end": 15,
        "startLoc": {
          "line": 3,
          "column": 9,
          "position": 28
        },
        "endLoc": {
          "line": 15,
          "column": 7,
          "position": 184
        }
      }
    },
    {
      "format": "typescript",
      "lines": 39,
      "fragment": ";\n\ntest(\"string coercion\", () => {\n  const schema = z.coerce.string();\n  expect(schema.parse(\"sup\")).toEqual(\"sup\");\n  expect(schema.parse(\"\")).toEqual(\"\");\n  expect(schema.parse(12)).toEqual(\"12\");\n  expect(schema.parse(0)).toEqual(\"0\");\n  expect(schema.parse(-12)).toEqual(\"-12\");\n  expect(schema.parse(3.14)).toEqual(\"3.14\");\n  expect(schema.parse(BigInt(15))).toEqual(\"15\");\n  expect(schema.parse(Number.NaN)).toEqual(\"NaN\");\n  expect(schema.parse(Number.POSITIVE_INFINITY)).toEqual(\"Infinity\");\n  expect(schema.parse(Number.NEGATIVE_INFINITY)).toEqual(\"-Infinity\");\n  expect(schema.parse(true)).toEqual(\"true\");\n  expect(schema.parse(false)).toEqual(\"false\");\n  expect(schema.parse(null)).toEqual(\"null\");\n  expect(schema.parse(undefined)).toEqual(\"undefined\");\n  expect(schema.parse({ hello: \"world!\" })).toEqual(\"[object Object]\");\n  expect(schema.parse([\"item\", \"another_item\"])).toEqual(\"item,another_item\");\n  expect(schema.parse([])).toEqual(\"\");\n  expect(schema.parse(new Date(\"2022-01-01T00:00:00.000Z\"))).toEqual(new Date(\"2022-01-01T00:00:00.000Z\").toString());\n});\n\ntest(\"number coercion\", () => {\n  const schema = z.coerce.number();\n  expect(schema.parse(\"12\")).toEqual(12);\n  expect(schema.parse(\"0\")).toEqual(0);\n  expect(schema.parse(\"-12\")).toEqual(-12);\n  expect(schema.parse(\"3.14\")).toEqual(3.14);\n  expect(schema.parse(\"\")).toEqual(0);\n  expect(() => schema.parse(\"NOT_A_NUMBER\")).toThrow(); // z.ZodError\n  expect(schema.parse(12)).toEqual(12);\n  expect(schema.parse(0)).toEqual(0);\n  expect(schema.parse(-12)).toEqual(-12);\n  expect(schema.parse(3.14)).toEqual(3.14);\n  expect(schema.parse(BigInt(15))).toEqual(15);\n  expect(() => schema.parse(Number.NaN)).toThrow(); // z.ZodError\n  expect",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/coerce.test.ts",
        "start": 4,
        "end": 42,
        "startLoc": {
          "line": 4,
          "column": 9,
          "position": 30
        },
        "endLoc": {
          "line": 42,
          "column": 7,
          "position": 662
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/coerce.test.ts",
        "start": 3,
        "end": 41,
        "startLoc": {
          "line": 3,
          "column": 9,
          "position": 31
        },
        "endLoc": {
          "line": 41,
          "column": 85,
          "position": 663
        }
      }
    },
    {
      "format": "typescript",
      "lines": 90,
      "fragment": "expect(schema.parse(true)).toEqual(1);\n  expect(schema.parse(false)).toEqual(0);\n  expect(schema.parse(null)).toEqual(0);\n  expect(() => schema.parse(undefined)).toThrow(); // z.ZodError\n  expect(() => schema.parse({ hello: \"world!\" })).toThrow(); // z.ZodError\n  expect(() => schema.parse([\"item\", \"another_item\"])).toThrow(); // z.ZodError\n  expect(schema.parse([])).toEqual(0);\n  expect(schema.parse(new Date(1670139203496))).toEqual(1670139203496);\n});\n\ntest(\"boolean coercion\", () => {\n  const schema = z.coerce.boolean();\n  expect(schema.parse(\"true\")).toEqual(true);\n  expect(schema.parse(\"false\")).toEqual(true);\n  expect(schema.parse(\"0\")).toEqual(true);\n  expect(schema.parse(\"1\")).toEqual(true);\n  expect(schema.parse(\"\")).toEqual(false);\n  expect(schema.parse(1)).toEqual(true);\n  expect(schema.parse(0)).toEqual(false);\n  expect(schema.parse(-1)).toEqual(true);\n  expect(schema.parse(3.14)).toEqual(true);\n  expect(schema.parse(BigInt(15))).toEqual(true);\n  expect(schema.parse(Number.NaN)).toEqual(false);\n  expect(schema.parse(Number.POSITIVE_INFINITY)).toEqual(true);\n  expect(schema.parse(Number.NEGATIVE_INFINITY)).toEqual(true);\n  expect(schema.parse(true)).toEqual(true);\n  expect(schema.parse(false)).toEqual(false);\n  expect(schema.parse(null)).toEqual(false);\n  expect(schema.parse(undefined)).toEqual(false);\n  expect(schema.parse({ hello: \"world!\" })).toEqual(true);\n  expect(schema.parse([\"item\", \"another_item\"])).toEqual(true);\n  expect(schema.parse([])).toEqual(true);\n  expect(schema.parse(new Date(1670139203496))).toEqual(true);\n});\n\ntest(\"bigint coercion\", () => {\n  const schema = z.coerce.bigint();\n  expect(schema.parse(\"5\")).toEqual(BigInt(5));\n  expect(schema.parse(\"0\")).toEqual(BigInt(0));\n  expect(schema.parse(\"-5\")).toEqual(BigInt(-5));\n  expect(() => schema.parse(\"3.14\")).toThrow(); // not a z.ZodError!\n  expect(schema.parse(\"\")).toEqual(BigInt(0));\n  expect(() => schema.parse(\"NOT_A_NUMBER\")).toThrow(); // not a z.ZodError!\n  expect(schema.parse(5)).toEqual(BigInt(5));\n  expect(schema.parse(0)).toEqual(BigInt(0));\n  expect(schema.parse(-5)).toEqual(BigInt(-5));\n  expect(() => schema.parse(3.14)).toThrow(); // not a z.ZodError!\n  expect(schema.parse(BigInt(5))).toEqual(BigInt(5));\n  expect(() => schema.parse(Number.NaN)).toThrow(); // not a z.ZodError!\n  expect(() => schema.parse(Number.POSITIVE_INFINITY)).toThrow(); // not a z.ZodError!\n  expect(() => schema.parse(Number.NEGATIVE_INFINITY)).toThrow(); // not a z.ZodError!\n  expect(schema.parse(true)).toEqual(BigInt(1));\n  expect(schema.parse(false)).toEqual(BigInt(0));\n  expect(() => schema.parse(null)).toThrow(); // not a z.ZodError!\n  expect(() => schema.parse(undefined)).toThrow(); // not a z.ZodError!\n  expect(() => schema.parse({ hello: \"world!\" })).toThrow(); // not a z.ZodError!\n  expect(() => schema.parse([\"item\", \"another_item\"])).toThrow(); // not a z.ZodError!\n  expect(schema.parse([])).toEqual(BigInt(0));\n  expect(schema.parse(new Date(1670139203496))).toEqual(BigInt(1670139203496));\n});\n\ntest(\"date coercion\", () => {\n  const schema = z.coerce.date();\n  expect(schema.parse(new Date().toDateString())).toBeInstanceOf(Date);\n  expect(schema.parse(new Date().toISOString())).toBeInstanceOf(Date);\n  expect(schema.parse(new Date().toUTCString())).toBeInstanceOf(Date);\n  expect(schema.parse(\"5\")).toBeInstanceOf(Date);\n  expect(schema.parse(\"2000-01-01\")).toBeInstanceOf(Date);\n  // expect(schema.parse(\"0\")).toBeInstanceOf(Date);\n  // expect(schema.parse(\"-5\")).toBeInstanceOf(Date);\n  // expect(schema.parse(\"3.14\")).toBeInstanceOf(Date);\n  expect(() => schema.parse(\"\")).toThrow(); // z.ZodError\n  expect(() => schema.parse(\"NOT_A_DATE\")).toThrow(); // z.ZodError\n  expect(schema.parse(5)).toBeInstanceOf(Date);\n  expect(schema.parse(0)).toBeInstanceOf(Date);\n  expect(schema.parse(-5)).toBeInstanceOf(Date);\n  expect(schema.parse(3.14)).toBeInstanceOf(Date);\n  expect(() => schema.parse(BigInt(5))).toThrow(); // not a z.ZodError!\n  expect(() => schema.parse(Number.NaN)).toThrow(); // z.ZodError\n  expect(() => schema.parse(Number.POSITIVE_INFINITY)).toThrow(); // z.ZodError\n  expect(() => schema.parse(Number.NEGATIVE_INFINITY)).toThrow(); // z.ZodError\n  expect(schema.parse(true)).toBeInstanceOf(Date);\n  expect(schema.parse(false)).toBeInstanceOf(Date);\n  expect(schema.parse(null)).toBeInstanceOf(Date);\n  expect(() => schema.parse(undefined)).toThrow(); // z.ZodError\n  expect(() => schema.parse({ hello: \"world!\" })).toThrow(); // z.ZodError\n  expect(() => schema.parse([\"item\", \"another_item\"])).toThrow(); // z.ZodError\n  expect(() => schema.parse([])).toThrow(); // z.ZodError\n  expect(schema.parse(new Date())).toBeInstanceOf(Date);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/coerce.test.ts",
        "start": 44,
        "end": 133,
        "startLoc": {
          "line": 44,
          "column": 3,
          "position": 704
        },
        "endLoc": {
          "line": 133,
          "column": 2,
          "position": 2372
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/coerce.test.ts",
        "start": 43,
        "end": 132,
        "startLoc": {
          "line": 43,
          "column": 3,
          "position": 669
        },
        "endLoc": {
          "line": 132,
          "column": 2,
          "position": 2337
        }
      }
    },
    {
      "format": "typescript",
      "lines": 40,
      "fragment": ";\n\ntest(\"basic catch\", () => {\n  expect(z.string().catch(\"default\").parse(undefined)).toBe(\"default\");\n});\n\ntest(\"catch fn does not run when parsing succeeds\", () => {\n  let isCalled = false;\n  const cb = () => {\n    isCalled = true;\n    return \"asdf\";\n  };\n  expect(z.string().catch(cb).parse(\"test\")).toBe(\"test\");\n  expect(isCalled).toEqual(false);\n});\n\ntest(\"basic catch async\", async () => {\n  const result = await z.string().catch(\"default\").parseAsync(1243);\n  expect(result).toBe(\"default\");\n});\n\ntest(\"catch replace wrong types\", () => {\n  expect(z.string().catch(\"default\").parse(true)).toBe(\"default\");\n  expect(z.string().catch(\"default\").parse(true)).toBe(\"default\");\n  expect(z.string().catch(\"default\").parse(15)).toBe(\"default\");\n  expect(z.string().catch(\"default\").parse([])).toBe(\"default\");\n  expect(z.string().catch(\"default\").parse(new Map())).toBe(\"default\");\n  expect(z.string().catch(\"default\").parse(new Set())).toBe(\"default\");\n  expect(z.string().catch(\"default\").parse({})).toBe(\"default\");\n});\n\ntest(\"catch with transform\", () => {\n  const stringWithDefault = z\n    .string()\n    .transform((val) => val.toUpperCase())\n    .catch(\"default\");\n  expect(stringWithDefault.parse(undefined)).toBe(\"default\");\n  expect(stringWithDefault.parse(15)).toBe(\"default\");\n  expect(stringWithDefault).toBeInstanceOf(z.ZodCatch);\n  expect(stringWithDefault._def",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/catch.test.ts",
        "start": 5,
        "end": 44,
        "startLoc": {
          "line": 5,
          "column": 21,
          "position": 43
        },
        "endLoc": {
          "line": 44,
          "column": 5,
          "position": 557
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/catch.test.ts",
        "start": 3,
        "end": 43,
        "startLoc": {
          "line": 3,
          "column": 14,
          "position": 45
        },
        "endLoc": {
          "line": 43,
          "column": 7,
          "position": 560
        }
      }
    },
    {
      "format": "typescript",
      "lines": 11,
      "fragment": "()\n    .optional()\n    .catch(\"asdfasdf\");\n\n  expect(complex.parse(\"qwer\")).toBe(\"QWER!\");\n  expect(complex.parse(15)).toBe(\"ASDF!\");\n  expect(complex.parse(true)).toBe(\"ASDF!\");\n});\n\ntest(\"removeCatch\", () => {\n  const stringWithRemovedDefault = z.string().catch(\"asdf\").removeCatch",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/catch.test.ts",
        "start": 83,
        "end": 93,
        "startLoc": {
          "line": 83,
          "column": 12,
          "position": 1046
        },
        "endLoc": {
          "line": 93,
          "column": 12,
          "position": 1150
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/catch.test.ts",
        "start": 83,
        "end": 93,
        "startLoc": {
          "line": 83,
          "column": 7,
          "position": 1095
        },
        "endLoc": {
          "line": 93,
          "column": 7,
          "position": 1199
        }
      }
    },
    {
      "format": "typescript",
      "lines": 17,
      "fragment": ">(true);\n  type out = z.output<typeof outer>;\n  util.assertEqual<out, { inner: string }>(true);\n  expect(outer.parse(undefined)).toEqual({ inner: \"asdf\" });\n  expect(outer.parse({})).toEqual({ inner: \"asdf\" });\n  expect(outer.parse({ inner: undefined })).toEqual({ inner: \"asdf\" });\n});\n\ntest(\"chained catch\", () => {\n  const stringWithDefault = z.string().catch(\"inner\").catch(\"outer\");\n  const result = stringWithDefault.parse(undefined);\n  expect(result).toEqual(\"inner\");\n  const resultDiff = stringWithDefault.parse(5);\n  expect(resultDiff).toEqual(\"inner\");\n});\n\ntest(\"factory\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/catch.test.ts",
        "start": 105,
        "end": 121,
        "startLoc": {
          "line": 105,
          "column": 8,
          "position": 1284
        },
        "endLoc": {
          "line": 121,
          "column": 10,
          "position": 1511
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/default.test.ts",
        "start": 75,
        "end": 122,
        "startLoc": {
          "line": 75,
          "column": 10,
          "position": 860
        },
        "endLoc": {
          "line": 122,
          "column": 14,
          "position": 1583
        }
      }
    },
    {
      "format": "typescript",
      "lines": 59,
      "fragment": ");\n});\n\ntest(\"native enum\", () => {\n  enum Fruits {\n    apple = \"apple\",\n    orange = \"orange\",\n  }\n\n  const schema = z.object({\n    fruit: z.nativeEnum(Fruits).catch(Fruits.apple),\n  });\n\n  expect(schema.parse({})).toEqual({ fruit: Fruits.apple });\n  expect(schema.parse({ fruit: 15 })).toEqual({ fruit: Fruits.apple });\n});\n\ntest(\"enum\", () => {\n  const schema = z.object({\n    fruit: z.enum([\"apple\", \"orange\"]).catch(\"apple\"),\n  });\n\n  expect(schema.parse({})).toEqual({ fruit: \"apple\" });\n  expect(schema.parse({ fruit: true })).toEqual({ fruit: \"apple\" });\n  expect(schema.parse({ fruit: 15 })).toEqual({ fruit: \"apple\" });\n});\n\ntest(\"reported issues with nested usage\", () => {\n  const schema = z.object({\n    string: z.string(),\n    obj: z.object({\n      sub: z.object({\n        lit: z.literal(\"a\"),\n        subCatch: z.number().catch(23),\n      }),\n      midCatch: z.number().catch(42),\n    }),\n    number: z.number().catch(0),\n    bool: z.boolean(),\n  });\n\n  try {\n    schema.parse({\n      string: {},\n      obj: {\n        sub: {\n          lit: \"b\",\n          subCatch: \"24\",\n        },\n        midCatch: 444,\n      },\n      number: \"\",\n      bool: \"yes\",\n    });\n  } catch (error) {\n    const issues = (error as z.ZodError).issues;\n\n    expect(issues.length).toEqual(3);\n    expect(issues[",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/catch.test.ts",
        "start": 124,
        "end": 182,
        "startLoc": {
          "line": 124,
          "column": 10,
          "position": 1551
        },
        "endLoc": {
          "line": 182,
          "column": 2,
          "position": 2119
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/catch.test.ts",
        "start": 119,
        "end": 177,
        "startLoc": {
          "line": 119,
          "column": 8,
          "position": 1573
        },
        "endLoc": {
          "line": 177,
          "column": 2,
          "position": 2141
        }
      }
    },
    {
      "format": "typescript",
      "lines": 52,
      "fragment": ";\n\nconst gtFive = z.bigint().gt(BigInt(5));\nconst gteFive = z.bigint().gte(BigInt(5));\nconst ltFive = z.bigint().lt(BigInt(5));\nconst lteFive = z.bigint().lte(BigInt(5));\nconst positive = z.bigint().positive();\nconst negative = z.bigint().negative();\nconst nonnegative = z.bigint().nonnegative();\nconst nonpositive = z.bigint().nonpositive();\nconst multipleOfFive = z.bigint().multipleOf(BigInt(5));\n\ntest(\"passing validations\", () => {\n  z.bigint().parse(BigInt(1));\n  z.bigint().parse(BigInt(0));\n  z.bigint().parse(BigInt(-1));\n  gtFive.parse(BigInt(6));\n  gteFive.parse(BigInt(5));\n  gteFive.parse(BigInt(6));\n  ltFive.parse(BigInt(4));\n  lteFive.parse(BigInt(5));\n  lteFive.parse(BigInt(4));\n  positive.parse(BigInt(3));\n  negative.parse(BigInt(-2));\n  nonnegative.parse(BigInt(0));\n  nonnegative.parse(BigInt(7));\n  nonpositive.parse(BigInt(0));\n  nonpositive.parse(BigInt(-12));\n  multipleOfFive.parse(BigInt(15));\n});\n\ntest(\"failing validations\", () => {\n  expect(() => gtFive.parse(BigInt(5))).toThrow();\n  expect(() => gteFive.parse(BigInt(4))).toThrow();\n  expect(() => ltFive.parse(BigInt(5))).toThrow();\n  expect(() => lteFive.parse(BigInt(6))).toThrow();\n  expect(() => positive.parse(BigInt(0))).toThrow();\n  expect(() => positive.parse(BigInt(-2))).toThrow();\n  expect(() => negative.parse(BigInt(0))).toThrow();\n  expect(() => negative.parse(BigInt(3))).toThrow();\n  expect(() => nonnegative.parse(BigInt(-1))).toThrow();\n  expect(() => nonpositive.parse(BigInt(1))).toThrow();\n  expect(() => multipleOfFive.parse(BigInt(13))).toThrow();\n});\n\ntest(\"min max getters\", () => {\n  expect(z.bigint().min(BigInt(5)).minValue).toEqual(BigInt(5));\n  expect(z.bigint().min(BigInt(5)).min(BigInt(10)).minValue).toEqual(BigInt(10));\n\n  expect(z.bigint().max(BigInt(5)).maxValue).toEqual(BigInt(5));\n  expect(z.bigint().max(BigInt(5)).max(BigInt(1)).maxValue).toEqual(BigInt(1));\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/bigint.test.ts",
        "start": 4,
        "end": 55,
        "startLoc": {
          "line": 4,
          "column": 9,
          "position": 30
        },
        "endLoc": {
          "line": 55,
          "column": 2,
          "position": 861
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/bigint.test.ts",
        "start": 3,
        "end": 54,
        "startLoc": {
          "line": 3,
          "column": 9,
          "position": 28
        },
        "endLoc": {
          "line": 54,
          "column": 2,
          "position": 859
        }
      }
    },
    {
      "format": "typescript",
      "lines": 16,
      "fragment": ", async () => {\n  // expect.assertions(2);\n\n  const schema1 = z.string().refine((_val) => Promise.resolve(true));\n  const v1 = await schema1.parseAsync(\"asdf\");\n  expect(v1).toEqual(\"asdf\");\n\n  const schema2 = z.string().refine((_val) => Promise.resolve(false));\n  await expect(schema2.parseAsync(\"asdf\")).rejects.toBeDefined();\n\n  const schema3 = z.string().refine((_val) => Promise.resolve(true));\n  await expect(schema3.parseAsync(\"asdf\")).resolves.toEqual(\"asdf\");\n  return await expect(schema3.parseAsync(\"qwer\")).resolves.toEqual(\"qwer\");\n});\n\ntest(\"parseAsync async with value\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/async-refinements.test.ts",
        "start": 23,
        "end": 38,
        "startLoc": {
          "line": 23,
          "column": 24,
          "position": 269
        },
        "endLoc": {
          "line": 38,
          "column": 30,
          "position": 476
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/async-refinements.test.ts",
        "start": 33,
        "end": 48,
        "startLoc": {
          "line": 33,
          "column": 29,
          "position": 250
        },
        "endLoc": {
          "line": 48,
          "column": 31,
          "position": 457
        }
      }
    },
    {
      "format": "typescript",
      "lines": 200,
      "fragment": ";\n\n/// string\nconst stringSchema = z.string();\n\ntest(\"string async parse\", async () => {\n  const goodData = \"XXX\";\n  const badData = 12;\n\n  const goodResult = await stringSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await stringSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// number\nconst numberSchema = z.number();\ntest(\"number async parse\", async () => {\n  const goodData = 1234.2353;\n  const badData = \"1234\";\n\n  const goodResult = await numberSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await numberSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// bigInt\nconst bigIntSchema = z.bigint();\ntest(\"bigInt async parse\", async () => {\n  const goodData = BigInt(145);\n  const badData = 134;\n\n  const goodResult = await bigIntSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await bigIntSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// boolean\nconst booleanSchema = z.boolean();\ntest(\"boolean async parse\", async () => {\n  const goodData = true;\n  const badData = 1;\n\n  const goodResult = await booleanSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await booleanSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// date\nconst dateSchema = z.date();\ntest(\"date async parse\", async () => {\n  const goodData = new Date();\n  const badData = new Date().toISOString();\n\n  const goodResult = await dateSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await dateSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// undefined\nconst undefinedSchema = z.undefined();\ntest(\"undefined async parse\", async () => {\n  const goodData = undefined;\n  const badData = \"XXX\";\n\n  const goodResult = await undefinedSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(undefined);\n\n  const badResult = await undefinedSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// null\nconst nullSchema = z.null();\ntest(\"null async parse\", async () => {\n  const goodData = null;\n  const badData = undefined;\n\n  const goodResult = await nullSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await nullSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// any\nconst anySchema = z.any();\ntest(\"any async parse\", async () => {\n  const goodData = [{}];\n  // const badData = 'XXX';\n\n  const goodResult = await anySchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  // const badResult = await anySchema.safeParseAsync(badData);\n  // expect(badResult.success).toBe(false);\n  // if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// unknown\nconst unknownSchema = z.unknown();\ntest(\"unknown async parse\", async () => {\n  const goodData = [\"asdf\", 124, () => {}];\n  // const badData = 'XXX';\n\n  const goodResult = await unknownSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  // const badResult = await unknownSchema.safeParseAsync(badData);\n  // expect(badResult.success).toBe(false);\n  // if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// void\nconst voidSchema = z.void();\ntest(\"void async parse\", async () => {\n  const goodData = undefined;\n  const badData = 0;\n\n  const goodResult = await voidSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await voidSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// array\nconst arraySchema = z.array(z.string());\ntest(\"array async parse\", async () => {\n  const goodData = [\"XXX\"];\n  const badData = \"XXX\";\n\n  const goodResult = await arraySchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await arraySchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// object\nconst objectSchema = z.object({ string: z.string() });\ntest(\"object async parse\", async () => {\n  const goodData = { string: \"XXX\" };\n  const badData = { string: 12 };\n\n  const goodResult = await objectSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await objectSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// union\nconst unionSchema = z.union([z.string(), z.undefined()]);\ntest(\"union async parse\", async () => {\n  const goodData = undefined;\n  const badData = null;\n\n  const goodResult = await unionSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await unionSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// record\nconst recordSchema = z.record(z.object",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/async-parsing.test.ts",
        "start": 4,
        "end": 203,
        "startLoc": {
          "line": 4,
          "column": 9,
          "position": 30
        },
        "endLoc": {
          "line": 203,
          "column": 7,
          "position": 2164
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/async-parsing.test.ts",
        "start": 3,
        "end": 202,
        "startLoc": {
          "line": 3,
          "column": 9,
          "position": 28
        },
        "endLoc": {
          "line": 202,
          "column": 7,
          "position": 2162
        }
      }
    },
    {
      "format": "typescript",
      "lines": 16,
      "fragment": "z.object({}));\ntest(\"record async parse\", async () => {\n  const goodData = { adsf: {}, asdf: {} };\n  const badData = [{}];\n\n  const goodResult = await recordSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await recordSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// function\nconst",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/async-parsing.test.ts",
        "start": 203,
        "end": 218,
        "startLoc": {
          "line": 203,
          "column": 2,
          "position": 2162
        },
        "endLoc": {
          "line": 218,
          "column": 6,
          "position": 2342
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/async-parsing.test.ts",
        "start": 202,
        "end": 217,
        "startLoc": {
          "line": 202,
          "column": 2,
          "position": 2167
        },
        "endLoc": {
          "line": 217,
          "column": 40,
          "position": 2347
        }
      }
    },
    {
      "format": "typescript",
      "lines": 57,
      "fragment": "/// literal\nconst literalSchema = z.literal(\"asdf\");\ntest(\"literal async parse\", async () => {\n  const goodData = \"asdf\";\n  const badData = \"asdff\";\n\n  const goodResult = await literalSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await literalSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// enum\nconst enumSchema = z.enum([\"fish\", \"whale\"]);\ntest(\"enum async parse\", async () => {\n  const goodData = \"whale\";\n  const badData = \"leopard\";\n\n  const goodResult = await enumSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await enumSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// nativeEnum\nenum nativeEnumTest {\n  asdf = \"qwer\",\n}\n// @ts-ignore\nconst nativeEnumSchema = z.nativeEnum(nativeEnumTest);\ntest(\"nativeEnum async parse\", async () => {\n  const goodData = nativeEnumTest.asdf;\n  const badData = \"asdf\";\n\n  const goodResult = await nativeEnumSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await nativeEnumSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// promise\nconst promiseSchema = z.promise(z.number());\ntest(\"promise async parse good\", async () => {\n  const goodData = Promise.resolve(123);\n\n  const goodResult = await promiseSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/async-parsing.test.ts",
        "start": 232,
        "end": 288,
        "startLoc": {
          "line": 232,
          "column": 1,
          "position": 2513
        },
        "endLoc": {
          "line": 288,
          "column": 3,
          "position": 3118
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/async-parsing.test.ts",
        "start": 231,
        "end": 287,
        "startLoc": {
          "line": 231,
          "column": 1,
          "position": 2372
        },
        "endLoc": {
          "line": 287,
          "column": 7,
          "position": 2977
        }
      }
    },
    {
      "format": "typescript",
      "lines": 15,
      "fragment": "});\n\ntest(\"async validation non-empty strings\", async () => {\n  const base = z.object({\n    hello: z.string().refine((x) => x && x.length > 0),\n    foo: z.string().refine((x) => x && x.length > 0),\n  });\n\n  const testval = { hello: \"\", foo: \"\" };\n  const result1 = base.safeParse(testval);\n  const result2 = base.safeParseAsync(testval);\n\n  const r1 = result1;\n  await result2.then((r2) => {\n    if",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/async-parsing.test.ts",
        "start": 308,
        "end": 322,
        "startLoc": {
          "line": 308,
          "column": 1,
          "position": 3312
        },
        "endLoc": {
          "line": 322,
          "column": 3,
          "position": 3494
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/async-parsing.test.ts",
        "start": 296,
        "end": 310,
        "startLoc": {
          "line": 296,
          "column": 1,
          "position": 3087
        },
        "endLoc": {
          "line": 310,
          "column": 7,
          "position": 3269
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": "});\n});\n\ntest(\"async validation multiple errors 1\", async () => {\n  const base = z.object({\n    hello: z.string(),\n    foo: z.number(),\n  });\n\n  const testval = { hello: 3, foo: \"hello\" };\n  const result1 = base.safeParse(testval);\n  const result2 = base.safeParseAsync(testval);\n\n  const",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/async-parsing.test.ts",
        "start": 323,
        "end": 336,
        "startLoc": {
          "line": 323,
          "column": 3,
          "position": 3542
        },
        "endLoc": {
          "line": 336,
          "column": 6,
          "position": 3661
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/async-parsing.test.ts",
        "start": 311,
        "end": 324,
        "startLoc": {
          "line": 311,
          "column": 3,
          "position": 3295
        },
        "endLoc": {
          "line": 324,
          "column": 6,
          "position": 3414
        }
      }
    },
    {
      "format": "typescript",
      "lines": 32,
      "fragment": ".issues.length);\n  });\n});\n\ntest(\"ensure early async failure prevents follow-up refinement checks\", async () => {\n  let count = 0;\n  const base = z.object({\n    hello: z.string(),\n    foo: z\n      .number()\n      .refine(async () => {\n        count++;\n        return true;\n      })\n      .refine(async () => {\n        count++;\n        return true;\n      }, \"Good\"),\n  });\n\n  const testval = { hello: \"bye\", foo: 3 };\n  const result = await base.safeParseAsync(testval);\n  if (result.success === false) {\n    expect(result.error.issues.length).toBe(1);\n    expect(count).toBe(1);\n  }\n\n  // await result.then((r) => {\n  //   if (r.success === false) expect(r.error.issues.length).toBe(1);\n  //   expect(count).toBe(2);\n  // });\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/async-parsing.test.ts",
        "start": 357,
        "end": 388,
        "startLoc": {
          "line": 357,
          "column": 6,
          "position": 3977
        },
        "endLoc": {
          "line": 388,
          "column": 2,
          "position": 4223
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/async-parsing.test.ts",
        "start": 350,
        "end": 381,
        "startLoc": {
          "line": 350,
          "column": 2,
          "position": 3709
        },
        "endLoc": {
          "line": 381,
          "column": 2,
          "position": 3955
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ".parse([\"a\", \"a\", \"a\"])).toThrow();\n});\n\ntest(\"parse empty array in nonempty\", () => {\n  expect(() =>\n    z\n      .array(z.string())\n      .nonempty()\n      .parse([] as any)\n  ).toThrow();\n});\n\ntest(\"get element\", () => {\n  justTwo",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/array.test.ts",
        "start": 36,
        "end": 49,
        "startLoc": {
          "line": 36,
          "column": 12,
          "position": 510
        },
        "endLoc": {
          "line": 49,
          "column": 8,
          "position": 613
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/array.test.ts",
        "start": 89,
        "end": 102,
        "startLoc": {
          "line": 89,
          "column": 7,
          "position": 565
        },
        "endLoc": {
          "line": 102,
          "column": 6,
          "position": 668
        }
      }
    },
    {
      "format": "typescript",
      "lines": 12,
      "fragment": ".element.parse(12)).toThrow();\n});\n\ntest(\"continue parsing despite array size error\", () => {\n  const schema = z.object({\n    people: z.string().array().min(2),\n  });\n\n  const result = schema.safeParse({\n    people: [123],\n  });\n  expect(result.",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/array.test.ts",
        "start": 50,
        "end": 61,
        "startLoc": {
          "line": 50,
          "column": 8,
          "position": 632
        },
        "endLoc": {
          "line": 61,
          "column": 2,
          "position": 733
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/array.test.ts",
        "start": 104,
        "end": 115,
        "startLoc": {
          "line": 104,
          "column": 7,
          "position": 705
        },
        "endLoc": {
          "line": 115,
          "column": 2,
          "position": 806
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\nconst Test = z.object({\n  f1: z.number(),\n  f2: z.string().optional(),\n  f3: z.string().nullable(),\n  f4: z.array(z.object({ t: z.union([z.string(), z.boolean()]) })),\n});\ntype",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/all-errors.test.ts",
        "start": 1,
        "end": 13,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 13,
          "column": 5,
          "position": 145
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/object.test.ts",
        "start": 1,
        "end": 12,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 12,
          "column": 5,
          "position": 146
        }
      }
    },
    {
      "format": "typescript",
      "lines": 18,
      "fragment": ";\n});\n\ntest(\"all errors\", () => {\n  const propertySchema = z.string();\n  const schema = z\n    .object({\n      a: propertySchema,\n      b: propertySchema,\n    })\n    .refine(\n      (val) => {\n        return val.a === val.b;\n      },\n      { message: \"Must be equal\" }\n    );\n\n  try",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/all-errors.test.ts",
        "start": 70,
        "end": 87,
        "startLoc": {
          "line": 70,
          "column": 2,
          "position": 884
        },
        "endLoc": {
          "line": 87,
          "column": 4,
          "position": 998
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/error-utils.test.ts",
        "start": 208,
        "end": 225,
        "startLoc": {
          "line": 208,
          "column": 2,
          "position": 908
        },
        "endLoc": {
          "line": 225,
          "column": 6,
          "position": 1022
        }
      }
    },
    {
      "format": "typescript",
      "lines": 28,
      "fragment": ");\n\nconst aSchema = z.object({\n  type: z.literal(\"a\"),\n});\nconst objA = {\n  type: \"a\",\n};\n\nconst bSchema = z.object({\n  type: z.literal(\"b\"),\n});\nconst objB = {\n  type: \"b\",\n};\n\nconst cSchema = z.object({\n  type: z.literal(\"c\"),\n});\nconst objC = {\n  type: \"c\",\n};\n\nconst dSchema = z.object({\n  type: z.literal(\"d\"),\n});\n\nconst double = z.discriminatedUnion",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/benchmarks/discriminatedUnion.ts",
        "start": 6,
        "end": 33,
        "startLoc": {
          "line": 6,
          "column": 29,
          "position": 53
        },
        "endLoc": {
          "line": 33,
          "column": 19,
          "position": 235
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/benchmarks/union.ts",
        "start": 6,
        "end": 33,
        "startLoc": {
          "line": 6,
          "column": 16,
          "position": 53
        },
        "endLoc": {
          "line": 33,
          "column": 6,
          "position": 235
        }
      }
    },
    {
      "format": "typescript",
      "lines": 47,
      "fragment": "[aSchema, bSchema, cSchema, dSchema]);\n\ndoubleSuite\n  .add(\"valid: a\", () => {\n    double.parse(objA);\n  })\n  .add(\"valid: b\", () => {\n    double.parse(objB);\n  })\n  .add(\"invalid: null\", () => {\n    try {\n      double.parse(null);\n    } catch (_err) {}\n  })\n  .add(\"invalid: wrong shape\", () => {\n    try {\n      double.parse(objC);\n    } catch (_err) {}\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`${(doubleSuite as any).name}: ${e.target}`);\n  });\n\nmanySuite\n  .add(\"valid: a\", () => {\n    many.parse(objA);\n  })\n  .add(\"valid: c\", () => {\n    many.parse(objC);\n  })\n  .add(\"invalid: null\", () => {\n    try {\n      many.parse(null);\n    } catch (_err) {}\n  })\n  .add(\"invalid: wrong shape\", () => {\n    try {\n      many.parse({ type: \"unknown\" });\n    } catch (_err) {}\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`${(manySuite as any).name}: ${e.target}`);\n  });\n\nexport default {\n  suites: [doubleSuite, manySuite],\n};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/benchmarks/discriminatedUnion.ts",
        "start": 34,
        "end": 80,
        "startLoc": {
          "line": 34,
          "column": 2,
          "position": 262
        },
        "endLoc": {
          "line": 80,
          "column": 2,
          "position": 694
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/benchmarks/union.ts",
        "start": 34,
        "end": 80,
        "startLoc": {
          "line": 34,
          "column": 2,
          "position": 256
        },
        "endLoc": {
          "line": 80,
          "column": 2,
          "position": 688
        }
      }
    },
    {
      "format": "typescript",
      "lines": 35,
      "fragment": "import { MessagePort } from 'node:worker_threads';\nimport { R as RequiredProperty } from '../../types-Cxp8y2TL.js';\n\ntype ScopedImport = (specifier: string, parent: string) => Promise<any>;\n\ntype TsconfigOptions = false | string;\ntype InitializationOptions = {\n    namespace?: string;\n    port?: MessagePort;\n    tsconfig?: TsconfigOptions;\n};\ntype RegisterOptions = {\n    namespace?: string;\n    onImport?: (url: string) => void;\n    tsconfig?: TsconfigOptions;\n};\ntype Unregister = () => Promise<void>;\ntype NamespacedUnregister = Unregister & {\n    import: ScopedImport;\n    unregister: Unregister;\n};\ntype Register = {\n    (options: RequiredProperty<RegisterOptions, 'namespace'>): NamespacedUnregister;\n    (options?: RegisterOptions): Unregister;\n};\ndeclare const register: Register;\n\ntype Options = {\n    parentURL: string;\n    onImport?: (url: string) => void;\n    tsconfig?: TsconfigOptions;\n};\ndeclare const tsImport: (specifier: string, options: string | Options) => Promise<any>;\n\nexport { type InitializationOptions, type NamespacedUnregister, type Register, type RegisterOptions, type ScopedImport, type Unregister, register, tsImport };",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/tsx/dist/esm/api/index.d.cts",
        "start": 1,
        "end": 35,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 35,
          "column": 2,
          "position": 366
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/tsx/dist/esm/api/index.d.mts",
        "start": 1,
        "end": 35,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 35,
          "column": 2,
          "position": 366
        }
      }
    },
    {
      "format": "typescript",
      "lines": 35,
      "fragment": "import { R as RequiredProperty } from '../../types-Cxp8y2TL.js';\n\ntype RegisterOptions = {\n    namespace?: string;\n};\ntype Unregister = () => void;\ntype ScopedRequire = (id: string, fromFile: string | URL) => any;\ntype ScopedResolve = (id: string, fromFile: string | URL, resolveOptions?: {\n    paths?: string[] | undefined;\n}) => string;\ntype NamespacedUnregister = Unregister & {\n    require: ScopedRequire;\n    resolve: ScopedResolve;\n    unregister: Unregister;\n};\ntype Register = {\n    (options: RequiredProperty<RegisterOptions, 'namespace'>): NamespacedUnregister;\n    (options?: RegisterOptions): Unregister;\n};\ndeclare const register: Register;\n\ndeclare const tsxRequire: {\n    (id: string, fromFile: string | URL): any;\n    resolve: {\n        (id: string, fromFile: string | URL, options?: {\n            paths?: string[] | undefined;\n        }): string;\n        paths: (request: string) => string[] | null;\n    };\n    main: NodeJS.Module | undefined;\n    extensions: NodeJS.RequireExtensions;\n    cache: NodeJS.Dict<NodeJS.Module>;\n};\n\nexport { register, tsxRequire as require };",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/tsx/dist/cjs/api/index.d.cts",
        "start": 1,
        "end": 35,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 35,
          "column": 2,
          "position": 382
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/tsx/dist/cjs/api/index.d.mts",
        "start": 1,
        "end": 35,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 35,
          "column": 2,
          "position": 382
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": ",\n    content,\n    core,\n    with$data(this, format),\n    metadata,\n    with$data(this, validation),\n  ].forEach((sch) => this.addMetaSchema(sch, undefined, false))\n  return this\n\n  function with$data(ajv: Ajv, sch: AnySchemaObject): AnySchemaObject {\n    return $data ? ajv.$dataMetaSchema(sch, META_SUPPORT_DATA) : sch\n  }\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/ajv/lib/refs/json-schema-2019-09/index.ts",
        "start": 16,
        "end": 28,
        "startLoc": {
          "line": 16,
          "column": 11,
          "position": 154
        },
        "endLoc": {
          "line": 28,
          "column": 2,
          "position": 268
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/ajv/lib/refs/json-schema-2020-12/index.ts",
        "start": 18,
        "end": 30,
        "startLoc": {
          "line": 18,
          "column": 12,
          "position": 170
        },
        "endLoc": {
          "line": 30,
          "column": 2,
          "position": 284
        }
      }
    },
    {
      "format": "typescript",
      "lines": 11,
      "fragment": "(\n  this: Ajv,\n  sch: SchemaEnv,\n  definitions: SchemaObjectMap\n): SchemaEnv {\n  const _sch = getCompilingSchema.call(this, sch)\n  if (_sch) return _sch\n  const {es5, lines} = this.opts.code\n  const {ownProperties} = this.opts\n  const gen = new CodeGen(this.scope, {es5, lines, ownProperties})\n  const parseName",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/ajv/lib/compile/jtd/parse.ts",
        "start": 39,
        "end": 49,
        "startLoc": {
          "line": 39,
          "column": 14,
          "position": 345
        },
        "endLoc": {
          "line": 49,
          "column": 10,
          "position": 463
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/ajv/lib/compile/jtd/serialize.ts",
        "start": 33,
        "end": 43,
        "startLoc": {
          "line": 33,
          "column": 18,
          "position": 286
        },
        "endLoc": {
          "line": 43,
          "column": 14,
          "position": 404
        }
      }
    },
    {
      "format": "typescript",
      "lines": 355,
      "fragment": ";\ntype SomeType = core.SomeType;\nexport interface ZodMiniType<out Output = unknown, out Input = unknown, out Internals extends core.$ZodTypeInternals<Output, Input> = core.$ZodTypeInternals<Output, Input>> extends core.$ZodType<Output, Input, Internals> {\n    check(...checks: (core.CheckFn<core.output<this>> | core.$ZodCheck<core.output<this>>)[]): this;\n    clone(def?: Internals[\"def\"], params?: {\n        parent: boolean;\n    }): this;\n    register<R extends core.$ZodRegistry>(registry: R, ...meta: this extends R[\"_schema\"] ? undefined extends R[\"_meta\"] ? [core.$replace<R[\"_meta\"], this>?] : [core.$replace<R[\"_meta\"], this>] : [\"Incompatible schema\"]): this;\n    brand<T extends PropertyKey = PropertyKey>(value?: T): PropertyKey extends T ? this : this & Record<\"_zod\", Record<\"output\", core.output<this> & core.$brand<T>>>;\n    def: Internals[\"def\"];\n    parse(data: unknown, params?: core.ParseContext<core.$ZodIssue>): core.output<this>;\n    safeParse(data: unknown, params?: core.ParseContext<core.$ZodIssue>): util.SafeParseResult<core.output<this>>;\n    parseAsync(data: unknown, params?: core.ParseContext<core.$ZodIssue>): Promise<core.output<this>>;\n    safeParseAsync(data: unknown, params?: core.ParseContext<core.$ZodIssue>): Promise<util.SafeParseResult<core.output<this>>>;\n}\ninterface _ZodMiniType<out Internals extends core.$ZodTypeInternals = core.$ZodTypeInternals> extends ZodMiniType<any, any, Internals> {\n}\nexport declare const ZodMiniType: core.$constructor<ZodMiniType>;\nexport interface _ZodMiniString<T extends core.$ZodStringInternals<unknown> = core.$ZodStringInternals<unknown>> extends _ZodMiniType<T>, core.$ZodString<T[\"input\"]> {\n    _zod: T;\n}\nexport interface ZodMiniString<Input = unknown> extends _ZodMiniString<core.$ZodStringInternals<Input>>, core.$ZodString<Input> {\n}\nexport declare const ZodMiniString: core.$constructor<ZodMiniString>;\nexport declare function string(params?: string | core.$ZodStringParams): ZodMiniString<string>;\nexport interface ZodMiniStringFormat<Format extends string = string> extends _ZodMiniString<core.$ZodStringFormatInternals<Format>>, core.$ZodStringFormat<Format> {\n}\nexport declare const ZodMiniStringFormat: core.$constructor<ZodMiniStringFormat>;\nexport interface ZodMiniEmail extends _ZodMiniString<core.$ZodEmailInternals> {\n}\nexport declare const ZodMiniEmail: core.$constructor<ZodMiniEmail>;\nexport declare function email(params?: string | core.$ZodEmailParams): ZodMiniEmail;\nexport interface ZodMiniGUID extends _ZodMiniString<core.$ZodGUIDInternals> {\n}\nexport declare const ZodMiniGUID: core.$constructor<ZodMiniGUID>;\nexport declare function guid(params?: string | core.$ZodGUIDParams): ZodMiniGUID;\nexport interface ZodMiniUUID extends _ZodMiniString<core.$ZodUUIDInternals> {\n}\nexport declare const ZodMiniUUID: core.$constructor<ZodMiniUUID>;\nexport declare function uuid(params?: string | core.$ZodUUIDParams): ZodMiniUUID;\nexport declare function uuidv4(params?: string | core.$ZodUUIDv4Params): ZodMiniUUID;\nexport declare function uuidv6(params?: string | core.$ZodUUIDv6Params): ZodMiniUUID;\nexport declare function uuidv7(params?: string | core.$ZodUUIDv7Params): ZodMiniUUID;\nexport interface ZodMiniURL extends _ZodMiniString<core.$ZodURLInternals> {\n}\nexport declare const ZodMiniURL: core.$constructor<ZodMiniURL>;\nexport declare function url(params?: string | core.$ZodURLParams): ZodMiniURL;\nexport interface ZodMiniEmoji extends _ZodMiniString<core.$ZodEmojiInternals> {\n}\nexport declare const ZodMiniEmoji: core.$constructor<ZodMiniEmoji>;\nexport declare function emoji(params?: string | core.$ZodEmojiParams): ZodMiniEmoji;\nexport interface ZodMiniNanoID extends _ZodMiniString<core.$ZodNanoIDInternals> {\n}\nexport declare const ZodMiniNanoID: core.$constructor<ZodMiniNanoID>;\nexport declare function nanoid(params?: string | core.$ZodNanoIDParams): ZodMiniNanoID;\nexport interface ZodMiniCUID extends _ZodMiniString<core.$ZodCUIDInternals> {\n}\nexport declare const ZodMiniCUID: core.$constructor<ZodMiniCUID>;\nexport declare function cuid(params?: string | core.$ZodCUIDParams): ZodMiniCUID;\nexport interface ZodMiniCUID2 extends _ZodMiniString<core.$ZodCUID2Internals> {\n}\nexport declare const ZodMiniCUID2: core.$constructor<ZodMiniCUID2>;\nexport declare function cuid2(params?: string | core.$ZodCUID2Params): ZodMiniCUID2;\nexport interface ZodMiniULID extends _ZodMiniString<core.$ZodULIDInternals> {\n}\nexport declare const ZodMiniULID: core.$constructor<ZodMiniULID>;\nexport declare function ulid(params?: string | core.$ZodULIDParams): ZodMiniULID;\nexport interface ZodMiniXID extends _ZodMiniString<core.$ZodXIDInternals> {\n}\nexport declare const ZodMiniXID: core.$constructor<ZodMiniXID>;\nexport declare function xid(params?: string | core.$ZodXIDParams): ZodMiniXID;\nexport interface ZodMiniKSUID extends _ZodMiniString<core.$ZodKSUIDInternals> {\n}\nexport declare const ZodMiniKSUID: core.$constructor<ZodMiniKSUID>;\nexport declare function ksuid(params?: string | core.$ZodKSUIDParams): ZodMiniKSUID;\nexport interface ZodMiniIPv4 extends _ZodMiniString<core.$ZodIPv4Internals> {\n}\nexport declare const ZodMiniIPv4: core.$constructor<ZodMiniIPv4>;\nexport declare function ipv4(params?: string | core.$ZodIPv4Params): ZodMiniIPv4;\nexport interface ZodMiniIPv6 extends _ZodMiniString<core.$ZodIPv6Internals> {\n}\nexport declare const ZodMiniIPv6: core.$constructor<ZodMiniIPv6>;\nexport declare function ipv6(params?: string | core.$ZodIPv6Params): ZodMiniIPv6;\nexport interface ZodMiniCIDRv4 extends _ZodMiniString<core.$ZodCIDRv4Internals> {\n}\nexport declare const ZodMiniCIDRv4: core.$constructor<ZodMiniCIDRv4>;\nexport declare function cidrv4(params?: string | core.$ZodCIDRv4Params): ZodMiniCIDRv4;\nexport interface ZodMiniCIDRv6 extends _ZodMiniString<core.$ZodCIDRv6Internals> {\n}\nexport declare const ZodMiniCIDRv6: core.$constructor<ZodMiniCIDRv6>;\nexport declare function cidrv6(params?: string | core.$ZodCIDRv6Params): ZodMiniCIDRv6;\nexport interface ZodMiniBase64 extends _ZodMiniString<core.$ZodBase64Internals> {\n}\nexport declare const ZodMiniBase64: core.$constructor<ZodMiniBase64>;\nexport declare function base64(params?: string | core.$ZodBase64Params): ZodMiniBase64;\nexport interface ZodMiniBase64URL extends _ZodMiniString<core.$ZodBase64URLInternals> {\n}\nexport declare const ZodMiniBase64URL: core.$constructor<ZodMiniBase64URL>;\nexport declare function base64url(params?: string | core.$ZodBase64URLParams): ZodMiniBase64URL;\nexport interface ZodMiniE164 extends _ZodMiniString<core.$ZodE164Internals> {\n}\nexport declare const ZodMiniE164: core.$constructor<ZodMiniE164>;\nexport declare function e164(params?: string | core.$ZodE164Params): ZodMiniE164;\nexport interface ZodMiniJWT extends _ZodMiniString<core.$ZodJWTInternals> {\n}\nexport declare const ZodMiniJWT: core.$constructor<ZodMiniJWT>;\nexport declare function jwt(params?: string | core.$ZodJWTParams): ZodMiniJWT;\nexport interface ZodMiniCustomStringFormat<Format extends string = string> extends ZodMiniStringFormat<Format>, core.$ZodCustomStringFormat<Format> {\n    _zod: core.$ZodCustomStringFormatInternals<Format>;\n}\nexport declare const ZodMiniCustomStringFormat: core.$constructor<ZodMiniCustomStringFormat>;\nexport declare function stringFormat<Format extends string>(format: Format, fnOrRegex: ((arg: string) => util.MaybeAsync<unknown>) | RegExp, _params?: string | core.$ZodStringFormatParams): ZodMiniCustomStringFormat<Format>;\ninterface _ZodMiniNumber<T extends core.$ZodNumberInternals<unknown> = core.$ZodNumberInternals<unknown>> extends _ZodMiniType<T>, core.$ZodNumber<T[\"input\"]> {\n    _zod: T;\n}\nexport interface ZodMiniNumber<Input = unknown> extends _ZodMiniNumber<core.$ZodNumberInternals<Input>>, core.$ZodNumber<Input> {\n}\nexport declare const ZodMiniNumber: core.$constructor<ZodMiniNumber>;\nexport declare function number(params?: string | core.$ZodNumberParams): ZodMiniNumber<number>;\nexport interface ZodMiniNumberFormat extends _ZodMiniNumber<core.$ZodNumberFormatInternals>, core.$ZodNumberFormat {\n}\nexport declare const ZodMiniNumberFormat: core.$constructor<ZodMiniNumberFormat>;\nexport declare function int(params?: string | core.$ZodCheckNumberFormatParams): ZodMiniNumberFormat;\nexport declare function float32(params?: string | core.$ZodCheckNumberFormatParams): ZodMiniNumberFormat;\nexport declare function float64(params?: string | core.$ZodCheckNumberFormatParams): ZodMiniNumberFormat;\nexport declare function int32(params?: string | core.$ZodCheckNumberFormatParams): ZodMiniNumberFormat;\nexport declare function uint32(params?: string | core.$ZodCheckNumberFormatParams): ZodMiniNumberFormat;\nexport interface ZodMiniBoolean<T = unknown> extends _ZodMiniType<core.$ZodBooleanInternals<T>> {\n}\nexport declare const ZodMiniBoolean: core.$constructor<ZodMiniBoolean>;\nexport declare function boolean(params?: string | core.$ZodBooleanParams): ZodMiniBoolean<boolean>;\nexport interface ZodMiniBigInt<T = unknown> extends _ZodMiniType<core.$ZodBigIntInternals<T>>, core.$ZodBigInt<T> {\n}\nexport declare const ZodMiniBigInt: core.$constructor<ZodMiniBigInt>;\nexport declare function bigint(params?: string | core.$ZodBigIntParams): ZodMiniBigInt<bigint>;\nexport interface ZodMiniBigIntFormat extends _ZodMiniType<core.$ZodBigIntFormatInternals> {\n}\nexport declare const ZodMiniBigIntFormat: core.$constructor<ZodMiniBigIntFormat>;\nexport declare function int64(params?: string | core.$ZodBigIntFormatParams): ZodMiniBigIntFormat;\nexport declare function uint64(params?: string | core.$ZodBigIntFormatParams): ZodMiniBigIntFormat;\nexport interface ZodMiniSymbol extends _ZodMiniType<core.$ZodSymbolInternals> {\n}\nexport declare const ZodMiniSymbol: core.$constructor<ZodMiniSymbol>;\nexport declare function symbol(params?: string | core.$ZodSymbolParams): ZodMiniSymbol;\nexport interface ZodMiniUndefined extends _ZodMiniType<core.$ZodUndefinedInternals> {\n}\nexport declare const ZodMiniUndefined: core.$constructor<ZodMiniUndefined>;\ndeclare function _undefined(params?: string | core.$ZodUndefinedParams): ZodMiniUndefined;\nexport { _undefined as undefined };\nexport interface ZodMiniNull extends _ZodMiniType<core.$ZodNullInternals> {\n}\nexport declare const ZodMiniNull: core.$constructor<ZodMiniNull>;\ndeclare function _null(params?: string | core.$ZodNullParams): ZodMiniNull;\nexport { _null as null };\nexport interface ZodMiniAny extends _ZodMiniType<core.$ZodAnyInternals> {\n}\nexport declare const ZodMiniAny: core.$constructor<ZodMiniAny>;\nexport declare function any(): ZodMiniAny;\nexport interface ZodMiniUnknown extends _ZodMiniType<core.$ZodUnknownInternals> {\n}\nexport declare const ZodMiniUnknown: core.$constructor<ZodMiniUnknown>;\nexport declare function unknown(): ZodMiniUnknown;\nexport interface ZodMiniNever extends _ZodMiniType<core.$ZodNeverInternals> {\n}\nexport declare const ZodMiniNever: core.$constructor<ZodMiniNever>;\nexport declare function never(params?: string | core.$ZodNeverParams): ZodMiniNever;\nexport interface ZodMiniVoid extends _ZodMiniType<core.$ZodVoidInternals> {\n}\nexport declare const ZodMiniVoid: core.$constructor<ZodMiniVoid>;\ndeclare function _void(params?: string | core.$ZodVoidParams): ZodMiniVoid;\nexport { _void as void };\nexport interface ZodMiniDate<T = unknown> extends _ZodMiniType<core.$ZodDateInternals<T>> {\n}\nexport declare const ZodMiniDate: core.$constructor<ZodMiniDate>;\nexport declare function date(params?: string | core.$ZodDateParams): ZodMiniDate<Date>;\nexport interface ZodMiniArray<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodArrayInternals<T>>, core.$ZodArray<T> {\n}\nexport declare const ZodMiniArray: core.$constructor<ZodMiniArray>;\nexport declare function array<T extends SomeType>(element: T, params?: string | core.$ZodArrayParams): ZodMiniArray<T>;\nexport declare function keyof<T extends ZodMiniObject>(schema: T): ZodMiniLiteral<Exclude<keyof T[\"shape\"], symbol>>;\nexport interface ZodMiniObject<\n/** @ts-ignore Cast variance */\nout Shape extends core.$ZodShape = core.$ZodShape, out Config extends core.$ZodObjectConfig = core.$strip> extends ZodMiniType<any, any, core.$ZodObjectInternals<Shape, Config>>, core.$ZodObject<Shape, Config> {\n    shape: Shape;\n}\nexport declare const ZodMiniObject: core.$constructor<ZodMiniObject>;\nexport declare function object<T extends core.$ZodLooseShape = Record<never, SomeType>>(shape?: T, params?: string | core.$ZodObjectParams): ZodMiniObject<T, core.$strip>;\nexport declare function strictObject<T extends core.$ZodLooseShape>(shape: T, params?: string | core.$ZodObjectParams): ZodMiniObject<T, core.$strict>;\nexport declare function looseObject<T extends core.$ZodLooseShape>(shape: T, params?: string | core.$ZodObjectParams): ZodMiniObject<T, core.$loose>;\nexport declare function extend<T extends ZodMiniObject, U extends core.$ZodLooseShape>(schema: T, shape: U): ZodMiniObject<util.Extend<T[\"shape\"], U>, T[\"_zod\"][\"config\"]>;\n/** @deprecated Identical to `z.extend(A, B)` */\nexport declare function merge<T extends ZodMiniObject, U extends ZodMiniObject>(a: T, b: U): ZodMiniObject<util.Extend<T[\"shape\"], U[\"shape\"]>, T[\"_zod\"][\"config\"]>;\nexport declare function pick<T extends ZodMiniObject, M extends util.Mask<keyof T[\"shape\"]>>(schema: T, mask: M): ZodMiniObject<util.Flatten<Pick<T[\"shape\"], keyof T[\"shape\"] & keyof M>>, T[\"_zod\"][\"config\"]>;\nexport declare function omit<T extends ZodMiniObject, const M extends util.Mask<keyof T[\"shape\"]>>(schema: T, mask: M): ZodMiniObject<util.Flatten<Omit<T[\"shape\"], keyof M>>, T[\"_zod\"][\"config\"]>;\nexport declare function partial<T extends ZodMiniObject>(schema: T): ZodMiniObject<{\n    [k in keyof T[\"shape\"]]: ZodMiniOptional<T[\"shape\"][k]>;\n}, T[\"_zod\"][\"config\"]>;\nexport declare function partial<T extends ZodMiniObject, M extends util.Mask<keyof T[\"shape\"]>>(schema: T, mask: M): ZodMiniObject<{\n    [k in keyof T[\"shape\"]]: k extends keyof M ? ZodMiniOptional<T[\"shape\"][k]> : T[\"shape\"][k];\n}, T[\"_zod\"][\"config\"]>;\nexport type RequiredInterfaceShape<Shape extends core.$ZodLooseShape, Keys extends PropertyKey = keyof Shape> = util.Identity<{\n    [k in keyof Shape as k extends Keys ? k : never]: ZodMiniNonOptional<Shape[k]>;\n} & {\n    [k in keyof Shape as k extends Keys ? never : k]: Shape[k];\n}>;\nexport declare function required<T extends ZodMiniObject>(schema: T): ZodMiniObject<{\n    [k in keyof T[\"shape\"]]: ZodMiniNonOptional<T[\"shape\"][k]>;\n}, T[\"_zod\"][\"config\"]>;\nexport declare function required<T extends ZodMiniObject, M extends util.Mask<keyof T[\"shape\"]>>(schema: T, mask: M): ZodMiniObject<util.Extend<T[\"shape\"], {\n    [k in keyof M & keyof T[\"shape\"]]: ZodMiniNonOptional<T[\"shape\"][k]>;\n}>, T[\"_zod\"][\"config\"]>;\nexport declare function catchall<T extends ZodMiniObject, U extends SomeType>(inst: T, catchall: U): ZodMiniObject<T[\"shape\"], core.$catchall<U>>;\nexport interface ZodMiniUnion<T extends readonly SomeType[] = readonly core.$ZodType[]> extends _ZodMiniType<core.$ZodUnionInternals<T>> {\n}\nexport declare const ZodMiniUnion: core.$constructor<ZodMiniUnion>;\nexport declare function union<const T extends readonly SomeType[]>(options: T, params?: string | core.$ZodUnionParams): ZodMiniUnion<T>;\nexport interface ZodMiniDiscriminatedUnion<Options extends readonly SomeType[] = readonly core.$ZodType[]> extends ZodMiniUnion<Options> {\n    _zod: core.$ZodDiscriminatedUnionInternals<Options>;\n}\nexport declare const ZodMiniDiscriminatedUnion: core.$constructor<ZodMiniDiscriminatedUnion>;\nexport declare function discriminatedUnion<Types extends readonly [core.$ZodTypeDiscriminable, ...core.$ZodTypeDiscriminable[]]>(discriminator: string, options: Types, params?: string | core.$ZodDiscriminatedUnionParams): ZodMiniDiscriminatedUnion<Types>;\nexport interface ZodMiniIntersection<A extends SomeType = core.$ZodType, B extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodIntersectionInternals<A, B>> {\n}\nexport declare const ZodMiniIntersection: core.$constructor<ZodMiniIntersection>;\nexport declare function intersection<T extends SomeType, U extends SomeType>(left: T, right: U): ZodMiniIntersection<T, U>;\nexport interface ZodMiniTuple<T extends util.TupleItems = readonly core.$ZodType[], Rest extends SomeType | null = core.$ZodType | null> extends _ZodMiniType<core.$ZodTupleInternals<T, Rest>> {\n}\nexport declare const ZodMiniTuple: core.$constructor<ZodMiniTuple>;\nexport declare function tuple<const T extends readonly [SomeType, ...SomeType[]]>(items: T, params?: string | core.$ZodTupleParams): ZodMiniTuple<T, null>;\nexport declare function tuple<const T extends readonly [SomeType, ...SomeType[]], Rest extends SomeType>(items: T, rest: Rest, params?: string | core.$ZodTupleParams): ZodMiniTuple<T, Rest>;\nexport declare function tuple(items: [], params?: string | core.$ZodTupleParams): ZodMiniTuple<[], null>;\nexport interface ZodMiniRecord<Key extends core.$ZodRecordKey = core.$ZodRecordKey, Value extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodRecordInternals<Key, Value>> {\n}\nexport declare const ZodMiniRecord: core.$constructor<ZodMiniRecord>;\nexport declare function record<Key extends core.$ZodRecordKey, Value extends SomeType>(keyType: Key, valueType: Value, params?: string | core.$ZodRecordParams): ZodMiniRecord<Key, Value>;\nexport declare function partialRecord<Key extends core.$ZodRecordKey, Value extends SomeType>(keyType: Key, valueType: Value, params?: string | core.$ZodRecordParams): ZodMiniRecord<Key & core.$partial, Value>;\nexport interface ZodMiniMap<Key extends SomeType = core.$ZodType, Value extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodMapInternals<Key, Value>> {\n}\nexport declare const ZodMiniMap: core.$constructor<ZodMiniMap>;\nexport declare function map<Key extends SomeType, Value extends SomeType>(keyType: Key, valueType: Value, params?: string | core.$ZodMapParams): ZodMiniMap<Key, Value>;\nexport interface ZodMiniSet<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodSetInternals<T>> {\n}\nexport declare const ZodMiniSet: core.$constructor<ZodMiniSet>;\nexport declare function set<Value extends SomeType>(valueType: Value, params?: string | core.$ZodSetParams): ZodMiniSet<Value>;\nexport interface ZodMiniEnum<T extends util.EnumLike = util.EnumLike> extends _ZodMiniType<core.$ZodEnumInternals<T>> {\n}\nexport declare const ZodMiniEnum: core.$constructor<ZodMiniEnum>;\ndeclare function _enum<const T extends readonly string[]>(values: T, params?: string | core.$ZodEnumParams): ZodMiniEnum<util.ToEnum<T[number]>>;\ndeclare function _enum<T extends util.EnumLike>(entries: T, params?: string | core.$ZodEnumParams): ZodMiniEnum<T>;\nexport { _enum as enum };\n/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.\n *\n * ```ts\n * enum Colors { red, green, blue }\n * z.enum(Colors);\n * ```\n */\nexport declare function nativeEnum<T extends util.EnumLike>(entries: T, params?: string | core.$ZodEnumParams): ZodMiniEnum<T>;\nexport interface ZodMiniLiteral<T extends util.Literal = util.Literal> extends _ZodMiniType<core.$ZodLiteralInternals<T>> {\n}\nexport declare const ZodMiniLiteral: core.$constructor<ZodMiniLiteral>;\nexport declare function literal<const T extends ReadonlyArray<util.Literal>>(value: T, params?: string | core.$ZodLiteralParams): ZodMiniLiteral<T[number]>;\nexport declare function literal<const T extends util.Literal>(value: T, params?: string | core.$ZodLiteralParams): ZodMiniLiteral<T>;\nexport interface ZodMiniFile extends _ZodMiniType<core.$ZodFileInternals> {\n}\nexport declare const ZodMiniFile: core.$constructor<ZodMiniFile>;\nexport declare function file(params?: string | core.$ZodFileParams): ZodMiniFile;\nexport interface ZodMiniTransform<O = unknown, I = unknown> extends _ZodMiniType<core.$ZodTransformInternals<O, I>> {\n}\nexport declare const ZodMiniTransform: core.$constructor<ZodMiniTransform>;\nexport declare function transform<I = unknown, O = I>(fn: (input: I, ctx: core.ParsePayload) => O): ZodMiniTransform<Awaited<O>, I>;\nexport interface ZodMiniOptional<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodOptionalInternals<T>>, core.$ZodOptional<T> {\n}\nexport declare const ZodMiniOptional: core.$constructor<ZodMiniOptional>;\nexport declare function optional<T extends SomeType>(innerType: T): ZodMiniOptional<T>;\nexport interface ZodMiniNullable<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodNullableInternals<T>> {\n}\nexport declare const ZodMiniNullable: core.$constructor<ZodMiniNullable>;\nexport declare function nullable<T extends SomeType>(innerType: T): ZodMiniNullable<T>;\nexport declare function nullish<T extends SomeType>(innerType: T): ZodMiniOptional<ZodMiniNullable<T>>;\nexport interface ZodMiniDefault<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodDefaultInternals<T>> {\n}\nexport declare const ZodMiniDefault: core.$constructor<ZodMiniDefault>;\nexport declare function _default<T extends SomeType>(innerType: T, defaultValue: util.NoUndefined<core.output<T>> | (() => util.NoUndefined<core.output<T>>)): ZodMiniDefault<T>;\nexport interface ZodMiniPrefault<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodPrefaultInternals<T>> {\n}\nexport declare const ZodMiniPrefault: core.$constructor<ZodMiniPrefault>;\nexport declare function prefault<T extends SomeType>(innerType: T, defaultValue: util.NoUndefined<core.input<T>> | (() => util.NoUndefined<core.input<T>>)): ZodMiniPrefault<T>;\nexport interface ZodMiniNonOptional<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodNonOptionalInternals<T>> {\n}\nexport declare const ZodMiniNonOptional: core.$constructor<ZodMiniNonOptional>;\nexport declare function nonoptional<T extends SomeType>(innerType: T, params?: string | core.$ZodNonOptionalParams): ZodMiniNonOptional<T>;\nexport interface ZodMiniSuccess<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodSuccessInternals<T>> {\n}\nexport declare const ZodMiniSuccess: core.$constructor<ZodMiniSuccess>;\nexport declare function success<T extends SomeType>(innerType: T): ZodMiniSuccess<T>;\nexport interface ZodMiniCatch<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodCatchInternals<T>> {\n}\nexport declare const ZodMiniCatch: core.$constructor<ZodMiniCatch>;\ndeclare function _catch<T extends SomeType>(innerType: T, catchValue: core.output<T> | ((ctx: core.$ZodCatchCtx) => core.output<T>)): ZodMiniCatch<T>;\nexport { _catch as catch };\nexport interface ZodMiniNaN extends _ZodMiniType<core.$ZodNaNInternals> {\n}\nexport declare const ZodMiniNaN: core.$constructor<ZodMiniNaN>;\nexport declare function nan(params?: string | core.$ZodNaNParams): ZodMiniNaN;\nexport interface ZodMiniPipe<A extends SomeType = core.$ZodType, B extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodPipeInternals<A, B>> {\n}\nexport declare const ZodMiniPipe: core.$constructor<ZodMiniPipe>;\nexport declare function pipe<const A extends SomeType, B extends core.$ZodType<unknown, core.output<A>> = core.$ZodType<unknown, core.output<A>>>(in_: A, out: B | core.$ZodType<unknown, core.output<A>>): ZodMiniPipe<A, B>;\nexport interface ZodMiniReadonly<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodReadonlyInternals<T>> {\n}\nexport declare const ZodMiniReadonly: core.$constructor<ZodMiniReadonly>;\nexport declare function readonly<T extends SomeType>(innerType: T): ZodMiniReadonly<T>;\nexport interface ZodMiniTemplateLiteral<Template extends string = string> extends _ZodMiniType<core.$ZodTemplateLiteralInternals<Template>> {\n}\nexport declare const ZodMiniTemplateLiteral: core.$constructor<ZodMiniTemplateLiteral>;\nexport declare function templateLiteral<const Parts extends core.$ZodTemplateLiteralPart[]>(parts: Parts, params?: string | core.$ZodTemplateLiteralParams): ZodMiniTemplateLiteral<core.$PartsToTemplateLiteral<Parts>>;\nexport interface ZodMiniLazy<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodLazyInternals<T>> {\n}\nexport declare const ZodMiniLazy: core.$constructor<ZodMiniLazy>;\ndeclare function _lazy<T extends SomeType>(getter: () => T): ZodMiniLazy<T>;\nexport { _lazy as lazy };\nexport interface ZodMiniPromise<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodPromiseInternals<T>> {\n}\nexport declare const ZodMiniPromise: core.$constructor<ZodMiniPromise>;\nexport declare function promise<T extends SomeType>(innerType: T): ZodMiniPromise<T>;\nexport interface ZodMiniCustom<O = unknown, I = unknown> extends _ZodMiniType<core.$ZodCustomInternals<O, I>> {\n}\nexport declare const ZodMiniCustom: core.$constructor<ZodMiniCustom>;\nexport declare function check<O = unknown>(fn: core.CheckFn<O>, params?: string | core.$ZodCustomParams): core.$ZodCheck<O>;\nexport declare function custom<O = unknown, I = O>(fn?: (data: O) => unknown, _params?: string | core.$ZodCustomParams | undefined): ZodMiniCustom<O, I>;\nexport declare function refine<T>(fn: (arg: NoInfer<T>) => util.MaybeAsync<unknown>, _params?: string | core.$ZodCustomParams): core.$ZodCheck<T>;\ndeclare abstract class Class {\n    constructor(..._args: any[]);\n}\ndeclare function _instanceof<T extends typeof Class>(cls: T, params?: core.$ZodCustomParams): ZodMiniCustom<InstanceType<T>, InstanceType<T>>;\nexport { _instanceof as instanceof };\nexport declare const stringbool: (_params?: string | core.$ZodStringBoolParams) => ZodMiniPipe<ZodMiniPipe<ZodMiniString, ZodMiniTransform<boolean, string>>, ZodMiniBoolean>;\ntype _ZodMiniJSONSchema = ZodMiniUnion<[\n    ZodMiniString,\n    ZodMiniNumber,\n    ZodMiniBoolean,\n    ZodMiniNull,\n    ZodMiniArray<ZodMiniJSONSchema>,\n    ZodMiniRecord<ZodMiniString<string>, ZodMiniJSONSchema>\n]>;\ntype _ZodMiniJSONSchemaInternals = _ZodMiniJSONSchema[\"_zod\"];\nexport interface ZodMiniJSONSchemaInternals extends _ZodMiniJSONSchemaInternals {\n    output: util.JSONType;\n    input: util.JSONType;\n}\nexport interface ZodMiniJSONSchema extends _ZodMiniJSONSchema {\n    _zod: ZodMiniJSONSchemaInternals;\n}\nexport declare function json(): ZodMiniJSONSchema;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/mini/schemas.d.cts",
        "start": 2,
        "end": 356,
        "startLoc": {
          "line": 2,
          "column": 20,
          "position": 24
        },
        "endLoc": {
          "line": 356,
          "column": 2,
          "position": 7699
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/mini/schemas.d.ts",
        "start": 2,
        "end": 356,
        "startLoc": {
          "line": 2,
          "column": 19,
          "position": 24
        },
        "endLoc": {
          "line": 356,
          "column": 2,
          "position": 7699
        }
      }
    },
    {
      "format": "typescript",
      "lines": 21,
      "fragment": ";\nexport interface ZodMiniISODateTime extends schemas.ZodMiniStringFormat<\"datetime\"> {\n    _zod: core.$ZodISODateTimeInternals;\n}\nexport declare const ZodMiniISODateTime: core.$constructor<ZodMiniISODateTime>;\nexport declare function datetime(params?: string | core.$ZodISODateTimeParams): ZodMiniISODateTime;\nexport interface ZodMiniISODate extends schemas.ZodMiniStringFormat<\"date\"> {\n    _zod: core.$ZodISODateInternals;\n}\nexport declare const ZodMiniISODate: core.$constructor<ZodMiniISODate>;\nexport declare function date(params?: string | core.$ZodISODateParams): ZodMiniISODate;\nexport interface ZodMiniISOTime extends schemas.ZodMiniStringFormat<\"time\"> {\n    _zod: core.$ZodISOTimeInternals;\n}\nexport declare const ZodMiniISOTime: core.$constructor<ZodMiniISOTime>;\nexport declare function time(params?: string | core.$ZodISOTimeParams): ZodMiniISOTime;\nexport interface ZodMiniISODuration extends schemas.ZodMiniStringFormat<\"duration\"> {\n    _zod: core.$ZodISODurationInternals;\n}\nexport declare const ZodMiniISODuration: core.$constructor<ZodMiniISODuration>;\nexport declare function duration(params?: string | core.$ZodISODurationParams): ZodMiniISODuration;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/mini/iso.d.cts",
        "start": 2,
        "end": 22,
        "startLoc": {
          "line": 2,
          "column": 16,
          "position": 24
        },
        "endLoc": {
          "line": 22,
          "column": 2,
          "position": 308
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/mini/iso.d.ts",
        "start": 2,
        "end": 22,
        "startLoc": {
          "line": 2,
          "column": 15,
          "position": 24
        },
        "endLoc": {
          "line": 22,
          "column": 2,
          "position": 308
        }
      }
    },
    {
      "format": "typescript",
      "lines": 39,
      "fragment": "export { default as ar } from \"./ar.js\";\nexport { default as az } from \"./az.js\";\nexport { default as be } from \"./be.js\";\nexport { default as ca } from \"./ca.js\";\nexport { default as cs } from \"./cs.js\";\nexport { default as de } from \"./de.js\";\nexport { default as en } from \"./en.js\";\nexport { default as eo } from \"./eo.js\";\nexport { default as es } from \"./es.js\";\nexport { default as fa } from \"./fa.js\";\nexport { default as fi } from \"./fi.js\";\nexport { default as fr } from \"./fr.js\";\nexport { default as frCA } from \"./fr-CA.js\";\nexport { default as he } from \"./he.js\";\nexport { default as hu } from \"./hu.js\";\nexport { default as id } from \"./id.js\";\nexport { default as it } from \"./it.js\";\nexport { default as ja } from \"./ja.js\";\nexport { default as kh } from \"./kh.js\";\nexport { default as ko } from \"./ko.js\";\nexport { default as mk } from \"./mk.js\";\nexport { default as ms } from \"./ms.js\";\nexport { default as nl } from \"./nl.js\";\nexport { default as no } from \"./no.js\";\nexport { default as ota } from \"./ota.js\";\nexport { default as ps } from \"./ps.js\";\nexport { default as pl } from \"./pl.js\";\nexport { default as pt } from \"./pt.js\";\nexport { default as ru } from \"./ru.js\";\nexport { default as sl } from \"./sl.js\";\nexport { default as sv } from \"./sv.js\";\nexport { default as ta } from \"./ta.js\";\nexport { default as th } from \"./th.js\";\nexport { default as tr } from \"./tr.js\";\nexport { default as ua } from \"./ua.js\";\nexport { default as ur } from \"./ur.js\";\nexport { default as vi } from \"./vi.js\";\nexport { default as zhCN } from \"./zh-CN.js\";\nexport { default as zhTW } from \"./zh-TW.js\";",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/locales/index.d.ts",
        "start": 1,
        "end": 39,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 39,
          "column": 2,
          "position": 661
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/index.ts",
        "start": 1,
        "end": 39,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 39,
          "column": 2,
          "position": 661
        }
      }
    },
    {
      "format": "typescript",
      "lines": 16,
      "fragment": "export type AssertEqual<T, U> = (<V>() => V extends T ? 1 : 2) extends <V>() => V extends U ? 1 : 2 ? true : false;\nexport type AssertNotEqual<T, U> = (<V>() => V extends T ? 1 : 2) extends <V>() => V extends U ? 1 : 2 ? false : true;\nexport type AssertExtends<T, U> = T extends U ? T : never;\nexport type IsAny<T> = 0 extends 1 & T ? true : false;\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\nexport type OmitKeys<T, K extends string> = Pick<T, Exclude<keyof T, K>>;\nexport type MakePartial<T, K extends keyof T> = Omit<T, K> & InexactPartial<Pick<T, K>>;\nexport type MakeRequired<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;\nexport type Exactly<T, X> = T & Record<Exclude<keyof X, keyof T>, never>;\nexport type NoUndefined<T> = T extends undefined ? never : T;\nexport type Whatever = {} | undefined | null;\nexport type LoosePartial<T extends object> = InexactPartial<T> & {\n    [k: string]: unknown;\n};\nexport type Mask<Keys extends PropertyKey> = {\n    [K in Keys]?: true;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/util.d.ts",
        "start": 12,
        "end": 27,
        "startLoc": {
          "line": 12,
          "column": 1,
          "position": 425
        },
        "endLoc": {
          "line": 27,
          "column": 2,
          "position": 929
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/util.ts",
        "start": 81,
        "end": 96,
        "startLoc": {
          "line": 81,
          "column": 1,
          "position": 502
        },
        "endLoc": {
          "line": 96,
          "column": 2,
          "position": 1007
        }
      }
    },
    {
      "format": "typescript",
      "lines": 11,
      "fragment": "};\nexport type Prettify<T> = {\n    [K in keyof T]: T[K];\n} & {};\nexport type NoNeverKeys<T> = {\n    [k in keyof T]: [T[k]] extends [never] ? never : k;\n}[keyof T];\nexport type NoNever<T> = Identity<{\n    [k in NoNeverKeys<T>]: k extends keyof T ? T[k] : never;\n}>;\nexport type Extend<A extends SomeObject, B extends SomeObject> = Flatten<keyof",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/util.d.ts",
        "start": 47,
        "end": 57,
        "startLoc": {
          "line": 47,
          "column": 1,
          "position": 1347
        },
        "endLoc": {
          "line": 57,
          "column": 6,
          "position": 1520
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/util.ts",
        "start": 124,
        "end": 136,
        "startLoc": {
          "line": 124,
          "column": 2,
          "position": 1434
        },
        "endLoc": {
          "line": 136,
          "column": 43,
          "position": 1610
        }
      }
    },
    {
      "format": "typescript",
      "lines": 22,
      "fragment": "keyof A & keyof B extends never ? A & B : {\n    [K in keyof A as K extends keyof B ? never : K]: A[K];\n} & {\n    [K in keyof B]: B[K];\n}>;\nexport type TupleItems = ReadonlyArray<schemas.SomeType>;\nexport type AnyFunc = (...args: any[]) => any;\nexport type IsProp<T, K extends keyof T> = T[K] extends AnyFunc ? never : K;\nexport type MaybeAsync<T> = T | Promise<T>;\nexport type KeyOf<T> = keyof OmitIndexSignature<T>;\nexport type OmitIndexSignature<T> = {\n    [K in keyof T as string extends K ? never : K extends string ? K : never]: T[K];\n};\nexport type ExtractIndexSignature<T> = {\n    [K in keyof T as string extends K ? K : K extends string ? never : K]: T[K];\n};\nexport type Keys<T extends object> = keyof OmitIndexSignature<T>;\nexport type SchemaClass<T extends schemas.SomeType> = {\n    new (def: T[\"_zod\"][\"def\"]): T;\n};\nexport type EnumValue = string | number;\nexport",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/util.d.ts",
        "start": 57,
        "end": 78,
        "startLoc": {
          "line": 57,
          "column": 2,
          "position": 1520
        },
        "endLoc": {
          "line": 78,
          "column": 7,
          "position": 1931
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/util.ts",
        "start": 137,
        "end": 162,
        "startLoc": {
          "line": 137,
          "column": 3,
          "position": 1613
        },
        "endLoc": {
          "line": 162,
          "column": 32,
          "position": 2031
        }
      }
    },
    {
      "format": "typescript",
      "lines": 180,
      "fragment": ";\nexport type JSONType = string | number | boolean | null | JSONType[] | {\n    [key: string]: JSONType;\n};\nexport type JWTAlgorithm = \"HS256\" | \"HS384\" | \"HS512\" | \"RS256\" | \"RS384\" | \"RS512\" | \"ES256\" | \"ES384\" | \"ES512\" | \"PS256\" | \"PS384\" | \"PS512\" | \"EdDSA\" | (string & {});\nexport type IPVersion = \"v4\" | \"v6\";\nexport type MimeTypes = \"application/json\" | \"application/xml\" | \"application/x-www-form-urlencoded\" | \"application/javascript\" | \"application/pdf\" | \"application/zip\" | \"application/vnd.ms-excel\" | \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\" | \"application/msword\" | \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\" | \"application/vnd.ms-powerpoint\" | \"application/vnd.openxmlformats-officedocument.presentationml.presentation\" | \"application/octet-stream\" | \"application/graphql\" | \"text/html\" | \"text/plain\" | \"text/css\" | \"text/javascript\" | \"text/csv\" | \"image/png\" | \"image/jpeg\" | \"image/gif\" | \"image/svg+xml\" | \"image/webp\" | \"audio/mpeg\" | \"audio/ogg\" | \"audio/wav\" | \"audio/webm\" | \"video/mp4\" | \"video/webm\" | \"video/ogg\" | \"font/woff\" | \"font/woff2\" | \"font/ttf\" | \"font/otf\" | \"multipart/form-data\" | (string & {});\nexport type ParsedTypes = \"string\" | \"number\" | \"bigint\" | \"boolean\" | \"symbol\" | \"undefined\" | \"object\" | \"function\" | \"file\" | \"date\" | \"array\" | \"map\" | \"set\" | \"nan\" | \"null\" | \"promise\";\nexport type AssertEqual<T, U> = (<V>() => V extends T ? 1 : 2) extends <V>() => V extends U ? 1 : 2 ? true : false;\nexport type AssertNotEqual<T, U> = (<V>() => V extends T ? 1 : 2) extends <V>() => V extends U ? 1 : 2 ? false : true;\nexport type AssertExtends<T, U> = T extends U ? T : never;\nexport type IsAny<T> = 0 extends 1 & T ? true : false;\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\nexport type OmitKeys<T, K extends string> = Pick<T, Exclude<keyof T, K>>;\nexport type MakePartial<T, K extends keyof T> = Omit<T, K> & InexactPartial<Pick<T, K>>;\nexport type MakeRequired<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;\nexport type Exactly<T, X> = T & Record<Exclude<keyof X, keyof T>, never>;\nexport type NoUndefined<T> = T extends undefined ? never : T;\nexport type Whatever = {} | undefined | null;\nexport type LoosePartial<T extends object> = InexactPartial<T> & {\n    [k: string]: unknown;\n};\nexport type Mask<Keys extends PropertyKey> = {\n    [K in Keys]?: true;\n};\nexport type Writeable<T> = {\n    -readonly [P in keyof T]: T[P];\n} & {};\nexport type InexactPartial<T> = {\n    [P in keyof T]?: T[P] | undefined;\n};\nexport type EmptyObject = Record<string, never>;\nexport type BuiltIn = (((...args: any[]) => any) | (new (...args: any[]) => any)) | {\n    readonly [Symbol.toStringTag]: string;\n} | Date | Error | Generator | Promise<unknown> | RegExp;\nexport type MakeReadonly<T> = T extends Map<infer K, infer V> ? ReadonlyMap<K, V> : T extends Set<infer V> ? ReadonlySet<V> : T extends [infer Head, ...infer Tail] ? readonly [Head, ...Tail] : T extends Array<infer V> ? ReadonlyArray<V> : T extends BuiltIn ? T : Readonly<T>;\nexport type SomeObject = Record<PropertyKey, any>;\nexport type Identity<T> = T;\nexport type Flatten<T> = Identity<{\n    [k in keyof T]: T[k];\n}>;\nexport type Mapped<T> = {\n    [k in keyof T]: T[k];\n};\nexport type Prettify<T> = {\n    [K in keyof T]: T[K];\n} & {};\nexport type NoNeverKeys<T> = {\n    [k in keyof T]: [T[k]] extends [never] ? never : k;\n}[keyof T];\nexport type NoNever<T> = Identity<{\n    [k in NoNeverKeys<T>]: k extends keyof T ? T[k] : never;\n}>;\nexport type Extend<A extends SomeObject, B extends SomeObject> = Flatten<keyof A & keyof B extends never ? A & B : {\n    [K in keyof A as K extends keyof B ? never : K]: A[K];\n} & {\n    [K in keyof B]: B[K];\n}>;\nexport type TupleItems = ReadonlyArray<schemas.SomeType>;\nexport type AnyFunc = (...args: any[]) => any;\nexport type IsProp<T, K extends keyof T> = T[K] extends AnyFunc ? never : K;\nexport type MaybeAsync<T> = T | Promise<T>;\nexport type KeyOf<T> = keyof OmitIndexSignature<T>;\nexport type OmitIndexSignature<T> = {\n    [K in keyof T as string extends K ? never : K extends string ? K : never]: T[K];\n};\nexport type ExtractIndexSignature<T> = {\n    [K in keyof T as string extends K ? K : K extends string ? never : K]: T[K];\n};\nexport type Keys<T extends object> = keyof OmitIndexSignature<T>;\nexport type SchemaClass<T extends schemas.SomeType> = {\n    new (def: T[\"_zod\"][\"def\"]): T;\n};\nexport type EnumValue = string | number;\nexport type EnumLike = Readonly<Record<string, EnumValue>>;\nexport type ToEnum<T extends EnumValue> = Flatten<{\n    [k in T]: k;\n}>;\nexport type KeysEnum<T extends object> = ToEnum<Exclude<keyof T, symbol>>;\nexport type KeysArray<T extends object> = Flatten<(keyof T & string)[]>;\nexport type Literal = string | number | bigint | boolean | null | undefined;\nexport type LiteralArray = Array<Literal>;\nexport type Primitive = string | number | symbol | bigint | boolean | null | undefined;\nexport type PrimitiveArray = Array<Primitive>;\nexport type HasSize = {\n    size: number;\n};\nexport type HasLength = {\n    length: number;\n};\nexport type Numeric = number | bigint | Date;\nexport type SafeParseResult<T> = SafeParseSuccess<T> | SafeParseError<T>;\nexport type SafeParseSuccess<T> = {\n    success: true;\n    data: T;\n    error?: never;\n};\nexport type SafeParseError<T> = {\n    success: false;\n    data?: never;\n    error: errors.$ZodError<T>;\n};\nexport type PropValues = Record<string, Set<Primitive>>;\nexport type PrimitiveSet = Set<Primitive>;\nexport declare function assertEqual<A, B>(val: AssertEqual<A, B>): AssertEqual<A, B>;\nexport declare function assertNotEqual<A, B>(val: AssertNotEqual<A, B>): AssertNotEqual<A, B>;\nexport declare function assertIs<T>(_arg: T): void;\nexport declare function assertNever(_x: never): never;\nexport declare function assert<T>(_: any): asserts _ is T;\nexport declare function getEnumValues(entries: EnumLike): EnumValue[];\nexport declare function joinValues<T extends Primitive[]>(array: T, separator?: string): string;\nexport declare function jsonStringifyReplacer(_: string, value: any): any;\nexport declare function cached<T>(getter: () => T): {\n    value: T;\n};\nexport declare function nullish(input: any): boolean;\nexport declare function cleanRegex(source: string): string;\nexport declare function floatSafeRemainder(val: number, step: number): number;\nexport declare function defineLazy<T, K extends keyof T>(object: T, key: K, getter: () => T[K]): void;\nexport declare function assignProp<T extends object, K extends PropertyKey>(target: T, prop: K, value: K extends keyof T ? T[K] : any): void;\nexport declare function getElementAtPath(obj: any, path: (string | number)[] | null | undefined): any;\nexport declare function promiseAllObject<T extends object>(promisesObj: T): Promise<{\n    [k in keyof T]: Awaited<T[k]>;\n}>;\nexport declare function randomString(length?: number): string;\nexport declare function esc(str: string): string;\nexport declare const captureStackTrace: (targetObject: object, constructorOpt?: Function) => void;\nexport declare function isObject(data: any): data is Record<PropertyKey, unknown>;\nexport declare const allowsEval: {\n    value: boolean;\n};\nexport declare function isPlainObject(o: any): o is Record<PropertyKey, unknown>;\nexport declare function numKeys(data: any): number;\nexport declare const getParsedType: (data: any) => ParsedTypes;\nexport declare const propertyKeyTypes: Set<string>;\nexport declare const primitiveTypes: Set<string>;\nexport declare function escapeRegex(str: string): string;\nexport declare function clone<T extends schemas.$ZodType>(inst: T, def?: T[\"_zod\"][\"def\"], params?: {\n    parent: boolean;\n}): T;\nexport type EmptyToNever<T> = keyof T extends never ? never : T;\nexport type Normalize<T> = T extends undefined ? never : T extends Record<any, any> ? Flatten<{\n    [k in keyof Omit<T, \"error\" | \"message\">]: T[k];\n} & (\"error\" extends keyof T ? {\n    error?: Exclude<T[\"error\"], string>;\n} : unknown)> : never;\nexport declare function normalizeParams<T>(_params: T): Normalize<T>;\nexport declare function createTransparentProxy<T extends object>(getter: () => T): T;\nexport declare function stringifyPrimitive(value: any): string;\nexport declare function optionalKeys(shape: schemas.$ZodShape): string[];\nexport type CleanKey<T extends PropertyKey> = T extends `?${infer K}` ? K : T extends `${infer K}?` ? K : T;\nexport type ToCleanMap<T extends schemas.$ZodLooseShape> = {\n    [k in keyof T]: k extends `?${infer K}` ? K : k extends `${infer K}?` ? K : k;\n};\nexport type FromCleanMap<T extends schemas.$ZodLooseShape> = {\n    [k in keyof T as k extends `?${infer K}` ? K : k extends `${infer K}?` ? K : k]: k;\n};\nexport declare const NUMBER_FORMAT_RANGES: Record<checks.$ZodNumberFormats, [number, number]>;\nexport declare const BIGINT_FORMAT_RANGES: Record<checks.$ZodBigIntFormats, [bigint, bigint]>;\nexport declare function pick(schema: schemas.$ZodObject, mask: Record<string, unknown>): any;\nexport declare function omit(schema: schemas.$ZodObject, mask: object): any;\nexport declare function extend(schema: schemas.$ZodObject, shape: schemas.$ZodShape): any;\nexport declare function merge(a: schemas.$ZodObject, b: schemas.$ZodObject): any;\nexport declare function partial(Class: SchemaClass<schemas.$ZodOptional> | null, schema: schemas.$ZodObject, mask: object | undefined): any;\nexport declare function required(Class: SchemaClass<schemas.$ZodNonOptional>, schema: schemas.$ZodObject, mask: object | undefined): any;\nexport type Constructor<T, Def extends any[] = any[]> = new (...args: Def) => T;\nexport declare function aborted(x: schemas.ParsePayload, startIndex?: number): boolean;\nexport declare function prefixIssues(path: PropertyKey, issues: errors.$ZodRawIssue[]): errors.$ZodRawIssue[];\nexport declare function unwrapMessage(message: string | {\n    message: string;\n} | undefined | null): string | undefined;\nexport declare function finalizeIssue(iss: errors.$ZodRawIssue, ctx: schemas.ParseContextInternal | undefined, config: $ZodConfig): errors.$ZodIssue;\nexport declare function getSizableOrigin(input: any): \"set\" | \"map\" | \"file\" | \"unknown\";\nexport declare function getLengthableOrigin(input: any): \"array\" | \"string\" | \"unknown\";\nexport declare function issue(_iss: string, input: any, inst: any): errors.$ZodRawIssue;\nexport declare function issue(_iss: errors.$ZodRawIssue): errors.$ZodRawIssue;\nexport declare function cleanEnum(obj: Record<string, EnumValue>): EnumValue[];\nexport declare abstract class Class {\n    constructor(..._args: any[]);\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/util.d.cts",
        "start": 4,
        "end": 183,
        "startLoc": {
          "line": 4,
          "column": 16,
          "position": 58
        },
        "endLoc": {
          "line": 183,
          "column": 2,
          "position": 4164
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/util.d.ts",
        "start": 4,
        "end": 183,
        "startLoc": {
          "line": 4,
          "column": 15,
          "position": 58
        },
        "endLoc": {
          "line": 183,
          "column": 2,
          "position": 4164
        }
      }
    },
    {
      "format": "typescript",
      "lines": 21,
      "fragment": "}>;\n        uri?: ((id: string) => string) | undefined;\n        defs: Record<string, JSONSchema.BaseSchema>;\n    } | undefined;\n}\ninterface Seen {\n    /** JSON Schema result for this Zod schema */\n    schema: JSONSchema.BaseSchema;\n    /** A cached version of the schema that doesn't get overwritten during ref resolution */\n    def?: JSONSchema.BaseSchema;\n    defId?: string | undefined;\n    /** Number of times this schema was encountered during traversal */\n    count: number;\n    /** Cycle path */\n    cycle?: (string | number)[] | undefined;\n    isParent?: boolean | undefined;\n    ref?: schemas.$ZodType | undefined | null;\n    /** JSON Schema property path for this schema */\n    path?: (string | number)[] | undefined;\n}\nexport declare",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/to-json-schema.d.ts",
        "start": 41,
        "end": 61,
        "startLoc": {
          "line": 41,
          "column": 9,
          "position": 269
        },
        "endLoc": {
          "line": 61,
          "column": 8,
          "position": 454
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/to-json-schema.ts",
        "start": 49,
        "end": 72,
        "startLoc": {
          "line": 49,
          "column": 2,
          "position": 307
        },
        "endLoc": {
          "line": 72,
          "column": 6,
          "position": 495
        }
      }
    },
    {
      "format": "typescript",
      "lines": 11,
      "fragment": "class JSONSchemaGenerator {\n    metadataRegistry: $ZodRegistry<Record<string, any>>;\n    target: \"draft-7\" | \"draft-2020-12\";\n    unrepresentable: \"throw\" | \"any\";\n    override: (ctx: {\n        zodSchema: schemas.$ZodTypes;\n        jsonSchema: JSONSchema.BaseSchema;\n        path: (string | number)[];\n    }) => void;\n    io: \"input\" | \"output\";\n    counter:",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/to-json-schema.d.ts",
        "start": 61,
        "end": 71,
        "startLoc": {
          "line": 61,
          "column": 2,
          "position": 456
        },
        "endLoc": {
          "line": 71,
          "column": 2,
          "position": 564
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/to-json-schema.ts",
        "start": 72,
        "end": 83,
        "startLoc": {
          "line": 72,
          "column": 2,
          "position": 495
        },
        "endLoc": {
          "line": 83,
          "column": 2,
          "position": 605
        }
      }
    },
    {
      "format": "typescript",
      "lines": 86,
      "fragment": ";\ninterface JSONSchemaGeneratorParams {\n    /** A registry used to look up metadata for each schema. Any schema with an `id` property will be extracted as a $def.\n     *  @default globalRegistry */\n    metadata?: $ZodRegistry<Record<string, any>>;\n    /** The JSON Schema version to target.\n     * - `\"draft-2020-12\"`  Default. JSON Schema Draft 2020-12\n     * - `\"draft-7\"`  JSON Schema Draft 7 */\n    target?: \"draft-7\" | \"draft-2020-12\";\n    /** How to handle unrepresentable types.\n     * - `\"throw\"`  Default. Unrepresentable types throw an error\n     * - `\"any\"`  Unrepresentable types become `{}` */\n    unrepresentable?: \"throw\" | \"any\";\n    /** Arbitrary custom logic that can be used to modify the generated JSON Schema. */\n    override?: (ctx: {\n        zodSchema: schemas.$ZodTypes;\n        jsonSchema: JSONSchema.BaseSchema;\n        path: (string | number)[];\n    }) => void;\n    /** Whether to extract the `\"input\"` or `\"output\"` type. Relevant to transforms, Error converting schema to JSONz, defaults, coerced primitives, etc.\n     * - `\"output\"`  Default. Convert the output schema.\n     * - `\"input\"`  Convert the input schema. */\n    io?: \"input\" | \"output\";\n}\ninterface ProcessParams {\n    schemaPath: schemas.$ZodType[];\n    path: (string | number)[];\n}\ninterface EmitParams {\n    /** How to handle cycles.\n     * - `\"ref\"`  Default. Cycles will be broken using $defs\n     * - `\"throw\"`  Cycles will throw an error if encountered */\n    cycles?: \"ref\" | \"throw\";\n    reused?: \"ref\" | \"inline\";\n    external?: {\n        /**  */\n        registry: $ZodRegistry<{\n            id?: string | undefined;\n        }>;\n        uri?: ((id: string) => string) | undefined;\n        defs: Record<string, JSONSchema.BaseSchema>;\n    } | undefined;\n}\ninterface Seen {\n    /** JSON Schema result for this Zod schema */\n    schema: JSONSchema.BaseSchema;\n    /** A cached version of the schema that doesn't get overwritten during ref resolution */\n    def?: JSONSchema.BaseSchema;\n    defId?: string | undefined;\n    /** Number of times this schema was encountered during traversal */\n    count: number;\n    /** Cycle path */\n    cycle?: (string | number)[] | undefined;\n    isParent?: boolean | undefined;\n    ref?: schemas.$ZodType | undefined | null;\n    /** JSON Schema property path for this schema */\n    path?: (string | number)[] | undefined;\n}\nexport declare class JSONSchemaGenerator {\n    metadataRegistry: $ZodRegistry<Record<string, any>>;\n    target: \"draft-7\" | \"draft-2020-12\";\n    unrepresentable: \"throw\" | \"any\";\n    override: (ctx: {\n        zodSchema: schemas.$ZodTypes;\n        jsonSchema: JSONSchema.BaseSchema;\n        path: (string | number)[];\n    }) => void;\n    io: \"input\" | \"output\";\n    counter: number;\n    seen: Map<schemas.$ZodType, Seen>;\n    constructor(params?: JSONSchemaGeneratorParams);\n    process(schema: schemas.$ZodType, _params?: ProcessParams): JSONSchema.BaseSchema;\n    emit(schema: schemas.$ZodType, _params?: EmitParams): JSONSchema.BaseSchema;\n}\ninterface ToJSONSchemaParams extends Omit<JSONSchemaGeneratorParams & EmitParams, \"external\"> {\n}\ninterface RegistryToJSONSchemaParams extends Omit<JSONSchemaGeneratorParams & EmitParams, \"external\"> {\n    uri?: (id: string) => string;\n}\nexport declare function toJSONSchema(schema: schemas.$ZodType, _params?: ToJSONSchemaParams): JSONSchema.BaseSchema;\nexport declare function toJSONSchema(registry: $ZodRegistry<{\n    id?: string | undefined;\n}>, _params?: RegistryToJSONSchemaParams): {\n    schemas: Record<string, JSONSchema.BaseSchema>;\n};\nexport {};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/to-json-schema.d.cts",
        "start": 3,
        "end": 88,
        "startLoc": {
          "line": 3,
          "column": 16,
          "position": 41
        },
        "endLoc": {
          "line": 88,
          "column": 2,
          "position": 798
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/to-json-schema.d.ts",
        "start": 3,
        "end": 88,
        "startLoc": {
          "line": 3,
          "column": 15,
          "position": 41
        },
        "endLoc": {
          "line": 88,
          "column": 2,
          "position": 798
        }
      }
    },
    {
      "format": "typescript",
      "lines": 12,
      "fragment": "interface Props<Input = unknown, Output = Input> {\n        /** The version number of the standard. */\n        readonly version: 1;\n        /** The vendor name of the schema library. */\n        readonly vendor: string;\n        /** Validates unknown input values. */\n        readonly validate: (value: unknown) => Result<Output> | Promise<Result<Output>>;\n        /** Inferred types associated with the schema. */\n        readonly types?: Types<Input, Output> | undefined;\n    }\n    /** The result interface of the validate function. */\n    type",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/standard-schema.d.ts",
        "start": 8,
        "end": 19,
        "startLoc": {
          "line": 8,
          "column": 5,
          "position": 60
        },
        "endLoc": {
          "line": 19,
          "column": 5,
          "position": 167
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/standard-schema.ts",
        "start": 9,
        "end": 21,
        "startLoc": {
          "line": 9,
          "column": 2,
          "position": 63
        },
        "endLoc": {
          "line": 21,
          "column": 7,
          "position": 171
        }
      }
    },
    {
      "format": "typescript",
      "lines": 55,
      "fragment": "/** The Standard Schema interface. */\nexport interface StandardSchemaV1<Input = unknown, Output = Input> {\n    /** The Standard Schema properties. */\n    readonly \"~standard\": StandardSchemaV1.Props<Input, Output>;\n}\nexport declare namespace StandardSchemaV1 {\n    /** The Standard Schema properties interface. */\n    interface Props<Input = unknown, Output = Input> {\n        /** The version number of the standard. */\n        readonly version: 1;\n        /** The vendor name of the schema library. */\n        readonly vendor: string;\n        /** Validates unknown input values. */\n        readonly validate: (value: unknown) => Result<Output> | Promise<Result<Output>>;\n        /** Inferred types associated with the schema. */\n        readonly types?: Types<Input, Output> | undefined;\n    }\n    /** The result interface of the validate function. */\n    type Result<Output> = SuccessResult<Output> | FailureResult;\n    /** The result interface if validation succeeds. */\n    interface SuccessResult<Output> {\n        /** The typed output value. */\n        readonly value: Output;\n        /** The non-existent issues. */\n        readonly issues?: undefined;\n    }\n    /** The result interface if validation fails. */\n    interface FailureResult {\n        /** The issues of failed validation. */\n        readonly issues: ReadonlyArray<Issue>;\n    }\n    /** The issue interface of the failure output. */\n    interface Issue {\n        /** The error message of the issue. */\n        readonly message: string;\n        /** The path of the issue, if any. */\n        readonly path?: ReadonlyArray<PropertyKey | PathSegment> | undefined;\n    }\n    /** The path segment interface of the issue. */\n    interface PathSegment {\n        /** The key representing a path segment. */\n        readonly key: PropertyKey;\n    }\n    /** The Standard Schema types interface. */\n    interface Types<Input = unknown, Output = Input> {\n        /** The input type of the schema. */\n        readonly input: Input;\n        /** The output type of the schema. */\n        readonly output: Output;\n    }\n    /** Infers the input type of a Standard Schema. */\n    type InferInput<Schema extends StandardSchemaV1> = NonNullable<Schema[\"~standard\"][\"types\"]>[\"input\"];\n    /** Infers the output type of a Standard Schema. */\n    type InferOutput<Schema extends StandardSchemaV1> = NonNullable<Schema[\"~standard\"][\"types\"]>[\"output\"];\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/standard-schema.d.cts",
        "start": 1,
        "end": 55,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 55,
          "column": 2,
          "position": 444
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/standard-schema.d.ts",
        "start": 1,
        "end": 55,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 55,
          "column": 2,
          "position": 444
        }
      }
    },
    {
      "format": "typescript",
      "lines": 34,
      "fragment": ";\nexport declare const $output: unique symbol;\nexport type $output = typeof $output;\nexport declare const $input: unique symbol;\nexport type $input = typeof $input;\nexport type $replace<Meta, S extends $ZodType> = Meta extends $output ? core.output<S> : Meta extends $input ? core.input<S> : Meta extends (infer M)[] ? $replace<M, S>[] : Meta extends (...args: infer P) => infer R ? (...args: {\n    [K in keyof P]: $replace<P[K], S>;\n}) => $replace<R, S> : Meta extends object ? {\n    [K in keyof Meta]: $replace<Meta[K], S>;\n} : Meta;\ntype MetadataType = Record<string, unknown> | undefined;\nexport declare class $ZodRegistry<Meta extends MetadataType = MetadataType, Schema extends $ZodType = $ZodType> {\n    _meta: Meta;\n    _schema: Schema;\n    _map: Map<Schema, $replace<Meta, Schema>>;\n    _idmap: Map<string, Schema>;\n    add<S extends Schema>(schema: S, ..._meta: undefined extends Meta ? [$replace<Meta, S>?] : [$replace<Meta, S>]): this;\n    clear(): this;\n    remove(schema: Schema): this;\n    get<S extends Schema>(schema: S): $replace<Meta, S> | undefined;\n    has(schema: Schema): boolean;\n}\nexport interface JSONSchemaMeta {\n    id?: string | undefined;\n    title?: string | undefined;\n    description?: string | undefined;\n    deprecated?: boolean | undefined;\n    [k: string]: unknown;\n}\nexport interface GlobalMeta extends JSONSchemaMeta {\n}\nexport declare function registry<T extends MetadataType = MetadataType, S extends $ZodType = $ZodType>(): $ZodRegistry<T, S>;\nexport declare const globalRegistry: $ZodRegistry<GlobalMeta>;\nexport {};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/registries.d.cts",
        "start": 2,
        "end": 35,
        "startLoc": {
          "line": 2,
          "column": 16,
          "position": 28
        },
        "endLoc": {
          "line": 35,
          "column": 2,
          "position": 635
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/registries.d.ts",
        "start": 2,
        "end": 35,
        "startLoc": {
          "line": 2,
          "column": 15,
          "position": 28
        },
        "endLoc": {
          "line": 35,
          "column": 2,
          "position": 635
        }
      }
    },
    {
      "format": "typescript",
      "lines": 62,
      "fragment": "export declare const cuid: RegExp;\nexport declare const cuid2: RegExp;\nexport declare const ulid: RegExp;\nexport declare const xid: RegExp;\nexport declare const ksuid: RegExp;\nexport declare const nanoid: RegExp;\n/** ISO 8601-1 duration regex. Does not support the 8601-2 extensions like negative durations or fractional/negative components. */\nexport declare const duration: RegExp;\n/** Implements ISO 8601-2 extensions like explicit +- prefixes, mixing weeks with other units, and fractional/negative components. */\nexport declare const extendedDuration: RegExp;\n/** A regex for any UUID-like identifier: 8-4-4-4-12 hex pattern */\nexport declare const guid: RegExp;\n/** Returns a regex for validating an RFC 4122 UUID.\n *\n * @param version Optionally specify a version 1-8. If no version is specified, all versions are supported. */\nexport declare const uuid: (version?: number | undefined) => RegExp;\nexport declare const uuid4: RegExp;\nexport declare const uuid6: RegExp;\nexport declare const uuid7: RegExp;\n/** Practical email validation */\nexport declare const email: RegExp;\n/** Equivalent to the HTML5 input[type=email] validation implemented by browsers. Source: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email */\nexport declare const html5Email: RegExp;\n/** The classic emailregex.com regex for RFC 5322-compliant emails */\nexport declare const rfc5322Email: RegExp;\n/** A loose regex that allows Unicode characters, enforces length limits, and that's about it. */\nexport declare const unicodeEmail: RegExp;\nexport declare const browserEmail: RegExp;\nexport declare const _emoji = \"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\";\nexport declare function emoji(): RegExp;\nexport declare const ipv4: RegExp;\nexport declare const ipv6: RegExp;\nexport declare const cidrv4: RegExp;\nexport declare const cidrv6: RegExp;\nexport declare const base64: RegExp;\nexport declare const base64url: RegExp;\nexport declare const hostname: RegExp;\nexport declare const domain: RegExp;\nexport declare const e164: RegExp;\nexport declare const date: RegExp;\nexport declare function time(args: {\n    precision?: number | null;\n}): RegExp;\nexport declare function datetime(args: {\n    precision?: number | null;\n    offset?: boolean;\n    local?: boolean;\n}): RegExp;\nexport declare const string: (params?: {\n    minimum?: number | undefined;\n    maximum?: number | undefined;\n}) => RegExp;\nexport declare const bigint: RegExp;\nexport declare const integer: RegExp;\nexport declare const number: RegExp;\nexport declare const boolean: RegExp;\ndeclare const _null: RegExp;\nexport { _null as null };\ndeclare const _undefined: RegExp;\nexport { _undefined as undefined };\nexport declare const lowercase: RegExp;\nexport declare const uppercase: RegExp;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/regexes.d.cts",
        "start": 1,
        "end": 62,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 62,
          "column": 2,
          "position": 637
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/regexes.d.ts",
        "start": 1,
        "end": 62,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 62,
          "column": 2,
          "position": 637
        }
      }
    },
    {
      "format": "typescript",
      "lines": 22,
      "fragment": ";\nexport type $ZodErrorClass = {\n    new (issues: errors.$ZodIssue[]): errors.$ZodError;\n};\nexport type $Parse = <T extends schemas.$ZodType>(schema: T, value: unknown, _ctx?: schemas.ParseContext<errors.$ZodIssue>, _params?: {\n    callee?: util.AnyFunc;\n    Err?: $ZodErrorClass;\n}) => core.output<T>;\nexport declare const _parse: (_Err: $ZodErrorClass) => $Parse;\nexport declare const parse: $Parse;\nexport type $ParseAsync = <T extends schemas.$ZodType>(schema: T, value: unknown, _ctx?: schemas.ParseContext<errors.$ZodIssue>, _params?: {\n    callee?: util.AnyFunc;\n    Err?: $ZodErrorClass;\n}) => Promise<core.output<T>>;\nexport declare const _parseAsync: (_Err: $ZodErrorClass) => $ParseAsync;\nexport declare const parseAsync: $ParseAsync;\nexport type $SafeParse = <T extends schemas.$ZodType>(schema: T, value: unknown, _ctx?: schemas.ParseContext<errors.$ZodIssue>) => util.SafeParseResult<core.output<T>>;\nexport declare const _safeParse: (_Err: $ZodErrorClass) => $SafeParse;\nexport declare const safeParse: $SafeParse;\nexport type $SafeParseAsync = <T extends schemas.$ZodType>(schema: T, value: unknown, _ctx?: schemas.ParseContext<errors.$ZodIssue>) => Promise<util.SafeParseResult<core.output<T>>>;\nexport declare const _safeParseAsync: (_Err: $ZodErrorClass) => $SafeParseAsync;\nexport declare const safeParseAsync: $SafeParseAsync;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/parse.d.cts",
        "start": 4,
        "end": 25,
        "startLoc": {
          "line": 4,
          "column": 13,
          "position": 52
        },
        "endLoc": {
          "line": 25,
          "column": 2,
          "position": 499
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/parse.d.ts",
        "start": 4,
        "end": 25,
        "startLoc": {
          "line": 4,
          "column": 12,
          "position": 52
        },
        "endLoc": {
          "line": 25,
          "column": 2,
          "position": 499
        }
      }
    },
    {
      "format": "typescript",
      "lines": 51,
      "fragment": "export type _JSONSchema = boolean | JSONSchema;\nexport type JSONSchema = {\n    [k: string]: unknown;\n    $schema?: \"https://json-schema.org/draft/2020-12/schema\" | \"http://json-schema.org/draft-07/schema#\";\n    $id?: string;\n    $anchor?: string;\n    $ref?: string;\n    $dynamicRef?: string;\n    $dynamicAnchor?: string;\n    $vocabulary?: Record<string, boolean>;\n    $comment?: string;\n    $defs?: Record<string, JSONSchema>;\n    type?: \"object\" | \"array\" | \"string\" | \"number\" | \"boolean\" | \"null\" | \"integer\";\n    additionalItems?: _JSONSchema;\n    unevaluatedItems?: _JSONSchema;\n    prefixItems?: _JSONSchema[];\n    items?: _JSONSchema | _JSONSchema[];\n    contains?: _JSONSchema;\n    additionalProperties?: _JSONSchema;\n    unevaluatedProperties?: _JSONSchema;\n    properties?: Record<string, _JSONSchema>;\n    patternProperties?: Record<string, _JSONSchema>;\n    dependentSchemas?: Record<string, _JSONSchema>;\n    propertyNames?: _JSONSchema;\n    if?: _JSONSchema;\n    then?: _JSONSchema;\n    else?: _JSONSchema;\n    allOf?: JSONSchema[];\n    anyOf?: JSONSchema[];\n    oneOf?: JSONSchema[];\n    not?: _JSONSchema;\n    multipleOf?: number;\n    maximum?: number;\n    exclusiveMaximum?: number;\n    minimum?: number;\n    exclusiveMinimum?: number;\n    maxLength?: number;\n    minLength?: number;\n    pattern?: string;\n    maxItems?: number;\n    minItems?: number;\n    uniqueItems?: boolean;\n    maxContains?: number;\n    minContains?: number;\n    maxProperties?: number;\n    minProperties?: number;\n    required?: string[];\n    dependentRequired?: Record<string, string[]>;\n    enum?: Array<string | number | boolean | null>;\n    const?: string | number | boolean | null;\n    id",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/json-schema.d.ts",
        "start": 2,
        "end": 52,
        "startLoc": {
          "line": 2,
          "column": 1,
          "position": 35
        },
        "endLoc": {
          "line": 52,
          "column": 3,
          "position": 558
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/json-schema.ts",
        "start": 45,
        "end": 96,
        "startLoc": {
          "line": 45,
          "column": 1,
          "position": 115
        },
        "endLoc": {
          "line": 96,
          "column": 12,
          "position": 639
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "id?: string;\n    title?: string;\n    description?: string;\n    default?: unknown;\n    deprecated?: boolean;\n    readOnly?: boolean;\n    writeOnly?: boolean;\n    examples?: unknown[];\n    format?: string;\n    contentMediaType?: string;\n    contentEncoding?: string;\n    contentSchema?: JSONSchema;\n    _prefault",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/json-schema.d.ts",
        "start": 52,
        "end": 64,
        "startLoc": {
          "line": 52,
          "column": 5,
          "position": 558
        },
        "endLoc": {
          "line": 64,
          "column": 10,
          "position": 656
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/json-schema.ts",
        "start": 97,
        "end": 110,
        "startLoc": {
          "line": 97,
          "column": 3,
          "position": 642
        },
        "endLoc": {
          "line": 110,
          "column": 12,
          "position": 741
        }
      }
    },
    {
      "format": "typescript",
      "lines": 22,
      "fragment": "export type BaseSchema = JSONSchema;\nexport interface ObjectSchema extends JSONSchema {\n    type: \"object\";\n}\nexport interface ArraySchema extends JSONSchema {\n    type: \"array\";\n}\nexport interface StringSchema extends JSONSchema {\n    type: \"string\";\n}\nexport interface NumberSchema extends JSONSchema {\n    type: \"number\";\n}\nexport interface IntegerSchema extends JSONSchema {\n    type: \"integer\";\n}\nexport interface BooleanSchema extends JSONSchema {\n    type: \"boolean\";\n}\nexport interface NullSchema extends JSONSchema {\n    type: \"null\";\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/json-schema.d.ts",
        "start": 66,
        "end": 87,
        "startLoc": {
          "line": 66,
          "column": 1,
          "position": 666
        },
        "endLoc": {
          "line": 87,
          "column": 2,
          "position": 822
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/json-schema.ts",
        "start": 115,
        "end": 143,
        "startLoc": {
          "line": 115,
          "column": 1,
          "position": 757
        },
        "endLoc": {
          "line": 143,
          "column": 2,
          "position": 920
        }
      }
    },
    {
      "format": "typescript",
      "lines": 87,
      "fragment": "export type Schema = ObjectSchema | ArraySchema | StringSchema | NumberSchema | IntegerSchema | BooleanSchema | NullSchema;\nexport type _JSONSchema = boolean | JSONSchema;\nexport type JSONSchema = {\n    [k: string]: unknown;\n    $schema?: \"https://json-schema.org/draft/2020-12/schema\" | \"http://json-schema.org/draft-07/schema#\";\n    $id?: string;\n    $anchor?: string;\n    $ref?: string;\n    $dynamicRef?: string;\n    $dynamicAnchor?: string;\n    $vocabulary?: Record<string, boolean>;\n    $comment?: string;\n    $defs?: Record<string, JSONSchema>;\n    type?: \"object\" | \"array\" | \"string\" | \"number\" | \"boolean\" | \"null\" | \"integer\";\n    additionalItems?: _JSONSchema;\n    unevaluatedItems?: _JSONSchema;\n    prefixItems?: _JSONSchema[];\n    items?: _JSONSchema | _JSONSchema[];\n    contains?: _JSONSchema;\n    additionalProperties?: _JSONSchema;\n    unevaluatedProperties?: _JSONSchema;\n    properties?: Record<string, _JSONSchema>;\n    patternProperties?: Record<string, _JSONSchema>;\n    dependentSchemas?: Record<string, _JSONSchema>;\n    propertyNames?: _JSONSchema;\n    if?: _JSONSchema;\n    then?: _JSONSchema;\n    else?: _JSONSchema;\n    allOf?: JSONSchema[];\n    anyOf?: JSONSchema[];\n    oneOf?: JSONSchema[];\n    not?: _JSONSchema;\n    multipleOf?: number;\n    maximum?: number;\n    exclusiveMaximum?: number;\n    minimum?: number;\n    exclusiveMinimum?: number;\n    maxLength?: number;\n    minLength?: number;\n    pattern?: string;\n    maxItems?: number;\n    minItems?: number;\n    uniqueItems?: boolean;\n    maxContains?: number;\n    minContains?: number;\n    maxProperties?: number;\n    minProperties?: number;\n    required?: string[];\n    dependentRequired?: Record<string, string[]>;\n    enum?: Array<string | number | boolean | null>;\n    const?: string | number | boolean | null;\n    id?: string;\n    title?: string;\n    description?: string;\n    default?: unknown;\n    deprecated?: boolean;\n    readOnly?: boolean;\n    writeOnly?: boolean;\n    examples?: unknown[];\n    format?: string;\n    contentMediaType?: string;\n    contentEncoding?: string;\n    contentSchema?: JSONSchema;\n    _prefault?: unknown;\n};\nexport type BaseSchema = JSONSchema;\nexport interface ObjectSchema extends JSONSchema {\n    type: \"object\";\n}\nexport interface ArraySchema extends JSONSchema {\n    type: \"array\";\n}\nexport interface StringSchema extends JSONSchema {\n    type: \"string\";\n}\nexport interface NumberSchema extends JSONSchema {\n    type: \"number\";\n}\nexport interface IntegerSchema extends JSONSchema {\n    type: \"integer\";\n}\nexport interface BooleanSchema extends JSONSchema {\n    type: \"boolean\";\n}\nexport interface NullSchema extends JSONSchema {\n    type: \"null\";\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/json-schema.d.cts",
        "start": 1,
        "end": 87,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 87,
          "column": 2,
          "position": 822
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/json-schema.d.ts",
        "start": 1,
        "end": 143,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 143,
          "column": 2,
          "position": 920
        }
      }
    },
    {
      "format": "typescript",
      "lines": 15,
      "fragment": "export * from \"./core.js\";\nexport * from \"./parse.js\";\nexport * from \"./errors.js\";\nexport * from \"./schemas.js\";\nexport * from \"./checks.js\";\nexport * from \"./versions.js\";\nexport * as util from \"./util.js\";\nexport * as regexes from \"./regexes.js\";\nexport * as locales from \"../locales/index.js\";\nexport * from \"./registries.js\";\nexport * from \"./doc.js\";\nexport * from \"./function.js\";\nexport * from \"./api.js\";\nexport * from \"./to-json-schema.js\";\nexport * as JSONSchema from \"./json-schema.js\";",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/index.d.ts",
        "start": 1,
        "end": 15,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 15,
          "column": 2,
          "position": 149
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/index.ts",
        "start": 1,
        "end": 15,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 15,
          "column": 2,
          "position": 149
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "> {\n    type: \"function\";\n    input: In;\n    output: Out;\n}\nexport type $ZodFunctionArgs = schemas.$ZodType<unknown[], unknown[]>;\nexport type $ZodFunctionIn = $ZodFunctionArgs;\nexport type $ZodFunctionOut = schemas.$ZodType;\nexport type $InferInnerFunctionType<Args extends $ZodFunctionIn, Returns extends $ZodFunctionOut> = (...args: $ZodFunctionIn extends Args ? never[] : core.output<Args>) => core.input<Returns>;\nexport type $InferInnerFunctionTypeAsync<Args extends $ZodFunctionIn, Returns extends $ZodFunctionOut> = (...args: $ZodFunctionIn extends Args ? never[] : core.output<Args>) => util.MaybeAsync<core.input<Returns>>;\nexport type $InferOuterFunctionType<Args extends $ZodFunctionIn, Returns extends $ZodFunctionOut> = (...args: $ZodFunctionIn extends Args ? never[] : core.input<Args>) => core.output<Returns>;\nexport type $InferOuterFunctionTypeAsync<Args extends $ZodFunctionIn, Returns extends $ZodFunctionOut> = (...args: $ZodFunctionIn extends Args ? never[] : core.input<Args>) => util.MaybeAsync<core.output<Returns>>;\nexport declare",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/function.d.ts",
        "start": 5,
        "end": 17,
        "startLoc": {
          "line": 5,
          "column": 16,
          "position": 82
        },
        "endLoc": {
          "line": 17,
          "column": 8,
          "position": 402
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/function.ts",
        "start": 18,
        "end": 44,
        "startLoc": {
          "line": 18,
          "column": 1,
          "position": 137
        },
        "endLoc": {
          "line": 44,
          "column": 6,
          "position": 475
        }
      }
    },
    {
      "format": "typescript",
      "lines": 49,
      "fragment": ";\nexport interface $ZodFunctionDef<In extends $ZodFunctionIn = $ZodFunctionIn, Out extends $ZodFunctionOut = $ZodFunctionOut> {\n    type: \"function\";\n    input: In;\n    output: Out;\n}\nexport type $ZodFunctionArgs = schemas.$ZodType<unknown[], unknown[]>;\nexport type $ZodFunctionIn = $ZodFunctionArgs;\nexport type $ZodFunctionOut = schemas.$ZodType;\nexport type $InferInnerFunctionType<Args extends $ZodFunctionIn, Returns extends $ZodFunctionOut> = (...args: $ZodFunctionIn extends Args ? never[] : core.output<Args>) => core.input<Returns>;\nexport type $InferInnerFunctionTypeAsync<Args extends $ZodFunctionIn, Returns extends $ZodFunctionOut> = (...args: $ZodFunctionIn extends Args ? never[] : core.output<Args>) => util.MaybeAsync<core.input<Returns>>;\nexport type $InferOuterFunctionType<Args extends $ZodFunctionIn, Returns extends $ZodFunctionOut> = (...args: $ZodFunctionIn extends Args ? never[] : core.input<Args>) => core.output<Returns>;\nexport type $InferOuterFunctionTypeAsync<Args extends $ZodFunctionIn, Returns extends $ZodFunctionOut> = (...args: $ZodFunctionIn extends Args ? never[] : core.input<Args>) => util.MaybeAsync<core.output<Returns>>;\nexport declare class $ZodFunction<Args extends $ZodFunctionIn = $ZodFunctionIn, Returns extends $ZodFunctionOut = $ZodFunctionOut> {\n    def: $ZodFunctionDef<Args, Returns>;\n    /** @deprecated */\n    _def: $ZodFunctionDef<Args, Returns>;\n    _input: $InferInnerFunctionType<Args, Returns>;\n    _output: $InferOuterFunctionType<Args, Returns>;\n    constructor(def: $ZodFunctionDef<Args, Returns>);\n    implement<F extends $InferInnerFunctionType<Args, Returns>>(func: F): (...args: Parameters<this[\"_output\"]>) => ReturnType<F> extends ReturnType<this[\"_output\"]> ? ReturnType<F> : ReturnType<this[\"_output\"]>;\n    implementAsync<F extends $InferInnerFunctionTypeAsync<Args, Returns>>(func: F): F extends $InferOuterFunctionTypeAsync<Args, Returns> ? F : $InferOuterFunctionTypeAsync<Args, Returns>;\n    input<const Items extends util.TupleItems, const Rest extends $ZodFunctionOut = $ZodFunctionOut>(args: Items, rest?: Rest): $ZodFunction<schemas.$ZodTuple<Items, Rest>, Returns>;\n    input<NewArgs extends $ZodFunctionIn>(args: NewArgs): $ZodFunction<NewArgs, Returns>;\n    output<NewReturns extends schemas.$ZodType>(output: NewReturns): $ZodFunction<Args, NewReturns>;\n}\nexport interface $ZodFunctionParams<I extends $ZodFunctionIn, O extends schemas.$ZodType> {\n    input?: I;\n    output?: O;\n}\ndeclare function _function(): $ZodFunction;\ndeclare function _function<const In extends Array<schemas.$ZodType> = Array<schemas.$ZodType>>(params: {\n    input: In;\n}): $ZodFunction<$ZodTuple<In, null>, $ZodFunctionOut>;\ndeclare function _function<const In extends Array<schemas.$ZodType> = Array<schemas.$ZodType>, const Out extends $ZodFunctionOut = $ZodFunctionOut>(params: {\n    input: In;\n    output: Out;\n}): $ZodFunction<$ZodTuple<In, null>, Out>;\ndeclare function _function<const In extends $ZodFunctionIn = $ZodFunctionIn>(params: {\n    input: In;\n}): $ZodFunction<In, $ZodFunctionOut>;\ndeclare function _function<const Out extends $ZodFunctionOut = $ZodFunctionOut>(params: {\n    output: Out;\n}): $ZodFunction<$ZodFunctionIn, Out>;\ndeclare function _function<In extends $ZodFunctionIn = $ZodFunctionIn, Out extends schemas.$ZodType = schemas.$ZodType>(params?: {\n    input: In;\n    output: Out;\n}): $ZodFunction<In, Out>;\nexport { _function as function };",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/function.d.cts",
        "start": 4,
        "end": 52,
        "startLoc": {
          "line": 4,
          "column": 13,
          "position": 54
        },
        "endLoc": {
          "line": 52,
          "column": 2,
          "position": 1094
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/function.d.ts",
        "start": 4,
        "end": 52,
        "startLoc": {
          "line": 4,
          "column": 12,
          "position": 54
        },
        "endLoc": {
          "line": 52,
          "column": 2,
          "position": 1094
        }
      }
    },
    {
      "format": "typescript",
      "lines": 68,
      "fragment": "export interface $ZodIssueInvalidType<Input = unknown> extends $ZodIssueBase {\n    readonly code: \"invalid_type\";\n    readonly expected: $ZodType[\"_zod\"][\"def\"][\"type\"];\n    readonly input: Input;\n}\nexport interface $ZodIssueTooBig<Input = unknown> extends $ZodIssueBase {\n    readonly code: \"too_big\";\n    readonly origin: \"number\" | \"int\" | \"bigint\" | \"date\" | \"string\" | \"array\" | \"set\" | \"file\" | (string & {});\n    readonly maximum: number | bigint;\n    readonly inclusive?: boolean;\n    readonly exact?: boolean;\n    readonly input: Input;\n}\nexport interface $ZodIssueTooSmall<Input = unknown> extends $ZodIssueBase {\n    readonly code: \"too_small\";\n    readonly origin: \"number\" | \"int\" | \"bigint\" | \"date\" | \"string\" | \"array\" | \"set\" | \"file\" | (string & {});\n    readonly minimum: number | bigint;\n    /** True if the allowable range includes the minimum */\n    readonly inclusive?: boolean;\n    /** True if the allowed value is fixed (e.g.` z.length(5)`), not a range (`z.minLength(5)`) */\n    readonly exact?: boolean;\n    readonly input: Input;\n}\nexport interface $ZodIssueInvalidStringFormat extends $ZodIssueBase {\n    readonly code: \"invalid_format\";\n    readonly format: $ZodStringFormats | (string & {});\n    readonly pattern?: string;\n    readonly input: string;\n}\nexport interface $ZodIssueNotMultipleOf<Input extends number | bigint = number | bigint> extends $ZodIssueBase {\n    readonly code: \"not_multiple_of\";\n    readonly divisor: number;\n    readonly input: Input;\n}\nexport interface $ZodIssueUnrecognizedKeys extends $ZodIssueBase {\n    readonly code: \"unrecognized_keys\";\n    readonly keys: string[];\n    readonly input: Record<string, unknown>;\n}\nexport interface $ZodIssueInvalidUnion extends $ZodIssueBase {\n    readonly code: \"invalid_union\";\n    readonly errors: $ZodIssue[][];\n    readonly input: unknown;\n}\nexport interface $ZodIssueInvalidKey<Input = unknown> extends $ZodIssueBase {\n    readonly code: \"invalid_key\";\n    readonly origin: \"map\" | \"record\";\n    readonly issues: $ZodIssue[];\n    readonly input: Input;\n}\nexport interface $ZodIssueInvalidElement<Input = unknown> extends $ZodIssueBase {\n    readonly code: \"invalid_element\";\n    readonly origin: \"map\" | \"set\";\n    readonly key: unknown;\n    readonly issues: $ZodIssue[];\n    readonly input: Input;\n}\nexport interface $ZodIssueInvalidValue<Input = unknown> extends $ZodIssueBase {\n    readonly code: \"invalid_value\";\n    readonly values: util.Primitive[];\n    readonly input: Input;\n}\nexport interface $ZodIssueCustom extends $ZodIssueBase {\n    readonly code: \"custom\";\n    readonly params?: Record<string, any> | undefined;\n    readonly input: unknown;\n}\nexport",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/errors.d.ts",
        "start": 11,
        "end": 78,
        "startLoc": {
          "line": 11,
          "column": 1,
          "position": 110
        },
        "endLoc": {
          "line": 78,
          "column": 7,
          "position": 868
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/errors.ts",
        "start": 20,
        "end": 98,
        "startLoc": {
          "line": 20,
          "column": 1,
          "position": 127
        },
        "endLoc": {
          "line": 98,
          "column": 45,
          "position": 896
        }
      }
    },
    {
      "format": "typescript",
      "lines": 24,
      "fragment": "export interface $ZodIssueStringCommonFormats extends $ZodIssueInvalidStringFormat {\n    format: Exclude<$ZodStringFormats, \"regex\" | \"jwt\" | \"starts_with\" | \"ends_with\" | \"includes\">;\n}\nexport interface $ZodIssueStringInvalidRegex extends $ZodIssueInvalidStringFormat {\n    format: \"regex\";\n    pattern: string;\n}\nexport interface $ZodIssueStringInvalidJWT extends $ZodIssueInvalidStringFormat {\n    format: \"jwt\";\n    algorithm?: string;\n}\nexport interface $ZodIssueStringStartsWith extends $ZodIssueInvalidStringFormat {\n    format: \"starts_with\";\n    prefix: string;\n}\nexport interface $ZodIssueStringEndsWith extends $ZodIssueInvalidStringFormat {\n    format: \"ends_with\";\n    suffix: string;\n}\nexport interface $ZodIssueStringIncludes extends $ZodIssueInvalidStringFormat {\n    format: \"includes\";\n    includes: string;\n}\nexport type $ZodStringFormatIssues = $ZodIssueStringCommonFormats",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/errors.d.ts",
        "start": 78,
        "end": 101,
        "startLoc": {
          "line": 78,
          "column": 1,
          "position": 868
        },
        "endLoc": {
          "line": 101,
          "column": 29,
          "position": 1060
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/errors.ts",
        "start": 102,
        "end": 132,
        "startLoc": {
          "line": 102,
          "column": 1,
          "position": 903
        },
        "endLoc": {
          "line": 132,
          "column": 2,
          "position": 1102
        }
      }
    },
    {
      "format": "typescript",
      "lines": 11,
      "fragment": "$ZodIssueInvalidType | $ZodIssueTooBig | $ZodIssueTooSmall | $ZodIssueInvalidStringFormat | $ZodIssueNotMultipleOf | $ZodIssueUnrecognizedKeys | $ZodIssueInvalidUnion | $ZodIssueInvalidKey | $ZodIssueInvalidElement | $ZodIssueInvalidValue | $ZodIssueCustom;\nexport type $ZodIssueCode = $ZodIssue[\"code\"];\nexport type $ZodRawIssue<T extends $ZodIssueBase = $ZodIssue> = T extends any ? RawIssue<T> : never;\ntype RawIssue<T extends $ZodIssueBase> = util.Flatten<util.MakePartial<T, \"message\" | \"path\"> & {\n    /** The input data */\n    readonly input?: unknown;\n    /** The schema or check that originated this issue. */\n    readonly inst?: $ZodType | $ZodCheck;\n    /** @deprecated Internal use only. If `true`, Zod will continue executing validation despite this issue. */\n    readonly continue?: boolean | undefined;\n} & Record<string, any>>",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/errors.d.ts",
        "start": 102,
        "end": 112,
        "startLoc": {
          "line": 102,
          "column": 2,
          "position": 1091
        },
        "endLoc": {
          "line": 112,
          "column": 3,
          "position": 1277
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/errors.ts",
        "start": 144,
        "end": 167,
        "startLoc": {
          "line": 144,
          "column": 2,
          "position": 1151
        },
        "endLoc": {
          "line": 167,
          "column": 2,
          "position": 1352
        }
      }
    },
    {
      "format": "typescript",
      "lines": 205,
      "fragment": ";\nexport interface $ZodIssueBase {\n    readonly code?: string;\n    readonly input?: unknown;\n    readonly path: PropertyKey[];\n    readonly message: string;\n}\nexport interface $ZodIssueInvalidType<Input = unknown> extends $ZodIssueBase {\n    readonly code: \"invalid_type\";\n    readonly expected: $ZodType[\"_zod\"][\"def\"][\"type\"];\n    readonly input: Input;\n}\nexport interface $ZodIssueTooBig<Input = unknown> extends $ZodIssueBase {\n    readonly code: \"too_big\";\n    readonly origin: \"number\" | \"int\" | \"bigint\" | \"date\" | \"string\" | \"array\" | \"set\" | \"file\" | (string & {});\n    readonly maximum: number | bigint;\n    readonly inclusive?: boolean;\n    readonly exact?: boolean;\n    readonly input: Input;\n}\nexport interface $ZodIssueTooSmall<Input = unknown> extends $ZodIssueBase {\n    readonly code: \"too_small\";\n    readonly origin: \"number\" | \"int\" | \"bigint\" | \"date\" | \"string\" | \"array\" | \"set\" | \"file\" | (string & {});\n    readonly minimum: number | bigint;\n    /** True if the allowable range includes the minimum */\n    readonly inclusive?: boolean;\n    /** True if the allowed value is fixed (e.g.` z.length(5)`), not a range (`z.minLength(5)`) */\n    readonly exact?: boolean;\n    readonly input: Input;\n}\nexport interface $ZodIssueInvalidStringFormat extends $ZodIssueBase {\n    readonly code: \"invalid_format\";\n    readonly format: $ZodStringFormats | (string & {});\n    readonly pattern?: string;\n    readonly input: string;\n}\nexport interface $ZodIssueNotMultipleOf<Input extends number | bigint = number | bigint> extends $ZodIssueBase {\n    readonly code: \"not_multiple_of\";\n    readonly divisor: number;\n    readonly input: Input;\n}\nexport interface $ZodIssueUnrecognizedKeys extends $ZodIssueBase {\n    readonly code: \"unrecognized_keys\";\n    readonly keys: string[];\n    readonly input: Record<string, unknown>;\n}\nexport interface $ZodIssueInvalidUnion extends $ZodIssueBase {\n    readonly code: \"invalid_union\";\n    readonly errors: $ZodIssue[][];\n    readonly input: unknown;\n}\nexport interface $ZodIssueInvalidKey<Input = unknown> extends $ZodIssueBase {\n    readonly code: \"invalid_key\";\n    readonly origin: \"map\" | \"record\";\n    readonly issues: $ZodIssue[];\n    readonly input: Input;\n}\nexport interface $ZodIssueInvalidElement<Input = unknown> extends $ZodIssueBase {\n    readonly code: \"invalid_element\";\n    readonly origin: \"map\" | \"set\";\n    readonly key: unknown;\n    readonly issues: $ZodIssue[];\n    readonly input: Input;\n}\nexport interface $ZodIssueInvalidValue<Input = unknown> extends $ZodIssueBase {\n    readonly code: \"invalid_value\";\n    readonly values: util.Primitive[];\n    readonly input: Input;\n}\nexport interface $ZodIssueCustom extends $ZodIssueBase {\n    readonly code: \"custom\";\n    readonly params?: Record<string, any> | undefined;\n    readonly input: unknown;\n}\nexport interface $ZodIssueStringCommonFormats extends $ZodIssueInvalidStringFormat {\n    format: Exclude<$ZodStringFormats, \"regex\" | \"jwt\" | \"starts_with\" | \"ends_with\" | \"includes\">;\n}\nexport interface $ZodIssueStringInvalidRegex extends $ZodIssueInvalidStringFormat {\n    format: \"regex\";\n    pattern: string;\n}\nexport interface $ZodIssueStringInvalidJWT extends $ZodIssueInvalidStringFormat {\n    format: \"jwt\";\n    algorithm?: string;\n}\nexport interface $ZodIssueStringStartsWith extends $ZodIssueInvalidStringFormat {\n    format: \"starts_with\";\n    prefix: string;\n}\nexport interface $ZodIssueStringEndsWith extends $ZodIssueInvalidStringFormat {\n    format: \"ends_with\";\n    suffix: string;\n}\nexport interface $ZodIssueStringIncludes extends $ZodIssueInvalidStringFormat {\n    format: \"includes\";\n    includes: string;\n}\nexport type $ZodStringFormatIssues = $ZodIssueStringCommonFormats | $ZodIssueStringInvalidRegex | $ZodIssueStringInvalidJWT | $ZodIssueStringStartsWith | $ZodIssueStringEndsWith | $ZodIssueStringIncludes;\nexport type $ZodIssue = $ZodIssueInvalidType | $ZodIssueTooBig | $ZodIssueTooSmall | $ZodIssueInvalidStringFormat | $ZodIssueNotMultipleOf | $ZodIssueUnrecognizedKeys | $ZodIssueInvalidUnion | $ZodIssueInvalidKey | $ZodIssueInvalidElement | $ZodIssueInvalidValue | $ZodIssueCustom;\nexport type $ZodIssueCode = $ZodIssue[\"code\"];\nexport type $ZodRawIssue<T extends $ZodIssueBase = $ZodIssue> = T extends any ? RawIssue<T> : never;\ntype RawIssue<T extends $ZodIssueBase> = util.Flatten<util.MakePartial<T, \"message\" | \"path\"> & {\n    /** The input data */\n    readonly input?: unknown;\n    /** The schema or check that originated this issue. */\n    readonly inst?: $ZodType | $ZodCheck;\n    /** @deprecated Internal use only. If `true`, Zod will continue executing validation despite this issue. */\n    readonly continue?: boolean | undefined;\n} & Record<string, any>>;\nexport interface $ZodErrorMap<T extends $ZodIssueBase = $ZodIssue> {\n    (issue: $ZodRawIssue<T>): {\n        message: string;\n    } | string | undefined | null;\n}\nexport interface $ZodError<T = unknown> extends Error {\n    type: T;\n    issues: $ZodIssue[];\n    _zod: {\n        output: T;\n        def: $ZodIssue[];\n    };\n    stack?: string;\n    name: string;\n}\nexport declare const $ZodError: $constructor<$ZodError>;\ninterface $ZodRealError<T = any> extends $ZodError<T> {\n}\nexport declare const $ZodRealError: $constructor<$ZodRealError>;\nexport type $ZodFlattenedError<T, U = string> = _FlattenedError<T, U>;\ntype _FlattenedError<T, U = string> = {\n    formErrors: U[];\n    fieldErrors: {\n        [P in keyof T]?: U[];\n    };\n};\nexport declare function flattenError<T>(error: $ZodError<T>): _FlattenedError<T>;\nexport declare function flattenError<T, U>(error: $ZodError<T>, mapper?: (issue: $ZodIssue) => U): _FlattenedError<T, U>;\ntype _ZodFormattedError<T, U = string> = T extends [any, ...any[]] ? {\n    [K in keyof T]?: $ZodFormattedError<T[K], U>;\n} : T extends any[] ? {\n    [k: number]: $ZodFormattedError<T[number], U>;\n} : T extends object ? util.Flatten<{\n    [K in keyof T]?: $ZodFormattedError<T[K], U>;\n}> : any;\nexport type $ZodFormattedError<T, U = string> = {\n    _errors: U[];\n} & util.Flatten<_ZodFormattedError<T, U>>;\nexport declare function formatError<T>(error: $ZodError<T>): $ZodFormattedError<T>;\nexport declare function formatError<T, U>(error: $ZodError<T>, mapper?: (issue: $ZodIssue) => U): $ZodFormattedError<T, U>;\nexport type $ZodErrorTree<T, U = string> = T extends [any, ...any[]] ? {\n    errors: U[];\n    items?: {\n        [K in keyof T]?: $ZodErrorTree<T[K], U>;\n    };\n} : T extends any[] ? {\n    errors: U[];\n    items?: Array<$ZodErrorTree<T[number], U>>;\n} : T extends object ? {\n    errors: U[];\n    properties?: {\n        [K in keyof T]?: $ZodErrorTree<T[K], U>;\n    };\n} : {\n    errors: U[];\n};\nexport declare function treeifyError<T>(error: $ZodError<T>): $ZodErrorTree<T>;\nexport declare function treeifyError<T, U>(error: $ZodError<T>, mapper?: (issue: $ZodIssue) => U): $ZodErrorTree<T, U>;\n/** Format a ZodError as a human-readable string in the following form.\n *\n * From\n *\n * ```ts\n * ZodError {\n *   issues: [\n *     {\n *       expected: 'string',\n *       code: 'invalid_type',\n *       path: [ 'username' ],\n *       message: 'Invalid input: expected string'\n *     },\n *     {\n *       expected: 'number',\n *       code: 'invalid_type',\n *       path: [ 'favoriteNumbers', 1 ],\n *       message: 'Invalid input: expected number'\n *     }\n *   ];\n * }\n * ```\n *\n * to\n *\n * ```\n * username\n *    Expected number, received string at \"username\n * favoriteNumbers[0]\n *    Invalid input: expected number\n * ```\n */\nexport declare function toDotPath(path: (string | number | symbol)[]): string;\ninterface BaseError {\n    issues: $ZodIssueBase[];\n}\nexport declare function prettifyError(error: BaseError): string;\nexport {};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/errors.d.cts",
        "start": 4,
        "end": 208,
        "startLoc": {
          "line": 4,
          "column": 13,
          "position": 58
        },
        "endLoc": {
          "line": 208,
          "column": 2,
          "position": 2249
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/errors.d.ts",
        "start": 4,
        "end": 208,
        "startLoc": {
          "line": 4,
          "column": 12,
          "position": 58
        },
        "endLoc": {
          "line": 208,
          "column": 2,
          "position": 2249
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": "type ModeWriter = (doc: Doc, modes: {\n    execution: \"sync\" | \"async\";\n}) => void;\nexport declare class Doc {\n    args: string[];\n    content: string[];\n    indent: number;\n    constructor(args?: string[]);\n    indented(fn: (doc: Doc) => void): void;\n    write(fn: ModeWriter): void;\n    write(line: string): void;\n    compile(): Function;\n}\nexport {};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/doc.d.cts",
        "start": 1,
        "end": 14,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 14,
          "column": 2,
          "position": 148
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/doc.d.ts",
        "start": 1,
        "end": 14,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 14,
          "column": 2,
          "position": 148
        }
      }
    },
    {
      "format": "typescript",
      "lines": 47,
      "fragment": ";\ntype ZodTrait = {\n    _zod: {\n        def: any;\n        [k: string]: any;\n    };\n};\nexport interface $constructor<T extends ZodTrait, D = T[\"_zod\"][\"def\"]> {\n    new (def: D): T;\n    init(inst: T, def: D): asserts inst is T;\n}\n/** A special constant with type `never` */\nexport declare const NEVER: never;\nexport declare function $constructor<T extends ZodTrait, D = T[\"_zod\"][\"def\"]>(name: string, initializer: (inst: T, def: D) => void, params?: {\n    Parent?: typeof Class;\n}): $constructor<T, D>;\nexport declare const $brand: unique symbol;\nexport type $brand<T extends string | number | symbol = string | number | symbol> = {\n    [$brand]: {\n        [k in T]: true;\n    };\n};\nexport type $ZodBranded<T extends schemas.SomeType, Brand extends string | number | symbol> = T & Record<\"_zod\", Record<\"output\", output<T> & $brand<Brand>>>;\nexport declare class $ZodAsyncError extends Error {\n    constructor();\n}\nexport type input<T> = T extends {\n    _zod: {\n        input: any;\n    };\n} ? Required<T[\"_zod\"]>[\"input\"] : unknown;\nexport type output<T> = T extends {\n    _zod: {\n        output: any;\n    };\n} ? Required<T[\"_zod\"]>[\"output\"] : unknown;\nexport type { output as infer };\nexport interface $ZodConfig {\n    /** Custom error map. Overrides `config().localeError`. */\n    customError?: errors.$ZodErrorMap | undefined;\n    /** Localized error map. Lowest priority. */\n    localeError?: errors.$ZodErrorMap | undefined;\n    /** Disable JIT schema compilation. Useful in environments that disallow `eval`. */\n    jitless?: boolean | undefined;\n}\nexport declare const globalConfig: $ZodConfig;\nexport declare function config(newConfig?: Partial<$ZodConfig>): $ZodConfig;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/core.d.cts",
        "start": 3,
        "end": 49,
        "startLoc": {
          "line": 3,
          "column": 13,
          "position": 43
        },
        "endLoc": {
          "line": 49,
          "column": 2,
          "position": 629
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/core.d.ts",
        "start": 3,
        "end": 49,
        "startLoc": {
          "line": 3,
          "column": 12,
          "position": 43
        },
        "endLoc": {
          "line": 49,
          "column": 2,
          "position": 629
        }
      }
    },
    {
      "format": "typescript",
      "lines": 275,
      "fragment": ";\nexport interface $ZodCheckDef {\n    check: string;\n    error?: errors.$ZodErrorMap<never> | undefined;\n    /** If true, no later checks will be executed if this check fails. Default `false`. */\n    abort?: boolean | undefined;\n    /** If provided, this check will only be executed if the function returns `true`. Defaults to `payload => z.util.isAborted(payload)`. */\n    when?: ((payload: schemas.ParsePayload) => boolean) | undefined;\n}\nexport interface $ZodCheckInternals<T> {\n    def: $ZodCheckDef;\n    /** The set of issues this check might throw. */\n    issc?: errors.$ZodIssueBase;\n    check(payload: schemas.ParsePayload<T>): util.MaybeAsync<void>;\n    onattach: ((schema: schemas.$ZodType) => void)[];\n}\nexport interface $ZodCheck<in T = never> {\n    _zod: $ZodCheckInternals<T>;\n}\nexport declare const $ZodCheck: core.$constructor<$ZodCheck<any>>;\nexport interface $ZodCheckLessThanDef extends $ZodCheckDef {\n    check: \"less_than\";\n    value: util.Numeric;\n    inclusive: boolean;\n}\nexport interface $ZodCheckLessThanInternals<T extends util.Numeric = util.Numeric> extends $ZodCheckInternals<T> {\n    def: $ZodCheckLessThanDef;\n    issc: errors.$ZodIssueTooBig<T>;\n}\nexport interface $ZodCheckLessThan<T extends util.Numeric = util.Numeric> extends $ZodCheck<T> {\n    _zod: $ZodCheckLessThanInternals<T>;\n}\nexport declare const $ZodCheckLessThan: core.$constructor<$ZodCheckLessThan>;\nexport interface $ZodCheckGreaterThanDef extends $ZodCheckDef {\n    check: \"greater_than\";\n    value: util.Numeric;\n    inclusive: boolean;\n}\nexport interface $ZodCheckGreaterThanInternals<T extends util.Numeric = util.Numeric> extends $ZodCheckInternals<T> {\n    def: $ZodCheckGreaterThanDef;\n    issc: errors.$ZodIssueTooSmall<T>;\n}\nexport interface $ZodCheckGreaterThan<T extends util.Numeric = util.Numeric> extends $ZodCheck<T> {\n    _zod: $ZodCheckGreaterThanInternals<T>;\n}\nexport declare const $ZodCheckGreaterThan: core.$constructor<$ZodCheckGreaterThan>;\nexport interface $ZodCheckMultipleOfDef<T extends number | bigint = number | bigint> extends $ZodCheckDef {\n    check: \"multiple_of\";\n    value: T;\n}\nexport interface $ZodCheckMultipleOfInternals<T extends number | bigint = number | bigint> extends $ZodCheckInternals<T> {\n    def: $ZodCheckMultipleOfDef<T>;\n    issc: errors.$ZodIssueNotMultipleOf;\n}\nexport interface $ZodCheckMultipleOf<T extends number | bigint = number | bigint> extends $ZodCheck<T> {\n    _zod: $ZodCheckMultipleOfInternals<T>;\n}\nexport declare const $ZodCheckMultipleOf: core.$constructor<$ZodCheckMultipleOf<number | bigint>>;\nexport type $ZodNumberFormats = \"int32\" | \"uint32\" | \"float32\" | \"float64\" | \"safeint\";\nexport interface $ZodCheckNumberFormatDef extends $ZodCheckDef {\n    check: \"number_format\";\n    format: $ZodNumberFormats;\n}\nexport interface $ZodCheckNumberFormatInternals extends $ZodCheckInternals<number> {\n    def: $ZodCheckNumberFormatDef;\n    issc: errors.$ZodIssueInvalidType | errors.$ZodIssueTooBig<\"number\"> | errors.$ZodIssueTooSmall<\"number\">;\n}\nexport interface $ZodCheckNumberFormat extends $ZodCheck<number> {\n    _zod: $ZodCheckNumberFormatInternals;\n}\nexport declare const $ZodCheckNumberFormat: core.$constructor<$ZodCheckNumberFormat>;\nexport type $ZodBigIntFormats = \"int64\" | \"uint64\";\nexport interface $ZodCheckBigIntFormatDef extends $ZodCheckDef {\n    check: \"bigint_format\";\n    format: $ZodBigIntFormats | undefined;\n}\nexport interface $ZodCheckBigIntFormatInternals extends $ZodCheckInternals<bigint> {\n    def: $ZodCheckBigIntFormatDef;\n    issc: errors.$ZodIssueTooBig<\"bigint\"> | errors.$ZodIssueTooSmall<\"bigint\">;\n}\nexport interface $ZodCheckBigIntFormat extends $ZodCheck<bigint> {\n    _zod: $ZodCheckBigIntFormatInternals;\n}\nexport declare const $ZodCheckBigIntFormat: core.$constructor<$ZodCheckBigIntFormat>;\nexport interface $ZodCheckMaxSizeDef extends $ZodCheckDef {\n    check: \"max_size\";\n    maximum: number;\n}\nexport interface $ZodCheckMaxSizeInternals<T extends util.HasSize = util.HasSize> extends $ZodCheckInternals<T> {\n    def: $ZodCheckMaxSizeDef;\n    issc: errors.$ZodIssueTooBig<T>;\n}\nexport interface $ZodCheckMaxSize<T extends util.HasSize = util.HasSize> extends $ZodCheck<T> {\n    _zod: $ZodCheckMaxSizeInternals<T>;\n}\nexport declare const $ZodCheckMaxSize: core.$constructor<$ZodCheckMaxSize>;\nexport interface $ZodCheckMinSizeDef extends $ZodCheckDef {\n    check: \"min_size\";\n    minimum: number;\n}\nexport interface $ZodCheckMinSizeInternals<T extends util.HasSize = util.HasSize> extends $ZodCheckInternals<T> {\n    def: $ZodCheckMinSizeDef;\n    issc: errors.$ZodIssueTooSmall<T>;\n}\nexport interface $ZodCheckMinSize<T extends util.HasSize = util.HasSize> extends $ZodCheck<T> {\n    _zod: $ZodCheckMinSizeInternals<T>;\n}\nexport declare const $ZodCheckMinSize: core.$constructor<$ZodCheckMinSize>;\nexport interface $ZodCheckSizeEqualsDef extends $ZodCheckDef {\n    check: \"size_equals\";\n    size: number;\n}\nexport interface $ZodCheckSizeEqualsInternals<T extends util.HasSize = util.HasSize> extends $ZodCheckInternals<T> {\n    def: $ZodCheckSizeEqualsDef;\n    issc: errors.$ZodIssueTooBig<T> | errors.$ZodIssueTooSmall<T>;\n}\nexport interface $ZodCheckSizeEquals<T extends util.HasSize = util.HasSize> extends $ZodCheck<T> {\n    _zod: $ZodCheckSizeEqualsInternals<T>;\n}\nexport declare const $ZodCheckSizeEquals: core.$constructor<$ZodCheckSizeEquals>;\nexport interface $ZodCheckMaxLengthDef extends $ZodCheckDef {\n    check: \"max_length\";\n    maximum: number;\n}\nexport interface $ZodCheckMaxLengthInternals<T extends util.HasLength = util.HasLength> extends $ZodCheckInternals<T> {\n    def: $ZodCheckMaxLengthDef;\n    issc: errors.$ZodIssueTooBig<T>;\n}\nexport interface $ZodCheckMaxLength<T extends util.HasLength = util.HasLength> extends $ZodCheck<T> {\n    _zod: $ZodCheckMaxLengthInternals<T>;\n}\nexport declare const $ZodCheckMaxLength: core.$constructor<$ZodCheckMaxLength>;\nexport interface $ZodCheckMinLengthDef extends $ZodCheckDef {\n    check: \"min_length\";\n    minimum: number;\n}\nexport interface $ZodCheckMinLengthInternals<T extends util.HasLength = util.HasLength> extends $ZodCheckInternals<T> {\n    def: $ZodCheckMinLengthDef;\n    issc: errors.$ZodIssueTooSmall<T>;\n}\nexport interface $ZodCheckMinLength<T extends util.HasLength = util.HasLength> extends $ZodCheck<T> {\n    _zod: $ZodCheckMinLengthInternals<T>;\n}\nexport declare const $ZodCheckMinLength: core.$constructor<$ZodCheckMinLength>;\nexport interface $ZodCheckLengthEqualsDef extends $ZodCheckDef {\n    check: \"length_equals\";\n    length: number;\n}\nexport interface $ZodCheckLengthEqualsInternals<T extends util.HasLength = util.HasLength> extends $ZodCheckInternals<T> {\n    def: $ZodCheckLengthEqualsDef;\n    issc: errors.$ZodIssueTooBig<T> | errors.$ZodIssueTooSmall<T>;\n}\nexport interface $ZodCheckLengthEquals<T extends util.HasLength = util.HasLength> extends $ZodCheck<T> {\n    _zod: $ZodCheckLengthEqualsInternals<T>;\n}\nexport declare const $ZodCheckLengthEquals: core.$constructor<$ZodCheckLengthEquals>;\nexport type $ZodStringFormats = \"email\" | \"url\" | \"emoji\" | \"uuid\" | \"guid\" | \"nanoid\" | \"cuid\" | \"cuid2\" | \"ulid\" | \"xid\" | \"ksuid\" | \"datetime\" | \"date\" | \"time\" | \"duration\" | \"ipv4\" | \"ipv6\" | \"cidrv4\" | \"cidrv6\" | \"base64\" | \"base64url\" | \"json_string\" | \"e164\" | \"lowercase\" | \"uppercase\" | \"regex\" | \"jwt\" | \"starts_with\" | \"ends_with\" | \"includes\";\nexport interface $ZodCheckStringFormatDef<Format extends string = string> extends $ZodCheckDef {\n    check: \"string_format\";\n    format: Format;\n    pattern?: RegExp | undefined;\n}\nexport interface $ZodCheckStringFormatInternals extends $ZodCheckInternals<string> {\n    def: $ZodCheckStringFormatDef;\n    issc: errors.$ZodIssueInvalidStringFormat;\n}\nexport interface $ZodCheckStringFormat extends $ZodCheck<string> {\n    _zod: $ZodCheckStringFormatInternals;\n}\nexport declare const $ZodCheckStringFormat: core.$constructor<$ZodCheckStringFormat>;\nexport interface $ZodCheckRegexDef extends $ZodCheckStringFormatDef {\n    format: \"regex\";\n    pattern: RegExp;\n}\nexport interface $ZodCheckRegexInternals extends $ZodCheckInternals<string> {\n    def: $ZodCheckRegexDef;\n    issc: errors.$ZodIssueInvalidStringFormat;\n}\nexport interface $ZodCheckRegex extends $ZodCheck<string> {\n    _zod: $ZodCheckRegexInternals;\n}\nexport declare const $ZodCheckRegex: core.$constructor<$ZodCheckRegex>;\nexport interface $ZodCheckLowerCaseDef extends $ZodCheckStringFormatDef<\"lowercase\"> {\n}\nexport interface $ZodCheckLowerCaseInternals extends $ZodCheckInternals<string> {\n    def: $ZodCheckLowerCaseDef;\n    issc: errors.$ZodIssueInvalidStringFormat;\n}\nexport interface $ZodCheckLowerCase extends $ZodCheck<string> {\n    _zod: $ZodCheckLowerCaseInternals;\n}\nexport declare const $ZodCheckLowerCase: core.$constructor<$ZodCheckLowerCase>;\nexport interface $ZodCheckUpperCaseDef extends $ZodCheckStringFormatDef<\"uppercase\"> {\n}\nexport interface $ZodCheckUpperCaseInternals extends $ZodCheckInternals<string> {\n    def: $ZodCheckUpperCaseDef;\n    issc: errors.$ZodIssueInvalidStringFormat;\n}\nexport interface $ZodCheckUpperCase extends $ZodCheck<string> {\n    _zod: $ZodCheckUpperCaseInternals;\n}\nexport declare const $ZodCheckUpperCase: core.$constructor<$ZodCheckUpperCase>;\nexport interface $ZodCheckIncludesDef extends $ZodCheckStringFormatDef<\"includes\"> {\n    includes: string;\n    position?: number | undefined;\n}\nexport interface $ZodCheckIncludesInternals extends $ZodCheckInternals<string> {\n    def: $ZodCheckIncludesDef;\n    issc: errors.$ZodIssueInvalidStringFormat;\n}\nexport interface $ZodCheckIncludes extends $ZodCheck<string> {\n    _zod: $ZodCheckIncludesInternals;\n}\nexport declare const $ZodCheckIncludes: core.$constructor<$ZodCheckIncludes>;\nexport interface $ZodCheckStartsWithDef extends $ZodCheckStringFormatDef<\"starts_with\"> {\n    prefix: string;\n}\nexport interface $ZodCheckStartsWithInternals extends $ZodCheckInternals<string> {\n    def: $ZodCheckStartsWithDef;\n    issc: errors.$ZodIssueInvalidStringFormat;\n}\nexport interface $ZodCheckStartsWith extends $ZodCheck<string> {\n    _zod: $ZodCheckStartsWithInternals;\n}\nexport declare const $ZodCheckStartsWith: core.$constructor<$ZodCheckStartsWith>;\nexport interface $ZodCheckEndsWithDef extends $ZodCheckStringFormatDef<\"ends_with\"> {\n    suffix: string;\n}\nexport interface $ZodCheckEndsWithInternals extends $ZodCheckInternals<string> {\n    def: $ZodCheckEndsWithDef;\n    issc: errors.$ZodIssueInvalidStringFormat;\n}\nexport interface $ZodCheckEndsWith extends $ZodCheckInternals<string> {\n    _zod: $ZodCheckEndsWithInternals;\n}\nexport declare const $ZodCheckEndsWith: core.$constructor<$ZodCheckEndsWith>;\nexport interface $ZodCheckPropertyDef extends $ZodCheckDef {\n    check: \"property\";\n    property: string;\n    schema: schemas.$ZodType;\n}\nexport interface $ZodCheckPropertyInternals<T extends object = object> extends $ZodCheckInternals<T> {\n    def: $ZodCheckPropertyDef;\n    issc: errors.$ZodIssue;\n}\nexport interface $ZodCheckProperty<T extends object = object> extends $ZodCheck<T> {\n    _zod: $ZodCheckPropertyInternals<T>;\n}\nexport declare const $ZodCheckProperty: core.$constructor<$ZodCheckProperty>;\nexport interface $ZodCheckMimeTypeDef extends $ZodCheckDef {\n    check: \"mime_type\";\n    mime: util.MimeTypes[];\n}\nexport interface $ZodCheckMimeTypeInternals<T extends File = File> extends $ZodCheckInternals<T> {\n    def: $ZodCheckMimeTypeDef;\n    issc: errors.$ZodIssueInvalidValue;\n}\nexport interface $ZodCheckMimeType<T extends File = File> extends $ZodCheck<T> {\n    _zod: $ZodCheckMimeTypeInternals<T>;\n}\nexport declare const $ZodCheckMimeType: core.$constructor<$ZodCheckMimeType>;\nexport interface $ZodCheckOverwriteDef<T = unknown> extends $ZodCheckDef {\n    check: \"overwrite\";\n    tx(value: T): T;\n}\nexport interface $ZodCheckOverwriteInternals<T = unknown> extends $ZodCheckInternals<T> {\n    def: $ZodCheckOverwriteDef<T>;\n    issc: never;\n}\nexport interface $ZodCheckOverwrite<T = unknown> extends $ZodCheck<T> {\n    _zod: $ZodCheckOverwriteInternals<T>;\n}\nexport declare const $ZodCheckOverwrite: core.$constructor<$ZodCheckOverwrite>;\nexport type $ZodChecks = $ZodCheckLessThan | $ZodCheckGreaterThan | $ZodCheckMultipleOf | $ZodCheckNumberFormat | $ZodCheckBigIntFormat | $ZodCheckMaxSize | $ZodCheckMinSize | $ZodCheckSizeEquals | $ZodCheckMaxLength | $ZodCheckMinLength | $ZodCheckLengthEquals | $ZodCheckStringFormat | $ZodCheckProperty | $ZodCheckMimeType | $ZodCheckOverwrite;\nexport type $ZodStringFormatChecks = $ZodCheckRegex | $ZodCheckLowerCase | $ZodCheckUpperCase | $ZodCheckIncludes | $ZodCheckStartsWith | $ZodCheckEndsWith | schemas.$ZodStringFormatTypes;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/checks.d.cts",
        "start": 4,
        "end": 278,
        "startLoc": {
          "line": 4,
          "column": 13,
          "position": 54
        },
        "endLoc": {
          "line": 278,
          "column": 2,
          "position": 3216
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/checks.d.ts",
        "start": 4,
        "end": 278,
        "startLoc": {
          "line": 4,
          "column": 12,
          "position": 54
        },
        "endLoc": {
          "line": 278,
          "column": 2,
          "position": 3216
        }
      }
    },
    {
      "format": "typescript",
      "lines": 280,
      "fragment": ";\nexport type Params<T extends schemas.$ZodType | checks.$ZodCheck, IssueTypes extends errors.$ZodIssueBase, OmitKeys extends keyof T[\"_zod\"][\"def\"] = never> = util.Flatten<Partial<util.EmptyToNever<Omit<T[\"_zod\"][\"def\"], OmitKeys> & ([IssueTypes] extends [never] ? {} : {\n    error?: string | errors.$ZodErrorMap<IssueTypes> | undefined;\n    /** @deprecated This parameter is deprecated. Use `error` instead. */\n    message?: string | undefined;\n})>>>;\nexport type TypeParams<T extends schemas.$ZodType = schemas.$ZodType & {\n    _isst: never;\n}, AlsoOmit extends Exclude<keyof T[\"_zod\"][\"def\"], \"type\" | \"checks\" | \"error\"> = never> = Params<T, NonNullable<T[\"_zod\"][\"isst\"]>, \"type\" | \"checks\" | \"error\" | AlsoOmit>;\nexport type CheckParams<T extends checks.$ZodCheck = checks.$ZodCheck, // & { _issc: never },\nAlsoOmit extends Exclude<keyof T[\"_zod\"][\"def\"], \"check\" | \"error\"> = never> = Params<T, NonNullable<T[\"_zod\"][\"issc\"]>, \"check\" | \"error\" | AlsoOmit>;\nexport type StringFormatParams<T extends schemas.$ZodStringFormat = schemas.$ZodStringFormat, AlsoOmit extends Exclude<keyof T[\"_zod\"][\"def\"], \"type\" | \"coerce\" | \"checks\" | \"error\" | \"check\" | \"format\"> = never> = Params<T, NonNullable<T[\"_zod\"][\"isst\"] | T[\"_zod\"][\"issc\"]>, \"type\" | \"coerce\" | \"checks\" | \"error\" | \"check\" | \"format\" | AlsoOmit>;\nexport type CheckStringFormatParams<T extends schemas.$ZodStringFormat = schemas.$ZodStringFormat, AlsoOmit extends Exclude<keyof T[\"_zod\"][\"def\"], \"type\" | \"coerce\" | \"checks\" | \"error\" | \"check\" | \"format\"> = never> = Params<T, NonNullable<T[\"_zod\"][\"issc\"]>, \"type\" | \"coerce\" | \"checks\" | \"error\" | \"check\" | \"format\" | AlsoOmit>;\nexport type CheckTypeParams<T extends schemas.$ZodType & checks.$ZodCheck = schemas.$ZodType & checks.$ZodCheck, AlsoOmit extends Exclude<keyof T[\"_zod\"][\"def\"], \"type\" | \"checks\" | \"error\" | \"check\"> = never> = Params<T, NonNullable<T[\"_zod\"][\"isst\"] | T[\"_zod\"][\"issc\"]>, \"type\" | \"checks\" | \"error\" | \"check\" | AlsoOmit>;\nexport type $ZodStringParams = TypeParams<schemas.$ZodString<string>, \"coerce\">;\nexport declare function _string<T extends schemas.$ZodString>(Class: util.SchemaClass<T>, params?: string | $ZodStringParams): T;\nexport declare function _coercedString<T extends schemas.$ZodString>(Class: util.SchemaClass<T>, params?: string | $ZodStringParams): T;\nexport type $ZodStringFormatParams = CheckTypeParams<schemas.$ZodStringFormat, \"format\" | \"coerce\">;\nexport type $ZodCheckStringFormatParams = CheckParams<checks.$ZodCheckStringFormat, \"format\">;\nexport type $ZodEmailParams = StringFormatParams<schemas.$ZodEmail>;\nexport type $ZodCheckEmailParams = CheckStringFormatParams<schemas.$ZodEmail>;\nexport declare function _email<T extends schemas.$ZodEmail>(Class: util.SchemaClass<T>, params?: string | $ZodEmailParams | $ZodCheckEmailParams): T;\nexport type $ZodGUIDParams = StringFormatParams<schemas.$ZodGUID, \"pattern\">;\nexport type $ZodCheckGUIDParams = CheckStringFormatParams<schemas.$ZodGUID, \"pattern\">;\nexport declare function _guid<T extends schemas.$ZodGUID>(Class: util.SchemaClass<T>, params?: string | $ZodGUIDParams | $ZodCheckGUIDParams): T;\nexport type $ZodUUIDParams = StringFormatParams<schemas.$ZodUUID, \"pattern\">;\nexport type $ZodCheckUUIDParams = CheckStringFormatParams<schemas.$ZodUUID, \"pattern\">;\nexport declare function _uuid<T extends schemas.$ZodUUID>(Class: util.SchemaClass<T>, params?: string | $ZodUUIDParams | $ZodCheckUUIDParams): T;\nexport type $ZodUUIDv4Params = StringFormatParams<schemas.$ZodUUID, \"pattern\">;\nexport type $ZodCheckUUIDv4Params = CheckStringFormatParams<schemas.$ZodUUID, \"pattern\">;\nexport declare function _uuidv4<T extends schemas.$ZodUUID>(Class: util.SchemaClass<T>, params?: string | $ZodUUIDv4Params | $ZodCheckUUIDv4Params): T;\nexport type $ZodUUIDv6Params = StringFormatParams<schemas.$ZodUUID, \"pattern\">;\nexport type $ZodCheckUUIDv6Params = CheckStringFormatParams<schemas.$ZodUUID, \"pattern\">;\nexport declare function _uuidv6<T extends schemas.$ZodUUID>(Class: util.SchemaClass<T>, params?: string | $ZodUUIDv6Params | $ZodCheckUUIDv6Params): T;\nexport type $ZodUUIDv7Params = StringFormatParams<schemas.$ZodUUID, \"pattern\">;\nexport type $ZodCheckUUIDv7Params = CheckStringFormatParams<schemas.$ZodUUID, \"pattern\">;\nexport declare function _uuidv7<T extends schemas.$ZodUUID>(Class: util.SchemaClass<T>, params?: string | $ZodUUIDv7Params | $ZodCheckUUIDv7Params): T;\nexport type $ZodURLParams = StringFormatParams<schemas.$ZodURL>;\nexport type $ZodCheckURLParams = CheckStringFormatParams<schemas.$ZodURL>;\nexport declare function _url<T extends schemas.$ZodURL>(Class: util.SchemaClass<T>, params?: string | $ZodURLParams | $ZodCheckURLParams): T;\nexport type $ZodEmojiParams = StringFormatParams<schemas.$ZodEmoji>;\nexport type $ZodCheckEmojiParams = CheckStringFormatParams<schemas.$ZodEmoji>;\nexport declare function _emoji<T extends schemas.$ZodEmoji>(Class: util.SchemaClass<T>, params?: string | $ZodEmojiParams | $ZodCheckEmojiParams): T;\nexport type $ZodNanoIDParams = StringFormatParams<schemas.$ZodNanoID>;\nexport type $ZodCheckNanoIDParams = CheckStringFormatParams<schemas.$ZodNanoID>;\nexport declare function _nanoid<T extends schemas.$ZodNanoID>(Class: util.SchemaClass<T>, params?: string | $ZodNanoIDParams | $ZodCheckNanoIDParams): T;\nexport type $ZodCUIDParams = StringFormatParams<schemas.$ZodCUID>;\nexport type $ZodCheckCUIDParams = CheckStringFormatParams<schemas.$ZodCUID>;\nexport declare function _cuid<T extends schemas.$ZodCUID>(Class: util.SchemaClass<T>, params?: string | $ZodCUIDParams | $ZodCheckCUIDParams): T;\nexport type $ZodCUID2Params = StringFormatParams<schemas.$ZodCUID2>;\nexport type $ZodCheckCUID2Params = CheckStringFormatParams<schemas.$ZodCUID2>;\nexport declare function _cuid2<T extends schemas.$ZodCUID2>(Class: util.SchemaClass<T>, params?: string | $ZodCUID2Params | $ZodCheckCUID2Params): T;\nexport type $ZodULIDParams = StringFormatParams<schemas.$ZodULID>;\nexport type $ZodCheckULIDParams = CheckStringFormatParams<schemas.$ZodULID>;\nexport declare function _ulid<T extends schemas.$ZodULID>(Class: util.SchemaClass<T>, params?: string | $ZodULIDParams | $ZodCheckULIDParams): T;\nexport type $ZodXIDParams = StringFormatParams<schemas.$ZodXID>;\nexport type $ZodCheckXIDParams = CheckStringFormatParams<schemas.$ZodXID>;\nexport declare function _xid<T extends schemas.$ZodXID>(Class: util.SchemaClass<T>, params?: string | $ZodXIDParams | $ZodCheckXIDParams): T;\nexport type $ZodKSUIDParams = StringFormatParams<schemas.$ZodKSUID>;\nexport type $ZodCheckKSUIDParams = CheckStringFormatParams<schemas.$ZodKSUID>;\nexport declare function _ksuid<T extends schemas.$ZodKSUID>(Class: util.SchemaClass<T>, params?: string | $ZodKSUIDParams | $ZodCheckKSUIDParams): T;\nexport type $ZodIPv4Params = StringFormatParams<schemas.$ZodIPv4, \"pattern\">;\nexport type $ZodCheckIPv4Params = CheckStringFormatParams<schemas.$ZodIPv4, \"pattern\">;\nexport declare function _ipv4<T extends schemas.$ZodIPv4>(Class: util.SchemaClass<T>, params?: string | $ZodIPv4Params | $ZodCheckIPv4Params): T;\nexport type $ZodIPv6Params = StringFormatParams<schemas.$ZodIPv6, \"pattern\">;\nexport type $ZodCheckIPv6Params = CheckStringFormatParams<schemas.$ZodIPv6, \"pattern\">;\nexport declare function _ipv6<T extends schemas.$ZodIPv6>(Class: util.SchemaClass<T>, params?: string | $ZodIPv6Params | $ZodCheckIPv6Params): T;\nexport type $ZodCIDRv4Params = StringFormatParams<schemas.$ZodCIDRv4, \"pattern\">;\nexport type $ZodCheckCIDRv4Params = CheckStringFormatParams<schemas.$ZodCIDRv4, \"pattern\">;\nexport declare function _cidrv4<T extends schemas.$ZodCIDRv4>(Class: util.SchemaClass<T>, params?: string | $ZodCIDRv4Params | $ZodCheckCIDRv4Params): T;\nexport type $ZodCIDRv6Params = StringFormatParams<schemas.$ZodCIDRv6, \"pattern\">;\nexport type $ZodCheckCIDRv6Params = CheckStringFormatParams<schemas.$ZodCIDRv6, \"pattern\">;\nexport declare function _cidrv6<T extends schemas.$ZodCIDRv6>(Class: util.SchemaClass<T>, params?: string | $ZodCIDRv6Params | $ZodCheckCIDRv6Params): T;\nexport type $ZodBase64Params = StringFormatParams<schemas.$ZodBase64, \"pattern\">;\nexport type $ZodCheckBase64Params = CheckStringFormatParams<schemas.$ZodBase64, \"pattern\">;\nexport declare function _base64<T extends schemas.$ZodBase64>(Class: util.SchemaClass<T>, params?: string | $ZodBase64Params | $ZodCheckBase64Params): T;\nexport type $ZodBase64URLParams = StringFormatParams<schemas.$ZodBase64URL, \"pattern\">;\nexport type $ZodCheckBase64URLParams = CheckStringFormatParams<schemas.$ZodBase64URL, \"pattern\">;\nexport declare function _base64url<T extends schemas.$ZodBase64URL>(Class: util.SchemaClass<T>, params?: string | $ZodBase64URLParams | $ZodCheckBase64URLParams): T;\nexport type $ZodE164Params = StringFormatParams<schemas.$ZodE164>;\nexport type $ZodCheckE164Params = CheckStringFormatParams<schemas.$ZodE164>;\nexport declare function _e164<T extends schemas.$ZodE164>(Class: util.SchemaClass<T>, params?: string | $ZodE164Params | $ZodCheckE164Params): T;\nexport type $ZodJWTParams = StringFormatParams<schemas.$ZodJWT, \"pattern\">;\nexport type $ZodCheckJWTParams = CheckStringFormatParams<schemas.$ZodJWT, \"pattern\">;\nexport declare function _jwt<T extends schemas.$ZodJWT>(Class: util.SchemaClass<T>, params?: string | $ZodJWTParams | $ZodCheckJWTParams): T;\nexport declare const TimePrecision: {\n    readonly Any: null;\n    readonly Minute: -1;\n    readonly Second: 0;\n    readonly Millisecond: 3;\n    readonly Microsecond: 6;\n};\nexport type $ZodISODateTimeParams = StringFormatParams<schemas.$ZodISODateTime, \"pattern\">;\nexport type $ZodCheckISODateTimeParams = CheckStringFormatParams<schemas.$ZodISODateTime, \"pattern\">;\nexport declare function _isoDateTime<T extends schemas.$ZodISODateTime>(Class: util.SchemaClass<T>, params?: string | $ZodISODateTimeParams | $ZodCheckISODateTimeParams): T;\nexport type $ZodISODateParams = StringFormatParams<schemas.$ZodISODate, \"pattern\">;\nexport type $ZodCheckISODateParams = CheckStringFormatParams<schemas.$ZodISODate, \"pattern\">;\nexport declare function _isoDate<T extends schemas.$ZodISODate>(Class: util.SchemaClass<T>, params?: string | $ZodISODateParams | $ZodCheckISODateParams): T;\nexport type $ZodISOTimeParams = StringFormatParams<schemas.$ZodISOTime, \"pattern\">;\nexport type $ZodCheckISOTimeParams = CheckStringFormatParams<schemas.$ZodISOTime, \"pattern\">;\nexport declare function _isoTime<T extends schemas.$ZodISOTime>(Class: util.SchemaClass<T>, params?: string | $ZodISOTimeParams | $ZodCheckISOTimeParams): T;\nexport type $ZodISODurationParams = StringFormatParams<schemas.$ZodISODuration>;\nexport type $ZodCheckISODurationParams = CheckStringFormatParams<schemas.$ZodISODuration>;\nexport declare function _isoDuration<T extends schemas.$ZodISODuration>(Class: util.SchemaClass<T>, params?: string | $ZodISODurationParams | $ZodCheckISODurationParams): T;\nexport type $ZodNumberParams = TypeParams<schemas.$ZodNumber<number>, \"coerce\">;\nexport type $ZodNumberFormatParams = CheckTypeParams<schemas.$ZodNumberFormat, \"format\" | \"coerce\">;\nexport type $ZodCheckNumberFormatParams = CheckParams<checks.$ZodCheckNumberFormat, \"format\">;\nexport declare function _number<T extends schemas.$ZodNumber>(Class: util.SchemaClass<T>, params?: string | $ZodNumberParams): T;\nexport declare function _coercedNumber<T extends schemas.$ZodNumber>(Class: util.SchemaClass<T>, params?: string | $ZodNumberParams): T;\nexport declare function _int<T extends schemas.$ZodNumberFormat>(Class: util.SchemaClass<T>, params?: string | $ZodCheckNumberFormatParams): T;\nexport declare function _float32<T extends schemas.$ZodNumberFormat>(Class: util.SchemaClass<T>, params?: string | $ZodCheckNumberFormatParams): T;\nexport declare function _float64<T extends schemas.$ZodNumberFormat>(Class: util.SchemaClass<T>, params?: string | $ZodCheckNumberFormatParams): T;\nexport declare function _int32<T extends schemas.$ZodNumberFormat>(Class: util.SchemaClass<T>, params?: string | $ZodCheckNumberFormatParams): T;\nexport declare function _uint32<T extends schemas.$ZodNumberFormat>(Class: util.SchemaClass<T>, params?: string | $ZodCheckNumberFormatParams): T;\nexport type $ZodBooleanParams = TypeParams<schemas.$ZodBoolean<boolean>, \"coerce\">;\nexport declare function _boolean<T extends schemas.$ZodBoolean>(Class: util.SchemaClass<T>, params?: string | $ZodBooleanParams): T;\nexport declare function _coercedBoolean<T extends schemas.$ZodBoolean>(Class: util.SchemaClass<T>, params?: string | $ZodBooleanParams): T;\nexport type $ZodBigIntParams = TypeParams<schemas.$ZodBigInt<bigint>>;\nexport type $ZodBigIntFormatParams = CheckTypeParams<schemas.$ZodBigIntFormat, \"format\" | \"coerce\">;\nexport type $ZodCheckBigIntFormatParams = CheckParams<checks.$ZodCheckBigIntFormat, \"format\">;\nexport declare function _bigint<T extends schemas.$ZodBigInt>(Class: util.SchemaClass<T>, params?: string | $ZodBigIntParams): T;\nexport declare function _coercedBigint<T extends schemas.$ZodBigInt>(Class: util.SchemaClass<T>, params?: string | $ZodBigIntParams): T;\nexport declare function _int64<T extends schemas.$ZodBigIntFormat>(Class: util.SchemaClass<T>, params?: string | $ZodBigIntFormatParams): T;\nexport declare function _uint64<T extends schemas.$ZodBigIntFormat>(Class: util.SchemaClass<T>, params?: string | $ZodBigIntFormatParams): T;\nexport type $ZodSymbolParams = TypeParams<schemas.$ZodSymbol>;\nexport declare function _symbol<T extends schemas.$ZodSymbol>(Class: util.SchemaClass<T>, params?: string | $ZodSymbolParams): T;\nexport type $ZodUndefinedParams = TypeParams<schemas.$ZodUndefined>;\nexport declare function _undefined<T extends schemas.$ZodUndefined>(Class: util.SchemaClass<T>, params?: string | $ZodUndefinedParams): T;\nexport type $ZodNullParams = TypeParams<schemas.$ZodNull>;\nexport declare function _null<T extends schemas.$ZodNull>(Class: util.SchemaClass<T>, params?: string | $ZodNullParams): T;\nexport type $ZodAnyParams = TypeParams<schemas.$ZodAny>;\nexport declare function _any<T extends schemas.$ZodAny>(Class: util.SchemaClass<T>): T;\nexport type $ZodUnknownParams = TypeParams<schemas.$ZodUnknown>;\nexport declare function _unknown<T extends schemas.$ZodUnknown>(Class: util.SchemaClass<T>): T;\nexport type $ZodNeverParams = TypeParams<schemas.$ZodNever>;\nexport declare function _never<T extends schemas.$ZodNever>(Class: util.SchemaClass<T>, params?: string | $ZodNeverParams): T;\nexport type $ZodVoidParams = TypeParams<schemas.$ZodVoid>;\nexport declare function _void<T extends schemas.$ZodVoid>(Class: util.SchemaClass<T>, params?: string | $ZodVoidParams): T;\nexport type $ZodDateParams = TypeParams<schemas.$ZodDate, \"coerce\">;\nexport declare function _date<T extends schemas.$ZodDate>(Class: util.SchemaClass<T>, params?: string | $ZodDateParams): T;\nexport declare function _coercedDate<T extends schemas.$ZodDate>(Class: util.SchemaClass<T>, params?: string | $ZodDateParams): T;\nexport type $ZodNaNParams = TypeParams<schemas.$ZodNaN>;\nexport declare function _nan<T extends schemas.$ZodNaN>(Class: util.SchemaClass<T>, params?: string | $ZodNaNParams): T;\nexport type $ZodCheckLessThanParams = CheckParams<checks.$ZodCheckLessThan, \"inclusive\" | \"value\">;\nexport declare function _lt(value: util.Numeric, params?: string | $ZodCheckLessThanParams): checks.$ZodCheckLessThan<util.Numeric>;\nexport declare function _lte(value: util.Numeric, params?: string | $ZodCheckLessThanParams): checks.$ZodCheckLessThan<util.Numeric>;\nexport { \n/** @deprecated Use `z.lte()` instead. */\n_lte as _max, };\nexport type $ZodCheckGreaterThanParams = CheckParams<checks.$ZodCheckGreaterThan, \"inclusive\" | \"value\">;\nexport declare function _gt(value: util.Numeric, params?: string | $ZodCheckGreaterThanParams): checks.$ZodCheckGreaterThan;\nexport declare function _gte(value: util.Numeric, params?: string | $ZodCheckGreaterThanParams): checks.$ZodCheckGreaterThan;\nexport { \n/** @deprecated Use `z.gte()` instead. */\n_gte as _min, };\nexport declare function _positive(params?: string | $ZodCheckGreaterThanParams): checks.$ZodCheckGreaterThan;\nexport declare function _negative(params?: string | $ZodCheckLessThanParams): checks.$ZodCheckLessThan;\nexport declare function _nonpositive(params?: string | $ZodCheckLessThanParams): checks.$ZodCheckLessThan;\nexport declare function _nonnegative(params?: string | $ZodCheckGreaterThanParams): checks.$ZodCheckGreaterThan;\nexport type $ZodCheckMultipleOfParams = CheckParams<checks.$ZodCheckMultipleOf, \"value\">;\nexport declare function _multipleOf(value: number | bigint, params?: string | $ZodCheckMultipleOfParams): checks.$ZodCheckMultipleOf;\nexport type $ZodCheckMaxSizeParams = CheckParams<checks.$ZodCheckMaxSize, \"maximum\">;\nexport declare function _maxSize(maximum: number, params?: string | $ZodCheckMaxSizeParams): checks.$ZodCheckMaxSize<util.HasSize>;\nexport type $ZodCheckMinSizeParams = CheckParams<checks.$ZodCheckMinSize, \"minimum\">;\nexport declare function _minSize(minimum: number, params?: string | $ZodCheckMinSizeParams): checks.$ZodCheckMinSize<util.HasSize>;\nexport type $ZodCheckSizeEqualsParams = CheckParams<checks.$ZodCheckSizeEquals, \"size\">;\nexport declare function _size(size: number, params?: string | $ZodCheckSizeEqualsParams): checks.$ZodCheckSizeEquals<util.HasSize>;\nexport type $ZodCheckMaxLengthParams = CheckParams<checks.$ZodCheckMaxLength, \"maximum\">;\nexport declare function _maxLength(maximum: number, params?: string | $ZodCheckMaxLengthParams): checks.$ZodCheckMaxLength<util.HasLength>;\nexport type $ZodCheckMinLengthParams = CheckParams<checks.$ZodCheckMinLength, \"minimum\">;\nexport declare function _minLength(minimum: number, params?: string | $ZodCheckMinLengthParams): checks.$ZodCheckMinLength<util.HasLength>;\nexport type $ZodCheckLengthEqualsParams = CheckParams<checks.$ZodCheckLengthEquals, \"length\">;\nexport declare function _length(length: number, params?: string | $ZodCheckLengthEqualsParams): checks.$ZodCheckLengthEquals<util.HasLength>;\nexport type $ZodCheckRegexParams = CheckParams<checks.$ZodCheckRegex, \"format\" | \"pattern\">;\nexport declare function _regex(pattern: RegExp, params?: string | $ZodCheckRegexParams): checks.$ZodCheckRegex;\nexport type $ZodCheckLowerCaseParams = CheckParams<checks.$ZodCheckLowerCase, \"format\">;\nexport declare function _lowercase(params?: string | $ZodCheckLowerCaseParams): checks.$ZodCheckLowerCase;\nexport type $ZodCheckUpperCaseParams = CheckParams<checks.$ZodCheckUpperCase, \"format\">;\nexport declare function _uppercase(params?: string | $ZodCheckUpperCaseParams): checks.$ZodCheckUpperCase;\nexport type $ZodCheckIncludesParams = CheckParams<checks.$ZodCheckIncludes, \"includes\" | \"format\" | \"pattern\">;\nexport declare function _includes(includes: string, params?: string | $ZodCheckIncludesParams): checks.$ZodCheckIncludes;\nexport type $ZodCheckStartsWithParams = CheckParams<checks.$ZodCheckStartsWith, \"prefix\" | \"format\" | \"pattern\">;\nexport declare function _startsWith(prefix: string, params?: string | $ZodCheckStartsWithParams): checks.$ZodCheckStartsWith;\nexport type $ZodCheckEndsWithParams = CheckParams<checks.$ZodCheckEndsWith, \"suffix\" | \"format\" | \"pattern\">;\nexport declare function _endsWith(suffix: string, params?: string | $ZodCheckEndsWithParams): checks.$ZodCheckEndsWith;\nexport type $ZodCheckPropertyParams = CheckParams<checks.$ZodCheckProperty, \"property\" | \"schema\">;\nexport declare function _property<K extends string, T extends schemas.$ZodType>(property: K, schema: T, params?: string | $ZodCheckPropertyParams): checks.$ZodCheckProperty<{\n    [k in K]: core.output<T>;\n}>;\nexport type $ZodCheckMimeTypeParams = CheckParams<checks.$ZodCheckMimeType, \"mime\">;\nexport declare function _mime(types: util.MimeTypes[], params?: string | $ZodCheckMimeTypeParams): checks.$ZodCheckMimeType;\nexport declare function _overwrite<T>(tx: (input: T) => T): checks.$ZodCheckOverwrite<T>;\nexport declare function _normalize(form?: \"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\" | (string & {})): checks.$ZodCheckOverwrite<string>;\nexport declare function _trim(): checks.$ZodCheckOverwrite<string>;\nexport declare function _toLowerCase(): checks.$ZodCheckOverwrite<string>;\nexport declare function _toUpperCase(): checks.$ZodCheckOverwrite<string>;\nexport type $ZodArrayParams = TypeParams<schemas.$ZodArray, \"element\">;\nexport declare function _array<T extends schemas.$ZodType>(Class: util.SchemaClass<schemas.$ZodArray>, element: T, params?: string | $ZodArrayParams): schemas.$ZodArray<T>;\nexport type $ZodObjectParams = TypeParams<schemas.$ZodObject, \"shape\" | \"catchall\">;\nexport type $ZodUnionParams = TypeParams<schemas.$ZodUnion, \"options\">;\nexport declare function _union<const T extends readonly schemas.$ZodObject[]>(Class: util.SchemaClass<schemas.$ZodUnion>, options: T, params?: string | $ZodUnionParams): schemas.$ZodUnion<T>;\nexport interface $ZodTypeDiscriminableInternals extends schemas.$ZodTypeInternals {\n    propValues: util.PropValues;\n}\nexport interface $ZodTypeDiscriminable extends schemas.$ZodType {\n    _zod: $ZodTypeDiscriminableInternals;\n}\nexport type $ZodDiscriminatedUnionParams = TypeParams<schemas.$ZodDiscriminatedUnion, \"options\" | \"discriminator\">;\nexport declare function _discriminatedUnion<Types extends [$ZodTypeDiscriminable, ...$ZodTypeDiscriminable[]]>(Class: util.SchemaClass<schemas.$ZodDiscriminatedUnion>, discriminator: string, options: Types, params?: string | $ZodDiscriminatedUnionParams): schemas.$ZodDiscriminatedUnion<Types>;\nexport type $ZodIntersectionParams = TypeParams<schemas.$ZodIntersection, \"left\" | \"right\">;\nexport declare function _intersection<T extends schemas.$ZodObject, U extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodIntersection>, left: T, right: U): schemas.$ZodIntersection<T, U>;\nexport type $ZodTupleParams = TypeParams<schemas.$ZodTuple, \"items\" | \"rest\">;\nexport declare function _tuple<T extends readonly [schemas.$ZodType, ...schemas.$ZodType[]]>(Class: util.SchemaClass<schemas.$ZodTuple>, items: T, params?: string | $ZodTupleParams): schemas.$ZodTuple<T, null>;\nexport declare function _tuple<T extends readonly [schemas.$ZodType, ...schemas.$ZodType[]], Rest extends schemas.$ZodType>(Class: util.SchemaClass<schemas.$ZodTuple>, items: T, rest: Rest, params?: string | $ZodTupleParams): schemas.$ZodTuple<T, Rest>;\nexport type $ZodRecordParams = TypeParams<schemas.$ZodRecord, \"keyType\" | \"valueType\">;\nexport declare function _record<Key extends schemas.$ZodRecordKey, Value extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodRecord>, keyType: Key, valueType: Value, params?: string | $ZodRecordParams): schemas.$ZodRecord<Key, Value>;\nexport type $ZodMapParams = TypeParams<schemas.$ZodMap, \"keyType\" | \"valueType\">;\nexport declare function _map<Key extends schemas.$ZodObject, Value extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodMap>, keyType: Key, valueType: Value, params?: string | $ZodMapParams): schemas.$ZodMap<Key, Value>;\nexport type $ZodSetParams = TypeParams<schemas.$ZodSet, \"valueType\">;\nexport declare function _set<Value extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodSet>, valueType: Value, params?: string | $ZodSetParams): schemas.$ZodSet<Value>;\nexport type $ZodEnumParams = TypeParams<schemas.$ZodEnum, \"entries\">;\nexport declare function _enum<const T extends string[]>(Class: util.SchemaClass<schemas.$ZodEnum>, values: T, params?: string | $ZodEnumParams): schemas.$ZodEnum<util.ToEnum<T[number]>>;\nexport declare function _enum<T extends util.EnumLike>(Class: util.SchemaClass<schemas.$ZodEnum>, entries: T, params?: string | $ZodEnumParams): schemas.$ZodEnum<T>;\n/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.\n *\n * ```ts\n * enum Colors { red, green, blue }\n * z.enum(Colors);\n * ```\n */\nexport declare function _nativeEnum<T extends util.EnumLike>(Class: util.SchemaClass<schemas.$ZodEnum>, entries: T, params?: string | $ZodEnumParams): schemas.$ZodEnum<T>;\nexport type $ZodLiteralParams = TypeParams<schemas.$ZodLiteral, \"values\">;\nexport declare function _literal<const T extends Array<util.Literal>>(Class: util.SchemaClass<schemas.$ZodLiteral>, value: T, params?: string | $ZodLiteralParams): schemas.$ZodLiteral<T[number]>;\nexport declare function _literal<const T extends util.Literal>(Class: util.SchemaClass<schemas.$ZodLiteral>, value: T, params?: string | $ZodLiteralParams): schemas.$ZodLiteral<T>;\nexport type $ZodFileParams = TypeParams<schemas.$ZodFile>;\nexport declare function _file(Class: util.SchemaClass<schemas.$ZodFile>, params?: string | $ZodFileParams): schemas.$ZodFile;\nexport type $ZodTransformParams = TypeParams<schemas.$ZodTransform, \"transform\">;\nexport declare function _transform<I = unknown, O = I>(Class: util.SchemaClass<schemas.$ZodTransform>, fn: (input: I, ctx?: schemas.ParsePayload) => O): schemas.$ZodTransform<Awaited<O>, I>;\nexport type $ZodOptionalParams = TypeParams<schemas.$ZodOptional, \"innerType\">;\nexport declare function _optional<T extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodOptional>, innerType: T): schemas.$ZodOptional<T>;\nexport type $ZodNullableParams = TypeParams<schemas.$ZodNullable, \"innerType\">;\nexport declare function _nullable<T extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodNullable>, innerType: T): schemas.$ZodNullable<T>;\nexport type $ZodDefaultParams = TypeParams<schemas.$ZodDefault, \"innerType\" | \"defaultValue\">;\nexport declare function _default<T extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodDefault>, innerType: T, defaultValue: util.NoUndefined<core.output<T>> | (() => util.NoUndefined<core.output<T>>)): schemas.$ZodDefault<T>;\nexport type $ZodNonOptionalParams = TypeParams<schemas.$ZodNonOptional, \"innerType\">;\nexport declare function _nonoptional<T extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodNonOptional>, innerType: T, params?: string | $ZodNonOptionalParams): schemas.$ZodNonOptional<T>;\nexport type $ZodSuccessParams = TypeParams<schemas.$ZodSuccess, \"innerType\">;\nexport declare function _success<T extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodSuccess>, innerType: T): schemas.$ZodSuccess<T>;\nexport type $ZodCatchParams = TypeParams<schemas.$ZodCatch, \"innerType\" | \"catchValue\">;\nexport declare function _catch<T extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodCatch>, innerType: T, catchValue: core.output<T> | ((ctx: schemas.$ZodCatchCtx) => core.output<T>)): schemas.$ZodCatch<T>;\nexport type $ZodPipeParams = TypeParams<schemas.$ZodPipe, \"in\" | \"out\">;\nexport declare function _pipe<const A extends schemas.$ZodType, B extends schemas.$ZodType<unknown, core.output<A>> = schemas.$ZodType<unknown, core.output<A>>>(Class: util.SchemaClass<schemas.$ZodPipe>, in_: A, out: B | schemas.$ZodType<unknown, core.output<A>>): schemas.$ZodPipe<A, B>;\nexport type $ZodReadonlyParams = TypeParams<schemas.$ZodReadonly, \"innerType\">;\nexport declare function _readonly<T extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodReadonly>, innerType: T): schemas.$ZodReadonly<T>;\nexport type $ZodTemplateLiteralParams = TypeParams<schemas.$ZodTemplateLiteral, \"parts\">;\nexport declare function _templateLiteral<const Parts extends schemas.$ZodTemplateLiteralPart[]>(Class: util.SchemaClass<schemas.$ZodTemplateLiteral>, parts: Parts, params?: string | $ZodTemplateLiteralParams): schemas.$ZodTemplateLiteral<schemas.$PartsToTemplateLiteral<Parts>>;\nexport type $ZodLazyParams = TypeParams<schemas.$ZodLazy, \"getter\">;\nexport declare function _lazy<T extends schemas.$ZodType>(Class: util.SchemaClass<schemas.$ZodLazy>, getter: () => T): schemas.$ZodLazy<T>;\nexport type $ZodPromiseParams = TypeParams<schemas.$ZodPromise, \"innerType\">;\nexport declare function _promise<T extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodPromise>, innerType: T): schemas.$ZodPromise<T>;\nexport type $ZodCustomParams = CheckTypeParams<schemas.$ZodCustom, \"fn\">;\nexport declare function _custom<O = unknown, I = O>(Class: util.SchemaClass<schemas.$ZodCustom>, fn: (data: O) => unknown, _params: string | $ZodCustomParams | undefined): schemas.$ZodCustom<O, I>;\nexport declare function _refine<O = unknown, I = O>(Class: util.SchemaClass<schemas.$ZodCustom>, fn: (data: O) => unknown, _params: string | $ZodCustomParams | undefined): schemas.$ZodCustom<O, I>;\nexport interface $ZodStringBoolParams extends TypeParams {\n    truthy?: string[];\n    falsy?: string[];\n    /**\n     * Options: `\"sensitive\"`, `\"insensitive\"`\n     *\n     * @default `\"insensitive\"`\n     */\n    case?: \"sensitive\" | \"insensitive\" | undefined;\n}\nexport declare function _stringbool(Classes: {\n    Pipe?: typeof schemas.$ZodPipe;\n    Boolean?: typeof schemas.$ZodBoolean;\n    Transform?: typeof schemas.$ZodTransform;\n    String?: typeof schemas.$ZodString;\n}, _params?: string | $ZodStringBoolParams): schemas.$ZodPipe<schemas.$ZodPipe<schemas.$ZodString, schemas.$ZodTransform<boolean, string>>, schemas.$ZodBoolean<boolean>>;\nexport declare function _stringFormat<Format extends string>(Class: typeof schemas.$ZodCustomStringFormat, format: Format, fnOrRegex: ((arg: string) => util.MaybeAsync<unknown>) | RegExp, _params?: string | $ZodStringFormatParams): schemas.$ZodCustomStringFormat<Format>;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/api.d.cts",
        "start": 5,
        "end": 284,
        "startLoc": {
          "line": 5,
          "column": 13,
          "position": 67
        },
        "endLoc": {
          "line": 284,
          "column": 2,
          "position": 8300
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/api.d.ts",
        "start": 5,
        "end": 284,
        "startLoc": {
          "line": 5,
          "column": 12,
          "position": 67
        },
        "endLoc": {
          "line": 284,
          "column": 2,
          "position": 8300
        }
      }
    },
    {
      "format": "typescript",
      "lines": 628,
      "fragment": ";\nexport interface RefinementCtx<T = unknown> extends core.ParsePayload<T> {\n    addIssue(arg: string | core.$ZodRawIssue | Partial<core.$ZodIssueCustom>): void;\n}\nexport interface ZodType<out Output = unknown, out Input = unknown, out Internals extends core.$ZodTypeInternals<Output, Input> = core.$ZodTypeInternals<Output, Input>> extends core.$ZodType<Output, Input, Internals> {\n    def: Internals[\"def\"];\n    type: Internals[\"def\"][\"type\"];\n    /** @deprecated Use `.def` instead. */\n    _def: Internals[\"def\"];\n    /** @deprecated Use `z.output<typeof schema>` instead. */\n    _output: Internals[\"output\"];\n    /** @deprecated Use `z.input<typeof schema>` instead. */\n    _input: Internals[\"input\"];\n    check(...checks: (core.CheckFn<core.output<this>> | core.$ZodCheck<core.output<this>>)[]): this;\n    clone(def?: Internals[\"def\"], params?: {\n        parent: boolean;\n    }): this;\n    register<R extends core.$ZodRegistry>(registry: R, ...meta: this extends R[\"_schema\"] ? undefined extends R[\"_meta\"] ? [core.$replace<R[\"_meta\"], this>?] : [core.$replace<R[\"_meta\"], this>] : [\"Incompatible schema\"]): this;\n    brand<T extends PropertyKey = PropertyKey>(value?: T): PropertyKey extends T ? this : core.$ZodBranded<this, T>;\n    parse(data: unknown, params?: core.ParseContext<core.$ZodIssue>): core.output<this>;\n    safeParse(data: unknown, params?: core.ParseContext<core.$ZodIssue>): parse.ZodSafeParseResult<core.output<this>>;\n    parseAsync(data: unknown, params?: core.ParseContext<core.$ZodIssue>): Promise<core.output<this>>;\n    safeParseAsync(data: unknown, params?: core.ParseContext<core.$ZodIssue>): Promise<parse.ZodSafeParseResult<core.output<this>>>;\n    spa: (data: unknown, params?: core.ParseContext<core.$ZodIssue>) => Promise<parse.ZodSafeParseResult<core.output<this>>>;\n    refine(check: (arg: core.output<this>) => unknown | Promise<unknown>, params?: string | core.$ZodCustomParams): this;\n    /** @deprecated Use `.check()` instead. */\n    superRefine(refinement: (arg: core.output<this>, ctx: RefinementCtx<core.output<this>>) => void | Promise<void>): this;\n    overwrite(fn: (x: core.output<this>) => core.output<this>): this;\n    optional(): ZodOptional<this>;\n    nonoptional(params?: string | core.$ZodNonOptionalParams): ZodNonOptional<this>;\n    nullable(): ZodNullable<this>;\n    nullish(): ZodOptional<ZodNullable<this>>;\n    default(def: core.output<this>): ZodDefault<this>;\n    default(def: () => util.NoUndefined<core.output<this>>): ZodDefault<this>;\n    prefault(def: () => core.input<this>): ZodPrefault<this>;\n    prefault(def: core.input<this>): ZodPrefault<this>;\n    array(): ZodArray<this>;\n    or<T extends core.SomeType>(option: T): ZodUnion<[this, T]>;\n    and<T extends core.SomeType>(incoming: T): ZodIntersection<this, T>;\n    transform<NewOut>(transform: (arg: core.output<this>, ctx: RefinementCtx<core.output<this>>) => NewOut | Promise<NewOut>): ZodPipe<this, ZodTransform<Awaited<NewOut>, core.output<this>>>;\n    catch(def: core.output<this>): ZodCatch<this>;\n    catch(def: (ctx: core.$ZodCatchCtx) => core.output<this>): ZodCatch<this>;\n    pipe<T extends core.$ZodType<any, core.output<this>>>(target: T | core.$ZodType<any, core.output<this>>): ZodPipe<this, T>;\n    readonly(): ZodReadonly<this>;\n    /** Returns a new instance that has been registered in `z.globalRegistry` with the specified description */\n    describe(description: string): this;\n    description?: string;\n    /** Returns the metadata associated with this instance in `z.globalRegistry` */\n    meta(): core.$replace<core.GlobalMeta, this> | undefined;\n    /** Returns a new instance that has been registered in `z.globalRegistry` with the specified metadata */\n    meta(data: core.$replace<core.GlobalMeta, this>): this;\n    /** @deprecated Try safe-parsing `undefined` (this is what `isOptional` does internally):\n     *\n     * ```ts\n     * const schema = z.string().optional();\n     * const isOptional = schema.safeParse(undefined).success; // true\n     * ```\n     */\n    isOptional(): boolean;\n    /**\n     * @deprecated Try safe-parsing `null` (this is what `isNullable` does internally):\n     *\n     * ```ts\n     * const schema = z.string().nullable();\n     * const isNullable = schema.safeParse(null).success; // true\n     * ```\n     */\n    isNullable(): boolean;\n}\nexport interface _ZodType<out Internals extends core.$ZodTypeInternals = core.$ZodTypeInternals> extends ZodType<any, any, Internals> {\n}\nexport declare const ZodType: core.$constructor<ZodType>;\nexport interface _ZodString<T extends core.$ZodStringInternals<unknown> = core.$ZodStringInternals<unknown>> extends _ZodType<T> {\n    format: string | null;\n    minLength: number | null;\n    maxLength: number | null;\n    regex(regex: RegExp, params?: string | core.$ZodCheckRegexParams): this;\n    includes(value: string, params?: core.$ZodCheckIncludesParams): this;\n    startsWith(value: string, params?: string | core.$ZodCheckStartsWithParams): this;\n    endsWith(value: string, params?: string | core.$ZodCheckEndsWithParams): this;\n    min(minLength: number, params?: string | core.$ZodCheckMinLengthParams): this;\n    max(maxLength: number, params?: string | core.$ZodCheckMaxLengthParams): this;\n    length(len: number, params?: string | core.$ZodCheckLengthEqualsParams): this;\n    nonempty(params?: string | core.$ZodCheckMinLengthParams): this;\n    lowercase(params?: string | core.$ZodCheckLowerCaseParams): this;\n    uppercase(params?: string | core.$ZodCheckUpperCaseParams): this;\n    trim(): this;\n    normalize(form?: \"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\" | (string & {})): this;\n    toLowerCase(): this;\n    toUpperCase(): this;\n}\n/** @internal */\nexport declare const _ZodString: core.$constructor<_ZodString>;\nexport interface ZodString extends _ZodString<core.$ZodStringInternals<string>> {\n    /** @deprecated Use `z.email()` instead. */\n    email(params?: string | core.$ZodCheckEmailParams): this;\n    /** @deprecated Use `z.url()` instead. */\n    url(params?: string | core.$ZodCheckURLParams): this;\n    /** @deprecated Use `z.jwt()` instead. */\n    jwt(params?: string | core.$ZodCheckJWTParams): this;\n    /** @deprecated Use `z.emoji()` instead. */\n    emoji(params?: string | core.$ZodCheckEmojiParams): this;\n    /** @deprecated Use `z.guid()` instead. */\n    guid(params?: string | core.$ZodCheckGUIDParams): this;\n    /** @deprecated Use `z.uuid()` instead. */\n    uuid(params?: string | core.$ZodCheckUUIDParams): this;\n    /** @deprecated Use `z.uuid()` instead. */\n    uuidv4(params?: string | core.$ZodCheckUUIDParams): this;\n    /** @deprecated Use `z.uuid()` instead. */\n    uuidv6(params?: string | core.$ZodCheckUUIDParams): this;\n    /** @deprecated Use `z.uuid()` instead. */\n    uuidv7(params?: string | core.$ZodCheckUUIDParams): this;\n    /** @deprecated Use `z.nanoid()` instead. */\n    nanoid(params?: string | core.$ZodCheckNanoIDParams): this;\n    /** @deprecated Use `z.guid()` instead. */\n    guid(params?: string | core.$ZodCheckGUIDParams): this;\n    /** @deprecated Use `z.cuid()` instead. */\n    cuid(params?: string | core.$ZodCheckCUIDParams): this;\n    /** @deprecated Use `z.cuid2()` instead. */\n    cuid2(params?: string | core.$ZodCheckCUID2Params): this;\n    /** @deprecated Use `z.ulid()` instead. */\n    ulid(params?: string | core.$ZodCheckULIDParams): this;\n    /** @deprecated Use `z.base64()` instead. */\n    base64(params?: string | core.$ZodCheckBase64Params): this;\n    /** @deprecated Use `z.base64url()` instead. */\n    base64url(params?: string | core.$ZodCheckBase64URLParams): this;\n    /** @deprecated Use `z.xid()` instead. */\n    xid(params?: string | core.$ZodCheckXIDParams): this;\n    /** @deprecated Use `z.ksuid()` instead. */\n    ksuid(params?: string | core.$ZodCheckKSUIDParams): this;\n    /** @deprecated Use `z.ipv4()` instead. */\n    ipv4(params?: string | core.$ZodCheckIPv4Params): this;\n    /** @deprecated Use `z.ipv6()` instead. */\n    ipv6(params?: string | core.$ZodCheckIPv6Params): this;\n    /** @deprecated Use `z.cidrv4()` instead. */\n    cidrv4(params?: string | core.$ZodCheckCIDRv4Params): this;\n    /** @deprecated Use `z.cidrv6()` instead. */\n    cidrv6(params?: string | core.$ZodCheckCIDRv6Params): this;\n    /** @deprecated Use `z.e164()` instead. */\n    e164(params?: string | core.$ZodCheckE164Params): this;\n    /** @deprecated Use `z.iso.datetime()` instead. */\n    datetime(params?: string | core.$ZodCheckISODateTimeParams): this;\n    /** @deprecated Use `z.iso.date()` instead. */\n    date(params?: string | core.$ZodCheckISODateParams): this;\n    /** @deprecated Use `z.iso.time()` instead. */\n    time(params?: string | core.$ZodCheckISOTimeParams): this;\n    /** @deprecated Use `z.iso.duration()` instead. */\n    duration(params?: string | core.$ZodCheckISODurationParams): this;\n}\nexport declare const ZodString: core.$constructor<ZodString>;\nexport declare function string(params?: string | core.$ZodStringParams): ZodString;\nexport declare function string<T extends string>(params?: string | core.$ZodStringParams): core.$ZodType<T, T>;\nexport interface ZodStringFormat<Format extends string = string> extends _ZodString<core.$ZodStringFormatInternals<Format>> {\n}\nexport declare const ZodStringFormat: core.$constructor<ZodStringFormat>;\nexport interface ZodEmail extends ZodStringFormat<\"email\"> {\n    _zod: core.$ZodEmailInternals;\n}\nexport declare const ZodEmail: core.$constructor<ZodEmail>;\nexport declare function email(params?: string | core.$ZodEmailParams): ZodEmail;\nexport interface ZodGUID extends ZodStringFormat<\"guid\"> {\n    _zod: core.$ZodGUIDInternals;\n}\nexport declare const ZodGUID: core.$constructor<ZodGUID>;\nexport declare function guid(params?: string | core.$ZodGUIDParams): ZodGUID;\nexport interface ZodUUID extends ZodStringFormat<\"uuid\"> {\n    _zod: core.$ZodUUIDInternals;\n}\nexport declare const ZodUUID: core.$constructor<ZodUUID>;\nexport declare function uuid(params?: string | core.$ZodUUIDParams): ZodUUID;\nexport declare function uuidv4(params?: string | core.$ZodUUIDv4Params): ZodUUID;\nexport declare function uuidv6(params?: string | core.$ZodUUIDv6Params): ZodUUID;\nexport declare function uuidv7(params?: string | core.$ZodUUIDv7Params): ZodUUID;\nexport interface ZodURL extends ZodStringFormat<\"url\"> {\n    _zod: core.$ZodURLInternals;\n}\nexport declare const ZodURL: core.$constructor<ZodURL>;\nexport declare function url(params?: string | core.$ZodURLParams): ZodURL;\nexport interface ZodEmoji extends ZodStringFormat<\"emoji\"> {\n    _zod: core.$ZodEmojiInternals;\n}\nexport declare const ZodEmoji: core.$constructor<ZodEmoji>;\nexport declare function emoji(params?: string | core.$ZodEmojiParams): ZodEmoji;\nexport interface ZodNanoID extends ZodStringFormat<\"nanoid\"> {\n    _zod: core.$ZodNanoIDInternals;\n}\nexport declare const ZodNanoID: core.$constructor<ZodNanoID>;\nexport declare function nanoid(params?: string | core.$ZodNanoIDParams): ZodNanoID;\nexport interface ZodCUID extends ZodStringFormat<\"cuid\"> {\n    _zod: core.$ZodCUIDInternals;\n}\nexport declare const ZodCUID: core.$constructor<ZodCUID>;\nexport declare function cuid(params?: string | core.$ZodCUIDParams): ZodCUID;\nexport interface ZodCUID2 extends ZodStringFormat<\"cuid2\"> {\n    _zod: core.$ZodCUID2Internals;\n}\nexport declare const ZodCUID2: core.$constructor<ZodCUID2>;\nexport declare function cuid2(params?: string | core.$ZodCUID2Params): ZodCUID2;\nexport interface ZodULID extends ZodStringFormat<\"ulid\"> {\n    _zod: core.$ZodULIDInternals;\n}\nexport declare const ZodULID: core.$constructor<ZodULID>;\nexport declare function ulid(params?: string | core.$ZodULIDParams): ZodULID;\nexport interface ZodXID extends ZodStringFormat<\"xid\"> {\n    _zod: core.$ZodXIDInternals;\n}\nexport declare const ZodXID: core.$constructor<ZodXID>;\nexport declare function xid(params?: string | core.$ZodXIDParams): ZodXID;\nexport interface ZodKSUID extends ZodStringFormat<\"ksuid\"> {\n    _zod: core.$ZodKSUIDInternals;\n}\nexport declare const ZodKSUID: core.$constructor<ZodKSUID>;\nexport declare function ksuid(params?: string | core.$ZodKSUIDParams): ZodKSUID;\nexport interface ZodIPv4 extends ZodStringFormat<\"ipv4\"> {\n    _zod: core.$ZodIPv4Internals;\n}\nexport declare const ZodIPv4: core.$constructor<ZodIPv4>;\nexport declare function ipv4(params?: string | core.$ZodIPv4Params): ZodIPv4;\nexport interface ZodIPv6 extends ZodStringFormat<\"ipv6\"> {\n    _zod: core.$ZodIPv6Internals;\n}\nexport declare const ZodIPv6: core.$constructor<ZodIPv6>;\nexport declare function ipv6(params?: string | core.$ZodIPv6Params): ZodIPv6;\nexport interface ZodCIDRv4 extends ZodStringFormat<\"cidrv4\"> {\n    _zod: core.$ZodCIDRv4Internals;\n}\nexport declare const ZodCIDRv4: core.$constructor<ZodCIDRv4>;\nexport declare function cidrv4(params?: string | core.$ZodCIDRv4Params): ZodCIDRv4;\nexport interface ZodCIDRv6 extends ZodStringFormat<\"cidrv6\"> {\n    _zod: core.$ZodCIDRv6Internals;\n}\nexport declare const ZodCIDRv6: core.$constructor<ZodCIDRv6>;\nexport declare function cidrv6(params?: string | core.$ZodCIDRv6Params): ZodCIDRv6;\nexport interface ZodBase64 extends ZodStringFormat<\"base64\"> {\n    _zod: core.$ZodBase64Internals;\n}\nexport declare const ZodBase64: core.$constructor<ZodBase64>;\nexport declare function base64(params?: string | core.$ZodBase64Params): ZodBase64;\nexport interface ZodBase64URL extends ZodStringFormat<\"base64url\"> {\n    _zod: core.$ZodBase64URLInternals;\n}\nexport declare const ZodBase64URL: core.$constructor<ZodBase64URL>;\nexport declare function base64url(params?: string | core.$ZodBase64URLParams): ZodBase64URL;\nexport interface ZodE164 extends ZodStringFormat<\"e164\"> {\n    _zod: core.$ZodE164Internals;\n}\nexport declare const ZodE164: core.$constructor<ZodE164>;\nexport declare function e164(params?: string | core.$ZodE164Params): ZodE164;\nexport interface ZodJWT extends ZodStringFormat<\"jwt\"> {\n    _zod: core.$ZodJWTInternals;\n}\nexport declare const ZodJWT: core.$constructor<ZodJWT>;\nexport declare function jwt(params?: string | core.$ZodJWTParams): ZodJWT;\nexport interface ZodCustomStringFormat<Format extends string = string> extends ZodStringFormat<Format>, core.$ZodCustomStringFormat<Format> {\n    _zod: core.$ZodCustomStringFormatInternals<Format>;\n}\nexport declare const ZodCustomStringFormat: core.$constructor<ZodCustomStringFormat>;\nexport declare function stringFormat<Format extends string>(format: Format, fnOrRegex: ((arg: string) => util.MaybeAsync<unknown>) | RegExp, _params?: string | core.$ZodStringFormatParams): ZodCustomStringFormat<Format>;\nexport interface _ZodNumber<Internals extends core.$ZodNumberInternals = core.$ZodNumberInternals> extends _ZodType<Internals> {\n    gt(value: number, params?: string | core.$ZodCheckGreaterThanParams): this;\n    /** Identical to .min() */\n    gte(value: number, params?: string | core.$ZodCheckGreaterThanParams): this;\n    min(value: number, params?: string | core.$ZodCheckGreaterThanParams): this;\n    lt(value: number, params?: string | core.$ZodCheckLessThanParams): this;\n    /** Identical to .max() */\n    lte(value: number, params?: string | core.$ZodCheckLessThanParams): this;\n    max(value: number, params?: string | core.$ZodCheckLessThanParams): this;\n    /** Consider `z.int()` instead. This API is considered *legacy*; it will never be removed but a better alternative exists. */\n    int(params?: string | core.$ZodCheckNumberFormatParams): this;\n    /** @deprecated This is now identical to `.int()`. Only numbers in the safe integer range are accepted. */\n    safe(params?: string | core.$ZodCheckNumberFormatParams): this;\n    positive(params?: string | core.$ZodCheckGreaterThanParams): this;\n    nonnegative(params?: string | core.$ZodCheckGreaterThanParams): this;\n    negative(params?: string | core.$ZodCheckLessThanParams): this;\n    nonpositive(params?: string | core.$ZodCheckLessThanParams): this;\n    multipleOf(value: number, params?: string | core.$ZodCheckMultipleOfParams): this;\n    /** @deprecated Use `.multipleOf()` instead. */\n    step(value: number, params?: string | core.$ZodCheckMultipleOfParams): this;\n    /** @deprecated In v4 and later, z.number() does not allow infinite values by default. This is a no-op. */\n    finite(params?: unknown): this;\n    minValue: number | null;\n    maxValue: number | null;\n    /** @deprecated Check the `format` property instead.  */\n    isInt: boolean;\n    /** @deprecated Number schemas no longer accept infinite values, so this always returns `true`. */\n    isFinite: boolean;\n    format: string | null;\n}\nexport interface ZodNumber extends _ZodNumber<core.$ZodNumberInternals<number>> {\n}\nexport declare const ZodNumber: core.$constructor<ZodNumber>;\nexport declare function number(params?: string | core.$ZodNumberParams): ZodNumber;\nexport interface ZodNumberFormat extends ZodNumber {\n    _zod: core.$ZodNumberFormatInternals;\n}\nexport declare const ZodNumberFormat: core.$constructor<ZodNumberFormat>;\nexport interface ZodInt extends ZodNumberFormat {\n}\nexport declare function int(params?: string | core.$ZodCheckNumberFormatParams): ZodInt;\nexport interface ZodFloat32 extends ZodNumberFormat {\n}\nexport declare function float32(params?: string | core.$ZodCheckNumberFormatParams): ZodFloat32;\nexport interface ZodFloat64 extends ZodNumberFormat {\n}\nexport declare function float64(params?: string | core.$ZodCheckNumberFormatParams): ZodFloat64;\nexport interface ZodInt32 extends ZodNumberFormat {\n}\nexport declare function int32(params?: string | core.$ZodCheckNumberFormatParams): ZodInt32;\nexport interface ZodUInt32 extends ZodNumberFormat {\n}\nexport declare function uint32(params?: string | core.$ZodCheckNumberFormatParams): ZodUInt32;\nexport interface _ZodBoolean<T extends core.$ZodBooleanInternals = core.$ZodBooleanInternals> extends _ZodType<T> {\n}\nexport interface ZodBoolean extends _ZodBoolean<core.$ZodBooleanInternals<boolean>> {\n}\nexport declare const ZodBoolean: core.$constructor<ZodBoolean>;\nexport declare function boolean(params?: string | core.$ZodBooleanParams): ZodBoolean;\nexport interface _ZodBigInt<T extends core.$ZodBigIntInternals = core.$ZodBigIntInternals> extends _ZodType<T> {\n    gte(value: bigint, params?: string | core.$ZodCheckGreaterThanParams): this;\n    /** Alias of `.gte()` */\n    min(value: bigint, params?: string | core.$ZodCheckGreaterThanParams): this;\n    gt(value: bigint, params?: string | core.$ZodCheckGreaterThanParams): this;\n    /** Alias of `.lte()` */\n    lte(value: bigint, params?: string | core.$ZodCheckLessThanParams): this;\n    max(value: bigint, params?: string | core.$ZodCheckLessThanParams): this;\n    lt(value: bigint, params?: string | core.$ZodCheckLessThanParams): this;\n    positive(params?: string | core.$ZodCheckGreaterThanParams): this;\n    negative(params?: string | core.$ZodCheckLessThanParams): this;\n    nonpositive(params?: string | core.$ZodCheckLessThanParams): this;\n    nonnegative(params?: string | core.$ZodCheckGreaterThanParams): this;\n    multipleOf(value: bigint, params?: string | core.$ZodCheckMultipleOfParams): this;\n    minValue: bigint | null;\n    maxValue: bigint | null;\n    format: string | null;\n}\nexport interface ZodBigInt extends _ZodBigInt<core.$ZodBigIntInternals<bigint>> {\n}\nexport declare const ZodBigInt: core.$constructor<ZodBigInt>;\nexport declare function bigint(params?: string | core.$ZodBigIntParams): ZodBigInt;\nexport interface ZodBigIntFormat extends ZodBigInt {\n    _zod: core.$ZodBigIntFormatInternals;\n}\nexport declare const ZodBigIntFormat: core.$constructor<ZodBigIntFormat>;\nexport declare function int64(params?: string | core.$ZodBigIntFormatParams): ZodBigIntFormat;\nexport declare function uint64(params?: string | core.$ZodBigIntFormatParams): ZodBigIntFormat;\nexport interface ZodSymbol extends _ZodType<core.$ZodSymbolInternals> {\n}\nexport declare const ZodSymbol: core.$constructor<ZodSymbol>;\nexport declare function symbol(params?: string | core.$ZodSymbolParams): ZodSymbol;\nexport interface ZodUndefined extends _ZodType<core.$ZodUndefinedInternals> {\n}\nexport declare const ZodUndefined: core.$constructor<ZodUndefined>;\ndeclare function _undefined(params?: string | core.$ZodUndefinedParams): ZodUndefined;\nexport { _undefined as undefined };\nexport interface ZodNull extends _ZodType<core.$ZodNullInternals> {\n}\nexport declare const ZodNull: core.$constructor<ZodNull>;\ndeclare function _null(params?: string | core.$ZodNullParams): ZodNull;\nexport { _null as null };\nexport interface ZodAny extends _ZodType<core.$ZodAnyInternals> {\n}\nexport declare const ZodAny: core.$constructor<ZodAny>;\nexport declare function any(): ZodAny;\nexport interface ZodUnknown extends _ZodType<core.$ZodUnknownInternals> {\n}\nexport declare const ZodUnknown: core.$constructor<ZodUnknown>;\nexport declare function unknown(): ZodUnknown;\nexport interface ZodNever extends _ZodType<core.$ZodNeverInternals> {\n}\nexport declare const ZodNever: core.$constructor<ZodNever>;\nexport declare function never(params?: string | core.$ZodNeverParams): ZodNever;\nexport interface ZodVoid extends _ZodType<core.$ZodVoidInternals> {\n}\nexport declare const ZodVoid: core.$constructor<ZodVoid>;\ndeclare function _void(params?: string | core.$ZodVoidParams): ZodVoid;\nexport { _void as void };\nexport interface _ZodDate<T extends core.$ZodDateInternals = core.$ZodDateInternals> extends _ZodType<T> {\n    min(value: number | Date, params?: string | core.$ZodCheckGreaterThanParams): this;\n    max(value: number | Date, params?: string | core.$ZodCheckLessThanParams): this;\n    /** @deprecated Not recommended. */\n    minDate: Date | null;\n    /** @deprecated Not recommended. */\n    maxDate: Date | null;\n}\nexport interface ZodDate extends _ZodDate<core.$ZodDateInternals<Date>> {\n}\nexport declare const ZodDate: core.$constructor<ZodDate>;\nexport declare function date(params?: string | core.$ZodDateParams): ZodDate;\nexport interface ZodArray<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodArrayInternals<T>>, core.$ZodArray<T> {\n    element: T;\n    min(minLength: number, params?: string | core.$ZodCheckMinLengthParams): this;\n    nonempty(params?: string | core.$ZodCheckMinLengthParams): this;\n    max(maxLength: number, params?: string | core.$ZodCheckMaxLengthParams): this;\n    length(len: number, params?: string | core.$ZodCheckLengthEqualsParams): this;\n    unwrap(): T;\n}\nexport declare const ZodArray: core.$constructor<ZodArray>;\nexport declare function array<T extends core.SomeType>(element: T, params?: string | core.$ZodArrayParams): ZodArray<T>;\nexport declare function keyof<T extends ZodObject>(schema: T): ZodLiteral<Exclude<keyof T[\"_zod\"][\"output\"], symbol>>;\nexport interface ZodObject<\n/** @ts-ignore Cast variance */\nout Shape extends core.$ZodShape = core.$ZodLooseShape, out Config extends core.$ZodObjectConfig = core.$strip> extends _ZodType<core.$ZodObjectInternals<Shape, Config>>, core.$ZodObject<Shape, Config> {\n    shape: Shape;\n    keyof(): ZodEnum<util.ToEnum<keyof Shape & string>>;\n    /** Define a schema to validate all unrecognized keys. This overrides the existing strict/loose behavior. */\n    catchall<T extends core.SomeType>(schema: T): ZodObject<Shape, core.$catchall<T>>;\n    /** @deprecated Use `z.looseObject()` or `.loose()` instead. */\n    passthrough(): ZodObject<Shape, core.$loose>;\n    /** Consider `z.looseObject(A.shape)` instead */\n    loose(): ZodObject<Shape, core.$loose>;\n    /** Consider `z.strictObject(A.shape)` instead */\n    strict(): ZodObject<Shape, core.$strict>;\n    /** This is the default behavior. This method call is likely unnecessary. */\n    strip(): ZodObject<Shape, core.$strip>;\n    extend<U extends core.$ZodLooseShape & Partial<Record<keyof Shape, core.SomeType>>>(shape: U): ZodObject<util.Extend<Shape, U>, Config>;\n    /**\n     * @deprecated Use spread syntax and the `.shape` property to combine two object schemas:\n     *\n     * ```ts\n     * const A = z.object({ a: z.string() });\n     * const B = z.object({ b: z.number() });\n     *\n     * const C = z.object({\n     *    ...A.shape,\n     *    ...B.shape\n     * });\n     * ```\n     */\n    merge<U extends ZodObject>(other: U): ZodObject<util.Extend<Shape, U[\"shape\"]>, U[\"_zod\"][\"config\"]>;\n    pick<M extends util.Mask<keyof Shape>>(mask: M): ZodObject<util.Flatten<Pick<Shape, Extract<keyof Shape, keyof M>>>, Config>;\n    omit<M extends util.Mask<keyof Shape>>(mask: M): ZodObject<util.Flatten<Omit<Shape, Extract<keyof Shape, keyof M>>>, Config>;\n    partial(): ZodObject<{\n        [k in keyof Shape]: ZodOptional<Shape[k]>;\n    }, Config>;\n    partial<M extends util.Mask<keyof Shape>>(mask: M): ZodObject<{\n        [k in keyof Shape]: k extends keyof M ? ZodOptional<Shape[k]> : Shape[k];\n    }, Config>;\n    required(): ZodObject<{\n        [k in keyof Shape]: ZodNonOptional<Shape[k]>;\n    }, Config>;\n    required<M extends util.Mask<keyof Shape>>(mask: M): ZodObject<{\n        [k in keyof Shape]: k extends keyof M ? ZodNonOptional<Shape[k]> : Shape[k];\n    }, Config>;\n}\nexport declare const ZodObject: core.$constructor<ZodObject>;\nexport declare function object<T extends core.$ZodLooseShape = Partial<Record<never, core.SomeType>>>(shape?: T, params?: string | core.$ZodObjectParams): ZodObject<util.Writeable<T>, core.$strip>;\nexport declare function strictObject<T extends core.$ZodLooseShape>(shape: T, params?: string | core.$ZodObjectParams): ZodObject<T, core.$strict>;\nexport declare function looseObject<T extends core.$ZodLooseShape>(shape: T, params?: string | core.$ZodObjectParams): ZodObject<T, core.$loose>;\nexport interface ZodUnion<T extends readonly core.SomeType[] = readonly core.$ZodType[]> extends _ZodType<core.$ZodUnionInternals<T>>, core.$ZodUnion<T> {\n    options: T;\n}\nexport declare const ZodUnion: core.$constructor<ZodUnion>;\nexport declare function union<const T extends readonly core.SomeType[]>(options: T, params?: string | core.$ZodUnionParams): ZodUnion<T>;\nexport interface ZodDiscriminatedUnion<Options extends readonly core.SomeType[] = readonly core.$ZodType[]> extends ZodUnion<Options>, core.$ZodDiscriminatedUnion<Options> {\n    _zod: core.$ZodDiscriminatedUnionInternals<Options>;\n}\nexport declare const ZodDiscriminatedUnion: core.$constructor<ZodDiscriminatedUnion>;\nexport declare function discriminatedUnion<Types extends readonly [core.$ZodTypeDiscriminable, ...core.$ZodTypeDiscriminable[]]>(discriminator: string, options: Types, params?: string | core.$ZodDiscriminatedUnionParams): ZodDiscriminatedUnion<Types>;\nexport interface ZodIntersection<A extends core.SomeType = core.$ZodType, B extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodIntersectionInternals<A, B>>, core.$ZodIntersection<A, B> {\n}\nexport declare const ZodIntersection: core.$constructor<ZodIntersection>;\nexport declare function intersection<T extends core.SomeType, U extends core.SomeType>(left: T, right: U): ZodIntersection<T, U>;\nexport interface ZodTuple<T extends util.TupleItems = readonly core.$ZodType[], Rest extends core.SomeType | null = core.$ZodType | null> extends _ZodType<core.$ZodTupleInternals<T, Rest>>, core.$ZodTuple<T, Rest> {\n    rest<Rest extends core.SomeType = core.$ZodType>(rest: Rest): ZodTuple<T, Rest>;\n}\nexport declare const ZodTuple: core.$constructor<ZodTuple>;\nexport declare function tuple<T extends readonly [core.SomeType, ...core.SomeType[]]>(items: T, params?: string | core.$ZodTupleParams): ZodTuple<T, null>;\nexport declare function tuple<T extends readonly [core.SomeType, ...core.SomeType[]], Rest extends core.SomeType>(items: T, rest: Rest, params?: string | core.$ZodTupleParams): ZodTuple<T, Rest>;\nexport declare function tuple(items: [], params?: string | core.$ZodTupleParams): ZodTuple<[], null>;\nexport interface ZodRecord<Key extends core.$ZodRecordKey = core.$ZodRecordKey, Value extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodRecordInternals<Key, Value>>, core.$ZodRecord<Key, Value> {\n    keyType: Key;\n    valueType: Value;\n}\nexport declare const ZodRecord: core.$constructor<ZodRecord>;\nexport declare function record<Key extends core.$ZodRecordKey, Value extends core.SomeType>(keyType: Key, valueType: Value, params?: string | core.$ZodRecordParams): ZodRecord<Key, Value>;\nexport declare function partialRecord<Key extends core.$ZodRecordKey, Value extends core.SomeType>(keyType: Key, valueType: Value, params?: string | core.$ZodRecordParams): ZodRecord<Key & core.$partial, Value>;\nexport interface ZodMap<Key extends core.SomeType = core.$ZodType, Value extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodMapInternals<Key, Value>>, core.$ZodMap<Key, Value> {\n    keyType: Key;\n    valueType: Value;\n}\nexport declare const ZodMap: core.$constructor<ZodMap>;\nexport declare function map<Key extends core.SomeType, Value extends core.SomeType>(keyType: Key, valueType: Value, params?: string | core.$ZodMapParams): ZodMap<Key, Value>;\nexport interface ZodSet<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodSetInternals<T>>, core.$ZodSet<T> {\n    min(minSize: number, params?: string | core.$ZodCheckMinSizeParams): this;\n    /** */\n    nonempty(params?: string | core.$ZodCheckMinSizeParams): this;\n    max(maxSize: number, params?: string | core.$ZodCheckMaxSizeParams): this;\n    size(size: number, params?: string | core.$ZodCheckSizeEqualsParams): this;\n}\nexport declare const ZodSet: core.$constructor<ZodSet>;\nexport declare function set<Value extends core.SomeType>(valueType: Value, params?: string | core.$ZodSetParams): ZodSet<Value>;\nexport interface ZodEnum<\n/** @ts-ignore Cast variance */\nout T extends util.EnumLike = util.EnumLike> extends _ZodType<core.$ZodEnumInternals<T>>, core.$ZodEnum<T> {\n    enum: T;\n    options: Array<T[keyof T]>;\n    extract<const U extends readonly (keyof T)[]>(values: U, params?: string | core.$ZodEnumParams): ZodEnum<util.Flatten<Pick<T, U[number]>>>;\n    exclude<const U extends readonly (keyof T)[]>(values: U, params?: string | core.$ZodEnumParams): ZodEnum<util.Flatten<Omit<T, U[number]>>>;\n}\nexport declare const ZodEnum: core.$constructor<ZodEnum>;\ndeclare function _enum<const T extends readonly string[]>(values: T, params?: string | core.$ZodEnumParams): ZodEnum<util.ToEnum<T[number]>>;\ndeclare function _enum<const T extends util.EnumLike>(entries: T, params?: string | core.$ZodEnumParams): ZodEnum<T>;\nexport { _enum as enum };\n/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.\n *\n * ```ts\n * enum Colors { red, green, blue }\n * z.enum(Colors);\n * ```\n */\nexport declare function nativeEnum<T extends util.EnumLike>(entries: T, params?: string | core.$ZodEnumParams): ZodEnum<T>;\nexport interface ZodLiteral<T extends util.Literal = util.Literal> extends _ZodType<core.$ZodLiteralInternals<T>>, core.$ZodLiteral<T> {\n    values: Set<T>;\n    /** @legacy Use `.values` instead. Accessing this property will throw an error if the literal accepts multiple values. */\n    value: T;\n}\nexport declare const ZodLiteral: core.$constructor<ZodLiteral>;\nexport declare function literal<const T extends ReadonlyArray<util.Literal>>(value: T, params?: string | core.$ZodLiteralParams): ZodLiteral<T[number]>;\nexport declare function literal<const T extends util.Literal>(value: T, params?: string | core.$ZodLiteralParams): ZodLiteral<T>;\nexport interface ZodFile extends _ZodType<core.$ZodFileInternals>, core.$ZodFile {\n    min(size: number, params?: string | core.$ZodCheckMinSizeParams): this;\n    max(size: number, params?: string | core.$ZodCheckMaxSizeParams): this;\n    mime(types: util.MimeTypes | Array<util.MimeTypes>, params?: string | core.$ZodCheckMimeTypeParams): this;\n}\nexport declare const ZodFile: core.$constructor<ZodFile>;\nexport declare function file(params?: string | core.$ZodFileParams): ZodFile;\nexport interface ZodTransform<O = unknown, I = unknown> extends _ZodType<core.$ZodTransformInternals<O, I>>, core.$ZodTransform<O, I> {\n}\nexport declare const ZodTransform: core.$constructor<ZodTransform>;\nexport declare function transform<I = unknown, O = I>(fn: (input: I, ctx: core.ParsePayload) => O): ZodTransform<Awaited<O>, I>;\nexport interface ZodOptional<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodOptionalInternals<T>>, core.$ZodOptional<T> {\n    unwrap(): T;\n}\nexport declare const ZodOptional: core.$constructor<ZodOptional>;\nexport declare function optional<T extends core.SomeType>(innerType: T): ZodOptional<T>;\nexport interface ZodNullable<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodNullableInternals<T>>, core.$ZodNullable<T> {\n    unwrap(): T;\n}\nexport declare const ZodNullable: core.$constructor<ZodNullable>;\nexport declare function nullable<T extends core.SomeType>(innerType: T): ZodNullable<T>;\nexport declare function nullish<T extends core.SomeType>(innerType: T): ZodOptional<ZodNullable<T>>;\nexport interface ZodDefault<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodDefaultInternals<T>>, core.$ZodDefault<T> {\n    unwrap(): T;\n    /** @deprecated Use `.unwrap()` instead. */\n    removeDefault(): T;\n}\nexport declare const ZodDefault: core.$constructor<ZodDefault>;\nexport declare function _default<T extends core.SomeType>(innerType: T, defaultValue: util.NoUndefined<core.output<T>> | (() => util.NoUndefined<core.output<T>>)): ZodDefault<T>;\nexport interface ZodPrefault<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodPrefaultInternals<T>>, core.$ZodPrefault<T> {\n    unwrap(): T;\n}\nexport declare const ZodPrefault: core.$constructor<ZodPrefault>;\nexport declare function prefault<T extends core.SomeType>(innerType: T, defaultValue: core.input<T> | (() => core.input<T>)): ZodPrefault<T>;\nexport interface ZodNonOptional<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodNonOptionalInternals<T>>, core.$ZodNonOptional<T> {\n    unwrap(): T;\n}\nexport declare const ZodNonOptional: core.$constructor<ZodNonOptional>;\nexport declare function nonoptional<T extends core.SomeType>(innerType: T, params?: string | core.$ZodNonOptionalParams): ZodNonOptional<T>;\nexport interface ZodSuccess<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodSuccessInternals<T>>, core.$ZodSuccess<T> {\n    unwrap(): T;\n}\nexport declare const ZodSuccess: core.$constructor<ZodSuccess>;\nexport declare function success<T extends core.SomeType>(innerType: T): ZodSuccess<T>;\nexport interface ZodCatch<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodCatchInternals<T>>, core.$ZodCatch<T> {\n    unwrap(): T;\n    /** @deprecated Use `.unwrap()` instead. */\n    removeCatch(): T;\n}\nexport declare const ZodCatch: core.$constructor<ZodCatch>;\ndeclare function _catch<T extends core.SomeType>(innerType: T, catchValue: core.output<T> | ((ctx: core.$ZodCatchCtx) => core.output<T>)): ZodCatch<T>;\nexport { _catch as catch };\nexport interface ZodNaN extends _ZodType<core.$ZodNaNInternals>, core.$ZodNaN {\n}\nexport declare const ZodNaN: core.$constructor<ZodNaN>;\nexport declare function nan(params?: string | core.$ZodNaNParams): ZodNaN;\nexport interface ZodPipe<A extends core.SomeType = core.$ZodType, B extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodPipeInternals<A, B>>, core.$ZodPipe<A, B> {\n    in: A;\n    out: B;\n}\nexport declare const ZodPipe: core.$constructor<ZodPipe>;\nexport declare function pipe<const A extends core.SomeType, B extends core.$ZodType<unknown, core.output<A>> = core.$ZodType<unknown, core.output<A>>>(in_: A, out: B | core.$ZodType<unknown, core.output<A>>): ZodPipe<A, B>;\nexport interface ZodReadonly<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodReadonlyInternals<T>>, core.$ZodReadonly<T> {\n}\nexport declare const ZodReadonly: core.$constructor<ZodReadonly>;\nexport declare function readonly<T extends core.SomeType>(innerType: T): ZodReadonly<T>;\nexport interface ZodTemplateLiteral<Template extends string = string> extends _ZodType<core.$ZodTemplateLiteralInternals<Template>>, core.$ZodTemplateLiteral<Template> {\n}\nexport declare const ZodTemplateLiteral: core.$constructor<ZodTemplateLiteral>;\nexport declare function templateLiteral<const Parts extends core.$ZodTemplateLiteralPart[]>(parts: Parts, params?: string | core.$ZodTemplateLiteralParams): ZodTemplateLiteral<core.$PartsToTemplateLiteral<Parts>>;\nexport interface ZodLazy<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodLazyInternals<T>>, core.$ZodLazy<T> {\n    unwrap(): T;\n}\nexport declare const ZodLazy: core.$constructor<ZodLazy>;\nexport declare function lazy<T extends core.SomeType>(getter: () => T): ZodLazy<T>;\nexport interface ZodPromise<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodPromiseInternals<T>>, core.$ZodPromise<T> {\n    unwrap(): T;\n}\nexport declare const ZodPromise: core.$constructor<ZodPromise>;\nexport declare function promise<T extends core.SomeType>(innerType: T): ZodPromise<T>;\nexport interface ZodCustom<O = unknown, I = unknown> extends _ZodType<core.$ZodCustomInternals<O, I>>, core.$ZodCustom<O, I> {\n}\nexport declare const ZodCustom: core.$constructor<ZodCustom>;\nexport declare function check<O = unknown>(fn: core.CheckFn<O>): core.$ZodCheck<O>;\nexport declare function custom<O>(fn?: (data: unknown) => unknown, _params?: string | core.$ZodCustomParams | undefined): ZodCustom<O, O>;\nexport declare function refine<T>(fn: (arg: NoInfer<T>) => util.MaybeAsync<unknown>, _params?: string | core.$ZodCustomParams): core.$ZodCheck<T>;\nexport declare function superRefine<T>(fn: (arg: T, payload: RefinementCtx<T>) => void | Promise<void>): core.$ZodCheck<T>;\ntype ZodInstanceOfParams = core.Params<ZodCustom, core.$ZodIssueCustom, \"type\" | \"check\" | \"checks\" | \"fn\" | \"abort\" | \"error\" | \"params\" | \"path\">;\ndeclare function _instanceof<T extends typeof util.Class>(cls: T, params?: ZodInstanceOfParams): ZodCustom<InstanceType<T>, InstanceType<T>>;\nexport { _instanceof as instanceof };\nexport declare const stringbool: (_params?: string | core.$ZodStringBoolParams) => ZodPipe<ZodPipe<ZodString, ZodTransform<boolean, string>>, ZodBoolean>;\ntype _ZodJSONSchema = ZodUnion<[\n    ZodString,\n    ZodNumber,\n    ZodBoolean,\n    ZodNull,\n    ZodArray<ZodJSONSchema>,\n    ZodRecord<ZodString, ZodJSONSchema>\n]>;\ntype _ZodJSONSchemaInternals = _ZodJSONSchema[\"_zod\"];\nexport interface ZodJSONSchemaInternals extends _ZodJSONSchemaInternals {\n    output: util.JSONType;\n    input: util.JSONType;\n}\nexport interface ZodJSONSchema extends _ZodJSONSchema {\n    _zod: ZodJSONSchemaInternals;\n}\nexport declare function json(params?: string | core.$ZodCustomParams): ZodJSONSchema;\nexport declare function preprocess<A, U extends core.SomeType, B = unknown>(fn: (arg: B, ctx: RefinementCtx) => A, schema: U): ZodPipe<ZodTransform<A, B>, U>;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/classic/schemas.d.cts",
        "start": 3,
        "end": 630,
        "startLoc": {
          "line": 3,
          "column": 14,
          "position": 37
        },
        "endLoc": {
          "line": 630,
          "column": 2,
          "position": 11305
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/classic/schemas.d.ts",
        "start": 3,
        "end": 630,
        "startLoc": {
          "line": 3,
          "column": 13,
          "position": 37
        },
        "endLoc": {
          "line": 630,
          "column": 2,
          "position": 11305
        }
      }
    },
    {
      "format": "typescript",
      "lines": 22,
      "fragment": ";\nexport type ZodSafeParseResult<T> = ZodSafeParseSuccess<T> | ZodSafeParseError<T>;\nexport type ZodSafeParseSuccess<T> = {\n    success: true;\n    data: T;\n    error?: never;\n};\nexport type ZodSafeParseError<T> = {\n    success: false;\n    data?: never;\n    error: ZodError<T>;\n};\nexport declare const parse: <T extends core.$ZodType>(schema: T, value: unknown, _ctx?: core.ParseContext<core.$ZodIssue>, _params?: {\n    callee?: core.util.AnyFunc;\n    Err?: core.$ZodErrorClass;\n}) => core.output<T>;\nexport declare const parseAsync: <T extends core.$ZodType>(schema: T, value: unknown, _ctx?: core.ParseContext<core.$ZodIssue>, _params?: {\n    callee?: core.util.AnyFunc;\n    Err?: core.$ZodErrorClass;\n}) => Promise<core.output<T>>;\nexport declare const safeParse: <T extends core.$ZodType>(schema: T, value: unknown, _ctx?: core.ParseContext<core.$ZodIssue>) => ZodSafeParseResult<core.output<T>>;\nexport declare const safeParseAsync: <T extends core.$ZodType>(schema: T, value: unknown, _ctx?: core.ParseContext<core.$ZodIssue>) => Promise<ZodSafeParseResult<core.output<T>>>;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/classic/parse.d.cts",
        "start": 2,
        "end": 23,
        "startLoc": {
          "line": 2,
          "column": 15,
          "position": 26
        },
        "endLoc": {
          "line": 23,
          "column": 2,
          "position": 419
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/classic/parse.d.ts",
        "start": 2,
        "end": 23,
        "startLoc": {
          "line": 2,
          "column": 14,
          "position": 26
        },
        "endLoc": {
          "line": 23,
          "column": 2,
          "position": 419
        }
      }
    },
    {
      "format": "typescript",
      "lines": 21,
      "fragment": ";\nexport interface ZodISODateTime extends schemas.ZodStringFormat {\n    _zod: core.$ZodISODateTimeInternals;\n}\nexport declare const ZodISODateTime: core.$constructor<ZodISODateTime>;\nexport declare function datetime(params?: string | core.$ZodISODateTimeParams): ZodISODateTime;\nexport interface ZodISODate extends schemas.ZodStringFormat {\n    _zod: core.$ZodISODateInternals;\n}\nexport declare const ZodISODate: core.$constructor<ZodISODate>;\nexport declare function date(params?: string | core.$ZodISODateParams): ZodISODate;\nexport interface ZodISOTime extends schemas.ZodStringFormat {\n    _zod: core.$ZodISOTimeInternals;\n}\nexport declare const ZodISOTime: core.$constructor<ZodISOTime>;\nexport declare function time(params?: string | core.$ZodISOTimeParams): ZodISOTime;\nexport interface ZodISODuration extends schemas.ZodStringFormat {\n    _zod: core.$ZodISODurationInternals;\n}\nexport declare const ZodISODuration: core.$constructor<ZodISODuration>;\nexport declare function duration(params?: string | core.$ZodISODurationParams): ZodISODuration;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/classic/iso.d.cts",
        "start": 2,
        "end": 22,
        "startLoc": {
          "line": 2,
          "column": 16,
          "position": 24
        },
        "endLoc": {
          "line": 22,
          "column": 2,
          "position": 296
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/classic/iso.d.ts",
        "start": 2,
        "end": 22,
        "startLoc": {
          "line": 2,
          "column": 15,
          "position": 24
        },
        "endLoc": {
          "line": 22,
          "column": 2,
          "position": 296
        }
      }
    },
    {
      "format": "typescript",
      "lines": 20,
      "fragment": "import * as core from \"../core/index.js\";\nimport { $ZodError } from \"../core/index.js\";\n/** @deprecated Use `z.core.$ZodIssue` from `@zod/core` instead, especially if you are building a library on top of Zod. */\nexport type ZodIssue = core.$ZodIssue;\n/** An Error-like class used to store Zod validation issues.  */\nexport interface ZodError<T = unknown> extends $ZodError<T> {\n    /** @deprecated Use the `z.treeifyError(err)` function instead. */\n    format(): core.$ZodFormattedError<T>;\n    format<U>(mapper: (issue: core.$ZodIssue) => U): core.$ZodFormattedError<T, U>;\n    /** @deprecated Use the `z.treeifyError(err)` function instead. */\n    flatten(): core.$ZodFlattenedError<T>;\n    flatten<U>(mapper: (issue: core.$ZodIssue) => U): core.$ZodFlattenedError<T, U>;\n    /** @deprecated Push directly to `.issues` instead. */\n    addIssue(issue: core.$ZodIssue): void;\n    /** @deprecated Push directly to `.issues` instead. */\n    addIssues(issues: core.$ZodIssue[]): void;\n    /** @deprecated Check `err.issues.length === 0` instead. */\n    isEmpty: boolean;\n}\nexport",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/classic/errors.d.ts",
        "start": 1,
        "end": 20,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 20,
          "column": 7,
          "position": 219
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/errors.ts",
        "start": 1,
        "end": 24,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 24,
          "column": 6,
          "position": 223
        }
      }
    },
    {
      "format": "typescript",
      "lines": 27,
      "fragment": ";\n/** @deprecated Use `z.core.$ZodIssue` from `@zod/core` instead, especially if you are building a library on top of Zod. */\nexport type ZodIssue = core.$ZodIssue;\n/** An Error-like class used to store Zod validation issues.  */\nexport interface ZodError<T = unknown> extends $ZodError<T> {\n    /** @deprecated Use the `z.treeifyError(err)` function instead. */\n    format(): core.$ZodFormattedError<T>;\n    format<U>(mapper: (issue: core.$ZodIssue) => U): core.$ZodFormattedError<T, U>;\n    /** @deprecated Use the `z.treeifyError(err)` function instead. */\n    flatten(): core.$ZodFlattenedError<T>;\n    flatten<U>(mapper: (issue: core.$ZodIssue) => U): core.$ZodFlattenedError<T, U>;\n    /** @deprecated Push directly to `.issues` instead. */\n    addIssue(issue: core.$ZodIssue): void;\n    /** @deprecated Push directly to `.issues` instead. */\n    addIssues(issues: core.$ZodIssue[]): void;\n    /** @deprecated Check `err.issues.length === 0` instead. */\n    isEmpty: boolean;\n}\nexport declare const ZodError: core.$constructor<ZodError>;\nexport declare const ZodRealError: core.$constructor<ZodError>;\nexport type { \n/** @deprecated Use `z.core.$ZodFlattenedError` instead. */\n$ZodFlattenedError as ZodFlattenedError, \n/** @deprecated Use `z.core.$ZodFormattedError` instead. */\n$ZodFormattedError as ZodFormattedError, \n/** @deprecated Use `z.core.$ZodErrorMap` instead. */\n$ZodErrorMap as ZodErrorMap, } from \"../core/index.cjs\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/classic/errors.d.cts",
        "start": 2,
        "end": 28,
        "startLoc": {
          "line": 2,
          "column": 20,
          "position": 24
        },
        "endLoc": {
          "line": 28,
          "column": 20,
          "position": 295
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/errors.ts",
        "start": 2,
        "end": 28,
        "startLoc": {
          "line": 2,
          "column": 19,
          "position": 24
        },
        "endLoc": {
          "line": 28,
          "column": 19,
          "position": 295
        }
      }
    },
    {
      "format": "typescript",
      "lines": 26,
      "fragment": ";\n/** @deprecated Use the raw string literal codes instead, e.g. \"invalid_type\". */\nexport declare const ZodIssueCode: {\n    readonly invalid_type: \"invalid_type\";\n    readonly too_big: \"too_big\";\n    readonly too_small: \"too_small\";\n    readonly invalid_format: \"invalid_format\";\n    readonly not_multiple_of: \"not_multiple_of\";\n    readonly unrecognized_keys: \"unrecognized_keys\";\n    readonly invalid_union: \"invalid_union\";\n    readonly invalid_key: \"invalid_key\";\n    readonly invalid_element: \"invalid_element\";\n    readonly invalid_value: \"invalid_value\";\n    readonly custom: \"custom\";\n};\n/** @deprecated Use `z.$ZodFlattenedError` */\nexport type inferFlattenedErrors<T extends core.$ZodType, U = string> = core.$ZodFlattenedError<core.output<T>, U>;\n/** @deprecated Use `z.$ZodFormattedError` */\nexport type inferFormattedError<T extends core.$ZodType<any, any>, U = string> = core.$ZodFormattedError<core.output<T>, U>;\n/** Use `z.$brand` instead */\nexport type BRAND<T extends string | number | symbol = string | number | symbol> = {\n    [core.$brand]: {\n        [k in T]: true;\n    };\n};\nexport { $brand, config } from \"../core/index.cjs\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/classic/compat.d.cts",
        "start": 9,
        "end": 34,
        "startLoc": {
          "line": 9,
          "column": 20,
          "position": 69
        },
        "endLoc": {
          "line": 34,
          "column": 20,
          "position": 358
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/classic/compat.d.ts",
        "start": 9,
        "end": 34,
        "startLoc": {
          "line": 9,
          "column": 19,
          "position": 69
        },
        "endLoc": {
          "line": 34,
          "column": 19,
          "position": 358
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": ";\n/** @deprecated Use `z.config(params)` instead. */\nexport declare function setErrorMap(map: core.$ZodErrorMap): void;\n/** @deprecated Use `z.config()` instead. */\nexport declare function getErrorMap(): core.$ZodErrorMap<core.$ZodIssue> | undefined;\nexport type { \n/** @deprecated Use z.ZodType (without generics) instead. */\nZodType as ZodTypeAny, \n/** @deprecated Use `z.ZodType` */\nZodType as ZodSchema, \n/** @deprecated Use `z.ZodType` */\nZodType as Schema, };\nexport type ZodRawShape = core.$ZodShape;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/classic/compat.d.cts",
        "start": 34,
        "end": 46,
        "startLoc": {
          "line": 34,
          "column": 20,
          "position": 359
        },
        "endLoc": {
          "line": 46,
          "column": 2,
          "position": 460
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/classic/compat.d.ts",
        "start": 34,
        "end": 46,
        "startLoc": {
          "line": 34,
          "column": 19,
          "position": 359
        },
        "endLoc": {
          "line": 46,
          "column": 2,
          "position": 460
        }
      }
    },
    {
      "format": "typescript",
      "lines": 16,
      "fragment": ";\nexport interface ZodCoercedString<T = unknown> extends schemas._ZodString<core.$ZodStringInternals<T>> {\n}\nexport declare function string<T = unknown>(params?: string | core.$ZodStringParams): ZodCoercedString<T>;\nexport interface ZodCoercedNumber<T = unknown> extends schemas._ZodNumber<core.$ZodNumberInternals<T>> {\n}\nexport declare function number<T = unknown>(params?: string | core.$ZodNumberParams): ZodCoercedNumber<T>;\nexport interface ZodCoercedBoolean<T = unknown> extends schemas._ZodBoolean<core.$ZodBooleanInternals<T>> {\n}\nexport declare function boolean<T = unknown>(params?: string | core.$ZodBooleanParams): ZodCoercedBoolean<T>;\nexport interface ZodCoercedBigInt<T = unknown> extends schemas._ZodBigInt<core.$ZodBigIntInternals<T>> {\n}\nexport declare function bigint<T = unknown>(params?: string | core.$ZodBigIntParams): ZodCoercedBigInt<T>;\nexport interface ZodCoercedDate<T = unknown> extends schemas._ZodDate<core.$ZodDateInternals<T>> {\n}\nexport declare function date<T = unknown>(params?: string | core.$ZodDateParams): ZodCoercedDate<T>;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v4/classic/coerce.d.cts",
        "start": 2,
        "end": 17,
        "startLoc": {
          "line": 2,
          "column": 16,
          "position": 24
        },
        "endLoc": {
          "line": 17,
          "column": 2,
          "position": 349
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/classic/coerce.d.ts",
        "start": 2,
        "end": 17,
        "startLoc": {
          "line": 2,
          "column": 15,
          "position": 24
        },
        "endLoc": {
          "line": 17,
          "column": 2,
          "position": 349
        }
      }
    },
    {
      "format": "typescript",
      "lines": 15,
      "fragment": "keyof U & keyof V extends never ? U & V : {\n        [k in Exclude<keyof U, keyof V>]: U[k];\n    } & V;\n    type optionalKeys<T extends object> = {\n        [k in keyof T]: undefined extends T[k] ? k : never;\n    }[keyof T];\n    type requiredKeys<T extends object> = {\n        [k in keyof T]: undefined extends T[k] ? never : k;\n    }[keyof T];\n    export type addQuestionMarks<T extends object, _O = any> = {\n        [K in requiredKeys<T>]: T[K];\n    } & {\n        [K in optionalKeys<T>]?: T[K];\n    } & {\n        [k in keyof T]?: unknown;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v3/helpers/util.d.ts",
        "start": 28,
        "end": 42,
        "startLoc": {
          "line": 28,
          "column": 2,
          "position": 708
        },
        "endLoc": {
          "line": 42,
          "column": 2,
          "position": 970
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/helpers/util.ts",
        "start": 84,
        "end": 100,
        "startLoc": {
          "line": 84,
          "column": 5,
          "position": 1250
        },
        "endLoc": {
          "line": 100,
          "column": 2,
          "position": 1515
        }
      }
    },
    {
      "format": "typescript",
      "lines": 22,
      "fragment": "const ZodParsedType: {\n    string: \"string\";\n    nan: \"nan\";\n    number: \"number\";\n    integer: \"integer\";\n    float: \"float\";\n    boolean: \"boolean\";\n    date: \"date\";\n    bigint: \"bigint\";\n    symbol: \"symbol\";\n    function: \"function\";\n    undefined: \"undefined\";\n    null: \"null\";\n    array: \"array\";\n    object: \"object\";\n    unknown: \"unknown\";\n    promise: \"promise\";\n    void: \"void\";\n    never: \"never\";\n    map: \"map\";\n    set: \"set\";\n};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v3/helpers/util.d.ts",
        "start": 62,
        "end": 83,
        "startLoc": {
          "line": 62,
          "column": 2,
          "position": 1304
        },
        "endLoc": {
          "line": 83,
          "column": 2,
          "position": 1452
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/helpers/util.ts",
        "start": 129,
        "end": 150,
        "startLoc": {
          "line": 129,
          "column": 2,
          "position": 1872
        },
        "endLoc": {
          "line": 150,
          "column": 2,
          "position": 2021
        }
      }
    },
    {
      "format": "typescript",
      "lines": 85,
      "fragment": "export declare namespace util {\n    type AssertEqual<T, U> = (<V>() => V extends T ? 1 : 2) extends <V>() => V extends U ? 1 : 2 ? true : false;\n    export type isAny<T> = 0 extends 1 & T ? true : false;\n    export const assertEqual: <A, B>(_: AssertEqual<A, B>) => void;\n    export function assertIs<T>(_arg: T): void;\n    export function assertNever(_x: never): never;\n    export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n    export type OmitKeys<T, K extends string> = Pick<T, Exclude<keyof T, K>>;\n    export type MakePartial<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n    export type Exactly<T, X> = T & Record<Exclude<keyof X, keyof T>, never>;\n    export type InexactPartial<T> = {\n        [k in keyof T]?: T[k] | undefined;\n    };\n    export const arrayToEnum: <T extends string, U extends [T, ...T[]]>(items: U) => { [k in U[number]]: k; };\n    export const getValidEnumValues: (obj: any) => any[];\n    export const objectValues: (obj: any) => any[];\n    export const objectKeys: ObjectConstructor[\"keys\"];\n    export const find: <T>(arr: T[], checker: (arg: T) => any) => T | undefined;\n    export type identity<T> = objectUtil.identity<T>;\n    export type flatten<T> = objectUtil.flatten<T>;\n    export type noUndefined<T> = T extends undefined ? never : T;\n    export const isInteger: NumberConstructor[\"isInteger\"];\n    export function joinValues<T extends any[]>(array: T, separator?: string): string;\n    export const jsonStringifyReplacer: (_: string, value: any) => any;\n    export {};\n}\nexport declare namespace objectUtil {\n    export type MergeShapes<U, V> = keyof U & keyof V extends never ? U & V : {\n        [k in Exclude<keyof U, keyof V>]: U[k];\n    } & V;\n    type optionalKeys<T extends object> = {\n        [k in keyof T]: undefined extends T[k] ? k : never;\n    }[keyof T];\n    type requiredKeys<T extends object> = {\n        [k in keyof T]: undefined extends T[k] ? never : k;\n    }[keyof T];\n    export type addQuestionMarks<T extends object, _O = any> = {\n        [K in requiredKeys<T>]: T[K];\n    } & {\n        [K in optionalKeys<T>]?: T[K];\n    } & {\n        [k in keyof T]?: unknown;\n    };\n    export type identity<T> = T;\n    export type flatten<T> = identity<{\n        [k in keyof T]: T[k];\n    }>;\n    export type noNeverKeys<T> = {\n        [k in keyof T]: [T[k]] extends [never] ? never : k;\n    }[keyof T];\n    export type noNever<T> = identity<{\n        [k in noNeverKeys<T>]: k extends keyof T ? T[k] : never;\n    }>;\n    export const mergeShapes: <U, T>(first: U, second: T) => T & U;\n    export type extendShape<A extends object, B extends object> = keyof A & keyof B extends never ? A & B : {\n        [K in keyof A as K extends keyof B ? never : K]: A[K];\n    } & {\n        [K in keyof B]: B[K];\n    };\n    export {};\n}\nexport declare const ZodParsedType: {\n    string: \"string\";\n    nan: \"nan\";\n    number: \"number\";\n    integer: \"integer\";\n    float: \"float\";\n    boolean: \"boolean\";\n    date: \"date\";\n    bigint: \"bigint\";\n    symbol: \"symbol\";\n    function: \"function\";\n    undefined: \"undefined\";\n    null: \"null\";\n    array: \"array\";\n    object: \"object\";\n    unknown: \"unknown\";\n    promise: \"promise\";\n    void: \"void\";\n    never: \"never\";\n    map: \"map\";\n    set: \"set\";\n};\nexport type ZodParsedType = keyof typeof ZodParsedType;\nexport declare const getParsedType: (data: any) => ZodParsedType;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v3/helpers/util.d.cts",
        "start": 1,
        "end": 85,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 85,
          "column": 2,
          "position": 1488
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v3/helpers/util.d.ts",
        "start": 1,
        "end": 85,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 85,
          "column": 2,
          "position": 1488
        }
      }
    },
    {
      "format": "typescript",
      "lines": 19,
      "fragment": ";\nexport interface ParseContext {\n    readonly common: {\n        readonly issues: ZodIssue[];\n        readonly contextualErrorMap?: ZodErrorMap | undefined;\n        readonly async: boolean;\n    };\n    readonly path: ParsePath;\n    readonly schemaErrorMap?: ZodErrorMap | undefined;\n    readonly parent: ParseContext | null;\n    readonly data: any;\n    readonly parsedType: ZodParsedType;\n}\nexport type ParseInput = {\n    data: any;\n    path: (string | number)[];\n    parent: ParseContext;\n};\nexport declare",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v3/helpers/parseUtil.d.ts",
        "start": 16,
        "end": 34,
        "startLoc": {
          "line": 16,
          "column": 10,
          "position": 177
        },
        "endLoc": {
          "line": 34,
          "column": 8,
          "position": 333
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/helpers/parseUtil.ts",
        "start": 51,
        "end": 72,
        "startLoc": {
          "line": 51,
          "column": 2,
          "position": 453
        },
        "endLoc": {
          "line": 72,
          "column": 9,
          "position": 612
        }
      }
    },
    {
      "format": "typescript",
      "lines": 77,
      "fragment": ";\nexport declare const makeIssue: (params: {\n    data: any;\n    path: (string | number)[];\n    errorMaps: ZodErrorMap[];\n    issueData: IssueData;\n}) => ZodIssue;\nexport type ParseParams = {\n    path: (string | number)[];\n    errorMap: ZodErrorMap;\n    async: boolean;\n};\nexport type ParsePathComponent = string | number;\nexport type ParsePath = ParsePathComponent[];\nexport declare const EMPTY_PATH: ParsePath;\nexport interface ParseContext {\n    readonly common: {\n        readonly issues: ZodIssue[];\n        readonly contextualErrorMap?: ZodErrorMap | undefined;\n        readonly async: boolean;\n    };\n    readonly path: ParsePath;\n    readonly schemaErrorMap?: ZodErrorMap | undefined;\n    readonly parent: ParseContext | null;\n    readonly data: any;\n    readonly parsedType: ZodParsedType;\n}\nexport type ParseInput = {\n    data: any;\n    path: (string | number)[];\n    parent: ParseContext;\n};\nexport declare function addIssueToContext(ctx: ParseContext, issueData: IssueData): void;\nexport type ObjectPair = {\n    key: SyncParseReturnType<any>;\n    value: SyncParseReturnType<any>;\n};\nexport declare class ParseStatus {\n    value: \"aborted\" | \"dirty\" | \"valid\";\n    dirty(): void;\n    abort(): void;\n    static mergeArray(status: ParseStatus, results: SyncParseReturnType<any>[]): SyncParseReturnType;\n    static mergeObjectAsync(status: ParseStatus, pairs: {\n        key: ParseReturnType<any>;\n        value: ParseReturnType<any>;\n    }[]): Promise<SyncParseReturnType<any>>;\n    static mergeObjectSync(status: ParseStatus, pairs: {\n        key: SyncParseReturnType<any>;\n        value: SyncParseReturnType<any>;\n        alwaysSet?: boolean;\n    }[]): SyncParseReturnType;\n}\nexport interface ParseResult {\n    status: \"aborted\" | \"dirty\" | \"valid\";\n    data: any;\n}\nexport type INVALID = {\n    status: \"aborted\";\n};\nexport declare const INVALID: INVALID;\nexport type DIRTY<T> = {\n    status: \"dirty\";\n    value: T;\n};\nexport declare const DIRTY: <T>(value: T) => DIRTY<T>;\nexport type OK<T> = {\n    status: \"valid\";\n    value: T;\n};\nexport declare const OK: <T>(value: T) => OK<T>;\nexport type SyncParseReturnType<T = any> = OK<T> | DIRTY<T> | INVALID;\nexport type AsyncParseReturnType<T> = Promise<SyncParseReturnType<T>>;\nexport type ParseReturnType<T> = SyncParseReturnType<T> | AsyncParseReturnType<T>;\nexport declare const isAborted: (x: ParseReturnType<any>) => x is INVALID;\nexport declare const isDirty: <T>(x: ParseReturnType<T>) => x is OK<T> | DIRTY<T>;\nexport declare const isValid: <T>(x: ParseReturnType<T>) => x is OK<T>;\nexport declare const isAsync: <T>(x: ParseReturnType<T>) => x is AsyncParseReturnType<T>;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v3/helpers/parseUtil.d.cts",
        "start": 2,
        "end": 78,
        "startLoc": {
          "line": 2,
          "column": 13,
          "position": 34
        },
        "endLoc": {
          "line": 78,
          "column": 2,
          "position": 952
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v3/helpers/parseUtil.d.ts",
        "start": 2,
        "end": 78,
        "startLoc": {
          "line": 2,
          "column": 12,
          "position": 34
        },
        "endLoc": {
          "line": 78,
          "column": 2,
          "position": 952
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": ");\n        } else if (issue.path.length === 0) {\n          (fieldErrors as any)._errors.push(mapper(issue));\n        } else {\n          let curr: any = fieldErrors;\n          let i = 0;\n          while (i < issue.path.length) {\n            const el = issue.path[i]!;\n            const terminal = i === issue.path.length - 1;\n\n            if (!terminal) {\n              curr[el] = curr[el] || { _errors: [] };\n              // if (typeof el === \"string\") {",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/ZodError.ts",
        "start": 231,
        "end": 243,
        "startLoc": {
          "line": 231,
          "column": 15,
          "position": 1964
        },
        "endLoc": {
          "line": 243,
          "column": 33,
          "position": 2131
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/errors.ts",
        "start": 271,
        "end": 283,
        "startLoc": {
          "line": 271,
          "column": 2,
          "position": 2668
        },
        "endLoc": {
          "line": 283,
          "column": 2,
          "position": 2835
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "} else {\n              curr[el] = curr[el] || { _errors: [] };\n              curr[el]._errors.push(mapper(issue));\n            }\n\n            curr = curr[el];\n            i++;\n          }\n        }\n      }\n    };\n\n    processError(this",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/ZodError.ts",
        "start": 250,
        "end": 262,
        "startLoc": {
          "line": 250,
          "column": 13,
          "position": 2152
        },
        "endLoc": {
          "line": 262,
          "column": 5,
          "position": 2238
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/errors.ts",
        "start": 283,
        "end": 294,
        "startLoc": {
          "line": 283,
          "column": 11,
          "position": 2835
        },
        "endLoc": {
          "line": 294,
          "column": 6,
          "position": 2920
        }
      }
    },
    {
      "format": "typescript",
      "lines": 27,
      "fragment": ";\n            readonly INDEX_SIZE_ERR: 1;\n            readonly DOMSTRING_SIZE_ERR: 2;\n            readonly HIERARCHY_REQUEST_ERR: 3;\n            readonly WRONG_DOCUMENT_ERR: 4;\n            readonly INVALID_CHARACTER_ERR: 5;\n            readonly NO_DATA_ALLOWED_ERR: 6;\n            readonly NO_MODIFICATION_ALLOWED_ERR: 7;\n            readonly NOT_FOUND_ERR: 8;\n            readonly NOT_SUPPORTED_ERR: 9;\n            readonly INUSE_ATTRIBUTE_ERR: 10;\n            readonly INVALID_STATE_ERR: 11;\n            readonly SYNTAX_ERR: 12;\n            readonly INVALID_MODIFICATION_ERR: 13;\n            readonly NAMESPACE_ERR: 14;\n            readonly INVALID_ACCESS_ERR: 15;\n            readonly VALIDATION_ERR: 16;\n            readonly TYPE_MISMATCH_ERR: 17;\n            readonly SECURITY_ERR: 18;\n            readonly NETWORK_ERR: 19;\n            readonly ABORT_ERR: 20;\n            readonly URL_MISMATCH_ERR: 21;\n            readonly QUOTA_EXCEEDED_ERR: 22;\n            readonly TIMEOUT_ERR: 23;\n            readonly INVALID_NODE_TYPE_ERR: 24;\n            readonly DATA_CLONE_ERR: 25;\n        };",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/@types/node/web-globals/domexception.d.ts",
        "start": 41,
        "end": 67,
        "startLoc": {
          "line": 41,
          "column": 13,
          "position": 421
        },
        "endLoc": {
          "line": 67,
          "column": 2,
          "position": 650
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/@types/node/web-globals/domexception.d.ts",
        "start": 7,
        "end": 35,
        "startLoc": {
          "line": 7,
          "column": 7,
          "position": 73
        },
        "endLoc": {
          "line": 35,
          "column": 8,
          "position": 303
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ".trim();\n\n      const result = extract(output);\n\n      expect(result.errors).toHaveLength(1);\n      expect(result.errors[0].file).toBe('vitest.config.ts');\n      expect(result.errors[0].message).toContain('Timeout calling \"onTaskUpdate\"');\n      expect(result.errors[0].message).toContain('system resource constraints');\n      expect(result.errors[0].message).toContain('Kill background processes');\n      expect(result.totalErrors).toBe(1);\n      expect(result.summary).toBe('1 test failure(s)');\n    });\n\n    it('should truncate errors array to MAX_ERRORS_IN_ARRAY but preserve totalErrors count'",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/src/extractors/vitest/index.test.ts",
        "start": 387,
        "end": 400,
        "startLoc": {
          "line": 387,
          "column": 8,
          "position": 1993
        },
        "endLoc": {
          "line": 400,
          "column": 85,
          "position": 2141
        }
      },
      "secondFile": {
        "name": "packages/extractors/src/extractors/vitest/index.test.ts",
        "start": 326,
        "end": 367,
        "startLoc": {
          "line": 326,
          "column": 8,
          "position": 1661
        },
        "endLoc": {
          "line": 367,
          "column": 77,
          "position": 1975
        }
      }
    },
    {
      "format": "typescript",
      "lines": 11,
      "fragment": ".exec(output)) !== null) {\n      errors.push({\n        file: match[1].trim(),\n        line: Number.parseInt(match[2]),\n        column: Number.parseInt(match[3]),\n        severity: match[4] as 'error' | 'warning',\n        code: match[5],\n        message: match[6].trim(),\n      });\n    }\n  }",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/src/extractors/typescript/index.ts",
        "start": 79,
        "end": 89,
        "startLoc": {
          "line": 79,
          "column": 11,
          "position": 467
        },
        "endLoc": {
          "line": 89,
          "column": 2,
          "position": 583
        }
      },
      "secondFile": {
        "name": "packages/extractors/src/extractors/typescript/index.ts",
        "start": 66,
        "end": 77,
        "startLoc": {
          "line": 66,
          "column": 11,
          "position": 323
        },
        "endLoc": {
          "line": 77,
          "column": 36,
          "position": 440
        }
      }
    },
    {
      "format": "typescript",
      "lines": 11,
      "fragment": ");\n\n      // totalErrors should be 15 (full count)\n      expect(result.totalErrors).toBe(15);\n\n      // errors array should be truncated to MAX_ERRORS_IN_ARRAY (10)\n      expect(result.errors).toHaveLength(MAX_ERRORS_IN_ARRAY);\n      expect(result.errors).toHaveLength(10);\n\n      // Verify we got the first 10 errors\n      expect(result.errors[0].file).toBe('src/file1.ts'",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/src/extractors/typescript/index.test.ts",
        "start": 204,
        "end": 214,
        "startLoc": {
          "line": 204,
          "column": 7,
          "position": 1549
        },
        "endLoc": {
          "line": 214,
          "column": 15,
          "position": 1621
        }
      },
      "secondFile": {
        "name": "packages/extractors/src/extractors/vitest/index.test.ts",
        "start": 415,
        "end": 425,
        "startLoc": {
          "line": 415,
          "column": 9,
          "position": 2287
        },
        "endLoc": {
          "line": 425,
          "column": 26,
          "position": 2359
        }
      }
    },
    {
      "format": "typescript",
      "lines": 12,
      "fragment": ");\n      expect(sample).toBeDefined();\n\n      if (sample && 'input' in sample) {\n        const result = extractMavenCheckstyle(sample.input!);\n        expect(result.totalErrors).toBe(sample.expected!.totalErrors);\n        if (sample.expected!.errors) {\n          expect(result.errors[0]).toMatchObject(sample.expected!.errors[0]);\n        }\n      }\n    });\n  }",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/src/extractors/maven-checkstyle/index.test.ts",
        "start": 209,
        "end": 220,
        "startLoc": {
          "line": 209,
          "column": 23,
          "position": 1776
        },
        "endLoc": {
          "line": 220,
          "column": 2,
          "position": 1894
        }
      },
      "secondFile": {
        "name": "packages/extractors/src/extractors/maven-checkstyle/index.test.ts",
        "start": 196,
        "end": 208,
        "startLoc": {
          "line": 196,
          "column": 20,
          "position": 1621
        },
        "endLoc": {
          "line": 208,
          "column": 3,
          "position": 1740
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": ");\n\n      const result = extract(output);\n\n      // totalErrors should be 15 (full count)\n      expect(result.totalErrors).toBe(15);\n\n      // errors array should be truncated to MAX_ERRORS_IN_ARRAY (10)\n      expect(result.errors).toHaveLength(MAX_ERRORS_IN_ARRAY);\n      expect(result.errors).toHaveLength(10);\n\n      // Verify we got the first 10 errors\n      expect(result.errors[0].message",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/src/extractors/jest/index.test.ts",
        "start": 214,
        "end": 226,
        "startLoc": {
          "line": 214,
          "column": 2,
          "position": 1413
        },
        "endLoc": {
          "line": 226,
          "column": 8,
          "position": 1494
        }
      },
      "secondFile": {
        "name": "packages/extractors/src/extractors/typescript/index.test.ts",
        "start": 202,
        "end": 425,
        "startLoc": {
          "line": 202,
          "column": 5,
          "position": 1535
        },
        "endLoc": {
          "line": 425,
          "column": 5,
          "position": 2354
        }
      }
    },
    {
      "format": "typescript",
      "lines": 20,
      "fragment": "], 10) : 0;\n\n  // Extract all failures\n  const failures = extractFailures(output);\n\n  // Early return if no failures detected (but failure count suggested there should be)\n  if (failureCount === 0 && failures.length === 0) {\n    return processTestFailures([], 95);\n  }\n\n  // Process failures using shared utility\n  return processTestFailures(failures, 95);\n}\n\n/**\n * Detect if output is from Jasmine test framework\n *\n * @param output - Command output to analyze\n * @returns Detection result with confidence and patterns\n */",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/src/extractors/jasmine/index.ts",
        "start": 160,
        "end": 179,
        "startLoc": {
          "line": 160,
          "column": 2,
          "position": 1104
        },
        "endLoc": {
          "line": 179,
          "column": 4,
          "position": 1194
        }
      },
      "secondFile": {
        "name": "packages/extractors/src/extractors/mocha/index.ts",
        "start": 174,
        "end": 193,
        "startLoc": {
          "line": 174,
          "column": 2,
          "position": 1084
        },
        "endLoc": {
          "line": 193,
          "column": 4,
          "position": 1174
        }
      }
    },
    {
      "format": "typescript",
      "lines": 12,
      "fragment": ".extract(input);\n\n        expect(result.summary).toBe('3 test(s) failed');\n        expect(result.errors).toHaveLength(3);\n        expect(result.errors[0].line).toBe(10);\n        expect(result.errors[1].line).toBe(20);\n        expect(result.errors[2].line).toBe(30);\n      });\n    });\n\n    describe('Error Type Detection', () => {\n      it('should detect assertion errors'",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/src/extractors/jasmine/index.test.ts",
        "start": 128,
        "end": 139,
        "startLoc": {
          "line": 128,
          "column": 14,
          "position": 602
        },
        "endLoc": {
          "line": 139,
          "column": 33,
          "position": 722
        }
      },
      "secondFile": {
        "name": "packages/extractors/src/extractors/mocha/index.test.ts",
        "start": 88,
        "end": 99,
        "startLoc": {
          "line": 88,
          "column": 12,
          "position": 443
        },
        "endLoc": {
          "line": 99,
          "column": 31,
          "position": 563
        }
      }
    },
    {
      "format": "typescript",
      "lines": 16,
      "fragment": ".extract(input);\n        expect(result.errors[0].file).toBe('/path/to/test.js');\n        expect(result.errors[0].line).toBe(42);\n      });\n\n      it('should handle relative paths', () => {\n        const input = `\nFailures:\n1) Test\n  Message:\n    Error: Test error\n  Stack:\n        at UserContext.<anonymous> (tests/unit/helpers.test.js:128:30)\n\n1 spec, 1 failure\n`",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/src/extractors/jasmine/index.test.ts",
        "start": 219,
        "end": 234,
        "startLoc": {
          "line": 219,
          "column": 14,
          "position": 1025
        },
        "endLoc": {
          "line": 234,
          "column": 2,
          "position": 1096
        }
      },
      "secondFile": {
        "name": "packages/extractors/src/extractors/mocha/index.test.ts",
        "start": 162,
        "end": 174,
        "startLoc": {
          "line": 162,
          "column": 12,
          "position": 865
        },
        "endLoc": {
          "line": 174,
          "column": 2,
          "position": 936
        }
      }
    },
    {
      "format": "typescript",
      "lines": 17,
      "fragment": ",\n          confidence: detection.confidence,\n          patterns: detection.patterns,\n          reason: detection.reason,\n        },\n        confidence: 100,\n        completeness: 100,\n        issues: [],\n      },\n    };\n  }\n\n  const errors: FormattedError[] = [];\n  let completeCount = 0;\n\n  for (const failure of failures) {\n    const file = failure.file ?? 'unknown'",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/src/extractors/ava/index.ts",
        "start": 164,
        "end": 180,
        "startLoc": {
          "line": 164,
          "column": 6,
          "position": 1021
        },
        "endLoc": {
          "line": 180,
          "column": 10,
          "position": 1144
        }
      },
      "secondFile": {
        "name": "packages/extractors/src/extractors/tap/index.ts",
        "start": 158,
        "end": 174,
        "startLoc": {
          "line": 158,
          "column": 6,
          "position": 988
        },
        "endLoc": {
          "line": 174,
          "column": 10,
          "position": 1111
        }
      }
    },
    {
      "format": "typescript",
      "lines": 24,
      "fragment": ",\n      confidence: detection.confidence,\n      patterns: detection.patterns,\n      reason: detection.reason,\n    },\n    confidence,\n    completeness,\n    issues: [],\n  };\n\n  return {\n    summary,\n    errors,\n    totalErrors: failures.length,\n    errorSummary: formatCleanOutput(errors),\n    guidance,\n    metadata,\n  };\n}\n\n/**\n * Extract all failures from Ava output\n * Strategy: Find detailed headers (test names with ), then parse each block\n */",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/src/extractors/ava/index.ts",
        "start": 211,
        "end": 234,
        "startLoc": {
          "line": 211,
          "column": 6,
          "position": 1417
        },
        "endLoc": {
          "line": 234,
          "column": 4,
          "position": 1518
        }
      },
      "secondFile": {
        "name": "packages/extractors/src/extractors/tap/index.ts",
        "start": 204,
        "end": 226,
        "startLoc": {
          "line": 204,
          "column": 6,
          "position": 1362
        },
        "endLoc": {
          "line": 226,
          "column": 4,
          "position": 1463
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": "+ 1, failure);\n\n        // Add error type detection and guidance\n        if (!failure.errorType && failure.message) {\n          failure.errorType = detectErrorType(failure.message);\n        }\n        if (failure.errorType) {\n          failure.guidance = getErrorGuidance(failure.errorType);\n        }\n\n        failures.push(failure);\n      }\n    }\n  }",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/src/extractors/ava/index.ts",
        "start": 296,
        "end": 309,
        "startLoc": {
          "line": 296,
          "column": 2,
          "position": 2102
        },
        "endLoc": {
          "line": 309,
          "column": 2,
          "position": 2197
        }
      },
      "secondFile": {
        "name": "packages/extractors/src/extractors/ava/index.ts",
        "start": 271,
        "end": 283,
        "startLoc": {
          "line": 271,
          "column": 2,
          "position": 1864
        },
        "endLoc": {
          "line": 283,
          "column": 5,
          "position": 1958
        }
      }
    },
    {
      "format": "typescript",
      "lines": 102,
      "fragment": "/**\n * The Standard Schema interface.\n */\nexport type StandardSchemaV1<Input = unknown, Output = Input> = {\n    /**\n     * The Standard Schema properties.\n     */\n    readonly \"~standard\": StandardSchemaV1.Props<Input, Output>;\n};\nexport declare namespace StandardSchemaV1 {\n    /**\n     * The Standard Schema properties interface.\n     */\n    export interface Props<Input = unknown, Output = Input> {\n        /**\n         * The version number of the standard.\n         */\n        readonly version: 1;\n        /**\n         * The vendor name of the schema library.\n         */\n        readonly vendor: string;\n        /**\n         * Validates unknown input values.\n         */\n        readonly validate: (value: unknown) => Result<Output> | Promise<Result<Output>>;\n        /**\n         * Inferred types associated with the schema.\n         */\n        readonly types?: Types<Input, Output> | undefined;\n    }\n    /**\n     * The result interface of the validate function.\n     */\n    export type Result<Output> = SuccessResult<Output> | FailureResult;\n    /**\n     * The result interface if validation succeeds.\n     */\n    export interface SuccessResult<Output> {\n        /**\n         * The typed output value.\n         */\n        readonly value: Output;\n        /**\n         * The non-existent issues.\n         */\n        readonly issues?: undefined;\n    }\n    /**\n     * The result interface if validation fails.\n     */\n    export interface FailureResult {\n        /**\n         * The issues of failed validation.\n         */\n        readonly issues: ReadonlyArray<Issue>;\n    }\n    /**\n     * The issue interface of the failure output.\n     */\n    export interface Issue {\n        /**\n         * The error message of the issue.\n         */\n        readonly message: string;\n        /**\n         * The path of the issue, if any.\n         */\n        readonly path?: ReadonlyArray<PropertyKey | PathSegment> | undefined;\n    }\n    /**\n     * The path segment interface of the issue.\n     */\n    export interface PathSegment {\n        /**\n         * The key representing a path segment.\n         */\n        readonly key: PropertyKey;\n    }\n    /**\n     * The Standard Schema types interface.\n     */\n    export interface Types<Input = unknown, Output = Input> {\n        /**\n         * The input type of the schema.\n         */\n        readonly input: Input;\n        /**\n         * The output type of the schema.\n         */\n        readonly output: Output;\n    }\n    /**\n     * Infers the input type of a Standard Schema.\n     */\n    export type InferInput<Schema extends StandardSchemaV1> = NonNullable<Schema[\"~standard\"][\"types\"]>[\"input\"];\n    /**\n     * Infers the output type of a Standard Schema.\n     */\n    export type InferOutput<Schema extends StandardSchemaV1> = NonNullable<Schema[\"~standard\"][\"types\"]>[\"output\"];\n    export {};\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v3/standard-schema.d.cts",
        "start": 1,
        "end": 102,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 102,
          "column": 2,
          "position": 472
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v3/standard-schema.d.ts",
        "start": 1,
        "end": 102,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 102,
          "column": 2,
          "position": 472
        }
      }
    },
    {
      "format": "typescript",
      "lines": 12,
      "fragment": "import type { Primitive } from \"./helpers/typeAliases.js\";\nimport { util, type ZodParsedType } from \"./helpers/util.js\";\nimport type { TypeOf, ZodType } from \"./index.js\";\ntype allKeys<T> = T extends any ? keyof T : never;\nexport type inferFlattenedErrors<T extends ZodType<any, any, any>, U = string> = typeToFlattenedError<TypeOf<T>, U>;\nexport type typeToFlattenedError<T, U = string> = {\n    formErrors: U[];\n    fieldErrors: {\n        [P in allKeys<T>]?: U[];\n    };\n};\nexport declare",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v3/ZodError.d.ts",
        "start": 1,
        "end": 12,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 12,
          "column": 8,
          "position": 183
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/ZodError.ts",
        "start": 1,
        "end": 15,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 15,
          "column": 6,
          "position": 186
        }
      }
    },
    {
      "format": "typescript",
      "lines": 45,
      "fragment": ";\nexport type ZodIssueCode = keyof typeof ZodIssueCode;\nexport type ZodIssueBase = {\n    path: (string | number)[];\n    message?: string | undefined;\n};\nexport interface ZodInvalidTypeIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_type;\n    expected: ZodParsedType;\n    received: ZodParsedType;\n}\nexport interface ZodInvalidLiteralIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_literal;\n    expected: unknown;\n    received: unknown;\n}\nexport interface ZodUnrecognizedKeysIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.unrecognized_keys;\n    keys: string[];\n}\nexport interface ZodInvalidUnionIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_union;\n    unionErrors: ZodError[];\n}\nexport interface ZodInvalidUnionDiscriminatorIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_union_discriminator;\n    options: Primitive[];\n}\nexport interface ZodInvalidEnumValueIssue extends ZodIssueBase {\n    received: string | number;\n    code: typeof ZodIssueCode.invalid_enum_value;\n    options: (string | number)[];\n}\nexport interface ZodInvalidArgumentsIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_arguments;\n    argumentsError: ZodError;\n}\nexport interface ZodInvalidReturnTypeIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_return_type;\n    returnTypeError: ZodError;\n}\nexport interface ZodInvalidDateIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_date;\n}\nexport type StringValidation = \"email\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v3/ZodError.d.ts",
        "start": 29,
        "end": 73,
        "startLoc": {
          "line": 29,
          "column": 2,
          "position": 305
        },
        "endLoc": {
          "line": 73,
          "column": 8,
          "position": 690
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/ZodError.ts",
        "start": 32,
        "end": 89,
        "startLoc": {
          "line": 32,
          "column": 2,
          "position": 264
        },
        "endLoc": {
          "line": 89,
          "column": 2,
          "position": 662
        }
      }
    },
    {
      "format": "typescript",
      "lines": 33,
      "fragment": "};\nexport interface ZodInvalidStringIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_string;\n    validation: StringValidation;\n}\nexport interface ZodTooSmallIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.too_small;\n    minimum: number | bigint;\n    inclusive: boolean;\n    exact?: boolean;\n    type: \"array\" | \"string\" | \"number\" | \"set\" | \"date\" | \"bigint\";\n}\nexport interface ZodTooBigIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.too_big;\n    maximum: number | bigint;\n    inclusive: boolean;\n    exact?: boolean;\n    type: \"array\" | \"string\" | \"number\" | \"set\" | \"date\" | \"bigint\";\n}\nexport interface ZodInvalidIntersectionTypesIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_intersection_types;\n}\nexport interface ZodNotMultipleOfIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.not_multiple_of;\n    multipleOf: number | bigint;\n}\nexport interface ZodNotFiniteIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.not_finite;\n}\nexport interface ZodCustomIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.custom;\n    params?: {\n        [k: string]: any;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v3/ZodError.d.ts",
        "start": 80,
        "end": 112,
        "startLoc": {
          "line": 80,
          "column": 1,
          "position": 809
        },
        "endLoc": {
          "line": 112,
          "column": 2,
          "position": 1126
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/ZodError.ts",
        "start": 109,
        "end": 147,
        "startLoc": {
          "line": 109,
          "column": 2,
          "position": 796
        },
        "endLoc": {
          "line": 147,
          "column": 2,
          "position": 1120
        }
      }
    },
    {
      "format": "typescript",
      "lines": 12,
      "fragment": "}\ntype stripPath<T extends object> = T extends any ? util.OmitKeys<T, \"path\"> : never;\nexport type IssueData = stripPath<ZodIssueOptionalMessage> & {\n    path?: (string | number)[];\n    fatal?: boolean | undefined;\n};\nexport type ErrorMapCtx = {\n    defaultError: string;\n    data: any;\n};\nexport type ZodErrorMap = (issue: ZodIssueOptionalMessage, _ctx: ErrorMapCtx) => {\n    message: string;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v3/ZodError.d.ts",
        "start": 151,
        "end": 162,
        "startLoc": {
          "line": 151,
          "column": 1,
          "position": 1772
        },
        "endLoc": {
          "line": 162,
          "column": 2,
          "position": 1915
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/ZodError.ts",
        "start": 316,
        "end": 330,
        "startLoc": {
          "line": 316,
          "column": 1,
          "position": 2801
        },
        "endLoc": {
          "line": 330,
          "column": 2,
          "position": 2948
        }
      }
    },
    {
      "format": "typescript",
      "lines": 162,
      "fragment": ";\ntype allKeys<T> = T extends any ? keyof T : never;\nexport type inferFlattenedErrors<T extends ZodType<any, any, any>, U = string> = typeToFlattenedError<TypeOf<T>, U>;\nexport type typeToFlattenedError<T, U = string> = {\n    formErrors: U[];\n    fieldErrors: {\n        [P in allKeys<T>]?: U[];\n    };\n};\nexport declare const ZodIssueCode: {\n    invalid_type: \"invalid_type\";\n    invalid_literal: \"invalid_literal\";\n    custom: \"custom\";\n    invalid_union: \"invalid_union\";\n    invalid_union_discriminator: \"invalid_union_discriminator\";\n    invalid_enum_value: \"invalid_enum_value\";\n    unrecognized_keys: \"unrecognized_keys\";\n    invalid_arguments: \"invalid_arguments\";\n    invalid_return_type: \"invalid_return_type\";\n    invalid_date: \"invalid_date\";\n    invalid_string: \"invalid_string\";\n    too_small: \"too_small\";\n    too_big: \"too_big\";\n    invalid_intersection_types: \"invalid_intersection_types\";\n    not_multiple_of: \"not_multiple_of\";\n    not_finite: \"not_finite\";\n};\nexport type ZodIssueCode = keyof typeof ZodIssueCode;\nexport type ZodIssueBase = {\n    path: (string | number)[];\n    message?: string | undefined;\n};\nexport interface ZodInvalidTypeIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_type;\n    expected: ZodParsedType;\n    received: ZodParsedType;\n}\nexport interface ZodInvalidLiteralIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_literal;\n    expected: unknown;\n    received: unknown;\n}\nexport interface ZodUnrecognizedKeysIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.unrecognized_keys;\n    keys: string[];\n}\nexport interface ZodInvalidUnionIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_union;\n    unionErrors: ZodError[];\n}\nexport interface ZodInvalidUnionDiscriminatorIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_union_discriminator;\n    options: Primitive[];\n}\nexport interface ZodInvalidEnumValueIssue extends ZodIssueBase {\n    received: string | number;\n    code: typeof ZodIssueCode.invalid_enum_value;\n    options: (string | number)[];\n}\nexport interface ZodInvalidArgumentsIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_arguments;\n    argumentsError: ZodError;\n}\nexport interface ZodInvalidReturnTypeIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_return_type;\n    returnTypeError: ZodError;\n}\nexport interface ZodInvalidDateIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_date;\n}\nexport type StringValidation = \"email\" | \"url\" | \"emoji\" | \"uuid\" | \"nanoid\" | \"regex\" | \"cuid\" | \"cuid2\" | \"ulid\" | \"datetime\" | \"date\" | \"time\" | \"duration\" | \"ip\" | \"cidr\" | \"base64\" | \"jwt\" | \"base64url\" | {\n    includes: string;\n    position?: number | undefined;\n} | {\n    startsWith: string;\n} | {\n    endsWith: string;\n};\nexport interface ZodInvalidStringIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_string;\n    validation: StringValidation;\n}\nexport interface ZodTooSmallIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.too_small;\n    minimum: number | bigint;\n    inclusive: boolean;\n    exact?: boolean;\n    type: \"array\" | \"string\" | \"number\" | \"set\" | \"date\" | \"bigint\";\n}\nexport interface ZodTooBigIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.too_big;\n    maximum: number | bigint;\n    inclusive: boolean;\n    exact?: boolean;\n    type: \"array\" | \"string\" | \"number\" | \"set\" | \"date\" | \"bigint\";\n}\nexport interface ZodInvalidIntersectionTypesIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_intersection_types;\n}\nexport interface ZodNotMultipleOfIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.not_multiple_of;\n    multipleOf: number | bigint;\n}\nexport interface ZodNotFiniteIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.not_finite;\n}\nexport interface ZodCustomIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.custom;\n    params?: {\n        [k: string]: any;\n    };\n}\nexport type DenormalizedError = {\n    [k: string]: DenormalizedError | string[];\n};\nexport type ZodIssueOptionalMessage = ZodInvalidTypeIssue | ZodInvalidLiteralIssue | ZodUnrecognizedKeysIssue | ZodInvalidUnionIssue | ZodInvalidUnionDiscriminatorIssue | ZodInvalidEnumValueIssue | ZodInvalidArgumentsIssue | ZodInvalidReturnTypeIssue | ZodInvalidDateIssue | ZodInvalidStringIssue | ZodTooSmallIssue | ZodTooBigIssue | ZodInvalidIntersectionTypesIssue | ZodNotMultipleOfIssue | ZodNotFiniteIssue | ZodCustomIssue;\nexport type ZodIssue = ZodIssueOptionalMessage & {\n    fatal?: boolean | undefined;\n    message: string;\n};\nexport declare const quotelessJson: (obj: any) => string;\ntype recursiveZodFormattedError<T> = T extends [any, ...any[]] ? {\n    [K in keyof T]?: ZodFormattedError<T[K]>;\n} : T extends any[] ? {\n    [k: number]: ZodFormattedError<T[number]>;\n} : T extends object ? {\n    [K in keyof T]?: ZodFormattedError<T[K]>;\n} : unknown;\nexport type ZodFormattedError<T, U = string> = {\n    _errors: U[];\n} & recursiveZodFormattedError<NonNullable<T>>;\nexport type inferFormattedError<T extends ZodType<any, any, any>, U = string> = ZodFormattedError<TypeOf<T>, U>;\nexport declare class ZodError<T = any> extends Error {\n    issues: ZodIssue[];\n    get errors(): ZodIssue[];\n    constructor(issues: ZodIssue[]);\n    format(): ZodFormattedError<T>;\n    format<U>(mapper: (issue: ZodIssue) => U): ZodFormattedError<T, U>;\n    static create: (issues: ZodIssue[]) => ZodError<any>;\n    static assert(value: unknown): asserts value is ZodError;\n    toString(): string;\n    get message(): string;\n    get isEmpty(): boolean;\n    addIssue: (sub: ZodIssue) => void;\n    addIssues: (subs?: ZodIssue[]) => void;\n    flatten(): typeToFlattenedError<T>;\n    flatten<U>(mapper?: (issue: ZodIssue) => U): typeToFlattenedError<T, U>;\n    get formErrors(): typeToFlattenedError<T, string>;\n}\ntype stripPath<T extends object> = T extends any ? util.OmitKeys<T, \"path\"> : never;\nexport type IssueData = stripPath<ZodIssueOptionalMessage> & {\n    path?: (string | number)[];\n    fatal?: boolean | undefined;\n};\nexport type ErrorMapCtx = {\n    defaultError: string;\n    data: any;\n};\nexport type ZodErrorMap = (issue: ZodIssueOptionalMessage, _ctx: ErrorMapCtx) => {\n    message: string;\n};\nexport {};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/zod/v3/ZodError.d.cts",
        "start": 3,
        "end": 164,
        "startLoc": {
          "line": 3,
          "column": 14,
          "position": 49
        },
        "endLoc": {
          "line": 164,
          "column": 2,
          "position": 1924
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/ZodError.ts",
        "start": 3,
        "end": 164,
        "startLoc": {
          "line": 3,
          "column": 13,
          "position": 49
        },
        "endLoc": {
          "line": 164,
          "column": 2,
          "position": 1924
        }
      }
    },
    {
      "format": "typescript",
      "lines": 19,
      "fragment": ";\nimport 'node:console';\nimport '@vitest/mocker';\nimport '@vitest/utils/source-map';\nimport './chunks/worker.d.1GmBbd7G.js';\nimport 'vite-node';\nimport './chunks/config.d.D2ROskhv.js';\nimport '@vitest/pretty-format';\nimport '@vitest/snapshot';\nimport '@vitest/snapshot/environment';\nimport '@vitest/utils/diff';\nimport 'chai';\nimport './chunks/benchmark.d.BwvBVTda.js';\nimport '@vitest/runner/utils';\nimport 'tinybench';\nimport './chunks/coverage.d.S9RMNXIe.js';\nimport 'vite-node/client';\nimport '@vitest/snapshot/manager';\nimport 'node:fs';",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/vitest/dist/coverage.d.ts",
        "start": 6,
        "end": 24,
        "startLoc": {
          "line": 6,
          "column": 14,
          "position": 81
        },
        "endLoc": {
          "line": 24,
          "column": 2,
          "position": 171
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/vitest/dist/reporters.d.ts",
        "start": 7,
        "end": 25,
        "startLoc": {
          "line": 7,
          "column": 7,
          "position": 206
        },
        "endLoc": {
          "line": 25,
          "column": 2,
          "position": 296
        }
      }
    },
    {
      "format": "typescript",
      "lines": 30,
      "fragment": "<T> {\n    /**\n     * @returns a new Set containing all the elements in this Set and also all the elements in the argument.\n     */\n    union<U>(other: ReadonlySetLike<U>): Set<T | U>;\n    /**\n     * @returns a new Set containing all the elements which are both in this Set and in the argument.\n     */\n    intersection<U>(other: ReadonlySetLike<U>): Set<T & U>;\n    /**\n     * @returns a new Set containing all the elements in this Set which are not also in the argument.\n     */\n    difference<U>(other: ReadonlySetLike<U>): Set<T>;\n    /**\n     * @returns a new Set containing all the elements which are in either this Set or in the argument, but not in both.\n     */\n    symmetricDifference<U>(other: ReadonlySetLike<U>): Set<T | U>;\n    /**\n     * @returns a boolean indicating whether all the elements in this Set are also in the argument.\n     */\n    isSubsetOf(other: ReadonlySetLike<unknown>): boolean;\n    /**\n     * @returns a boolean indicating whether all the elements in the argument are also in this Set.\n     */\n    isSupersetOf(other: ReadonlySetLike<unknown>): boolean;\n    /**\n     * @returns a boolean indicating whether this Set has no elements in common with the argument.\n     */\n    isDisjointFrom(other: ReadonlySetLike<unknown>): boolean;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.esnext.collection.d.ts",
        "start": 67,
        "end": 96,
        "startLoc": {
          "line": 67,
          "column": 12,
          "position": 249
        },
        "endLoc": {
          "line": 96,
          "column": 2,
          "position": 424
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.esnext.collection.d.ts",
        "start": 36,
        "end": 65,
        "startLoc": {
          "line": 36,
          "column": 4,
          "position": 68
        },
        "endLoc": {
          "line": 65,
          "column": 2,
          "position": 243
        }
      }
    },
    {
      "format": "typescript",
      "lines": 19,
      "fragment": "/**\n     * Returns the value of the last element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate findLast calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found, findLast\n     * immediately returns that element value. Otherwise, findLast returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLast<S extends number>(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => value is S,\n        thisArg?: any,\n    ): S | undefined;\n    findLast(\n        predicate: (value: number, index: number, array: this)",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2023.array.d.ts",
        "start": 167,
        "end": 185,
        "startLoc": {
          "line": 167,
          "column": 5,
          "position": 649
        },
        "endLoc": {
          "line": 185,
          "column": 2,
          "position": 745
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.esnext.float16.d.ts",
        "start": 115,
        "end": 136,
        "startLoc": {
          "line": 115,
          "column": 5,
          "position": 353
        },
        "endLoc": {
          "line": 136,
          "column": 2,
          "position": 453
        }
      }
    },
    {
      "format": "typescript",
      "lines": 41,
      "fragment": "<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Returns the value of the last element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate findLast calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found, findLast\n     * immediately returns that element value. Otherwise, findLast returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLast<S extends number>(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => value is S,\n        thisArg?: any,\n    ): S | undefined;\n    findLast(\n        predicate: (value: number, index: number, array: this) => unknown,\n        thisArg?: any,\n    ): number | undefined;\n\n    /**\n     * Returns the index of the last element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate findLastIndex calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLastIndex(\n        predicate: (value: number, index: number, array: this) => unknown,\n        thisArg?: any,\n    ): number;\n\n    /**\n     * Copies the array and returns the copy with the elements in reverse order.\n     */\n    toReversed(): Uint8Array",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2023.array.d.ts",
        "start": 230,
        "end": 270,
        "startLoc": {
          "line": 230,
          "column": 11,
          "position": 906
        },
        "endLoc": {
          "line": 270,
          "column": 11,
          "position": 1100
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2023.array.d.ts",
        "start": 166,
        "end": 206,
        "startLoc": {
          "line": 166,
          "column": 10,
          "position": 638
        },
        "endLoc": {
          "line": 206,
          "column": 10,
          "position": 832
        }
      }
    },
    {
      "format": "typescript",
      "lines": 48,
      "fragment": "<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Returns the value of the last element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate findLast calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found, findLast\n     * immediately returns that element value. Otherwise, findLast returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLast<S extends number>(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => value is S,\n        thisArg?: any,\n    ): S | undefined;\n    findLast(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => unknown,\n        thisArg?: any,\n    ): number | undefined;\n\n    /**\n     * Returns the index of the last element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate findLastIndex calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLastIndex(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => unknown,\n        thisArg?: any,\n    ): number;\n\n    /**\n     * Copies the array and returns the copy with the elements in reverse order.\n     */",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2023.array.d.ts",
        "start": 294,
        "end": 341,
        "startLoc": {
          "line": 294,
          "column": 18,
          "position": 1174
        },
        "endLoc": {
          "line": 341,
          "column": 8,
          "position": 1374
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2023.array.d.ts",
        "start": 166,
        "end": 165,
        "startLoc": {
          "line": 166,
          "column": 10,
          "position": 638
        },
        "endLoc": {
          "line": 165,
          "column": 8,
          "position": 542
        }
      }
    },
    {
      "format": "typescript",
      "lines": 41,
      "fragment": "<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Returns the value of the last element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate findLast calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found, findLast\n     * immediately returns that element value. Otherwise, findLast returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLast<S extends number>(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => value is S,\n        thisArg?: any,\n    ): S | undefined;\n    findLast(\n        predicate: (value: number, index: number, array: this) => unknown,\n        thisArg?: any,\n    ): number | undefined;\n\n    /**\n     * Returns the index of the last element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate findLastIndex calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLastIndex(\n        predicate: (value: number, index: number, array: this) => unknown,\n        thisArg?: any,\n    ): number;\n\n    /**\n     * Copies the array and returns the copy with the elements in reverse order.\n     */\n    toReversed(): Int16Array",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2023.array.d.ts",
        "start": 366,
        "end": 406,
        "startLoc": {
          "line": 366,
          "column": 11,
          "position": 1456
        },
        "endLoc": {
          "line": 406,
          "column": 11,
          "position": 1650
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2023.array.d.ts",
        "start": 166,
        "end": 206,
        "startLoc": {
          "line": 166,
          "column": 10,
          "position": 638
        },
        "endLoc": {
          "line": 206,
          "column": 10,
          "position": 832
        }
      }
    },
    {
      "format": "typescript",
      "lines": 49,
      "fragment": "<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Returns the value of the last element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate findLast calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found, findLast\n     * immediately returns that element value. Otherwise, findLast returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLast<S extends number>(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => value is S,\n        thisArg?: any,\n    ): S | undefined;\n    findLast(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => unknown,\n        thisArg?: any,\n    ): number | undefined;\n\n    /**\n     * Returns the index of the last element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate findLastIndex calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLastIndex(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => unknown,\n        thisArg?: any,\n    ): number;\n\n    /**\n     * Copies the array and returns the copy with the elements in reverse order.\n     */\n    toReversed(): Uint16Array",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2023.array.d.ts",
        "start": 430,
        "end": 478,
        "startLoc": {
          "line": 430,
          "column": 12,
          "position": 1724
        },
        "endLoc": {
          "line": 478,
          "column": 12,
          "position": 1932
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2023.array.d.ts",
        "start": 166,
        "end": 342,
        "startLoc": {
          "line": 166,
          "column": 10,
          "position": 638
        },
        "endLoc": {
          "line": 342,
          "column": 18,
          "position": 1382
        }
      }
    },
    {
      "format": "typescript",
      "lines": 41,
      "fragment": "<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Returns the value of the last element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate findLast calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found, findLast\n     * immediately returns that element value. Otherwise, findLast returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLast<S extends number>(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => value is S,\n        thisArg?: any,\n    ): S | undefined;\n    findLast(\n        predicate: (value: number, index: number, array: this) => unknown,\n        thisArg?: any,\n    ): number | undefined;\n\n    /**\n     * Returns the index of the last element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate findLastIndex calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLastIndex(\n        predicate: (value: number, index: number, array: this) => unknown,\n        thisArg?: any,\n    ): number;\n\n    /**\n     * Copies the array and returns the copy with the elements in reverse order.\n     */\n    toReversed(): Int32Array",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2023.array.d.ts",
        "start": 502,
        "end": 542,
        "startLoc": {
          "line": 502,
          "column": 11,
          "position": 2006
        },
        "endLoc": {
          "line": 542,
          "column": 11,
          "position": 2200
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2023.array.d.ts",
        "start": 166,
        "end": 206,
        "startLoc": {
          "line": 166,
          "column": 10,
          "position": 638
        },
        "endLoc": {
          "line": 206,
          "column": 10,
          "position": 832
        }
      }
    },
    {
      "format": "typescript",
      "lines": 49,
      "fragment": "<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Returns the value of the last element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate findLast calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found, findLast\n     * immediately returns that element value. Otherwise, findLast returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLast<S extends number>(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => value is S,\n        thisArg?: any,\n    ): S | undefined;\n    findLast(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => unknown,\n        thisArg?: any,\n    ): number | undefined;\n\n    /**\n     * Returns the index of the last element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate findLastIndex calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLastIndex(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => unknown,\n        thisArg?: any,\n    ): number;\n\n    /**\n     * Copies the array and returns the copy with the elements in reverse order.\n     */\n    toReversed(): Uint32Array",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2023.array.d.ts",
        "start": 566,
        "end": 614,
        "startLoc": {
          "line": 566,
          "column": 12,
          "position": 2274
        },
        "endLoc": {
          "line": 614,
          "column": 12,
          "position": 2482
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2023.array.d.ts",
        "start": 166,
        "end": 342,
        "startLoc": {
          "line": 166,
          "column": 10,
          "position": 638
        },
        "endLoc": {
          "line": 342,
          "column": 18,
          "position": 1382
        }
      }
    },
    {
      "format": "typescript",
      "lines": 49,
      "fragment": "<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Returns the value of the last element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate findLast calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found, findLast\n     * immediately returns that element value. Otherwise, findLast returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLast<S extends number>(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => value is S,\n        thisArg?: any,\n    ): S | undefined;\n    findLast(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => unknown,\n        thisArg?: any,\n    ): number | undefined;\n\n    /**\n     * Returns the index of the last element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate findLastIndex calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLastIndex(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => unknown,\n        thisArg?: any,\n    ): number;\n\n    /**\n     * Copies the array and returns the copy with the elements in reverse order.\n     */\n    toReversed(): Float32Array",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2023.array.d.ts",
        "start": 638,
        "end": 686,
        "startLoc": {
          "line": 638,
          "column": 13,
          "position": 2556
        },
        "endLoc": {
          "line": 686,
          "column": 13,
          "position": 2764
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2023.array.d.ts",
        "start": 166,
        "end": 342,
        "startLoc": {
          "line": 166,
          "column": 10,
          "position": 638
        },
        "endLoc": {
          "line": 342,
          "column": 18,
          "position": 1382
        }
      }
    },
    {
      "format": "typescript",
      "lines": 49,
      "fragment": "<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Returns the value of the last element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate findLast calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found, findLast\n     * immediately returns that element value. Otherwise, findLast returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLast<S extends number>(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => value is S,\n        thisArg?: any,\n    ): S | undefined;\n    findLast(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => unknown,\n        thisArg?: any,\n    ): number | undefined;\n\n    /**\n     * Returns the index of the last element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate findLastIndex calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLastIndex(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => unknown,\n        thisArg?: any,\n    ): number;\n\n    /**\n     * Copies the array and returns the copy with the elements in reverse order.\n     */\n    toReversed(): Float64Array",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2023.array.d.ts",
        "start": 710,
        "end": 758,
        "startLoc": {
          "line": 710,
          "column": 13,
          "position": 2838
        },
        "endLoc": {
          "line": 758,
          "column": 13,
          "position": 3046
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2023.array.d.ts",
        "start": 166,
        "end": 342,
        "startLoc": {
          "line": 166,
          "column": 10,
          "position": 638
        },
        "endLoc": {
          "line": 342,
          "column": 18,
          "position": 1382
        }
      }
    },
    {
      "format": "typescript",
      "lines": 49,
      "fragment": "<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Returns the value of the last element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate findLast calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found, findLast\n     * immediately returns that element value. Otherwise, findLast returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLast<S extends bigint>(\n        predicate: (\n            value: bigint,\n            index: number,\n            array: this,\n        ) => value is S,\n        thisArg?: any,\n    ): S | undefined;\n    findLast(\n        predicate: (\n            value: bigint,\n            index: number,\n            array: this,\n        ) => unknown,\n        thisArg?: any,\n    ): bigint | undefined;\n\n    /**\n     * Returns the index of the last element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate findLastIndex calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLastIndex(\n        predicate: (\n            value: bigint,\n            index: number,\n            array: this,\n        ) => unknown,\n        thisArg?: any,\n    ): number;\n\n    /**\n     * Copies the array and returns the copy with the elements in reverse order.\n     */\n    toReversed(): BigUint64Array",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2023.array.d.ts",
        "start": 854,
        "end": 902,
        "startLoc": {
          "line": 854,
          "column": 15,
          "position": 3402
        },
        "endLoc": {
          "line": 902,
          "column": 15,
          "position": 3610
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2023.array.d.ts",
        "start": 782,
        "end": 830,
        "startLoc": {
          "line": 782,
          "column": 14,
          "position": 3120
        },
        "endLoc": {
          "line": 830,
          "column": 14,
          "position": 3328
        }
      }
    },
    {
      "format": "typescript",
      "lines": 36,
      "fragment": "<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike> {\n    /** The size in bytes of each element in the array. */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /** The ArrayBuffer instance referenced by the array. */\n    readonly buffer: TArrayBuffer;\n\n    /** The length in bytes of the array. */\n    readonly byteLength: number;\n\n    /** The offset in bytes of the array. */\n    readonly byteOffset: number;\n\n    /**\n     * Returns the this object after copying a section of the array identified by start and end\n     * to the same array starting at position target\n     * @param target If target is negative, it is treated as length+target where length is the\n     * length of the array.\n     * @param start If start is negative, it is treated as length+start. If end is negative, it\n     * is treated as length+end.\n     * @param end If not specified, length of the this object is used as its default value.\n     */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /** Yields index, value pairs for every entry in the array. */\n    entries(): ArrayIterator<[number, bigint]>;\n\n    /**\n     * Determines whether all the members of an array satisfy the specified test.\n     * @param predicate A function that accepts up to three arguments. The every method calls\n     * the predicate function for each element in the array until the predicate returns false,\n     * or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    every(predicate: (value: bigint, index: number, array: BigUint64Array",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2020.bigint.d.ts",
        "start": 440,
        "end": 475,
        "startLoc": {
          "line": 440,
          "column": 15,
          "position": 2220
        },
        "endLoc": {
          "line": 475,
          "column": 15,
          "position": 2362
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2020.bigint.d.ts",
        "start": 149,
        "end": 184,
        "startLoc": {
          "line": 149,
          "column": 14,
          "position": 776
        },
        "endLoc": {
          "line": 184,
          "column": 14,
          "position": 918
        }
      }
    },
    {
      "format": "typescript",
      "lines": 20,
      "fragment": "<TArrayBuffer>) => boolean, thisArg?: any): boolean;\n\n    /**\n     * Changes all array elements from `start` to `end` index to a static `value` and returns the modified array\n     * @param value value to fill array section with\n     * @param start index to start filling the array at. If start is negative, it is treated as\n     * length+start where length is the length of the array.\n     * @param end index to stop filling the array at. If end is negative, it is treated as\n     * length+end.\n     */\n    fill(value: bigint, start?: number, end?: number): this;\n\n    /**\n     * Returns the elements of an array that meet the condition specified in a callback function.\n     * @param predicate A function that accepts up to three arguments. The filter method calls\n     * the predicate function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    filter(predicate: (value: bigint, index: number, array: BigUint64Array",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2020.bigint.d.ts",
        "start": 475,
        "end": 494,
        "startLoc": {
          "line": 475,
          "column": 15,
          "position": 2363
        },
        "endLoc": {
          "line": 494,
          "column": 15,
          "position": 2441
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2020.bigint.d.ts",
        "start": 184,
        "end": 203,
        "startLoc": {
          "line": 184,
          "column": 14,
          "position": 919
        },
        "endLoc": {
          "line": 203,
          "column": 14,
          "position": 997
        }
      }
    },
    {
      "format": "typescript",
      "lines": 47,
      "fragment": "<TArrayBuffer>) => void, thisArg?: any): void;\n\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: bigint, fromIndex?: number): boolean;\n\n    /**\n     * Returns the index of the first occurrence of a value in an array.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n     * search starts at index 0.\n     */\n    indexOf(searchElement: bigint, fromIndex?: number): number;\n\n    /**\n     * Adds all the elements of an array separated by the specified separator string.\n     * @param separator A string used to separate one element of an array from the next in the\n     * resulting String. If omitted, the array elements are separated with a comma.\n     */\n    join(separator?: string): string;\n\n    /** Yields each index in the array. */\n    keys(): ArrayIterator<number>;\n\n    /**\n     * Returns the index of the last occurrence of a value in an array.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n     * search starts at index 0.\n     */\n    lastIndexOf(searchElement: bigint, fromIndex?: number): number;\n\n    /** The length of the array. */\n    readonly length: number;\n\n    /**\n     * Calls a defined callback function on each element of an array, and returns an array that\n     * contains the results.\n     * @param callbackfn A function that accepts up to three arguments. The map method calls the\n     * callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    map(callbackfn: (value: bigint, index: number, array: BigUint64Array",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2020.bigint.d.ts",
        "start": 525,
        "end": 571,
        "startLoc": {
          "line": 525,
          "column": 15,
          "position": 2593
        },
        "endLoc": {
          "line": 571,
          "column": 15,
          "position": 2759
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2020.bigint.d.ts",
        "start": 234,
        "end": 280,
        "startLoc": {
          "line": 234,
          "column": 14,
          "position": 1149
        },
        "endLoc": {
          "line": 280,
          "column": 14,
          "position": 1315
        }
      }
    },
    {
      "format": "typescript",
      "lines": 18,
      "fragment": "<TArrayBuffer>) => U, initialValue: U): U;\n\n    /** Reverses the elements in the array. */\n    reverse(): this;\n\n    /**\n     * Sets a value or an array of values.\n     * @param array A typed or untyped array of values to set.\n     * @param offset The index in the current array at which the values are to be written.\n     */\n    set(array: ArrayLike<bigint>, offset?: number): void;\n\n    /**\n     * Returns a section of an array.\n     * @param start The beginning of the specified portion of the array.\n     * @param end The end of the specified portion of the array.\n     */\n    slice(start?: number, end?: number): BigUint64Array",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2020.bigint.d.ts",
        "start": 619,
        "end": 636,
        "startLoc": {
          "line": 619,
          "column": 15,
          "position": 2970
        },
        "endLoc": {
          "line": 636,
          "column": 15,
          "position": 3052
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2020.bigint.d.ts",
        "start": 328,
        "end": 345,
        "startLoc": {
          "line": 328,
          "column": 14,
          "position": 1526
        },
        "endLoc": {
          "line": 345,
          "column": 14,
          "position": 1608
        }
      }
    },
    {
      "format": "typescript",
      "lines": 27,
      "fragment": "<T> {\n    /**\n     * Calls a defined callback function on each element of an array. Then, flattens the result into\n     * a new array.\n     * This is identical to a map followed by flat with depth 1.\n     *\n     * @param callback A function that accepts up to three arguments. The flatMap method calls the\n     * callback function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callback function. If\n     * thisArg is omitted, undefined is used as the this value.\n     */\n    flatMap<U, This = undefined>(\n        callback: (this: This, value: T, index: number, array: T[]) => U | ReadonlyArray<U>,\n        thisArg?: This,\n    ): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<A, D extends number = 1>(\n        this: A,\n        depth?: D,\n    ): FlatArray<A, D>[];\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2019.array.d.ts",
        "start": 53,
        "end": 79,
        "startLoc": {
          "line": 53,
          "column": 6,
          "position": 296
        },
        "endLoc": {
          "line": 79,
          "column": 2,
          "position": 431
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2019.array.d.ts",
        "start": 25,
        "end": 51,
        "startLoc": {
          "line": 25,
          "column": 14,
          "position": 155
        },
        "endLoc": {
          "line": 51,
          "column": 2,
          "position": 290
        }
      }
    },
    {
      "format": "typescript",
      "lines": 21,
      "fragment": "<K, V> {\n    /** Returns an iterable of entries in the map. */\n    [Symbol.iterator](): MapIterator<[K, V]>;\n\n    /**\n     * Returns an iterable of key, value pairs for every entry in the map.\n     */\n    entries(): MapIterator<[K, V]>;\n\n    /**\n     * Returns an iterable of keys in the map\n     */\n    keys(): MapIterator<K>;\n\n    /**\n     * Returns an iterable of values in the map\n     */\n    values(): MapIterator<V>;\n}\n\ninterface MapConstructor",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2015.iterable.d.ts",
        "start": 161,
        "end": 181,
        "startLoc": {
          "line": 161,
          "column": 12,
          "position": 878
        },
        "endLoc": {
          "line": 181,
          "column": 15,
          "position": 969
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2015.iterable.d.ts",
        "start": 141,
        "end": 161,
        "startLoc": {
          "line": 141,
          "column": 4,
          "position": 786
        },
        "endLoc": {
          "line": 161,
          "column": 12,
          "position": 877
        }
      }
    },
    {
      "format": "typescript",
      "lines": 21,
      "fragment": "<T> {\n    /** Iterates over values in the set. */\n    [Symbol.iterator](): SetIterator<T>;\n\n    /**\n     * Returns an iterable of [v,v] pairs for every value `v` in the set.\n     */\n    entries(): SetIterator<[T, T]>;\n\n    /**\n     * Despite its name, returns an iterable of the values in the set.\n     */\n    keys(): SetIterator<T>;\n\n    /**\n     * Returns an iterable of values in the set.\n     */\n    values(): SetIterator<T>;\n}\n\ninterface SetConstructor",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2015.iterable.d.ts",
        "start": 216,
        "end": 236,
        "startLoc": {
          "line": 216,
          "column": 12,
          "position": 1228
        },
        "endLoc": {
          "line": 236,
          "column": 15,
          "position": 1311
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2015.iterable.d.ts",
        "start": 196,
        "end": 216,
        "startLoc": {
          "line": 196,
          "column": 4,
          "position": 1144
        },
        "endLoc": {
          "line": 216,
          "column": 12,
          "position": 1227
        }
      }
    },
    {
      "format": "typescript",
      "lines": 20,
      "fragment": "<TArrayBuffer extends ArrayBufferLike> {\n    [Symbol.iterator](): ArrayIterator<number>;\n\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): ArrayIterator<[number, number]>;\n\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): ArrayIterator<number>;\n\n    /**\n     * Returns an list of values in the array\n     */\n    values(): ArrayIterator<number>;\n}\n\ninterface Uint8ArrayConstructor",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2015.iterable.d.ts",
        "start": 312,
        "end": 331,
        "startLoc": {
          "line": 312,
          "column": 11,
          "position": 1755
        },
        "endLoc": {
          "line": 331,
          "column": 22,
          "position": 1839
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2015.iterable.d.ts",
        "start": 275,
        "end": 294,
        "startLoc": {
          "line": 275,
          "column": 10,
          "position": 1563
        },
        "endLoc": {
          "line": 294,
          "column": 21,
          "position": 1647
        }
      }
    },
    {
      "format": "typescript",
      "lines": 20,
      "fragment": "<TArrayBuffer extends ArrayBufferLike> {\n    [Symbol.iterator](): ArrayIterator<number>;\n\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): ArrayIterator<[number, number]>;\n\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): ArrayIterator<number>;\n\n    /**\n     * Returns an list of values in the array\n     */\n    values(): ArrayIterator<number>;\n}\n\ninterface Uint8ClampedArrayConstructor",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2015.iterable.d.ts",
        "start": 349,
        "end": 368,
        "startLoc": {
          "line": 349,
          "column": 18,
          "position": 1947
        },
        "endLoc": {
          "line": 368,
          "column": 29,
          "position": 2031
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2015.iterable.d.ts",
        "start": 275,
        "end": 294,
        "startLoc": {
          "line": 275,
          "column": 10,
          "position": 1563
        },
        "endLoc": {
          "line": 294,
          "column": 21,
          "position": 1647
        }
      }
    },
    {
      "format": "typescript",
      "lines": 19,
      "fragment": "<TArrayBuffer extends ArrayBufferLike> {\n    [Symbol.iterator](): ArrayIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): ArrayIterator<[number, number]>;\n\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): ArrayIterator<number>;\n\n    /**\n     * Returns an list of values in the array\n     */\n    values(): ArrayIterator<number>;\n}\n\ninterface Int16ArrayConstructor",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2015.iterable.d.ts",
        "start": 386,
        "end": 404,
        "startLoc": {
          "line": 386,
          "column": 11,
          "position": 2139
        },
        "endLoc": {
          "line": 404,
          "column": 22,
          "position": 2222
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2015.iterable.d.ts",
        "start": 275,
        "end": 294,
        "startLoc": {
          "line": 275,
          "column": 10,
          "position": 1563
        },
        "endLoc": {
          "line": 294,
          "column": 21,
          "position": 1647
        }
      }
    },
    {
      "format": "typescript",
      "lines": 20,
      "fragment": "<TArrayBuffer extends ArrayBufferLike> {\n    [Symbol.iterator](): ArrayIterator<number>;\n\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): ArrayIterator<[number, number]>;\n\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): ArrayIterator<number>;\n\n    /**\n     * Returns an list of values in the array\n     */\n    values(): ArrayIterator<number>;\n}\n\ninterface Uint16ArrayConstructor",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2015.iterable.d.ts",
        "start": 422,
        "end": 441,
        "startLoc": {
          "line": 422,
          "column": 12,
          "position": 2330
        },
        "endLoc": {
          "line": 441,
          "column": 23,
          "position": 2414
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2015.iterable.d.ts",
        "start": 275,
        "end": 294,
        "startLoc": {
          "line": 275,
          "column": 10,
          "position": 1563
        },
        "endLoc": {
          "line": 294,
          "column": 21,
          "position": 1647
        }
      }
    },
    {
      "format": "typescript",
      "lines": 20,
      "fragment": "<TArrayBuffer extends ArrayBufferLike> {\n    [Symbol.iterator](): ArrayIterator<number>;\n\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): ArrayIterator<[number, number]>;\n\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): ArrayIterator<number>;\n\n    /**\n     * Returns an list of values in the array\n     */\n    values(): ArrayIterator<number>;\n}\n\ninterface Int32ArrayConstructor",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2015.iterable.d.ts",
        "start": 459,
        "end": 478,
        "startLoc": {
          "line": 459,
          "column": 11,
          "position": 2522
        },
        "endLoc": {
          "line": 478,
          "column": 22,
          "position": 2606
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2015.iterable.d.ts",
        "start": 275,
        "end": 294,
        "startLoc": {
          "line": 275,
          "column": 10,
          "position": 1563
        },
        "endLoc": {
          "line": 294,
          "column": 21,
          "position": 1647
        }
      }
    },
    {
      "format": "typescript",
      "lines": 20,
      "fragment": "<TArrayBuffer extends ArrayBufferLike> {\n    [Symbol.iterator](): ArrayIterator<number>;\n\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): ArrayIterator<[number, number]>;\n\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): ArrayIterator<number>;\n\n    /**\n     * Returns an list of values in the array\n     */\n    values(): ArrayIterator<number>;\n}\n\ninterface Uint32ArrayConstructor",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2015.iterable.d.ts",
        "start": 496,
        "end": 515,
        "startLoc": {
          "line": 496,
          "column": 12,
          "position": 2714
        },
        "endLoc": {
          "line": 515,
          "column": 23,
          "position": 2798
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2015.iterable.d.ts",
        "start": 275,
        "end": 294,
        "startLoc": {
          "line": 275,
          "column": 10,
          "position": 1563
        },
        "endLoc": {
          "line": 294,
          "column": 21,
          "position": 1647
        }
      }
    },
    {
      "format": "typescript",
      "lines": 20,
      "fragment": "<TArrayBuffer extends ArrayBufferLike> {\n    [Symbol.iterator](): ArrayIterator<number>;\n\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): ArrayIterator<[number, number]>;\n\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): ArrayIterator<number>;\n\n    /**\n     * Returns an list of values in the array\n     */\n    values(): ArrayIterator<number>;\n}\n\ninterface Float32ArrayConstructor",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2015.iterable.d.ts",
        "start": 533,
        "end": 552,
        "startLoc": {
          "line": 533,
          "column": 13,
          "position": 2906
        },
        "endLoc": {
          "line": 552,
          "column": 24,
          "position": 2990
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2015.iterable.d.ts",
        "start": 275,
        "end": 294,
        "startLoc": {
          "line": 275,
          "column": 10,
          "position": 1563
        },
        "endLoc": {
          "line": 294,
          "column": 21,
          "position": 1647
        }
      }
    },
    {
      "format": "typescript",
      "lines": 20,
      "fragment": "<TArrayBuffer extends ArrayBufferLike> {\n    [Symbol.iterator](): ArrayIterator<number>;\n\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): ArrayIterator<[number, number]>;\n\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): ArrayIterator<number>;\n\n    /**\n     * Returns an list of values in the array\n     */\n    values(): ArrayIterator<number>;\n}\n\ninterface Float64ArrayConstructor",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2015.iterable.d.ts",
        "start": 570,
        "end": 589,
        "startLoc": {
          "line": 570,
          "column": 13,
          "position": 3098
        },
        "endLoc": {
          "line": 589,
          "column": 24,
          "position": 3182
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2015.iterable.d.ts",
        "start": 275,
        "end": 294,
        "startLoc": {
          "line": 275,
          "column": 10,
          "position": 1563
        },
        "endLoc": {
          "line": 294,
          "column": 21,
          "position": 1647
        }
      }
    },
    {
      "format": "typescript",
      "lines": 52,
      "fragment": ">;\n}\n\ninterface CSSTransformValue {\n    [Symbol.iterator](): ArrayIterator<CSSTransformComponent>;\n    entries(): ArrayIterator<[number, CSSTransformComponent]>;\n    keys(): ArrayIterator<number>;\n    values(): ArrayIterator<CSSTransformComponent>;\n}\n\ninterface CSSUnparsedValue {\n    [Symbol.iterator](): ArrayIterator<CSSUnparsedSegment>;\n    entries(): ArrayIterator<[number, CSSUnparsedSegment]>;\n    keys(): ArrayIterator<number>;\n    values(): ArrayIterator<CSSUnparsedSegment>;\n}\n\ninterface Cache {\n    /**\n     * The **`addAll()`** method of the Cache interface takes an array of URLs, retrieves them, and adds the resulting response objects to the given cache.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Cache/addAll)\n     */\n    addAll(requests: Iterable<RequestInfo>): Promise<void>;\n}\n\ninterface CanvasPath {\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/roundRect) */\n    roundRect(x: number, y: number, w: number, h: number, radii?: number | DOMPointInit | Iterable<number | DOMPointInit>): void;\n}\n\ninterface CanvasPathDrawingStyles {\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash) */\n    setLineDash(segments: Iterable<number>): void;\n}\n\ninterface CookieStoreManager {\n    /**\n     * The **`subscribe()`** method of the CookieStoreManager interface subscribes a ServiceWorkerRegistration to cookie change events.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/CookieStoreManager/subscribe)\n     */\n    subscribe(subscriptions: Iterable<CookieStoreGetOptions>): Promise<void>;\n    /**\n     * The **`unsubscribe()`** method of the CookieStoreManager interface stops the ServiceWorkerRegistration from receiving previously subscribed events.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/CookieStoreManager/unsubscribe)\n     */\n    unsubscribe(subscriptions: Iterable<CookieStoreGetOptions>): Promise<void>;\n}\n\ninterface CustomStateSet",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.dom.iterable.d.ts",
        "start": 66,
        "end": 117,
        "startLoc": {
          "line": 66,
          "column": 7,
          "position": 280
        },
        "endLoc": {
          "line": 117,
          "column": 15,
          "position": 597
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.webworker.iterable.d.ts",
        "start": 27,
        "end": 78,
        "startLoc": {
          "line": 27,
          "column": 16,
          "position": 74
        },
        "endLoc": {
          "line": 78,
          "column": 14,
          "position": 391
        }
      }
    },
    {
      "format": "typescript",
      "lines": 24,
      "fragment": "}\n\ninterface FileList {\n    [Symbol.iterator](): ArrayIterator<File>;\n}\n\ninterface FontFaceSet extends Set<FontFace> {\n}\n\ninterface FormDataIterator<T> extends IteratorObject<T, BuiltinIteratorReturn, unknown> {\n    [Symbol.iterator](): FormDataIterator<T>;\n}\n\ninterface FormData {\n    [Symbol.iterator](): FormDataIterator<[string, FormDataEntryValue]>;\n    /** Returns an array of key, value pairs for every entry in the list. */\n    entries(): FormDataIterator<[string, FormDataEntryValue]>;\n    /** Returns a list of keys in the list. */\n    keys(): FormDataIterator<string>;\n    /** Returns a list of values in the list. */\n    values(): FormDataIterator<FormDataEntryValue>;\n}\n\ninterface HTMLAllCollection",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.dom.iterable.d.ts",
        "start": 140,
        "end": 163,
        "startLoc": {
          "line": 140,
          "column": 1,
          "position": 768
        },
        "endLoc": {
          "line": 163,
          "column": 18,
          "position": 935
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.webworker.iterable.d.ts",
        "start": 80,
        "end": 103,
        "startLoc": {
          "line": 80,
          "column": 1,
          "position": 411
        },
        "endLoc": {
          "line": 103,
          "column": 16,
          "position": 578
        }
      }
    },
    {
      "format": "typescript",
      "lines": 18,
      "fragment": ">;\n}\n\ninterface HeadersIterator<T> extends IteratorObject<T, BuiltinIteratorReturn, unknown> {\n    [Symbol.iterator](): HeadersIterator<T>;\n}\n\ninterface Headers {\n    [Symbol.iterator](): HeadersIterator<[string, string]>;\n    /** Returns an iterator allowing to go through all key/value pairs contained in this object. */\n    entries(): HeadersIterator<[string, string]>;\n    /** Returns an iterator allowing to go through all keys of the key/value pairs contained in this object. */\n    keys(): HeadersIterator<string>;\n    /** Returns an iterator allowing to go through all values of the key/value pairs contained in this object. */\n    values(): HeadersIterator<string>;\n}\n\ninterface Highlight",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.dom.iterable.d.ts",
        "start": 180,
        "end": 197,
        "startLoc": {
          "line": 180,
          "column": 18,
          "position": 1059
        },
        "endLoc": {
          "line": 197,
          "column": 10,
          "position": 1188
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.webworker.iterable.d.ts",
        "start": 100,
        "end": 117,
        "startLoc": {
          "line": 100,
          "column": 19,
          "position": 570
        },
        "endLoc": {
          "line": 117,
          "column": 12,
          "position": 699
        }
      }
    },
    {
      "format": "typescript",
      "lines": 25,
      "fragment": "}\n\ninterface IDBDatabase {\n    /**\n     * The **`transaction`** method of the IDBDatabase interface immediately returns a transaction object (IDBTransaction) containing the IDBTransaction.objectStore method, which you can use to access your object store.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBDatabase/transaction)\n     */\n    transaction(storeNames: string | Iterable<string>, mode?: IDBTransactionMode, options?: IDBTransactionOptions): IDBTransaction;\n}\n\ninterface IDBObjectStore {\n    /**\n     * The **`createIndex()`** method of the field/column defining a new data point for each database record to contain.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBObjectStore/createIndex)\n     */\n    createIndex(name: string, keyPath: string | Iterable<string>, options?: IDBIndexParameters): IDBIndex;\n}\n\ninterface ImageTrackList {\n    [Symbol.iterator](): ArrayIterator<ImageTrack>;\n}\n\ninterface MIDIInputMap",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.dom.iterable.d.ts",
        "start": 201,
        "end": 225,
        "startLoc": {
          "line": 201,
          "column": 1,
          "position": 1218
        },
        "endLoc": {
          "line": 225,
          "column": 13,
          "position": 1339
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.webworker.iterable.d.ts",
        "start": 115,
        "end": 139,
        "startLoc": {
          "line": 115,
          "column": 1,
          "position": 694
        },
        "endLoc": {
          "line": 139,
          "column": 13,
          "position": 815
        }
      }
    },
    {
      "format": "typescript",
      "lines": 15,
      "fragment": ";\n}\n\ninterface StylePropertyMapReadOnlyIterator<T> extends IteratorObject<T, BuiltinIteratorReturn, unknown> {\n    [Symbol.iterator](): StylePropertyMapReadOnlyIterator<T>;\n}\n\ninterface StylePropertyMapReadOnly {\n    [Symbol.iterator](): StylePropertyMapReadOnlyIterator<[string, Iterable<CSSStyleValue>]>;\n    entries(): StylePropertyMapReadOnlyIterator<[string, Iterable<CSSStyleValue>]>;\n    keys(): StylePropertyMapReadOnlyIterator<string>;\n    values(): StylePropertyMapReadOnlyIterator<Iterable<CSSStyleValue>>;\n}\n\ninterface StyleSheetList",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.dom.iterable.d.ts",
        "start": 353,
        "end": 367,
        "startLoc": {
          "line": 353,
          "column": 2,
          "position": 2190
        },
        "endLoc": {
          "line": 367,
          "column": 15,
          "position": 2317
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.webworker.iterable.d.ts",
        "start": 141,
        "end": 155,
        "startLoc": {
          "line": 141,
          "column": 5,
          "position": 896
        },
        "endLoc": {
          "line": 155,
          "column": 13,
          "position": 1023
        }
      }
    },
    {
      "format": "typescript",
      "lines": 35,
      "fragment": ";\n}\n\ninterface SubtleCrypto {\n    /**\n     * The **`deriveKey()`** method of the SubtleCrypto interface can be used to derive a secret key from a master key.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/deriveKey)\n     */\n    deriveKey(algorithm: AlgorithmIdentifier | EcdhKeyDeriveParams | HkdfParams | Pbkdf2Params, baseKey: CryptoKey, derivedKeyType: AlgorithmIdentifier | AesDerivedKeyParams | HmacImportParams | HkdfParams | Pbkdf2Params, extractable: boolean, keyUsages: Iterable<KeyUsage>): Promise<CryptoKey>;\n    /**\n     * The **`generateKey()`** method of the SubtleCrypto interface is used to generate a new key (for symmetric algorithms) or key pair (for public-key algorithms).\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/generateKey)\n     */\n    generateKey(algorithm: \"Ed25519\" | { name: \"Ed25519\" }, extractable: boolean, keyUsages: ReadonlyArray<\"sign\" | \"verify\">): Promise<CryptoKeyPair>;\n    generateKey(algorithm: RsaHashedKeyGenParams | EcKeyGenParams, extractable: boolean, keyUsages: ReadonlyArray<KeyUsage>): Promise<CryptoKeyPair>;\n    generateKey(algorithm: AesKeyGenParams | HmacKeyGenParams | Pbkdf2Params, extractable: boolean, keyUsages: ReadonlyArray<KeyUsage>): Promise<CryptoKey>;\n    generateKey(algorithm: AlgorithmIdentifier, extractable: boolean, keyUsages: Iterable<KeyUsage>): Promise<CryptoKeyPair | CryptoKey>;\n    /**\n     * The **`importKey()`** method of the SubtleCrypto interface imports a key: that is, it takes as input a key in an external, portable format and gives you a CryptoKey object that you can use in the Web Crypto API.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/importKey)\n     */\n    importKey(format: \"jwk\", keyData: JsonWebKey, algorithm: AlgorithmIdentifier | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | AesKeyAlgorithm, extractable: boolean, keyUsages: ReadonlyArray<KeyUsage>): Promise<CryptoKey>;\n    importKey(format: Exclude<KeyFormat, \"jwk\">, keyData: BufferSource, algorithm: AlgorithmIdentifier | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | AesKeyAlgorithm, extractable: boolean, keyUsages: Iterable<KeyUsage>): Promise<CryptoKey>;\n    /**\n     * The **`unwrapKey()`** method of the SubtleCrypto interface 'unwraps' a key.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/unwrapKey)\n     */\n    unwrapKey(format: KeyFormat, wrappedKey: BufferSource, unwrappingKey: CryptoKey, unwrapAlgorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams, unwrappedKeyAlgorithm: AlgorithmIdentifier | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | AesKeyAlgorithm, extractable: boolean, keyUsages: Iterable<KeyUsage>): Promise<CryptoKey>;\n}\n\ninterface TextTrackCueList",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.dom.iterable.d.ts",
        "start": 368,
        "end": 402,
        "startLoc": {
          "line": 368,
          "column": 2,
          "position": 2335
        },
        "endLoc": {
          "line": 402,
          "column": 17,
          "position": 2800
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.webworker.iterable.d.ts",
        "start": 152,
        "end": 186,
        "startLoc": {
          "line": 152,
          "column": 3,
          "position": 1016
        },
        "endLoc": {
          "line": 186,
          "column": 24,
          "position": 1481
        }
      }
    },
    {
      "format": "typescript",
      "lines": 18,
      "fragment": ">;\n}\n\ninterface URLSearchParamsIterator<T> extends IteratorObject<T, BuiltinIteratorReturn, unknown> {\n    [Symbol.iterator](): URLSearchParamsIterator<T>;\n}\n\ninterface URLSearchParams {\n    [Symbol.iterator](): URLSearchParamsIterator<[string, string]>;\n    /** Returns an array of key, value pairs for every entry in the search params. */\n    entries(): URLSearchParamsIterator<[string, string]>;\n    /** Returns a list of keys in the search params. */\n    keys(): URLSearchParamsIterator<string>;\n    /** Returns a list of values in the search params. */\n    values(): URLSearchParamsIterator<string>;\n}\n\ninterface ViewTransitionTypeSet",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.dom.iterable.d.ts",
        "start": 411,
        "end": 428,
        "startLoc": {
          "line": 411,
          "column": 6,
          "position": 2867
        },
        "endLoc": {
          "line": 428,
          "column": 22,
          "position": 2996
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.webworker.iterable.d.ts",
        "start": 183,
        "end": 200,
        "startLoc": {
          "line": 183,
          "column": 10,
          "position": 1473
        },
        "endLoc": {
          "line": 200,
          "column": 19,
          "position": 1602
        }
      }
    },
    {
      "format": "typescript",
      "lines": 143,
      "fragment": "}\n\ninterface WEBGL_draw_buffers {\n    /**\n     * The **`WEBGL_draw_buffers.drawBuffersWEBGL()`** method is part of the WebGL API and allows you to define the draw buffers to which all fragment colors are written.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_draw_buffers/drawBuffersWEBGL)\n     */\n    drawBuffersWEBGL(buffers: Iterable<GLenum>): void;\n}\n\ninterface WEBGL_multi_draw {\n    /**\n     * The **`WEBGL_multi_draw.multiDrawArraysInstancedWEBGL()`** method of the WebGL API renders multiple primitives from array data.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_multi_draw/multiDrawArraysInstancedWEBGL)\n     */\n    multiDrawArraysInstancedWEBGL(mode: GLenum, firstsList: Int32Array<ArrayBufferLike> | Iterable<GLint>, firstsOffset: number, countsList: Int32Array<ArrayBufferLike> | Iterable<GLsizei>, countsOffset: number, instanceCountsList: Int32Array<ArrayBufferLike> | Iterable<GLsizei>, instanceCountsOffset: number, drawcount: GLsizei): void;\n    /**\n     * The **`WEBGL_multi_draw.multiDrawArraysWEBGL()`** method of the WebGL API renders multiple primitives from array data.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_multi_draw/multiDrawArraysWEBGL)\n     */\n    multiDrawArraysWEBGL(mode: GLenum, firstsList: Int32Array<ArrayBufferLike> | Iterable<GLint>, firstsOffset: number, countsList: Int32Array<ArrayBufferLike> | Iterable<GLsizei>, countsOffset: number, drawcount: GLsizei): void;\n    /**\n     * The **`WEBGL_multi_draw.multiDrawElementsInstancedWEBGL()`** method of the WebGL API renders multiple primitives from array data.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_multi_draw/multiDrawElementsInstancedWEBGL)\n     */\n    multiDrawElementsInstancedWEBGL(mode: GLenum, countsList: Int32Array<ArrayBufferLike> | Iterable<GLsizei>, countsOffset: number, type: GLenum, offsetsList: Int32Array<ArrayBufferLike> | Iterable<GLsizei>, offsetsOffset: number, instanceCountsList: Int32Array<ArrayBufferLike> | Iterable<GLsizei>, instanceCountsOffset: number, drawcount: GLsizei): void;\n    /**\n     * The **`WEBGL_multi_draw.multiDrawElementsWEBGL()`** method of the WebGL API renders multiple primitives from array data.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_multi_draw/multiDrawElementsWEBGL)\n     */\n    multiDrawElementsWEBGL(mode: GLenum, countsList: Int32Array<ArrayBufferLike> | Iterable<GLsizei>, countsOffset: number, type: GLenum, offsetsList: Int32Array<ArrayBufferLike> | Iterable<GLsizei>, offsetsOffset: number, drawcount: GLsizei): void;\n}\n\ninterface WebGL2RenderingContextBase {\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/clearBuffer) */\n    clearBufferfv(buffer: GLenum, drawbuffer: GLint, values: Iterable<GLfloat>, srcOffset?: number): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/clearBuffer) */\n    clearBufferiv(buffer: GLenum, drawbuffer: GLint, values: Iterable<GLint>, srcOffset?: number): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/clearBuffer) */\n    clearBufferuiv(buffer: GLenum, drawbuffer: GLint, values: Iterable<GLuint>, srcOffset?: number): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/drawBuffers) */\n    drawBuffers(buffers: Iterable<GLenum>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/getActiveUniforms) */\n    getActiveUniforms(program: WebGLProgram, uniformIndices: Iterable<GLuint>, pname: GLenum): any;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/getUniformIndices) */\n    getUniformIndices(program: WebGLProgram, uniformNames: Iterable<string>): GLuint[] | null;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/invalidateFramebuffer) */\n    invalidateFramebuffer(target: GLenum, attachments: Iterable<GLenum>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/invalidateSubFramebuffer) */\n    invalidateSubFramebuffer(target: GLenum, attachments: Iterable<GLenum>, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/transformFeedbackVaryings) */\n    transformFeedbackVaryings(program: WebGLProgram, varyings: Iterable<string>, bufferMode: GLenum): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniform) */\n    uniform1uiv(location: WebGLUniformLocation | null, data: Iterable<GLuint>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniform) */\n    uniform2uiv(location: WebGLUniformLocation | null, data: Iterable<GLuint>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniform) */\n    uniform3uiv(location: WebGLUniformLocation | null, data: Iterable<GLuint>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniform) */\n    uniform4uiv(location: WebGLUniformLocation | null, data: Iterable<GLuint>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniformMatrix) */\n    uniformMatrix2x3fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniformMatrix) */\n    uniformMatrix2x4fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniformMatrix) */\n    uniformMatrix3x2fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniformMatrix) */\n    uniformMatrix3x4fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniformMatrix) */\n    uniformMatrix4x2fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniformMatrix) */\n    uniformMatrix4x3fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/vertexAttribI) */\n    vertexAttribI4iv(index: GLuint, values: Iterable<GLint>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/vertexAttribI) */\n    vertexAttribI4uiv(index: GLuint, values: Iterable<GLuint>): void;\n}\n\ninterface WebGL2RenderingContextOverloads {\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform1fv(location: WebGLUniformLocation | null, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform1iv(location: WebGLUniformLocation | null, data: Iterable<GLint>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform2fv(location: WebGLUniformLocation | null, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform2iv(location: WebGLUniformLocation | null, data: Iterable<GLint>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform3fv(location: WebGLUniformLocation | null, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform3iv(location: WebGLUniformLocation | null, data: Iterable<GLint>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform4fv(location: WebGLUniformLocation | null, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform4iv(location: WebGLUniformLocation | null, data: Iterable<GLint>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniformMatrix) */\n    uniformMatrix2fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniformMatrix) */\n    uniformMatrix3fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniformMatrix) */\n    uniformMatrix4fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n}\n\ninterface WebGLRenderingContextBase {\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/vertexAttrib) */\n    vertexAttrib1fv(index: GLuint, values: Iterable<GLfloat>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/vertexAttrib) */\n    vertexAttrib2fv(index: GLuint, values: Iterable<GLfloat>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/vertexAttrib) */\n    vertexAttrib3fv(index: GLuint, values: Iterable<GLfloat>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/vertexAttrib) */\n    vertexAttrib4fv(index: GLuint, values: Iterable<GLfloat>): void;\n}\n\ninterface WebGLRenderingContextOverloads {\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform1fv(location: WebGLUniformLocation | null, v: Iterable<GLfloat>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform1iv(location: WebGLUniformLocation | null, v: Iterable<GLint>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform2fv(location: WebGLUniformLocation | null, v: Iterable<GLfloat>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform2iv(location: WebGLUniformLocation | null, v: Iterable<GLint>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform3fv(location: WebGLUniformLocation | null, v: Iterable<GLfloat>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform3iv(location: WebGLUniformLocation | null, v: Iterable<GLint>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform4fv(location: WebGLUniformLocation | null, v: Iterable<GLfloat>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform4iv(location: WebGLUniformLocation | null, v: Iterable<GLint>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniformMatrix) */\n    uniformMatrix2fv(location: WebGLUniformLocation | null, transpose: GLboolean, value: Iterable<GLfloat>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniformMatrix) */\n    uniformMatrix3fv(location: WebGLUniformLocation | null, transpose: GLboolean, value: Iterable<GLfloat>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniformMatrix) */\n    uniformMatrix4fv(location: WebGLUniformLocation | null, transpose: GLboolean, value: Iterable<GLfloat>): void;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.dom.iterable.d.ts",
        "start": 429,
        "end": 571,
        "startLoc": {
          "line": 429,
          "column": 1,
          "position": 3007
        },
        "endLoc": {
          "line": 571,
          "column": 2,
          "position": 5144
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.webworker.iterable.d.ts",
        "start": 198,
        "end": 340,
        "startLoc": {
          "line": 198,
          "column": 1,
          "position": 1597
        },
        "endLoc": {
          "line": 340,
          "column": 2,
          "position": 3734
        }
      }
    },
    {
      "format": "typescript",
      "lines": 21,
      "fragment": "/////////////////////////////\n\ninterface FileSystemDirectoryHandleAsyncIterator<T> extends AsyncIteratorObject<T, BuiltinIteratorReturn, unknown> {\n    [Symbol.asyncIterator](): FileSystemDirectoryHandleAsyncIterator<T>;\n}\n\ninterface FileSystemDirectoryHandle {\n    [Symbol.asyncIterator](): FileSystemDirectoryHandleAsyncIterator<[string, FileSystemHandle]>;\n    entries(): FileSystemDirectoryHandleAsyncIterator<[string, FileSystemHandle]>;\n    keys(): FileSystemDirectoryHandleAsyncIterator<string>;\n    values(): FileSystemDirectoryHandleAsyncIterator<FileSystemHandle>;\n}\n\ninterface ReadableStreamAsyncIterator<T> extends AsyncIteratorObject<T, BuiltinIteratorReturn, unknown> {\n    [Symbol.asyncIterator](): ReadableStreamAsyncIterator<T>;\n}\n\ninterface ReadableStream<R = any> {\n    [Symbol.asyncIterator](options?: ReadableStreamIteratorOptions): ReadableStreamAsyncIterator<R>;\n    values(options?: ReadableStreamIteratorOptions): ReadableStreamAsyncIterator<R>;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.dom.asynciterable.d.ts",
        "start": 21,
        "end": 41,
        "startLoc": {
          "line": 21,
          "column": 1,
          "position": 11
        },
        "endLoc": {
          "line": 41,
          "column": 2,
          "position": 218
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.webworker.asynciterable.d.ts",
        "start": 21,
        "end": 41,
        "startLoc": {
          "line": 21,
          "column": 1,
          "position": 11
        },
        "endLoc": {
          "line": 41,
          "column": 2,
          "position": 218
        }
      }
    },
    {
      "format": "typescript",
      "lines": 27,
      "fragment": "}\n}\n\nmodule.exports = exports = Ajv\nmodule.exports.Ajv = Ajv\nObject.defineProperty(exports, \"__esModule\", {value: true})\n\nexport default Ajv\n\nexport {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  SchemaValidateFunction",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/ajv/lib/ajv.ts",
        "start": 31,
        "end": 57,
        "startLoc": {
          "line": 31,
          "column": 3,
          "position": 289
        },
        "endLoc": {
          "line": 57,
          "column": 23,
          "position": 411
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/ajv/lib/jtd.ts",
        "start": 92,
        "end": 118,
        "startLoc": {
          "line": 92,
          "column": 3,
          "position": 867
        },
        "endLoc": {
          "line": 118,
          "column": 12,
          "position": 989
        }
      }
    },
    {
      "format": "typescript",
      "lines": 11,
      "fragment": ")\n    this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    return (this.opts.defaultMeta =\n      super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined))\n  }\n}\n\nmodule.exports = exports = Ajv2020",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/ajv/lib/2020.ts",
        "start": 30,
        "end": 40,
        "startLoc": {
          "line": 30,
          "column": 6,
          "position": 237
        },
        "endLoc": {
          "line": 40,
          "column": 8,
          "position": 328
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/ajv/lib/ajv.ts",
        "start": 24,
        "end": 34,
        "startLoc": {
          "line": 24,
          "column": 6,
          "position": 213
        },
        "endLoc": {
          "line": 34,
          "column": 4,
          "position": 304
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ",\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {Plugin, Options, CodeOptions, InstanceOptions, Logger, ErrorsTextOptions} from \"./core\"\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\nexport {default as ValidationError} from \"./runtime/validation_error\"\nexport {default as MissingRefError} from \"./compile/ref_error\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/ajv/lib/2020.ts",
        "start": 62,
        "end": 75,
        "startLoc": {
          "line": 62,
          "column": 22,
          "position": 432
        },
        "endLoc": {
          "line": 75,
          "column": 22,
          "position": 584
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/ajv/lib/ajv.ts",
        "start": 57,
        "end": 70,
        "startLoc": {
          "line": 57,
          "column": 23,
          "position": 412
        },
        "endLoc": {
          "line": 70,
          "column": 22,
          "position": 564
        }
      }
    },
    {
      "format": "typescript",
      "lines": 11,
      "fragment": ".call(this, $data)\n    this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    return (this.opts.defaultMeta =\n      super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined))\n  }\n}\n\nmodule.exports = exports = Ajv2019",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/ajv/lib/2019.ts",
        "start": 36,
        "end": 46,
        "startLoc": {
          "line": 36,
          "column": 18,
          "position": 278
        },
        "endLoc": {
          "line": 46,
          "column": 8,
          "position": 376
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/ajv/lib/2020.ts",
        "start": 30,
        "end": 34,
        "startLoc": {
          "line": 30,
          "column": 18,
          "position": 230
        },
        "endLoc": {
          "line": 34,
          "column": 4,
          "position": 304
        }
      }
    },
    {
      "format": "typescript",
      "lines": 30,
      "fragment": "export {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {Plugin, Options, CodeOptions, InstanceOptions, Logger, ErrorsTextOptions} from \"./core\"\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\nexport {default as ValidationError} from \"./runtime/validation_error\"\nexport {default as MissingRefError} from \"./compile/ref_error\"",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/ajv/lib/2019.ts",
        "start": 52,
        "end": 81,
        "startLoc": {
          "line": 52,
          "column": 1,
          "position": 414
        },
        "endLoc": {
          "line": 81,
          "column": 22,
          "position": 632
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/ajv/lib/2020.ts",
        "start": 46,
        "end": 70,
        "startLoc": {
          "line": 46,
          "column": 1,
          "position": 366
        },
        "endLoc": {
          "line": 70,
          "column": 22,
          "position": 564
        }
      }
    },
    {
      "format": "typescript",
      "lines": 11,
      "fragment": ";\nexport { Format, FormatDefinition, AsyncFormatDefinition, KeywordDefinition, KeywordErrorDefinition, CodeKeywordDefinition, MacroKeywordDefinition, FuncKeywordDefinition, Vocabulary, Schema, SchemaObject, AnySchemaObject, AsyncSchema, AnySchema, ValidateFunction, AsyncValidateFunction, ErrorObject, ErrorNoParams, } from \"./types\";\nexport { Plugin, Options, CodeOptions, InstanceOptions, Logger, ErrorsTextOptions } from \"./core\";\nexport { SchemaCxt, SchemaObjCxt } from \"./compile\";\nexport { KeywordCxt } from \"./compile/validate\";\nexport { DefinedError } from \"./vocabularies/errors\";\nexport { JSONType } from \"./compile/rules\";\nexport { JSONSchemaType } from \"./types/json-schema\";\nexport { _, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions } from \"./compile/codegen\";\nexport { default as ValidationError } from \"./runtime/validation_error\";\nexport { default as MissingRefError } from \"./compile/ref_error\";",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/ajv/dist/2019.d.ts",
        "start": 9,
        "end": 19,
        "startLoc": {
          "line": 9,
          "column": 8,
          "position": 98
        },
        "endLoc": {
          "line": 19,
          "column": 2,
          "position": 327
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/ajv/dist/2020.d.ts",
        "start": 9,
        "end": 18,
        "startLoc": {
          "line": 9,
          "column": 8,
          "position": 98
        },
        "endLoc": {
          "line": 18,
          "column": 2,
          "position": 312
        }
      }
    },
    {
      "format": "typescript",
      "lines": 42,
      "fragment": "class Resolver {\n        constructor(options?: ResolverOptions);\n        /**\n         * Cancel all outstanding DNS queries made by this resolver. The corresponding\n         * callbacks will be called with an error with code `ECANCELLED`.\n         * @since v8.3.0\n         */\n        cancel(): void;\n        getServers: typeof getServers;\n        resolve: typeof resolve;\n        resolve4: typeof resolve4;\n        resolve6: typeof resolve6;\n        resolveAny: typeof resolveAny;\n        resolveCaa: typeof resolveCaa;\n        resolveCname: typeof resolveCname;\n        resolveMx: typeof resolveMx;\n        resolveNaptr: typeof resolveNaptr;\n        resolveNs: typeof resolveNs;\n        resolvePtr: typeof resolvePtr;\n        resolveSoa: typeof resolveSoa;\n        resolveSrv: typeof resolveSrv;\n        resolveTxt: typeof resolveTxt;\n        reverse: typeof reverse;\n        /**\n         * The resolver instance will send its requests from the specified IP address.\n         * This allows programs to specify outbound interfaces when used on multi-homed\n         * systems.\n         *\n         * If a v4 or v6 address is not specified, it is set to the default and the\n         * operating system will choose a local address automatically.\n         *\n         * The resolver will use the v4 local address when making requests to IPv4 DNS\n         * servers, and the v6 local address when making requests to IPv6 DNS servers.\n         * The `rrtype` of resolution requests has no impact on the local address used.\n         * @since v15.1.0, v14.17.0\n         * @param [ipv4='0.0.0.0'] A string representation of an IPv4 address.\n         * @param [ipv6='::0'] A string representation of an IPv6 address.\n         */\n        setLocalAddress(ipv4?: string, ipv6?: string): void;\n        setServers: typeof setServers;\n    }\n    export",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/node_modules/@types/node/dns.d.ts",
        "start": 826,
        "end": 867,
        "startLoc": {
          "line": 826,
          "column": 2,
          "position": 4327
        },
        "endLoc": {
          "line": 867,
          "column": 7,
          "position": 4528
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/@types/node/dns/promises.d.ts",
        "start": 435,
        "end": 476,
        "startLoc": {
          "line": 435,
          "column": 5,
          "position": 1303
        },
        "endLoc": {
          "line": 476,
          "column": 2,
          "position": 1503
        }
      }
    },
    {
      "format": "typescript",
      "lines": 19,
      "fragment": "}],\n        totalErrors: 1,\n        summary: '1 error',\n        guidance: 'Fix it',\n        metadata: {\n          detection: {\n            extractor: 'test-extractor',\n            confidence: 100,\n            patterns: ['test'],\n            reason: 'Test',\n          },\n          confidence: 100,\n          completeness: 100,\n          issues: [],\n        },\n      }));\n\n      const wrappedExtract = createSandboxedExtractor(plugin, { trust: 'full' });\n      const result = await wrappedExtract('error'",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/test/sandboxed-extractor.test.ts",
        "start": 71,
        "end": 89,
        "startLoc": {
          "line": 71,
          "column": 2,
          "position": 660
        },
        "endLoc": {
          "line": 89,
          "column": 8,
          "position": 798
        }
      },
      "secondFile": {
        "name": "packages/extractors/test/sandboxed-extractor.test.ts",
        "start": 44,
        "end": 62,
        "startLoc": {
          "line": 44,
          "column": 2,
          "position": 396
        },
        "endLoc": {
          "line": 62,
          "column": 21,
          "position": 534
        }
      }
    },
    {
      "format": "typescript",
      "lines": 16,
      "fragment": ",\n        metadata: {\n          detection: {\n            extractor: 'test-extractor',\n            confidence: 100,\n            patterns: ['test'],\n            reason: 'Test',\n          },\n          confidence: 100,\n          completeness: 100,\n          issues: [],\n        },\n      }));\n\n      const wrappedExtract = createSandboxedExtractor(plugin, { trust: 'full' });\n      const result = await wrappedExtract('clean output'",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/test/sandboxed-extractor.test.ts",
        "start": 99,
        "end": 114,
        "startLoc": {
          "line": 99,
          "column": 11,
          "position": 890
        },
        "endLoc": {
          "line": 114,
          "column": 15,
          "position": 1005
        }
      },
      "secondFile": {
        "name": "packages/extractors/test/sandboxed-extractor.test.ts",
        "start": 47,
        "end": 62,
        "startLoc": {
          "line": 47,
          "column": 9,
          "position": 419
        },
        "endLoc": {
          "line": 62,
          "column": 21,
          "position": 534
        }
      }
    },
    {
      "format": "typescript",
      "lines": 20,
      "fragment": ", async () => {\n      const plugin = createMockPlugin((output) => ({\n        errors: [{ file: 'test.ts', line: 1, message: output }],\n        totalErrors: 1,\n        summary: '1 error',\n        guidance: 'Fix it',\n        metadata: {\n          detection: {\n            extractor: 'test-extractor',\n            confidence: 100,\n            patterns: ['test'],\n            reason: 'Test',\n          },\n          confidence: 100,\n          completeness: 100,\n          issues: [],\n        },\n      }));\n\n      const wrappedExtract = createSandboxedExtractor(plugin, { trust: 'sandbox'",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/test/sandboxed-extractor.test.ts",
        "start": 122,
        "end": 141,
        "startLoc": {
          "line": 122,
          "column": 38,
          "position": 1066
        },
        "endLoc": {
          "line": 141,
          "column": 10,
          "position": 1240
        }
      },
      "secondFile": {
        "name": "packages/extractors/test/sandboxed-extractor.test.ts",
        "start": 42,
        "end": 61,
        "startLoc": {
          "line": 42,
          "column": 55,
          "position": 343
        },
        "endLoc": {
          "line": 61,
          "column": 7,
          "position": 517
        }
      }
    },
    {
      "format": "typescript",
      "lines": 20,
      "fragment": ", async () => {\n      const plugin = createMockPlugin((output) => ({\n        errors: [{ file: 'test.ts', line: 1, message: output }],\n        totalErrors: 1,\n        summary: '1 error',\n        guidance: 'Fix it',\n        metadata: {\n          detection: {\n            extractor: 'test-extractor',\n            confidence: 100,\n            patterns: ['test'],\n            reason: 'Test',\n          },\n          confidence: 100,\n          completeness: 100,\n          issues: [],\n        },\n      }));\n\n      // No trust specified - should default to sandbox",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/test/sandboxed-extractor.test.ts",
        "start": 148,
        "end": 167,
        "startLoc": {
          "line": 148,
          "column": 62,
          "position": 1305
        },
        "endLoc": {
          "line": 167,
          "column": 50,
          "position": 1463
        }
      },
      "secondFile": {
        "name": "packages/extractors/test/sandboxed-extractor.test.ts",
        "start": 42,
        "end": 61,
        "startLoc": {
          "line": 42,
          "column": 55,
          "position": 343
        },
        "endLoc": {
          "line": 61,
          "column": 6,
          "position": 501
        }
      }
    },
    {
      "format": "typescript",
      "lines": 16,
      "fragment": ",\n        metadata: {\n          detection: {\n            extractor: 'test-extractor',\n            confidence: 100,\n            patterns: ['test'],\n            reason: 'Test',\n          },\n          confidence: 100,\n          completeness: 100,\n          issues: [],\n        },\n      }));\n\n      const wrappedExtract = createSandboxedExtractor(plugin, { trust: 'sandbox' });\n      const result = await wrappedExtract('multiple errors'",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/test/sandboxed-extractor.test.ts",
        "start": 183,
        "end": 198,
        "startLoc": {
          "line": 183,
          "column": 11,
          "position": 1644
        },
        "endLoc": {
          "line": 198,
          "column": 18,
          "position": 1759
        }
      },
      "secondFile": {
        "name": "packages/extractors/test/sandboxed-extractor.test.ts",
        "start": 47,
        "end": 142,
        "startLoc": {
          "line": 47,
          "column": 9,
          "position": 419
        },
        "endLoc": {
          "line": 142,
          "column": 21,
          "position": 1257
        }
      }
    },
    {
      "format": "typescript",
      "lines": 24,
      "fragment": ");\n    });\n\n    it('should handle extractors that return no errors', async () => {\n      const plugin = createMockPlugin(() => ({\n        errors: [],\n        totalErrors: 0,\n        summary: 'No errors',\n        guidance: 'All good',\n        metadata: {\n          detection: {\n            extractor: 'test-extractor',\n            confidence: 100,\n            patterns: ['test'],\n            reason: 'Test',\n          },\n          confidence: 100,\n          completeness: 100,\n          issues: [],\n        },\n      }));\n\n      const wrappedExtract = createSandboxedExtractor(plugin, { trust: 'sandbox' });\n      const result = await wrappedExtract('clean output'",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/test/sandboxed-extractor.test.ts",
        "start": 279,
        "end": 302,
        "startLoc": {
          "line": 279,
          "column": 3,
          "position": 2463
        },
        "endLoc": {
          "line": 302,
          "column": 15,
          "position": 2646
        }
      },
      "secondFile": {
        "name": "packages/extractors/test/sandboxed-extractor.test.ts",
        "start": 91,
        "end": 142,
        "startLoc": {
          "line": 91,
          "column": 18,
          "position": 822
        },
        "endLoc": {
          "line": 142,
          "column": 21,
          "position": 1257
        }
      }
    },
    {
      "format": "typescript",
      "lines": 22,
      "fragment": ", async () => {\n      const plugin = createMockPlugin(() => ({\n        errors: [],\n        totalErrors: 0,\n        summary: 'No errors',\n        guidance: '',\n        metadata: {\n          detection: {\n            extractor: 'test-extractor',\n            confidence: 100,\n            patterns: [],\n            reason: 'Test',\n          },\n          confidence: 100,\n          completeness: 100,\n          issues: [],\n        },\n      }));\n\n      const wrappedExtract = createSandboxedExtractor(plugin, {\n        trust: 'sandbox',\n        timeoutMs",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/test/sandboxed-extractor.test.ts",
        "start": 383,
        "end": 404,
        "startLoc": {
          "line": 383,
          "column": 32,
          "position": 3361
        },
        "endLoc": {
          "line": 404,
          "column": 10,
          "position": 3518
        }
      },
      "secondFile": {
        "name": "packages/extractors/test/sandboxed-extractor.test.ts",
        "start": 355,
        "end": 376,
        "startLoc": {
          "line": 355,
          "column": 37,
          "position": 3156
        },
        "endLoc": {
          "line": 376,
          "column": 14,
          "position": 3313
        }
      }
    },
    {
      "format": "typescript",
      "lines": 80,
      "fragment": "format(_output: string): ExtractorResult;\n}\n/**\n * Detection result from pattern matching\n */\nexport interface DetectionResult {\n    /** Confidence level (0-100) - higher means more certain */\n    confidence: number;\n    /** Patterns that matched in the output */\n    patterns: string[];\n    /** Human-readable explanation of detection */\n    reason: string;\n}\n/**\n * Fast filtering hints for efficient multi-extractor detection\n * Uses simple string.includes() checks (no regex) for O(M) single-pass filtering\n */\nexport interface ExtractorHints {\n    /** Required keywords - all must be present */\n    required?: string[];\n    /** Any-of keywords - at least one must be present */\n    anyOf?: string[];\n    /** Forbidden keywords - if present, skip this extractor */\n    forbidden?: string[];\n}\n/**\n * Sample test data for extractor validation\n */\nexport interface ExtractorSample {\n    /** Unique name for this sample */\n    name: string;\n    /** Human-readable description */\n    description: string;\n    /** Inline sample data OR */\n    input?: string;\n    /** Path to sample file (relative to extractor directory) */\n    inputFile?: string;\n    /** Expected extraction result (partial match) */\n    expected?: Partial<ExtractorResult>;\n    /** Expected number of errors (simplified validation) */\n    expectedErrors?: number;\n    /** Expected patterns in output (simplified validation) */\n    expectedPatterns?: string[];\n}\n/**\n * Extractor plugin metadata\n */\nexport interface ExtractorMetadata {\n    /** Unique name identifying this extractor (source of truth for registration) */\n    name: string;\n    /** Semantic version */\n    version: string;\n    /** Author name and email */\n    author?: string;\n    /** Human-readable description */\n    description: string;\n    /** Repository URL */\n    repository?: string;\n    /** Tags for discovery and categorization */\n    tags?: string[];\n}\n/**\n * Complete extractor plugin interface\n *\n * This is the unified interface for all extractors (built-in and external plugins).\n */\nexport interface ExtractorPlugin {\n    /** Plugin metadata (source of truth for name/version) */\n    metadata: ExtractorMetadata;\n    /** Fast filtering hints for efficient detection */\n    hints?: ExtractorHints;\n    /** Priority for detection order (higher = check first) */\n    priority: number;\n    /**\n     * Detection function - determines if this extractor can handle the output\n     * Only called if hints match (or no hints provided)\n     *\n     * @param _output - Raw command output\n     * @returns Detection result with confidence score\n     */",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/dist/types.d.ts",
        "start": 39,
        "end": 118,
        "startLoc": {
          "line": 39,
          "column": 5,
          "position": 102
        },
        "endLoc": {
          "line": 118,
          "column": 8,
          "position": 422
        }
      },
      "secondFile": {
        "name": "packages/extractors/src/types.ts",
        "start": 50,
        "end": 137,
        "startLoc": {
          "line": 50,
          "column": 3,
          "position": 114
        },
        "endLoc": {
          "line": 137,
          "column": 6,
          "position": 442
        }
      }
    },
    {
      "format": "typescript",
      "lines": 20,
      "fragment": "z.ZodObject<{\n        /** Which extractor was used */\n        extractor: z.ZodString;\n        /** Confidence in detection (0-100) */\n        confidence: z.ZodNumber;\n        /** Patterns that matched */\n        patterns: z.ZodArray<z.ZodString, \"many\">;\n        /** Why this extractor was chosen */\n        reason: z.ZodString;\n    }, \"strip\", z.ZodTypeAny, {\n        extractor: string;\n        confidence: number;\n        patterns: string[];\n        reason: string;\n    }, {\n        extractor: string;\n        confidence: number;\n        patterns: string[];\n        reason: string;\n    }>>",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/dist/result-schema.d.ts",
        "start": 89,
        "end": 108,
        "startLoc": {
          "line": 89,
          "column": 2,
          "position": 580
        },
        "endLoc": {
          "line": 108,
          "column": 3,
          "position": 724
        }
      },
      "secondFile": {
        "name": "packages/extractors/dist/result-schema.d.ts",
        "start": 62,
        "end": 81,
        "startLoc": {
          "line": 62,
          "column": 2,
          "position": 408
        },
        "endLoc": {
          "line": 81,
          "column": 2,
          "position": 549
        }
      }
    },
    {
      "format": "typescript",
      "lines": 12,
      "fragment": ", {\n    issues: string[];\n    confidence: number;\n    completeness: number;\n    detection?: {\n        extractor: string;\n        confidence: number;\n        patterns: string[];\n        reason: string;\n    } | undefined;\n    suggestions?: string[] | undefined;\n}>",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/dist/result-schema.d.ts",
        "start": 128,
        "end": 139,
        "startLoc": {
          "line": 128,
          "column": 2,
          "position": 891
        },
        "endLoc": {
          "line": 139,
          "column": 2,
          "position": 978
        }
      },
      "secondFile": {
        "name": "packages/extractors/dist/result-schema.d.ts",
        "start": 117,
        "end": 128,
        "startLoc": {
          "line": 117,
          "column": 11,
          "position": 804
        },
        "endLoc": {
          "line": 128,
          "column": 2,
          "position": 891
        }
      }
    },
    {
      "format": "typescript",
      "lines": 36,
      "fragment": "z.ZodObject<{\n        /** File path where the error occurred */\n        file: z.ZodOptional<z.ZodString>;\n        /** Line number (1-indexed) */\n        line: z.ZodOptional<z.ZodNumber>;\n        /** Column number (1-indexed) */\n        column: z.ZodOptional<z.ZodNumber>;\n        /** Error message */\n        message: z.ZodString;\n        /** Error code (e.g., TS2322, ESLint rule name) */\n        code: z.ZodOptional<z.ZodString>;\n        /** Severity level */\n        severity: z.ZodOptional<z.ZodEnum<[\"error\", \"warning\"]>>;\n        /** Additional context (surrounding code, stack trace excerpt) */\n        context: z.ZodOptional<z.ZodString>;\n        /** Guidance for fixing the error */\n        guidance: z.ZodOptional<z.ZodString>;\n    }, \"strip\", z.ZodTypeAny, {\n        message: string;\n        file?: string | undefined;\n        line?: number | undefined;\n        column?: number | undefined;\n        code?: string | undefined;\n        severity?: \"error\" | \"warning\" | undefined;\n        context?: string | undefined;\n        guidance?: string | undefined;\n    }, {\n        message: string;\n        file?: string | undefined;\n        line?: number | undefined;\n        column?: number | undefined;\n        code?: string | undefined;\n        severity?: \"error\" | \"warning\" | undefined;\n        context?: string | undefined;\n        guidance?: string | undefined;\n    }>,",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/dist/result-schema.d.ts",
        "start": 157,
        "end": 192,
        "startLoc": {
          "line": 157,
          "column": 2,
          "position": 1033
        },
        "endLoc": {
          "line": 192,
          "column": 2,
          "position": 1390
        }
      },
      "secondFile": {
        "name": "packages/extractors/dist/result-schema.d.ts",
        "start": 21,
        "end": 56,
        "startLoc": {
          "line": 21,
          "column": 2,
          "position": 41
        },
        "endLoc": {
          "line": 56,
          "column": 2,
          "position": 395
        }
      }
    },
    {
      "format": "typescript",
      "lines": 53,
      "fragment": "z.ZodObject<{\n        /** Detection information (only included when developerFeedback: true) */\n        detection: z.ZodOptional<z.ZodObject<{\n            /** Which extractor was used */\n            extractor: z.ZodString;\n            /** Confidence in detection (0-100) */\n            confidence: z.ZodNumber;\n            /** Patterns that matched */\n            patterns: z.ZodArray<z.ZodString, \"many\">;\n            /** Why this extractor was chosen */\n            reason: z.ZodString;\n        }, \"strip\", z.ZodTypeAny, {\n            extractor: string;\n            confidence: number;\n            patterns: string[];\n            reason: string;\n        }, {\n            extractor: string;\n            confidence: number;\n            patterns: string[];\n            reason: string;\n        }>>;\n        /** Extraction confidence (0-100) */\n        confidence: z.ZodNumber;\n        /** Percentage of extracted errors with complete data (0-100) */\n        completeness: z.ZodNumber;\n        /** Issues encountered during extraction */\n        issues: z.ZodArray<z.ZodString, \"many\">;\n        /** Suggestions for improvement (only included when developerFeedback: true) */\n        suggestions: z.ZodOptional<z.ZodArray<z.ZodString, \"many\">>;\n    }, \"strip\", z.ZodTypeAny, {\n        issues: string[];\n        confidence: number;\n        completeness: number;\n        detection?: {\n            extractor: string;\n            confidence: number;\n            patterns: string[];\n            reason: string;\n        } | undefined;\n        suggestions?: string[] | undefined;\n    }, {\n        issues: string[];\n        confidence: number;\n        completeness: number;\n        detection?: {\n            extractor: string;\n            confidence: number;\n            patterns: string[];\n            reason: string;\n        } | undefined;\n        suggestions?: string[] | undefined;\n    }>>",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/dist/result-schema.d.ts",
        "start": 207,
        "end": 259,
        "startLoc": {
          "line": 207,
          "column": 2,
          "position": 1441
        },
        "endLoc": {
          "line": 259,
          "column": 3,
          "position": 1859
        }
      },
      "secondFile": {
        "name": "packages/extractors/dist/result-schema.d.ts",
        "start": 87,
        "end": 128,
        "startLoc": {
          "line": 87,
          "column": 2,
          "position": 563
        },
        "endLoc": {
          "line": 128,
          "column": 2,
          "position": 891
        }
      }
    },
    {
      "format": "typescript",
      "lines": 12,
      "fragment": "{\n        issues: string[];\n        confidence: number;\n        completeness: number;\n        detection?: {\n            extractor: string;\n            confidence: number;\n            patterns: string[];\n            reason: string;\n        } | undefined;\n        suggestions?: string[] | undefined;\n    } |",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/dist/result-schema.d.ts",
        "start": 275,
        "end": 286,
        "startLoc": {
          "line": 275,
          "column": 2,
          "position": 2025
        },
        "endLoc": {
          "line": 286,
          "column": 2,
          "position": 2112
        }
      },
      "secondFile": {
        "name": "packages/extractors/dist/result-schema.d.ts",
        "start": 117,
        "end": 128,
        "startLoc": {
          "line": 117,
          "column": 2,
          "position": 806
        },
        "endLoc": {
          "line": 128,
          "column": 2,
          "position": 891
        }
      }
    },
    {
      "format": "typescript",
      "lines": 28,
      "fragment": ", {\n    summary: string;\n    totalErrors: number;\n    errors: {\n        message: string;\n        file?: string | undefined;\n        line?: number | undefined;\n        column?: number | undefined;\n        code?: string | undefined;\n        severity?: \"error\" | \"warning\" | undefined;\n        context?: string | undefined;\n        guidance?: string | undefined;\n    }[];\n    guidance?: string | undefined;\n    errorSummary?: string | undefined;\n    metadata?: {\n        issues: string[];\n        confidence: number;\n        completeness: number;\n        detection?: {\n            extractor: string;\n            confidence: number;\n            patterns: string[];\n            reason: string;\n        } | undefined;\n        suggestions?: string[] | undefined;\n    } | undefined;\n}>",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/dist/result-schema.d.ts",
        "start": 287,
        "end": 314,
        "startLoc": {
          "line": 287,
          "column": 2,
          "position": 2118
        },
        "endLoc": {
          "line": 314,
          "column": 2,
          "position": 2365
        }
      },
      "secondFile": {
        "name": "packages/extractors/dist/result-schema.d.ts",
        "start": 260,
        "end": 287,
        "startLoc": {
          "line": 260,
          "column": 11,
          "position": 1871
        },
        "endLoc": {
          "line": 287,
          "column": 2,
          "position": 2118
        }
      }
    },
    {
      "format": "typescript",
      "lines": 19,
      "fragment": ";\n/**\n * Inferred TypeScript types from Zod schemas\n */\nexport type FormattedError = z.infer<typeof FormattedErrorSchema>;\nexport type DetectionMetadata = z.infer<typeof DetectionMetadataSchema>;\nexport type ExtractionMetadata = z.infer<typeof ExtractionMetadataSchema>;\nexport type ErrorExtractorResult = z.infer<typeof ErrorExtractorResultSchema>;\n/**\n * Safe validation function for ErrorExtractorResult\n *\n * NOTE: This duplicates the pattern from @vibe-validate/core's createSafeValidator.\n * We can't import from core here due to circular dependency (core  extractors).\n * This is an acceptable trade-off for a foundational package.\n *\n * @param data - Data to validate\n * @returns Validation result with success/error information\n */\nexport declare",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/dist/result-schema.d.ts",
        "start": 314,
        "end": 332,
        "startLoc": {
          "line": 314,
          "column": 2,
          "position": 2366
        },
        "endLoc": {
          "line": 332,
          "column": 8,
          "position": 2446
        }
      },
      "secondFile": {
        "name": "packages/extractors/src/result-schema.ts",
        "start": 129,
        "end": 149,
        "startLoc": {
          "line": 129,
          "column": 2,
          "position": 569
        },
        "endLoc": {
          "line": 149,
          "column": 9,
          "position": 651
        }
      }
    },
    {
      "format": "typescript",
      "lines": 15,
      "fragment": "export { default as typescriptPlugin } from './extractors/typescript/index.js';\nexport { default as eslintPlugin } from './extractors/eslint/index.js';\nexport { default as vitestPlugin } from './extractors/vitest/index.js';\nexport { default as jestPlugin } from './extractors/jest/index.js';\nexport { default as mochaPlugin } from './extractors/mocha/index.js';\nexport { default as jasminePlugin } from './extractors/jasmine/index.js';\nexport { default as playwrightPlugin } from './extractors/playwright/index.js';\nexport { default as junitPlugin } from './extractors/junit/index.js';\nexport { default as mavenCompilerPlugin } from './extractors/maven-compiler/index.js';\nexport { default as mavenCheckstylePlugin } from './extractors/maven-checkstyle/index.js';\nexport { default as mavenSurefirePlugin } from './extractors/maven-surefire/index.js';\nexport { default as avaPlugin } from './extractors/ava/index.js';\nexport { default as tapPlugin } from './extractors/tap/index.js';\nexport { default as genericPlugin } from './extractors/generic/index.js';\nexport",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/dist/index.d.ts",
        "start": 31,
        "end": 45,
        "startLoc": {
          "line": 31,
          "column": 1,
          "position": 90
        },
        "endLoc": {
          "line": 45,
          "column": 7,
          "position": 328
        }
      },
      "secondFile": {
        "name": "packages/extractors/src/index.ts",
        "start": 59,
        "end": 74,
        "startLoc": {
          "line": 59,
          "column": 1,
          "position": 119
        },
        "endLoc": {
          "line": 74,
          "column": 50,
          "position": 358
        }
      }
    },
    {
      "format": "typescript",
      "lines": 56,
      "fragment": ";\n/**\n * Trust level for extractor execution\n * - 'full': Run with full Node.js access (built-in trusted code, no sandbox)\n * - 'sandbox': Run in isolated V8 context (external plugins, secure)\n */\nexport type ExtractorTrustLevel = 'full' | 'sandbox';\n/**\n * Extractor descriptor with detection and extraction logic\n */\nexport interface ExtractorDescriptor {\n    /** Unique name identifying this extractor */\n    name: string;\n    /** Detection function that analyzes output and returns confidence */\n    detect: (_output: string) => DetectionResult;\n    /** Extraction function that parses errors from output */\n    extract: (_output: string) => ErrorExtractorResult;\n    /** Priority for detection order (higher = check first) */\n    priority: number;\n    /** Trust level for execution (default: 'full' for built-ins) */\n    trust: ExtractorTrustLevel;\n    /** Optional hints for fast pre-filtering (Phase 2B) */\n    hints?: {\n        required?: string[];\n        anyOf?: string[];\n        forbidden?: string[];\n    };\n}\n/**\n * Registry of all available extractors\n *\n * All extractors now use the ExtractorPlugin structure with:\n * - Co-located tests (*.test.ts)\n * - Documentation (README.md + CLAUDE.md)\n * - Sample test cases\n * - Fast filtering hints\n * - Structured metadata\n *\n * Extractors are sorted by priority (highest first):\n * 1. Vitest (Priority 100) - \"RUN v\" header is unmistakable\n * 2. JUnit (Priority 100) - XML format is unique\n * 3. TypeScript (Priority 95) - Very specific error codes\n * 4. Playwright (Priority 95) - .spec.ts files with  separator\n * 5. Jest (Priority 90) - Must check before Mocha\n * 6. Vitest (Priority 90) - Secondary fallback patterns\n * 7. ESLint (Priority 85) - Distinctive format\n * 8. Jasmine (Priority 85) - Distinctive \"Failures:\" header\n * 9. Ava (Priority 82) - Ava v6+ format with  markers\n * 10. Mocha (Priority 80) - Generic \"passing/failing\" patterns\n * 11. TAP (Priority 78) - TAP version 13 protocol\n * 12. Maven Compiler (Priority 70) - Compilation error patterns\n * 13. Maven Checkstyle (Priority 60) - Checkstyle-specific patterns\n * 14. Maven Surefire (Priority 65) - Test plugin patterns\n * 15. Generic (Priority 10) - Fallback for unknown formats\n */\nexport declare",
      "tokens": 0,
      "firstFile": {
        "name": "packages/extractors/dist/extractor-registry.d.ts",
        "start": 15,
        "end": 70,
        "startLoc": {
          "line": 15,
          "column": 13,
          "position": 30
        },
        "endLoc": {
          "line": 70,
          "column": 8,
          "position": 177
        }
      },
      "secondFile": {
        "name": "packages/extractors/src/extractor-registry.ts",
        "start": 32,
        "end": 90,
        "startLoc": {
          "line": 32,
          "column": 32,
          "position": 160
        },
        "endLoc": {
          "line": 90,
          "column": 6,
          "position": 310
        }
      }
    },
    {
      "format": "typescript",
      "lines": 69,
      "fragment": "import { expect, test } from \"vitest\";\nimport * as z from \"zod/v4\";\nimport { parsedType } from \"../../../locales/tr.js\";\n\ntest(\"parsedType\", () => {\n  expect(parsedType(\"string\")).toBe(\"string\");\n  expect(parsedType(1)).toBe(\"number\");\n  expect(parsedType(true)).toBe(\"boolean\");\n  expect(parsedType(null)).toBe(\"null\");\n  expect(parsedType(undefined)).toBe(\"undefined\");\n  expect(parsedType([])).toBe(\"array\");\n  expect(parsedType({})).toBe(\"object\");\n  expect(parsedType(new Date())).toBe(\"Date\");\n  expect(parsedType(new Map())).toBe(\"Map\");\n  expect(parsedType(new Set())).toBe(\"Set\");\n  expect(parsedType(new Error())).toBe(\"Error\");\n\n  const nullPrototype = Object.create(null);\n  expect(parsedType(nullPrototype)).toBe(\"object\");\n\n  const doubleNullPrototype = Object.create(Object.create(null));\n  expect(parsedType(doubleNullPrototype)).toBe(\"object\");\n\n  expect(parsedType(Number.NaN)).toBe(\"NaN\");\n});\n\ntest(\"locales - tr\", () => {\n  z.config(z.locales.tr());\n\n  const invalidType = z.number().safeParse(\"a\");\n  expect(invalidType.error!.issues[0].code).toBe(\"invalid_type\");\n  expect(invalidType.error!.issues[0].message).toBe(\"Geersiz deer: beklenen number, alnan string\");\n\n  const invalidType2 = z.string().safeParse(1);\n  expect(invalidType2.error!.issues[0].code).toBe(\"invalid_type\");\n  expect(invalidType2.error!.issues[0].message).toBe(\"Geersiz deer: beklenen string, alnan number\");\n\n  const invalidValue = z.enum([\"a\", \"b\"]).safeParse(1);\n  expect(invalidValue.error!.issues[0].code).toBe(\"invalid_value\");\n  expect(invalidValue.error!.issues[0].message).toBe('Geersiz seenek: aadakilerden biri olmal: \"a\"|\"b\"');\n\n  const tooBig = z.number().max(10).safeParse(15);\n  expect(tooBig.error!.issues[0].code).toBe(\"too_big\");\n  expect(tooBig.error!.issues[0].message).toBe(\"ok byk: beklenen number <=10\");\n\n  const tooSmall = z.number().min(10).safeParse(5);\n  expect(tooSmall.error!.issues[0].code).toBe(\"too_small\");\n  expect(tooSmall.error!.issues[0].message).toBe(\"ok kk: beklenen number >=10\");\n\n  const invalidFormatRegex = z.string().regex(/abcd/).safeParse(\"invalid-string\");\n  expect(invalidFormatRegex.error!.issues[0].code).toBe(\"invalid_format\");\n  expect(invalidFormatRegex.error!.issues[0].message).toBe(\"Geersiz metin: /abcd/ desenine uymal\");\n\n  const invalidFormatStartsWith = z.string().startsWith(\"abcd\").safeParse(\"invalid-string\");\n  expect(invalidFormatStartsWith.error!.issues[0].code).toBe(\"invalid_format\");\n  expect(invalidFormatStartsWith.error!.issues[0].message).toBe('Geersiz metin: \"abcd\" ile balamal');\n\n  const notMultipleOf = z.number().multipleOf(3).safeParse(10);\n  expect(notMultipleOf.error!.issues[0].code).toBe(\"not_multiple_of\");\n  expect(notMultipleOf.error!.issues[0].message).toBe(\"Geersiz say: 3 ile tam blnebilmeli\");\n\n  const unrecognizedKeys = z.object({ a: z.string(), b: z.number() }).strict().safeParse({ a: \"a\", b: 1, c: 2 });\n  expect(unrecognizedKeys.error!.issues[0].code).toBe(\"unrecognized_keys\");\n  expect(unrecognizedKeys.error!.issues[0].message).toBe('Tannmayan anahtar: \"c\"');\n\n  const invalidUnion = z.union([z.string(), z.number()]).safeParse(true);\n  expect(invalidUnion.error!.issues[0].code).toBe(\"invalid_union\");\n  expect(invalidUnion.error!.issues[0].message).toBe(\"Geersiz deer\");\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/core/tests/locales/tr.test.ts",
        "start": 1,
        "end": 69,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 69,
          "column": 2,
          "position": 1087
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/tests/locales/tr.test.ts",
        "start": 1,
        "end": 69,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 69,
          "column": 2,
          "position": 1087
        }
      }
    },
    {
      "format": "typescript",
      "lines": 128,
      "fragment": "import { describe, expect, it } from \"vitest\";\nimport ru from \"../../../locales/ru.js\";\n\ndescribe(\"Russian localization\", () => {\n  const localeError = ru().localeError;\n\n  describe(\"pluralization rules\", () => {\n    for (const { type, cases } of TEST_CASES) {\n      describe(`${type} pluralization`, () => {\n        for (const { count, expected } of cases) {\n          it(`correctly pluralizes ${count} ${type}`, () => {\n            const error = localeError({\n              code: \"too_small\",\n              minimum: count,\n              type: \"number\",\n              inclusive: true,\n              path: [],\n              origin: type,\n              input: count - 1,\n            });\n\n            expect(error).toContain(expected);\n          });\n        }\n      });\n    }\n\n    it(\"handles negative numbers correctly\", () => {\n      const error = localeError({\n        code: \"too_small\",\n        minimum: -2,\n        type: \"number\",\n        inclusive: true,\n        path: [],\n        origin: \"array\",\n        input: -3,\n      });\n\n      expect(error).toContain(\"-2 \");\n    });\n\n    it(\"handles zero correctly\", () => {\n      const error = localeError({\n        code: \"too_small\",\n        minimum: 0,\n        type: \"number\",\n        inclusive: true,\n        path: [],\n        origin: \"array\",\n        input: -1,\n      });\n\n      expect(error).toContain(\"0 \");\n    });\n\n    it(\"handles bigint values correctly\", () => {\n      const error = localeError({\n        code: \"too_small\",\n        minimum: BigInt(21),\n        type: \"number\",\n        inclusive: true,\n        path: [],\n        origin: \"array\",\n        input: BigInt(20),\n      });\n\n      expect(error).toContain(\"21 \");\n    });\n  });\n});\n\nconst TEST_CASES = [\n  {\n    type: \"array\",\n    cases: [\n      { count: 1, expected: \"1 \" },\n      { count: 2, expected: \"2 \" },\n      { count: 5, expected: \"5 \" },\n      { count: 11, expected: \"11 \" },\n      { count: 21, expected: \"21 \" },\n      { count: 22, expected: \"22 \" },\n      { count: 25, expected: \"25 \" },\n      { count: 101, expected: \"101 \" },\n      { count: 111, expected: \"111 \" },\n    ],\n  },\n  {\n    type: \"set\",\n    cases: [\n      { count: 1, expected: \"1 \" },\n      { count: 2, expected: \"2 \" },\n      { count: 5, expected: \"5 \" },\n      { count: 11, expected: \"11 \" },\n      { count: 21, expected: \"21 \" },\n      { count: 22, expected: \"22 \" },\n      { count: 25, expected: \"25 \" },\n      { count: 101, expected: \"101 \" },\n      { count: 111, expected: \"111 \" },\n    ],\n  },\n  {\n    type: \"string\",\n    cases: [\n      { count: 1, expected: \"1 \" },\n      { count: 2, expected: \"2 \" },\n      { count: 5, expected: \"5 \" },\n      { count: 11, expected: \"11 \" },\n      { count: 21, expected: \"21 \" },\n      { count: 22, expected: \"22 \" },\n      { count: 25, expected: \"25 \" },\n    ],\n  },\n  {\n    type: \"file\",\n    cases: [\n      { count: 0, expected: \"0 \" },\n      { count: 1, expected: \"1 \" },\n      { count: 2, expected: \"2 \" },\n      { count: 5, expected: \"5 \" },\n      { count: 11, expected: \"11 \" },\n      { count: 21, expected: \"21 \" },\n      { count: 22, expected: \"22 \" },\n      { count: 25, expected: \"25 \" },\n      { count: 101, expected: \"101 \" },\n      { count: 110, expected: \"110 \" },\n    ],\n  },\n] as const;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/core/tests/locales/ru.test.ts",
        "start": 1,
        "end": 128,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 128,
          "column": 2,
          "position": 1267
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/tests/locales/ru.test.ts",
        "start": 1,
        "end": 128,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 128,
          "column": 2,
          "position": 1267
        }
      }
    },
    {
      "format": "typescript",
      "lines": 22,
      "fragment": "import { expect, test } from \"vitest\";\nimport { parsedType } from \"../../../locales/en.js\";\n\ntest(\"parsedType\", () => {\n  expect(parsedType(\"string\")).toBe(\"string\");\n  expect(parsedType(1)).toBe(\"number\");\n  expect(parsedType(true)).toBe(\"boolean\");\n  expect(parsedType(null)).toBe(\"null\");\n  expect(parsedType(undefined)).toBe(\"undefined\");\n  expect(parsedType([])).toBe(\"array\");\n  expect(parsedType({})).toBe(\"object\");\n  expect(parsedType(new Date())).toBe(\"Date\");\n  expect(parsedType(new Map())).toBe(\"Map\");\n  expect(parsedType(new Set())).toBe(\"Set\");\n  expect(parsedType(new Error())).toBe(\"Error\");\n\n  const nullPrototype = Object.create(null);\n  expect(parsedType(nullPrototype)).toBe(\"object\");\n\n  const doubleNullPrototype = Object.create(Object.create(null));\n  expect(parsedType(doubleNullPrototype)).toBe(\"object\");\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/core/tests/locales/en.test.ts",
        "start": 1,
        "end": 22,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 22,
          "column": 2,
          "position": 294
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/tests/locales/en.test.ts",
        "start": 1,
        "end": 22,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 22,
          "column": 2,
          "position": 294
        }
      }
    },
    {
      "format": "typescript",
      "lines": 124,
      "fragment": "import { describe, expect, it } from \"vitest\";\nimport be from \"../../../locales/be.js\";\n\ndescribe(\"Belarusian localization\", () => {\n  const localeError = be().localeError;\n\n  describe(\"pluralization rules\", () => {\n    for (const { type, cases } of TEST_CASES) {\n      describe(`${type} pluralization`, () => {\n        for (const { count, expected } of cases) {\n          it(`correctly pluralizes ${count} ${type}`, () => {\n            const error = localeError({\n              code: \"too_small\",\n              minimum: count,\n              type: \"number\",\n              inclusive: true,\n              path: [],\n              origin: type,\n              input: count - 1,\n            });\n            expect(error).toContain(expected);\n          });\n        }\n      });\n    }\n\n    it(\"handles negative numbers correctly\", () => {\n      const error = localeError({\n        code: \"too_small\",\n        minimum: -2,\n        type: \"number\",\n        inclusive: true,\n        path: [],\n        origin: \"array\",\n        input: -3,\n      });\n      expect(error).toContain(\"-2 \");\n    });\n\n    it(\"handles zero correctly\", () => {\n      const error = localeError({\n        code: \"too_small\",\n        minimum: 0,\n        type: \"number\",\n        inclusive: true,\n        path: [],\n        origin: \"array\",\n        input: -1,\n      });\n      expect(error).toContain(\"0 \");\n    });\n\n    it(\"handles bigint values correctly\", () => {\n      const error = localeError({\n        code: \"too_small\",\n        minimum: BigInt(21),\n        type: \"number\",\n        inclusive: true,\n        path: [],\n        origin: \"array\",\n        input: BigInt(20),\n      });\n      expect(error).toContain(\"21 \");\n    });\n  });\n});\n\nconst TEST_CASES = [\n  {\n    type: \"array\",\n    cases: [\n      { count: 1, expected: \"1 \" },\n      { count: 2, expected: \"2 \" },\n      { count: 5, expected: \"5 \" },\n      { count: 11, expected: \"11 \" },\n      { count: 21, expected: \"21 \" },\n      { count: 22, expected: \"22 \" },\n      { count: 25, expected: \"25 \" },\n      { count: 101, expected: \"101 \" },\n      { count: 111, expected: \"111 \" },\n    ],\n  },\n  {\n    type: \"set\",\n    cases: [\n      { count: 1, expected: \"1 \" },\n      { count: 2, expected: \"2 \" },\n      { count: 5, expected: \"5 \" },\n      { count: 11, expected: \"11 \" },\n      { count: 21, expected: \"21 \" },\n      { count: 22, expected: \"22 \" },\n      { count: 25, expected: \"25 \" },\n      { count: 101, expected: \"101 \" },\n      { count: 111, expected: \"111 \" },\n    ],\n  },\n  {\n    type: \"string\",\n    cases: [\n      { count: 1, expected: \"1 \" },\n      { count: 2, expected: \"2 \" },\n      { count: 5, expected: \"5 \" },\n      { count: 11, expected: \"11 \" },\n      { count: 21, expected: \"21 \" },\n      { count: 22, expected: \"22 \" },\n      { count: 25, expected: \"25 \" },\n    ],\n  },\n  {\n    type: \"file\",\n    cases: [\n      { count: 0, expected: \"0 \" },\n      { count: 1, expected: \"1 \" },\n      { count: 2, expected: \"2 \" },\n      { count: 5, expected: \"5 \" },\n      { count: 11, expected: \"11 \" },\n      { count: 21, expected: \"21 \" },\n      { count: 22, expected: \"22 \" },\n      { count: 25, expected: \"25 \" },\n      { count: 101, expected: \"101 \" },\n      { count: 110, expected: \"110 \" },\n    ],\n  },\n] as const;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/core/tests/locales/be.test.ts",
        "start": 1,
        "end": 124,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 124,
          "column": 2,
          "position": 1263
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/tests/locales/be.test.ts",
        "start": 1,
        "end": 124,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 124,
          "column": 2,
          "position": 1263
        }
      }
    },
    {
      "format": "typescript",
      "lines": 299,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4-mini\";\n\nconst FAIL = { success: false };\n\ntest(\"z.string\", async () => {\n  const a = z.string();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(() => z.parse(a, 123)).toThrow();\n  expect(() => z.parse(a, false)).toThrow();\n  type a = z.infer<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n});\n\n// test(\"z.string with description\", () => {\n//   const a = z.string({ description: \"string description\" });\n//   a._def;\n//   expect(a._def.description).toEqual(\"string description\");\n// });\n\ntest(\"z.string with custom error\", () => {\n  const a = z.string({ error: () => \"BAD\" });\n  expect(z.safeParse(a, 123).error!.issues[0].message).toEqual(\"BAD\");\n});\n\ntest(\"inference in checks\", () => {\n  const a = z.string().check(z.refine((val) => val.length));\n  z.parse(a, \"___\");\n  expect(() => z.parse(a, \"\")).toThrow();\n  const b = z.string().check(z.refine((val) => val.length));\n  z.parse(b, \"___\");\n  expect(() => z.parse(b, \"\")).toThrow();\n  const c = z.string().check(z.refine((val) => val.length));\n  z.parse(c, \"___\");\n  expect(() => z.parse(c, \"\")).toThrow();\n  const d = z.string().check(z.refine((val) => val.length));\n  z.parse(d, \"___\");\n  expect(() => z.parse(d, \"\")).toThrow();\n});\n\ntest(\"z.string async\", async () => {\n  // async\n  const a = z.string().check(z.refine(async (val) => val.length));\n  expect(await z.parseAsync(a, \"___\")).toEqual(\"___\");\n  await expect(() => z.parseAsync(a, \"\")).rejects.toThrowError();\n});\n\ntest(\"z.uuid\", () => {\n  const a = z.uuid();\n  // parse uuid\n  z.parse(a, \"550e8400-e29b-41d4-a716-446655440000\");\n  z.parse(a, \"550e8400-e29b-61d4-a716-446655440000\");\n\n  // bad uuid\n  expect(() => z.parse(a, \"hello\")).toThrow();\n  // wrong type\n  expect(() => z.parse(a, 123)).toThrow();\n\n  const b = z.uuidv4();\n  z.parse(b, \"550e8400-e29b-41d4-a716-446655440000\");\n  expect(z.safeParse(b, \"550e8400-e29b-61d4-a716-446655440000\")).toMatchObject(FAIL);\n\n  const c = z.uuidv6();\n  z.parse(c, \"550e8400-e29b-61d4-a716-446655440000\");\n  expect(z.safeParse(c, \"550e8400-e29b-41d4-a716-446655440000\")).toMatchObject(FAIL);\n\n  const d = z.uuidv7();\n  z.parse(d, \"550e8400-e29b-71d4-a716-446655440000\");\n  expect(z.safeParse(d, \"550e8400-e29b-41d4-a716-446655440000\")).toMatchObject(FAIL);\n  expect(z.safeParse(d, \"550e8400-e29b-61d4-a716-446655440000\")).toMatchObject(FAIL);\n});\n\ntest(\"z.email\", () => {\n  const a = z.email();\n  expect(z.parse(a, \"test@test.com\")).toEqual(\"test@test.com\");\n  expect(() => z.parse(a, \"test\")).toThrow();\n  expect(z.safeParse(a, \"bad email\", { error: () => \"bad email\" }).error!.issues[0].message).toEqual(\"bad email\");\n\n  const b = z.email(\"bad email\");\n  expect(z.safeParse(b, \"bad email\").error!.issues[0].message).toEqual(\"bad email\");\n\n  const c = z.email({ error: \"bad email\" });\n  expect(z.safeParse(c, \"bad email\").error!.issues[0].message).toEqual(\"bad email\");\n\n  const d = z.email({ error: () => \"bad email\" });\n  expect(z.safeParse(d, \"bad email\").error!.issues[0].message).toEqual(\"bad email\");\n});\n\ntest(\"z.url\", () => {\n  const a = z.url();\n  // valid URLs\n  expect(a.parse(\"http://example.com\")).toEqual(\"http://example.com\");\n  expect(a.parse(\"https://example.com\")).toEqual(\"https://example.com\");\n  expect(a.parse(\"ftp://example.com\")).toEqual(\"ftp://example.com\");\n  expect(a.parse(\"http://sub.example.com\")).toEqual(\"http://sub.example.com\");\n  expect(a.parse(\"https://example.com/path?query=123#fragment\")).toEqual(\"https://example.com/path?query=123#fragment\");\n  expect(a.parse(\"http://localhost\")).toEqual(\"http://localhost\");\n  expect(a.parse(\"https://localhost\")).toEqual(\"https://localhost\");\n  expect(a.parse(\"http://localhost:3000\")).toEqual(\"http://localhost:3000\");\n  expect(a.parse(\"https://localhost:3000\")).toEqual(\"https://localhost:3000\");\n\n  // test trimming\n  expect(a.parse(\"  http://example.com  \")).toEqual(\"http://example.com\");\n  expect(a.parse(\"  http://example.com/\")).toEqual(\"http://example.com/\");\n  expect(a.parse(\"  http://example.com\")).toEqual(\"http://example.com\");\n  expect(a.parse(\"  http://example.com//\")).toEqual(\"http://example.com//\");\n\n  // invalid URLs\n  expect(() => a.parse(\"not-a-url\")).toThrow();\n  // expect(() => a.parse(\"http:/example.com\")).toThrow();\n  expect(() => a.parse(\"://example.com\")).toThrow();\n  expect(() => a.parse(\"http://\")).toThrow();\n  expect(() => a.parse(\"example.com\")).toThrow();\n\n  // wrong type\n  expect(() => a.parse(123)).toThrow();\n  expect(() => a.parse(null)).toThrow();\n  expect(() => a.parse(undefined)).toThrow();\n});\n\ntest(\"z.url with optional hostname regex\", () => {\n  const a = z.url({ hostname: /example\\.com$/ });\n  expect(a.parse(\"http://example.com\")).toEqual(\"http://example.com\");\n  expect(a.parse(\"https://sub.example.com\")).toEqual(\"https://sub.example.com\");\n  expect(() => a.parse(\"http://examples.com\")).toThrow();\n  expect(() => a.parse(\"http://example.org\")).toThrow();\n  expect(() => a.parse(\"asdf\")).toThrow();\n});\n\ntest(\"z.url - file urls\", () => {\n  // file URLs\n  const a = z.url({ hostname: /.*/ }); // allow any hostname\n  expect(a.parse(\"file:///path/to/file.txt\")).toEqual(\"file:///path/to/file.txt\");\n  expect(a.parse(\"file:///C:/path/to/file.txt\")).toEqual(\"file:///C:/path/to/file.txt\");\n  expect(a.parse(\"file:///C:/path/to/file.txt?query=123#fragment\")).toEqual(\n    \"file:///C:/path/to/file.txt?query=123#fragment\"\n  );\n});\ntest(\"z.url with optional protocol regex\", () => {\n  const a = z.url({ protocol: /^https?$/ });\n  expect(a.parse(\"http://example.com\")).toEqual(\"http://example.com\");\n  expect(a.parse(\"https://example.com\")).toEqual(\"https://example.com\");\n  expect(() => a.parse(\"ftp://example.com\")).toThrow();\n  expect(() => a.parse(\"mailto:example@example.com\")).toThrow();\n  expect(() => a.parse(\"asdf\")).toThrow();\n});\n\ntest(\"z.url with both hostname and protocol regexes\", () => {\n  const a = z.url({ hostname: /example\\.com$/, protocol: /^https$/ });\n  expect(a.parse(\"https://example.com\")).toEqual(\"https://example.com\");\n  expect(a.parse(\"https://sub.example.com\")).toEqual(\"https://sub.example.com\");\n  expect(() => a.parse(\"http://example.com\")).toThrow();\n  expect(() => a.parse(\"https://example.org\")).toThrow();\n  expect(() => a.parse(\"ftp://example.com\")).toThrow();\n  expect(() => a.parse(\"asdf\")).toThrow();\n});\n\ntest(\"z.url with invalid regex patterns\", () => {\n  const a = z.url({ hostname: /a+$/, protocol: /^ftp$/ });\n  a.parse(\"ftp://a\");\n  a.parse(\"ftp://aaaaaaaa\");\n  expect(() => a.parse(\"http://aaa\")).toThrow();\n  expect(() => a.parse(\"https://example.com\")).toThrow();\n  expect(() => a.parse(\"ftp://asdfasdf\")).toThrow();\n  expect(() => a.parse(\"ftp://invalid\")).toThrow();\n});\n\ntest(\"z.emoji\", () => {\n  const a = z.emoji();\n  expect(z.parse(a, \"\")).toEqual(\"\");\n  expect(() => z.parse(a, \"hello\")).toThrow();\n});\n\ntest(\"z.nanoid\", () => {\n  const a = z.nanoid();\n  expect(z.parse(a, \"8FHZpIxleEK3axQRBNNjN\")).toEqual(\"8FHZpIxleEK3axQRBNNjN\");\n  expect(() => z.parse(a, \"abc\")).toThrow();\n});\n\ntest(\"z.cuid\", () => {\n  const a = z.cuid();\n  expect(z.parse(a, \"cixs7y0c0000f7x3b1z6m3w6r\")).toEqual(\"cixs7y0c0000f7x3b1z6m3w6r\");\n  expect(() => z.parse(a, \"abc\")).toThrow();\n});\n\ntest(\"z.cuid2\", () => {\n  const a = z.cuid2();\n  expect(z.parse(a, \"cixs7y0c0000f7x3b1z6m3w6r\")).toEqual(\"cixs7y0c0000f7x3b1z6m3w6r\");\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.ulid\", () => {\n  const a = z.ulid();\n  expect(z.parse(a, \"01ETGRM9QYVX6S9V2F3B6JXG4N\")).toEqual(\"01ETGRM9QYVX6S9V2F3B6JXG4N\");\n  expect(() => z.parse(a, \"abc\")).toThrow();\n});\n\ntest(\"z.xid\", () => {\n  const a = z.xid();\n  expect(z.parse(a, \"9m4e2mr0ui3e8a215n4g\")).toEqual(\"9m4e2mr0ui3e8a215n4g\");\n  expect(() => z.parse(a, \"abc\")).toThrow();\n});\n\ntest(\"z.ksuid\", () => {\n  const a = z.ksuid();\n  expect(z.parse(a, \"2naeRjTrrHJAkfd3tOuEjw90WCA\")).toEqual(\"2naeRjTrrHJAkfd3tOuEjw90WCA\");\n  expect(() => z.parse(a, \"abc\")).toThrow();\n});\n\n// test(\"z.ip\", () => {\n//   const a = z.ip();\n//   expect(z.parse(a, \"127.0.0.1\")).toEqual(\"127.0.0.1\");\n//   expect(z.parse(a, \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\")).toEqual(\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\");\n//   expect(() => z.parse(a, \"abc\")).toThrow();\n// });\n\ntest(\"z.ipv4\", () => {\n  const a = z.ipv4();\n  // valid ipv4\n  expect(z.parse(a, \"192.168.1.1\")).toEqual(\"192.168.1.1\");\n  expect(z.parse(a, \"255.255.255.255\")).toEqual(\"255.255.255.255\");\n  // invalid ipv4\n  expect(() => z.parse(a, \"999.999.999.999\")).toThrow();\n  expect(() => z.parse(a, \"256.256.256.256\")).toThrow();\n  expect(() => z.parse(a, \"192.168.1\")).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n  // wrong type\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.ipv6\", () => {\n  const a = z.ipv6();\n  // valid ipv6\n  expect(z.parse(a, \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\")).toEqual(\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\");\n  expect(z.parse(a, \"::1\")).toEqual(\"::1\");\n  // invalid ipv6\n  expect(() => z.parse(a, \"2001:db8::85a3::8a2e:370:7334\")).toThrow();\n  expect(() => z.parse(a, \"2001:db8:85a3:0:0:8a2e:370g:7334\")).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n  // wrong type\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.base64\", () => {\n  const a = z.base64();\n  // valid base64\n  expect(z.parse(a, \"SGVsbG8gd29ybGQ=\")).toEqual(\"SGVsbG8gd29ybGQ=\");\n  expect(z.parse(a, \"U29tZSBvdGhlciBzdHJpbmc=\")).toEqual(\"U29tZSBvdGhlciBzdHJpbmc=\");\n  // invalid base64\n  expect(() => z.parse(a, \"SGVsbG8gd29ybGQ\")).toThrow();\n  expect(() => z.parse(a, \"U29tZSBvdGhlciBzdHJpbmc\")).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n  // wrong type\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\n// test(\"z.jsonString\", () => {\n//   const a = z.jsonString();\n//   // valid JSON string\n//   expect(z.parse(a, '{\"key\":\"value\"}')).toEqual('{\"key\":\"value\"}');\n//   expect(z.parse(a, '[\"item1\", \"item2\"]')).toEqual('[\"item1\", \"item2\"]');\n//   // invalid JSON string\n//   expect(() => z.parse(a, '{\"key\":value}')).toThrow();\n//   expect(() => z.parse(a, '[\"item1\", \"item2\"')).toThrow();\n//   expect(() => z.parse(a, \"hello\")).toThrow();\n//   // wrong type\n//   expect(() => z.parse(a, 123)).toThrow();\n// });\n\ntest(\"z.e164\", () => {\n  const a = z.e164();\n  // valid e164\n  expect(z.parse(a, \"+1234567890\")).toEqual(\"+1234567890\");\n  expect(z.parse(a, \"+19876543210\")).toEqual(\"+19876543210\");\n  // invalid e164\n  expect(() => z.parse(a, \"1234567890\")).toThrow();\n  expect(() => z.parse(a, \"+12345\")).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n  // wrong type\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.jwt\", () => {\n  const a = z.jwt();\n  // valid jwt\n  expect(\n    z.parse(\n      a,\n      \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\"\n    )\n  ).toEqual(\n    \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\"\n  );\n  // invalid jwt\n  expect(() => z.parse(a, \"invalid.jwt.token\")).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n  // wrong type\n  expect(() => z.parse(a, 123)).toThrow();\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/mini/tests/string.test.ts",
        "start": 1,
        "end": 299,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 299,
          "column": 2,
          "position": 3744
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/string.test.ts",
        "start": 1,
        "end": 299,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 299,
          "column": 2,
          "position": 3744
        }
      }
    },
    {
      "format": "typescript",
      "lines": 275,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport { z } from \"zod/v4-mini\";\n\ntest(\"recursion with z.lazy\", () => {\n  const data = {\n    name: \"I\",\n    subcategories: [\n      {\n        name: \"A\",\n        subcategories: [\n          {\n            name: \"1\",\n            subcategories: [\n              {\n                name: \"a\",\n                subcategories: [],\n              },\n            ],\n          },\n        ],\n      },\n    ],\n  };\n\n  const Category = z.object({\n    name: z.string(),\n    get subcategories(): z.ZodMiniOptional<z.ZodMiniArray<typeof Category>> {\n      return z.optional(z.array(Category));\n    },\n  });\n  Category.parse(data);\n\n  type Category = z.infer<typeof Category>;\n  interface _Category {\n    name: string;\n    subcategories?: _Category[];\n  }\n  expectTypeOf<Category>().toEqualTypeOf<_Category>();\n});\n\ntest(\"recursion involving union type\", () => {\n  const data = {\n    value: 1,\n    next: {\n      value: 2,\n      next: {\n        value: 3,\n        next: {\n          value: 4,\n          next: null,\n        },\n      },\n    },\n  };\n\n  const LL = z.object({\n    value: z.number(),\n    get next(): z.ZodMiniNullable<typeof LL> {\n      return z.nullable(LL);\n    },\n  });\n\n  LL.parse(data);\n  type LL = z.infer<typeof LL>;\n  type _LL = {\n    value: number;\n    next: _LL | null;\n  };\n  expectTypeOf<LL>().toEqualTypeOf<_LL>();\n});\n\ntest(\"mutual recursion - native\", () => {\n  const Alazy = z.object({\n    val: z.number(),\n    get b() {\n      return z.optional(Blazy);\n    },\n  });\n\n  const Blazy = z.object({\n    val: z.number(),\n    get a() {\n      return z.optional(Alazy);\n    },\n  });\n  const testData = {\n    val: 1,\n    b: {\n      val: 5,\n      a: {\n        val: 3,\n        b: {\n          val: 4,\n          a: {\n            val: 2,\n            b: {\n              val: 1,\n            },\n          },\n        },\n      },\n    },\n  };\n\n  Alazy.parse(testData);\n  Blazy.parse(testData.b);\n\n  type Alazy = z.infer<typeof Alazy>;\n  type Blazy = z.infer<typeof Blazy>;\n  interface _Alazy {\n    val: number;\n    b?: _Blazy | undefined;\n  }\n  interface _Blazy {\n    val: number;\n    a?: _Alazy | undefined;\n  }\n  expectTypeOf<Alazy>().toEqualTypeOf<_Alazy>();\n  expectTypeOf<Blazy>().toEqualTypeOf<_Blazy>();\n\n  expect(() => Alazy.parse({ val: \"asdf\" })).toThrow();\n});\n\ntest(\"pick and omit with getter\", () => {\n  const Category = z.strictObject({\n    name: z.string(),\n    get subcategories() {\n      return z.array(Category);\n    },\n  });\n\n  type Category = z.infer<typeof Category>;\n  interface _Category {\n    name: string;\n    subcategories: _Category[];\n  }\n  expectTypeOf<Category>().toEqualTypeOf<_Category>();\n\n  const PickedCategory = z.pick(Category, { name: true });\n  const OmittedCategory = z.omit(Category, { subcategories: true });\n  type PickedCategory = z.infer<typeof PickedCategory>;\n  type OmittedCategory = z.infer<typeof OmittedCategory>;\n  interface _PickedCategory {\n    name: string;\n  }\n  interface _OmittedCategory {\n    name: string;\n  }\n  expectTypeOf<PickedCategory>().toEqualTypeOf<_PickedCategory>();\n  expectTypeOf<OmittedCategory>().toEqualTypeOf<_OmittedCategory>();\n\n  const picked = { name: \"test\" };\n  const omitted = { name: \"test\" };\n\n  PickedCategory.parse(picked);\n  OmittedCategory.parse(omitted);\n\n  expect(() => PickedCategory.parse({ name: \"test\", subcategories: [] })).toThrow();\n  expect(() => OmittedCategory.parse({ name: \"test\", subcategories: [] })).toThrow();\n});\n\ntest(\"deferred self-recursion\", () => {\n  const Feature = z.object({\n    title: z.string(),\n    get features(): z.ZodMiniOptional<z.ZodMiniArray<typeof Feature>> {\n      return z.optional(z.array(Feature)); //.optional();\n    },\n  });\n  type Feature = z.infer<typeof Feature>;\n\n  const Output = z.object({\n    id: z.int(), //.nonnegative(),\n    name: z.string(),\n    features: z.array(Feature), //.array(), // <\n  });\n\n  type Output = z.output<typeof Output>;\n\n  type _Feature = {\n    title: string;\n    features?: _Feature[] | undefined;\n  };\n\n  type _Output = {\n    id: number;\n    name: string;\n    features: _Feature[];\n  };\n\n  expectTypeOf<Feature>().toEqualTypeOf<_Feature>();\n  expectTypeOf<Output>().toEqualTypeOf<_Output>();\n});\n\ntest(\"recursion compatibility\", () => {\n  // array\n  const A = z.object({\n    get subcategories() {\n      return z.array(A);\n    },\n  });\n  // tuple\n  const B = z.object({\n    get subcategories() {\n      return z.tuple([B, B]);\n    },\n  });\n  // object\n  const C = z.object({\n    get subcategories() {\n      return z.object({\n        subcategories: C,\n      });\n    },\n  });\n  // union\n  const D = z.object({\n    get subcategories() {\n      return z.union([D, z.string()]);\n    },\n  });\n  // intersection\n  const E = z.object({\n    get subcategories() {\n      return z.intersection(E, E);\n    },\n  });\n  // record\n  const F = z.object({\n    get subcategories() {\n      return z.record(z.string(), F);\n    },\n  });\n  // map\n  const G = z.object({\n    get subcategories() {\n      return z.map(z.string(), G);\n    },\n  });\n  // set\n  const H = z.object({\n    get subcategories() {\n      return z.set(H);\n    },\n  });\n  // optional\n  const I = z.object({\n    get subcategories() {\n      return z.optional(I);\n    },\n  });\n  // nullable\n  const J = z.object({\n    get subcategories() {\n      return z.nullable(J);\n    },\n  });\n  // optional\n  const L = z.object({\n    get subcategories() {\n      return z.optional(L);\n    },\n  });\n  // nullable\n  const M = z.object({\n    get subcategories() {\n      return z.nullable(M);\n    },\n  });\n  // nonoptional\n  const N = z.object({\n    get subcategories() {\n      return z.nonoptional(N);\n    },\n  });\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/mini/tests/recursive-types.test.ts",
        "start": 1,
        "end": 275,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 275,
          "column": 2,
          "position": 2264
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/recursive-types.test.ts",
        "start": 1,
        "end": 275,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 275,
          "column": 2,
          "position": 2264
        }
      }
    },
    {
      "format": "typescript",
      "lines": 43,
      "fragment": "import { expect, test } from \"vitest\";\nimport * as z from \"zod/v4-mini\";\n\ndeclare module \"zod/v4/core\" {\n  interface $ZodType {\n    /** @deprecated */\n    _core(): string;\n  }\n}\n\ntest(\"prototype extension\", () => {\n  z.core.$ZodType.prototype._core = function () {\n    return \"_core\";\n  };\n\n  // should pass\n  const result = z.string()._core();\n  expect(result).toBe(\"_core\");\n  // expectTypeOf<typeof result>().toEqualTypeOf<string>();\n\n  // clean up\n  z.ZodMiniType.prototype._core = undefined;\n});\n\ndeclare module \"zod/v4/mini\" {\n  interface ZodMiniType {\n    /** @deprecated */\n    _mini(): string;\n  }\n}\n\ntest(\"prototype extension\", () => {\n  z.ZodMiniType.prototype._mini = function () {\n    return \"_mini\";\n  };\n\n  // should pass\n  const result = z.string()._mini();\n  expect(result).toBe(\"_mini\");\n\n  // clean up\n  z.ZodMiniType.prototype._mini = undefined;\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/mini/tests/prototypes.test.ts",
        "start": 1,
        "end": 43,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 43,
          "column": 2,
          "position": 292
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/prototypes.test.ts",
        "start": 1,
        "end": 43,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 43,
          "column": 2,
          "position": 292
        }
      }
    },
    {
      "format": "typescript",
      "lines": 185,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4-mini\";\n\ntest(\"z.object\", () => {\n  const a = z.object({\n    name: z.string(),\n    age: z.number(),\n    points: z.optional(z.number()),\n    \"test?\": z.boolean(),\n  });\n\n  a._zod.def.shape[\"test?\"];\n  a._zod.def.shape.points._zod.optin;\n\n  type a = z.output<typeof a>;\n\n  expectTypeOf<a>().toEqualTypeOf<{\n    name: string;\n    age: number;\n    points?: number;\n    \"test?\": boolean;\n  }>();\n  expect(z.parse(a, { name: \"john\", age: 30, \"test?\": true })).toEqual({\n    name: \"john\",\n    age: 30,\n    \"test?\": true,\n  });\n  // \"test?\" is required in ZodObject\n  expect(() => z.parse(a, { name: \"john\", age: \"30\" })).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n\n  // null prototype\n  const schema = z.object({ a: z.string() });\n  const obj = Object.create(null);\n  obj.a = \"foo\";\n  expect(schema.parse(obj)).toEqual({ a: \"foo\" });\n});\n\ntest(\"z.object().check()\", () => {\n  const a = z.object({\n    name: z.string(),\n    age: z.number(),\n    points: z.optional(z.number()),\n    \"test?\": z.boolean(),\n  });\n\n  type a = z.output<typeof a>;\n\n  a.check(({ value }) => {\n    expectTypeOf(value).toEqualTypeOf<a>();\n  });\n});\n\ntest(\"z.strictObject\", () => {\n  const a = z.strictObject({\n    name: z.string(),\n  });\n  expect(z.parse(a, { name: \"john\" })).toEqual({ name: \"john\" });\n  expect(() => z.parse(a, { name: \"john\", age: 30 })).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n});\n\ntest(\"z.looseObject\", () => {\n  const a = z.looseObject({\n    name: z.string(),\n    age: z.number(),\n  });\n  expect(z.parse(a, { name: \"john\", age: 30 })).toEqual({\n    name: \"john\",\n    age: 30,\n  });\n  expect(z.parse(a, { name: \"john\", age: 30, extra: true })).toEqual({\n    name: \"john\",\n    age: 30,\n    extra: true,\n  });\n  expect(() => z.parse(a, \"hello\")).toThrow();\n});\n\nconst userSchema = z.object({\n  name: z.string(),\n  age: z.number(),\n  email: z.optional(z.string()),\n});\n\ntest(\"z.keyof\", () => {\n  // z.keyof returns an enum schema of the keys of an object schema\n  const userKeysSchema = z.keyof(userSchema);\n  type UserKeys = z.infer<typeof userKeysSchema>;\n  expectTypeOf<UserKeys>().toEqualTypeOf<\"name\" | \"age\" | \"email\">();\n  expect(userKeysSchema).toBeDefined();\n  expect(z.safeParse(userKeysSchema, \"name\").success).toBe(true);\n  expect(z.safeParse(userKeysSchema, \"age\").success).toBe(true);\n  expect(z.safeParse(userKeysSchema, \"email\").success).toBe(true);\n  expect(z.safeParse(userKeysSchema, \"isAdmin\").success).toBe(false);\n});\n\ntest(\"z.extend\", () => {\n  const extendedSchema = z.extend(userSchema, {\n    isAdmin: z.boolean(),\n  });\n  type ExtendedUser = z.infer<typeof extendedSchema>;\n  expectTypeOf<ExtendedUser>().toEqualTypeOf<{\n    name: string;\n    age: number;\n    email?: string;\n    isAdmin: boolean;\n  }>();\n  expect(extendedSchema).toBeDefined();\n  expect(z.safeParse(extendedSchema, { name: \"John\", age: 30, isAdmin: true }).success).toBe(true);\n});\n\ntest(\"z.pick\", () => {\n  const pickedSchema = z.pick(userSchema, { name: true, email: true });\n  type PickedUser = z.infer<typeof pickedSchema>;\n  expectTypeOf<PickedUser>().toEqualTypeOf<{ name: string; email?: string }>();\n  expect(pickedSchema).toBeDefined();\n  expect(z.safeParse(pickedSchema, { name: \"John\", email: \"john@example.com\" }).success).toBe(true);\n});\n\ntest(\"z.omit\", () => {\n  const omittedSchema = z.omit(userSchema, { age: true });\n  type OmittedUser = z.infer<typeof omittedSchema>;\n  expectTypeOf<OmittedUser>().toEqualTypeOf<{\n    name: string;\n    email?: string | undefined;\n  }>();\n  expect(omittedSchema).toBeDefined();\n  expect(Reflect.ownKeys(omittedSchema._zod.def.shape)).toEqual([\"name\", \"email\"]);\n  expect(z.safeParse(omittedSchema, { name: \"John\", email: \"john@example.com\" }).success).toBe(true);\n});\n\ntest(\"z.partial\", () => {\n  const partialSchema = z.partial(userSchema);\n  type PartialUser = z.infer<typeof partialSchema>;\n  expectTypeOf<PartialUser>().toEqualTypeOf<{\n    name?: string;\n    age?: number;\n    email?: string;\n  }>();\n  expect(z.safeParse(partialSchema, { name: \"John\" }).success).toBe(true);\n});\n\ntest(\"z.partial with mask\", () => {\n  const partialSchemaWithMask = z.partial(userSchema, { name: true });\n  type PartialUserWithMask = z.infer<typeof partialSchemaWithMask>;\n  expectTypeOf<PartialUserWithMask>().toEqualTypeOf<{\n    name?: string;\n    age: number;\n    email?: string;\n  }>();\n  expect(z.safeParse(partialSchemaWithMask, { age: 30 }).success).toBe(true);\n  expect(z.safeParse(partialSchemaWithMask, { name: \"John\" }).success).toBe(false);\n});\n\ntest(\"z.catchall\", () => {\n  // z.catchall()\n  const schema = z.catchall(\n    z.object({\n      name: z.string(),\n      // age: z.number(),\n    }),\n    z.string()\n  );\n\n  type schemaIn = z.input<typeof schema>;\n  type schemaOut = z.output<typeof schema>;\n  expectTypeOf<schemaIn>().toEqualTypeOf<{\n    name: string;\n    [key: string]: string;\n  }>();\n\n  expectTypeOf<schemaOut>().toEqualTypeOf<{\n    name: string;\n    [key: string]: string;\n  }>();\n\n  schema.parse({\n    name: \"john\",\n    age: \"30\",\n    extra: \"extra value\",\n  });\n\n  expect(() => schema.parse({ name: \"john\", age: 30 })).toThrow();\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/mini/tests/object.test.ts",
        "start": 1,
        "end": 185,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 185,
          "column": 2,
          "position": 2129
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/object.test.ts",
        "start": 1,
        "end": 185,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 185,
          "column": 2,
          "position": 2129
        }
      }
    },
    {
      "format": "typescript",
      "lines": 95,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4-mini\";\n\ntest(\"z.number\", () => {\n  const a = z.number();\n  expect(z.parse(a, 123)).toEqual(123);\n  expect(z.parse(a, 123.45)).toEqual(123.45);\n  expect(() => z.parse(a, \"123\")).toThrow();\n  expect(() => z.parse(a, false)).toThrow();\n\n  type a = z.infer<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<number>();\n});\n\ntest(\"z.number async\", async () => {\n  const a = z.number().check(z.refine(async (_) => _ > 0));\n  await expect(z.parseAsync(a, 123)).resolves.toEqual(123);\n  await expect(() => z.parseAsync(a, -123)).rejects.toThrow();\n  await expect(() => z.parseAsync(a, \"123\")).rejects.toThrow();\n});\n\ntest(\"z.int\", () => {\n  const a = z.int();\n  expect(z.parse(a, 123)).toEqual(123);\n  expect(() => z.parse(a, 123.45)).toThrow();\n  expect(() => z.parse(a, \"123\")).toThrow();\n  expect(() => z.parse(a, false)).toThrow();\n});\n\ntest(\"z.float32\", () => {\n  const a = z.float32();\n  expect(z.parse(a, 123.45)).toEqual(123.45);\n  expect(() => z.parse(a, \"123.45\")).toThrow();\n  expect(() => z.parse(a, false)).toThrow();\n  // -3.4028234663852886e38, 3.4028234663852886e38;\n  expect(() => z.parse(a, 3.4028234663852886e38 * 2)).toThrow(); // Exceeds max\n  expect(() => z.parse(a, -3.4028234663852886e38 * 2)).toThrow(); // Exceeds min\n});\n\ntest(\"z.float64\", () => {\n  const a = z.float64();\n  expect(z.parse(a, 123.45)).toEqual(123.45);\n  expect(() => z.parse(a, \"123.45\")).toThrow();\n  expect(() => z.parse(a, false)).toThrow();\n  expect(() => z.parse(a, 1.7976931348623157e308 * 2)).toThrow(); // Exceeds max\n  expect(() => z.parse(a, -1.7976931348623157e308 * 2)).toThrow(); // Exceeds min\n});\n\ntest(\"z.int32\", () => {\n  const a = z.int32();\n  expect(z.parse(a, 123)).toEqual(123);\n  expect(() => z.parse(a, 123.45)).toThrow();\n  expect(() => z.parse(a, \"123\")).toThrow();\n  expect(() => z.parse(a, false)).toThrow();\n  expect(() => z.parse(a, 2147483648)).toThrow(); // Exceeds max\n  expect(() => z.parse(a, -2147483649)).toThrow(); // Exceeds min\n});\n\ntest(\"z.uint32\", () => {\n  const a = z.uint32();\n  expect(z.parse(a, 123)).toEqual(123);\n  expect(() => z.parse(a, -123)).toThrow();\n  expect(() => z.parse(a, 123.45)).toThrow();\n  expect(() => z.parse(a, \"123\")).toThrow();\n  expect(() => z.parse(a, false)).toThrow();\n  expect(() => z.parse(a, 4294967296)).toThrow(); // Exceeds max\n  expect(() => z.parse(a, -1)).toThrow(); // Below min\n});\n\ntest(\"z.int64\", () => {\n  const a = z.int64();\n  expect(z.parse(a, BigInt(123))).toEqual(BigInt(123));\n  expect(() => z.parse(a, 123)).toThrow();\n  expect(() => z.parse(a, 123.45)).toThrow();\n  expect(() => z.parse(a, \"123\")).toThrow();\n  expect(() => z.parse(a, false)).toThrow();\n  expect(() => z.parse(a, BigInt(\"9223372036854775808\"))).toThrow();\n  expect(() => z.parse(a, BigInt(\"-9223372036854775809\"))).toThrow();\n  // expect(() => z.parse(a, BigInt(\"9223372036854775808\"))).toThrow(); // Exceeds max\n  // expect(() => z.parse(a, BigInt(\"-9223372036854775809\"))).toThrow(); // Exceeds min\n});\n\ntest(\"z.uint64\", () => {\n  const a = z.uint64();\n  expect(z.parse(a, BigInt(123))).toEqual(BigInt(123));\n  expect(() => z.parse(a, 123)).toThrow();\n  expect(() => z.parse(a, -123)).toThrow();\n  expect(() => z.parse(a, 123.45)).toThrow();\n  expect(() => z.parse(a, \"123\")).toThrow();\n  expect(() => z.parse(a, false)).toThrow();\n  expect(() => z.parse(a, BigInt(\"18446744073709551616\"))).toThrow(); // Exceeds max\n  expect(() => z.parse(a, BigInt(\"-1\"))).toThrow(); // Below min\n  // expect(() => z.parse(a, BigInt(\"18446744073709551616\"))).toThrow(); // Exceeds max\n  // expect(() => z.parse(a, BigInt(\"-1\"))).toThrow(); // Below min\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/mini/tests/number.test.ts",
        "start": 1,
        "end": 95,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 95,
          "column": 2,
          "position": 1597
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/number.test.ts",
        "start": 1,
        "end": 95,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 95,
          "column": 2,
          "position": 1597
        }
      }
    },
    {
      "format": "typescript",
      "lines": 871,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4-mini\";\nimport type { util } from \"zod/v4/core\";\n\ntest(\"z.boolean\", () => {\n  const a = z.boolean();\n  expect(z.parse(a, true)).toEqual(true);\n  expect(z.parse(a, false)).toEqual(false);\n  expect(() => z.parse(a, 123)).toThrow();\n  expect(() => z.parse(a, \"true\")).toThrow();\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<boolean>();\n});\n\ntest(\"z.bigint\", () => {\n  const a = z.bigint();\n  expect(z.parse(a, BigInt(123))).toEqual(BigInt(123));\n  expect(() => z.parse(a, 123)).toThrow();\n  expect(() => z.parse(a, \"123\")).toThrow();\n});\n\ntest(\"z.symbol\", () => {\n  const a = z.symbol();\n  const sym = Symbol();\n  expect(z.parse(a, sym)).toEqual(sym);\n  expect(() => z.parse(a, \"symbol\")).toThrow();\n});\n\ntest(\"z.date\", () => {\n  const a = z.date();\n  const date = new Date();\n  expect(z.parse(a, date)).toEqual(date);\n  expect(() => z.parse(a, \"date\")).toThrow();\n});\n\ntest(\"z.coerce.string\", () => {\n  const a = z.coerce.string();\n  expect(z.parse(a, 123)).toEqual(\"123\");\n  expect(z.parse(a, true)).toEqual(\"true\");\n  expect(z.parse(a, null)).toEqual(\"null\");\n  expect(z.parse(a, undefined)).toEqual(\"undefined\");\n});\n\ntest(\"z.coerce.number\", () => {\n  const a = z.coerce.number();\n  expect(z.parse(a, \"123\")).toEqual(123);\n  expect(z.parse(a, \"123.45\")).toEqual(123.45);\n  expect(z.parse(a, true)).toEqual(1);\n  expect(z.parse(a, false)).toEqual(0);\n  expect(() => z.parse(a, \"abc\")).toThrow();\n});\n\ntest(\"z.coerce.boolean\", () => {\n  const a = z.coerce.boolean();\n  // test booleans\n  expect(z.parse(a, true)).toEqual(true);\n  expect(z.parse(a, false)).toEqual(false);\n  expect(z.parse(a, \"true\")).toEqual(true);\n  expect(z.parse(a, \"false\")).toEqual(true);\n  expect(z.parse(a, 1)).toEqual(true);\n  expect(z.parse(a, 0)).toEqual(false);\n  expect(z.parse(a, {})).toEqual(true);\n  expect(z.parse(a, [])).toEqual(true);\n  expect(z.parse(a, undefined)).toEqual(false);\n  expect(z.parse(a, null)).toEqual(false);\n  expect(z.parse(a, \"\")).toEqual(false);\n});\n\ntest(\"z.coerce.bigint\", () => {\n  const a = z.coerce.bigint();\n  expect(z.parse(a, \"123\")).toEqual(BigInt(123));\n  expect(z.parse(a, 123)).toEqual(BigInt(123));\n  expect(() => z.parse(a, \"abc\")).toThrow();\n});\n\ntest(\"z.coerce.date\", () => {\n  const a = z.coerce.date();\n  const date = new Date();\n  expect(z.parse(a, date.toISOString())).toEqual(date);\n  expect(z.parse(a, date.getTime())).toEqual(date);\n  expect(() => z.parse(a, \"invalid date\")).toThrow();\n});\n\ntest(\"z.iso.datetime\", () => {\n  const d1 = \"2021-01-01T00:00:00Z\";\n  const d2 = \"2021-01-01T00:00:00.123Z\";\n  const d3 = \"2021-01-01T00:00:00\";\n  const d4 = \"2021-01-01T00:00:00+07:00\";\n  const d5 = \"bad data\";\n\n  // local: false, offset: false, precision: null\n  const a = z.iso.datetime();\n  expect(z.safeParse(a, d1).success).toEqual(true);\n  expect(z.safeParse(a, d2).success).toEqual(true);\n  expect(z.safeParse(a, d3).success).toEqual(false);\n  expect(z.safeParse(a, d4).success).toEqual(false);\n  expect(z.safeParse(a, d5).success).toEqual(false);\n\n  const b = z.iso.datetime({ local: true });\n  expect(z.safeParse(b, d1).success).toEqual(true);\n  expect(z.safeParse(b, d2).success).toEqual(true);\n  expect(z.safeParse(b, d3).success).toEqual(true);\n  expect(z.safeParse(b, d4).success).toEqual(false);\n  expect(z.safeParse(b, d5).success).toEqual(false);\n\n  const c = z.iso.datetime({ offset: true });\n  expect(z.safeParse(c, d1).success).toEqual(true);\n  expect(z.safeParse(c, d2).success).toEqual(true);\n  expect(z.safeParse(c, d3).success).toEqual(false);\n  expect(z.safeParse(c, d4).success).toEqual(true);\n  expect(z.safeParse(c, d5).success).toEqual(false);\n\n  const d = z.iso.datetime({ precision: 3 });\n  expect(z.safeParse(d, d1).success).toEqual(false);\n  expect(z.safeParse(d, d2).success).toEqual(true);\n  expect(z.safeParse(d, d3).success).toEqual(false);\n  expect(z.safeParse(d, d4).success).toEqual(false);\n  expect(z.safeParse(d, d5).success).toEqual(false);\n});\n\ntest(\"z.iso.date\", () => {\n  const d1 = \"2021-01-01\";\n  const d2 = \"bad data\";\n\n  const a = z.iso.date();\n  expect(z.safeParse(a, d1).success).toEqual(true);\n  expect(z.safeParse(a, d2).success).toEqual(false);\n\n  const b = z.string().check(z.iso.date());\n  expect(z.safeParse(b, d1).success).toEqual(true);\n  expect(z.safeParse(b, d2).success).toEqual(false);\n});\n\ntest(\"z.iso.time\", () => {\n  const d1 = \"00:00:00\";\n  const d2 = \"00:00:00.123\";\n  const d3 = \"bad data\";\n\n  const a = z.iso.time();\n  expect(z.safeParse(a, d1).success).toEqual(true);\n  expect(z.safeParse(a, d2).success).toEqual(true);\n  expect(z.safeParse(a, d3).success).toEqual(false);\n\n  const b = z.iso.time({ precision: 3 });\n  expect(z.safeParse(b, d1).success).toEqual(false);\n  expect(z.safeParse(b, d2).success).toEqual(true);\n  expect(z.safeParse(b, d3).success).toEqual(false);\n\n  const c = z.string().check(z.iso.time());\n  expect(z.safeParse(c, d1).success).toEqual(true);\n  expect(z.safeParse(c, d2).success).toEqual(true);\n  expect(z.safeParse(c, d3).success).toEqual(false);\n});\n\ntest(\"z.iso.duration\", () => {\n  const d1 = \"P3Y6M4DT12H30M5S\";\n  const d2 = \"bad data\";\n\n  const a = z.iso.duration();\n  expect(z.safeParse(a, d1).success).toEqual(true);\n  expect(z.safeParse(a, d2).success).toEqual(false);\n\n  const b = z.string().check(z.iso.duration());\n  expect(z.safeParse(b, d1).success).toEqual(true);\n  expect(z.safeParse(b, d2).success).toEqual(false);\n});\n\ntest(\"z.undefined\", () => {\n  const a = z.undefined();\n  expect(z.parse(a, undefined)).toEqual(undefined);\n  expect(() => z.parse(a, \"undefined\")).toThrow();\n});\n\ntest(\"z.null\", () => {\n  const a = z.null();\n  expect(z.parse(a, null)).toEqual(null);\n  expect(() => z.parse(a, \"null\")).toThrow();\n});\n\ntest(\"z.any\", () => {\n  const a = z.any();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, 123)).toEqual(123);\n  expect(z.parse(a, true)).toEqual(true);\n  expect(z.parse(a, null)).toEqual(null);\n  expect(z.parse(a, undefined)).toEqual(undefined);\n  z.parse(a, {});\n  z.parse(a, []);\n  z.parse(a, Symbol());\n  z.parse(a, new Date());\n});\n\ntest(\"z.unknown\", () => {\n  const a = z.unknown();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, 123)).toEqual(123);\n  expect(z.parse(a, true)).toEqual(true);\n  expect(z.parse(a, null)).toEqual(null);\n  expect(z.parse(a, undefined)).toEqual(undefined);\n  z.parse(a, {});\n  z.parse(a, []);\n  z.parse(a, Symbol());\n  z.parse(a, new Date());\n});\n\ntest(\"z.never\", () => {\n  const a = z.never();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n});\n\ntest(\"z.void\", () => {\n  const a = z.void();\n  expect(z.parse(a, undefined)).toEqual(undefined);\n  expect(() => z.parse(a, null)).toThrow();\n});\n\ntest(\"z.array\", () => {\n  const a = z.array(z.string());\n  expect(z.parse(a, [\"hello\", \"world\"])).toEqual([\"hello\", \"world\"]);\n  expect(() => z.parse(a, [123])).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n});\n\ntest(\"z.union\", () => {\n  const a = z.union([z.string(), z.number()]);\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, 123)).toEqual(123);\n  expect(() => z.parse(a, true)).toThrow();\n});\n\ntest(\"z.intersection\", () => {\n  const a = z.intersection(z.object({ a: z.string() }), z.object({ b: z.number() }));\n  expect(z.parse(a, { a: \"hello\", b: 123 })).toEqual({ a: \"hello\", b: 123 });\n  expect(() => z.parse(a, { a: \"hello\" })).toThrow();\n  expect(() => z.parse(a, { b: 123 })).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n});\n\ntest(\"z.tuple\", () => {\n  const a = z.tuple([z.string(), z.number()]);\n  expect(z.parse(a, [\"hello\", 123])).toEqual([\"hello\", 123]);\n  expect(() => z.parse(a, [\"hello\", \"world\"])).toThrow();\n  expect(() => z.parse(a, [123, 456])).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n\n  // tuple with rest\n  const b = z.tuple([z.string(), z.number(), z.optional(z.string())], z.boolean());\n  type b = z.output<typeof b>;\n\n  expectTypeOf<b>().toEqualTypeOf<[string, number, string?, ...boolean[]]>();\n  const datas = [\n    [\"hello\", 123],\n    [\"hello\", 123, \"world\"],\n    [\"hello\", 123, \"world\", true],\n    [\"hello\", 123, \"world\", true, false, true],\n  ];\n  for (const data of datas) {\n    expect(z.parse(b, data)).toEqual(data);\n  }\n\n  expect(() => z.parse(b, [\"hello\", 123, 123])).toThrow();\n  expect(() => z.parse(b, [\"hello\", 123, \"world\", 123])).toThrow();\n\n  // tuple with readonly args\n  const cArgs = [z.string(), z.number(), z.optional(z.string())] as const;\n  const c = z.tuple(cArgs, z.boolean());\n  type c = z.output<typeof c>;\n  expectTypeOf<c>().toEqualTypeOf<[string, number, string?, ...boolean[]]>();\n});\n\ntest(\"z.record\", () => {\n  // record schema with enum keys\n  const a = z.record(z.string(), z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<Record<string, string>>();\n\n  const b = z.record(z.union([z.string(), z.number(), z.symbol()]), z.string());\n  type b = z.output<typeof b>;\n  expectTypeOf<b>().toEqualTypeOf<Record<string | number | symbol, string>>();\n  expect(z.parse(b, { a: \"hello\", 1: \"world\", [Symbol.for(\"asdf\")]: \"symbol\" })).toEqual({\n    a: \"hello\",\n    1: \"world\",\n    [Symbol.for(\"asdf\")]: \"symbol\",\n  });\n\n  // enum keys\n  const c = z.record(z.enum([\"a\", \"b\", \"c\"]), z.string());\n  type c = z.output<typeof c>;\n  expectTypeOf<c>().toEqualTypeOf<Record<\"a\" | \"b\" | \"c\", string>>();\n  expect(z.parse(c, { a: \"hello\", b: \"world\", c: \"world\" })).toEqual({\n    a: \"hello\",\n    b: \"world\",\n    c: \"world\",\n  });\n  // missing keys\n  expect(() => z.parse(c, { a: \"hello\", b: \"world\" })).toThrow();\n  // extra keys\n  expect(() => z.parse(c, { a: \"hello\", b: \"world\", c: \"world\", d: \"world\" })).toThrow();\n});\n\ntest(\"z.map\", () => {\n  const a = z.map(z.string(), z.number());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<Map<string, number>>();\n  expect(z.parse(a, new Map([[\"hello\", 123]]))).toEqual(new Map([[\"hello\", 123]]));\n  expect(() => z.parse(a, new Map([[\"hello\", \"world\"]]))).toThrow();\n  expect(() => z.parse(a, new Map([[1243, \"world\"]]))).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n\n  const r1 = z.safeParse(a, new Map([[123, 123]]));\n  expect(r1.error?.issues[0].code).toEqual(\"invalid_type\");\n  expect(r1.error?.issues[0].path).toEqual([123]);\n\n  const r2: any = z.safeParse(a, new Map([[BigInt(123), 123]]));\n  expect(r2.error!.issues[0].code).toEqual(\"invalid_key\");\n  expect(r2.error!.issues[0].path).toEqual([]);\n\n  const r3: any = z.safeParse(a, new Map([[\"hello\", \"world\"]]));\n  expect(r3.error!.issues[0].code).toEqual(\"invalid_type\");\n  expect(r3.error!.issues[0].path).toEqual([\"hello\"]);\n});\n\ntest(\"z.map invalid_element\", () => {\n  const a = z.map(z.bigint(), z.number());\n  const r1 = z.safeParse(a, new Map([[BigInt(123), BigInt(123)]]));\n\n  expect(r1.error!.issues[0].code).toEqual(\"invalid_element\");\n  expect(r1.error!.issues[0].path).toEqual([]);\n});\n\ntest(\"z.map async\", async () => {\n  const a = z.map(z.string().check(z.refine(async () => true)), z.number().check(z.refine(async () => true)));\n  const d1 = new Map([[\"hello\", 123]]);\n  expect(await z.parseAsync(a, d1)).toEqual(d1);\n\n  await expect(z.parseAsync(a, new Map([[123, 123]]))).rejects.toThrow();\n  await expect(z.parseAsync(a, new Map([[\"hi\", \"world\"]]))).rejects.toThrow();\n  await expect(z.parseAsync(a, new Map([[1243, \"world\"]]))).rejects.toThrow();\n  await expect(z.parseAsync(a, \"hello\")).rejects.toThrow();\n\n  const r = await z.safeParseAsync(a, new Map([[123, 123]]));\n  expect(r.success).toEqual(false);\n  expect(r.error!.issues[0].code).toEqual(\"invalid_type\");\n  expect(r.error!.issues[0].path).toEqual([123]);\n});\n\ntest(\"z.set\", () => {\n  const a = z.set(z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<Set<string>>();\n  expect(z.parse(a, new Set([\"hello\", \"world\"]))).toEqual(new Set([\"hello\", \"world\"]));\n  expect(() => z.parse(a, new Set([123]))).toThrow();\n  expect(() => z.parse(a, [\"hello\", \"world\"])).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n\n  const b = z.set(z.number());\n  expect(z.parse(b, new Set([1, 2, 3]))).toEqual(new Set([1, 2, 3]));\n  expect(() => z.parse(b, new Set([\"hello\"]))).toThrow();\n  expect(() => z.parse(b, [1, 2, 3])).toThrow();\n  expect(() => z.parse(b, 123)).toThrow();\n});\n\ntest(\"z.enum\", () => {\n  const a = z.enum([\"A\", \"B\", \"C\"]);\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<\"A\" | \"B\" | \"C\">();\n  expect(z.parse(a, \"A\")).toEqual(\"A\");\n  expect(z.parse(a, \"B\")).toEqual(\"B\");\n  expect(z.parse(a, \"C\")).toEqual(\"C\");\n  expect(() => z.parse(a, \"D\")).toThrow();\n  expect(() => z.parse(a, 123)).toThrow();\n\n  // expect(a.enum.A).toEqual(\"A\");\n  // expect(a.enum.B).toEqual(\"B\");\n  // expect(a.enum.C).toEqual(\"C\");\n  // expect((a.enum as any).D).toEqual(undefined);\n});\n\ntest(\"z.enum - native\", () => {\n  enum NativeEnum {\n    A = \"A\",\n    B = \"B\",\n    C = \"C\",\n  }\n  const a = z.enum(NativeEnum);\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<NativeEnum>();\n  expect(z.parse(a, NativeEnum.A)).toEqual(NativeEnum.A);\n  expect(z.parse(a, NativeEnum.B)).toEqual(NativeEnum.B);\n  expect(z.parse(a, NativeEnum.C)).toEqual(NativeEnum.C);\n  expect(() => z.parse(a, \"D\")).toThrow();\n  expect(() => z.parse(a, 123)).toThrow();\n\n  // test a.enum\n  a;\n  // expect(a.enum.A).toEqual(NativeEnum.A);\n  // expect(a.enum.B).toEqual(NativeEnum.B);\n  // expect(a.enum.C).toEqual(NativeEnum.C);\n});\n\ntest(\"z.nativeEnum\", () => {\n  enum NativeEnum {\n    A = \"A\",\n    B = \"B\",\n    C = \"C\",\n  }\n  const a = z.nativeEnum(NativeEnum);\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<NativeEnum>();\n  expect(z.parse(a, NativeEnum.A)).toEqual(NativeEnum.A);\n  expect(z.parse(a, NativeEnum.B)).toEqual(NativeEnum.B);\n  expect(z.parse(a, NativeEnum.C)).toEqual(NativeEnum.C);\n  expect(() => z.parse(a, \"D\")).toThrow();\n  expect(() => z.parse(a, 123)).toThrow();\n\n  // test a.enum\n  a;\n  // expect(a.enum.A).toEqual(NativeEnum.A);\n  // expect(a.enum.B).toEqual(NativeEnum.B);\n  // expect(a.enum.C).toEqual(NativeEnum.C);\n});\n\ntest(\"z.literal\", () => {\n  const a = z.literal(\"hello\");\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<\"hello\">();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(() => z.parse(a, \"world\")).toThrow();\n  expect(() => z.parse(a, 123)).toThrow();\n\n  z.literal([\"adf\"] as const);\n});\n\ntest(\"z.file\", () => {\n  const a = z.file();\n  const file = new File([\"content\"], \"filename.txt\", { type: \"text/plain\" });\n  expect(z.parse(a, file)).toEqual(file);\n  expect(() => z.parse(a, \"file\")).toThrow();\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.transform\", () => {\n  const a = z.pipe(\n    z.string(),\n    z.transform((val) => val.toUpperCase())\n  );\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n  expect(z.parse(a, \"hello\")).toEqual(\"HELLO\");\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.transform async\", async () => {\n  const a = z.pipe(\n    z.string(),\n    z.transform(async (val) => val.toUpperCase())\n  );\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n  expect(await z.parseAsync(a, \"hello\")).toEqual(\"HELLO\");\n  await expect(() => z.parseAsync(a, 123)).rejects.toThrow();\n});\n\ntest(\"z.preprocess\", () => {\n  const a = z.pipe(\n    z.transform((val) => String(val).toUpperCase()),\n    z.string()\n  );\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n  expect(z.parse(a, 123)).toEqual(\"123\");\n  expect(z.parse(a, true)).toEqual(\"TRUE\");\n  expect(z.parse(a, BigInt(1234))).toEqual(\"1234\");\n  // expect(() => z.parse(a, Symbol(\"asdf\"))).toThrow();\n});\n\n// test(\"z.preprocess async\", () => {\n//   const a = z.preprocess(async (val) => String(val), z.string());\n//   type a = z.output<typeof a>;\n//   expectTypeOf<a>().toEqualTypeOf<string>();\n//   expect(z.parse(a, 123)).toEqual(\"123\");\n//   expect(z.parse(a, true)).toEqual(\"true\");\n//   expect(() => z.parse(a, {})).toThrow();\n// });\n\ntest(\"z.optional\", () => {\n  const a = z.optional(z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string | undefined>();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, undefined)).toEqual(undefined);\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.nullable\", () => {\n  const a = z.nullable(z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string | null>();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, null)).toEqual(null);\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.default\", () => {\n  const a = z._default(z.string(), \"default\");\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n  expect(z.parse(a, undefined)).toEqual(\"default\");\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(() => z.parse(a, 123)).toThrow();\n\n  const b = z._default(z.string(), () => \"default\");\n  expect(z.parse(b, undefined)).toEqual(\"default\");\n  expect(z.parse(b, \"hello\")).toEqual(\"hello\");\n  expect(() => z.parse(b, 123)).toThrow();\n});\n\ntest(\"z.catch\", () => {\n  const a = z.catch(z.string(), \"default\");\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, 123)).toEqual(\"default\");\n\n  const b = z.catch(z.string(), () => \"default\");\n  expect(z.parse(b, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(b, 123)).toEqual(\"default\");\n\n  const c = z.catch(z.string(), (ctx) => {\n    return `${ctx.error.issues.length}issues`;\n  });\n  expect(z.parse(c, 1234)).toEqual(\"1issues\");\n});\n\ntest(\"z.nan\", () => {\n  const a = z.nan();\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<number>();\n  expect(z.parse(a, Number.NaN)).toEqual(Number.NaN);\n  expect(() => z.parse(a, 123)).toThrow();\n  expect(() => z.parse(a, \"NaN\")).toThrow();\n});\n\ntest(\"z.pipe\", () => {\n  const a = z.pipe(\n    z.pipe(\n      z.string(),\n      z.transform((val) => val.length)\n    ),\n    z.number()\n  );\n  type a_in = z.input<typeof a>;\n  expectTypeOf<a_in>().toEqualTypeOf<string>();\n  type a_out = z.output<typeof a>;\n  expectTypeOf<a_out>().toEqualTypeOf<number>();\n\n  expect(z.parse(a, \"123\")).toEqual(3);\n  expect(z.parse(a, \"hello\")).toEqual(5);\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.readonly\", () => {\n  const a = z.readonly(z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<Readonly<string>>();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.templateLiteral\", () => {\n  const a = z.templateLiteral([z.string(), z.number()]);\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<`${string}${number}`>();\n  expect(z.parse(a, \"hello123\")).toEqual(\"hello123\");\n  expect(() => z.parse(a, \"hello\")).toThrow();\n  expect(() => z.parse(a, 123)).toThrow();\n\n  // multipart\n  const b = z.templateLiteral([z.string(), z.number(), z.string()]);\n  type b = z.output<typeof b>;\n  expectTypeOf<b>().toEqualTypeOf<`${string}${number}${string}`>();\n  expect(z.parse(b, \"hello123world\")).toEqual(\"hello123world\");\n  expect(z.parse(b, \"123\")).toEqual(\"123\");\n  expect(() => z.parse(b, \"hello\")).toThrow();\n  expect(() => z.parse(b, 123)).toThrow();\n\n  // include boolean\n  const c = z.templateLiteral([z.string(), z.boolean()]);\n  type c = z.output<typeof c>;\n  expectTypeOf<c>().toEqualTypeOf<`${string}${boolean}`>();\n  expect(z.parse(c, \"hellotrue\")).toEqual(\"hellotrue\");\n  expect(z.parse(c, \"hellofalse\")).toEqual(\"hellofalse\");\n  expect(() => z.parse(c, \"hello\")).toThrow();\n  expect(() => z.parse(c, 123)).toThrow();\n\n  // include literal prefix\n  const d = z.templateLiteral([z.literal(\"hello\"), z.number()]);\n  type d = z.output<typeof d>;\n  expectTypeOf<d>().toEqualTypeOf<`hello${number}`>();\n  expect(z.parse(d, \"hello123\")).toEqual(\"hello123\");\n  expect(() => z.parse(d, 123)).toThrow();\n  expect(() => z.parse(d, \"world123\")).toThrow();\n\n  // include literal union\n  const e = z.templateLiteral([z.literal([\"aa\", \"bb\"]), z.number()]);\n  type e = z.output<typeof e>;\n  expectTypeOf<e>().toEqualTypeOf<`aa${number}` | `bb${number}`>();\n  expect(z.parse(e, \"aa123\")).toEqual(\"aa123\");\n  expect(z.parse(e, \"bb123\")).toEqual(\"bb123\");\n  expect(() => z.parse(e, \"cc123\")).toThrow();\n  expect(() => z.parse(e, 123)).toThrow();\n});\n\n// this returns both a schema and a check\ntest(\"z.custom\", () => {\n  const a = z.custom((val) => {\n    return typeof val === \"string\";\n  });\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(() => z.parse(a, 123)).toThrow();\n\n  const b = z.string().check(z.custom((val) => val.length > 3));\n\n  expect(z.parse(b, \"hello\")).toEqual(\"hello\");\n  expect(() => z.parse(b, \"hi\")).toThrow();\n});\n\ntest(\"z.check\", () => {\n  // this is a more flexible version of z.custom that accepts an arbitrary _parse logic\n  // the function should return core.$ZodResult\n  const a = z.any().check(\n    z.check<string>((ctx) => {\n      if (typeof ctx.value === \"string\") return;\n      ctx.issues.push({\n        code: \"custom\",\n        origin: \"custom\",\n        message: \"Expected a string\",\n        input: ctx.value,\n      });\n    })\n  );\n  expect(z.safeParse(a, \"hello\")).toMatchObject({\n    success: true,\n    data: \"hello\",\n  });\n  expect(z.safeParse(a, 123)).toMatchObject({\n    success: false,\n    error: { issues: [{ code: \"custom\", message: \"Expected a string\" }] },\n  });\n});\n\ntest(\"z.instanceof\", () => {\n  class A {}\n\n  const a = z.instanceof(A);\n  expect(z.parse(a, new A())).toBeInstanceOf(A);\n  expect(() => z.parse(a, {})).toThrow();\n});\n\ntest(\"z.refine\", () => {\n  const a = z.number().check(\n    z.refine((val) => val > 3),\n    z.refine((val) => val < 10)\n  );\n  expect(z.parse(a, 5)).toEqual(5);\n  expect(() => z.parse(a, 2)).toThrow();\n  expect(() => z.parse(a, 11)).toThrow();\n  expect(() => z.parse(a, \"hi\")).toThrow();\n});\n\n// test(\"z.superRefine\", () => {\n//   const a = z.number([\n//     z.superRefine((val, ctx) => {\n//       if (val < 3) {\n//         return ctx.addIssue({\n//           code: \"custom\",\n//           origin: \"custom\",\n//           message: \"Too small\",\n//           input: val,\n//         });\n//       }\n//       if (val > 10) {\n//         return ctx.addIssue(\"Too big\");\n//       }\n//     }),\n//   ]);\n\n//   expect(z.parse(a, 5)).toEqual(5);\n//   expect(() => z.parse(a, 2)).toThrow();\n//   expect(() => z.parse(a, 11)).toThrow();\n//   expect(() => z.parse(a, \"hi\")).toThrow();\n// });\n\ntest(\"z.transform\", () => {\n  const a = z.transform((val: number) => {\n    return `${val}`;\n  });\n  type a_in = z.input<typeof a>;\n  expectTypeOf<a_in>().toEqualTypeOf<number>();\n  type a_out = z.output<typeof a>;\n  expectTypeOf<a_out>().toEqualTypeOf<string>();\n  expect(z.parse(a, 123)).toEqual(\"123\");\n});\n\ntest(\"z.$brand()\", () => {\n  const a = z.string().brand<\"my-brand\">();\n  type a = z.output<typeof a>;\n  const branded = (_: a) => {};\n  // @ts-expect-error\n  branded(\"asdf\");\n});\n\ntest(\"z.lazy\", () => {\n  const a = z.lazy(() => z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\n// schema that validates JSON-like data\ntest(\"z.json\", () => {\n  const a = z.json();\n  type a = z.output<typeof a>;\n  a._zod.output;\n\n  expectTypeOf<a>().toEqualTypeOf<util.JSONType>();\n\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, 123)).toEqual(123);\n  expect(z.parse(a, true)).toEqual(true);\n  expect(z.parse(a, null)).toEqual(null);\n  expect(z.parse(a, {})).toEqual({});\n  expect(z.parse(a, { a: \"hello\" })).toEqual({ a: \"hello\" });\n  expect(z.parse(a, [1, 2, 3])).toEqual([1, 2, 3]);\n  expect(z.parse(a, [{ a: \"hello\" }])).toEqual([{ a: \"hello\" }]);\n\n  // fail cases\n  expect(() => z.parse(a, new Date())).toThrow();\n  expect(() => z.parse(a, Symbol())).toThrow();\n  expect(() => z.parse(a, { a: new Date() })).toThrow();\n  expect(() => z.parse(a, undefined)).toThrow();\n  expect(() => z.parse(a, { a: undefined })).toThrow();\n});\n\ntest(\"z.stringbool\", () => {\n  const a = z.stringbool();\n\n  expect(z.parse(a, \"true\")).toEqual(true);\n  expect(z.parse(a, \"yes\")).toEqual(true);\n  expect(z.parse(a, \"1\")).toEqual(true);\n  expect(z.parse(a, \"on\")).toEqual(true);\n  expect(z.parse(a, \"y\")).toEqual(true);\n  expect(z.parse(a, \"enabled\")).toEqual(true);\n  expect(z.parse(a, \"TRUE\")).toEqual(true);\n\n  expect(z.parse(a, \"false\")).toEqual(false);\n  expect(z.parse(a, \"no\")).toEqual(false);\n  expect(z.parse(a, \"0\")).toEqual(false);\n  expect(z.parse(a, \"off\")).toEqual(false);\n  expect(z.parse(a, \"n\")).toEqual(false);\n  expect(z.parse(a, \"disabled\")).toEqual(false);\n  expect(z.parse(a, \"FALSE\")).toEqual(false);\n\n  expect(z.safeParse(a, \"other\")).toMatchObject({ success: false });\n  expect(z.safeParse(a, \"\")).toMatchObject({ success: false });\n  expect(z.safeParse(a, undefined)).toMatchObject({ success: false });\n  expect(z.safeParse(a, {})).toMatchObject({ success: false });\n  expect(z.safeParse(a, true)).toMatchObject({ success: false });\n  expect(z.safeParse(a, false)).toMatchObject({ success: false });\n\n  const b = z.stringbool({\n    truthy: [\"y\"],\n    falsy: [\"n\"],\n  });\n  expect(z.parse(b, \"y\")).toEqual(true);\n  expect(z.parse(b, \"n\")).toEqual(false);\n  expect(z.safeParse(b, \"true\")).toMatchObject({ success: false });\n  expect(z.safeParse(b, \"false\")).toMatchObject({ success: false });\n\n  const c = z.stringbool({\n    case: \"sensitive\",\n  });\n  expect(z.parse(c, \"true\")).toEqual(true);\n  expect(z.safeParse(c, \"TRUE\")).toMatchObject({ success: false });\n});\n\n// promise\ntest(\"z.promise\", async () => {\n  const a = z.promise(z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n\n  expect(await z.safeParseAsync(a, Promise.resolve(\"hello\"))).toMatchObject({\n    success: true,\n    data: \"hello\",\n  });\n  expect(await z.safeParseAsync(a, Promise.resolve(123))).toMatchObject({\n    success: false,\n  });\n\n  const b = z.string();\n  expect(() => z.parse(b, Promise.resolve(\"hello\"))).toThrow();\n});\n\n// test(\"type assertions\", () => {\n//   const schema = z.pipe(\n//     z.string(),\n//     z.transform((val) => val.length)\n//   );\n//   schema.assertInput<string>();\n//   // @ts-expect-error\n//   schema.assertInput<number>();\n\n//   schema.assertOutput<number>();\n//   // @ts-expect-error\n//   schema.assertOutput<string>();\n// });\n\ntest(\"z.pipe type enforcement\", () => {\n  z.pipe(\n    z.pipe(\n      z.string().check(z.regex(/asdf/)),\n      z.transform((v) => new Date(v))\n    ),\n    z.date().check(z.maximum(new Date()))\n  );\n});\n\ntest(\"def typing\", () => {\n  z.string().def.type satisfies \"string\";\n  z.email().def.format satisfies \"email\";\n  z.number().def.type satisfies \"number\";\n  z.float64().def.format satisfies z.core.$ZodNumberFormats;\n  z.bigint().def.type satisfies \"bigint\";\n  z.boolean().def.type satisfies \"boolean\";\n  z.date().def.type satisfies \"date\";\n  z.symbol().def.type satisfies \"symbol\";\n  z.undefined().def.type satisfies \"undefined\";\n  z.nullable(z.string()).def.type satisfies \"nullable\";\n  z.null().def.type satisfies \"null\";\n  z.any().def.type satisfies \"any\";\n  z.unknown().def.type satisfies \"unknown\";\n  z.never().def.type satisfies \"never\";\n  z.void().def.type satisfies \"void\";\n  z.array(z.string()).def.type satisfies \"array\";\n  z.object({ key: z.string() }).def.type satisfies \"object\";\n  z.union([z.string(), z.number()]).def.type satisfies \"union\";\n  z.intersection(z.string(), z.number()).def.type satisfies \"intersection\";\n  z.tuple([z.string(), z.number()]).def.type satisfies \"tuple\";\n  z.record(z.string(), z.number()).def.type satisfies \"record\";\n  z.map(z.string(), z.number()).def.type satisfies \"map\";\n  z.set(z.string()).def.type satisfies \"set\";\n  z.literal(\"example\").def.type satisfies \"literal\";\n  expectTypeOf(z.literal(\"example\").def.values).toEqualTypeOf<\"example\"[]>();\n  z.enum([\"a\", \"b\", \"c\"]).def.type satisfies \"enum\";\n  z.promise(z.string()).def.type satisfies \"promise\";\n  z.lazy(() => z.string()).def.type satisfies \"lazy\";\n  z.optional(z.string()).def.type satisfies \"optional\";\n  z._default(z.string(), \"default\").def.type satisfies \"default\";\n  z.templateLiteral([z.literal(\"a\"), z.literal(\"b\")]).def.type satisfies \"template_literal\";\n  z.custom<string>((val) => typeof val === \"string\").def.type satisfies \"custom\";\n  z.transform((val) => val as string).def.type satisfies \"transform\";\n  z.nonoptional(z.string()).def.type satisfies \"nonoptional\";\n  z.readonly(z.unknown()).def.type satisfies \"readonly\";\n  z.nan().def.type satisfies \"nan\";\n  z.pipe(z.unknown(), z.number()).def.type satisfies \"pipe\";\n  z.success(z.string()).def.type satisfies \"success\";\n  z.catch(z.string(), \"fallback\").def.type satisfies \"catch\";\n  z.file().def.type satisfies \"file\";\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/mini/tests/index.test.ts",
        "start": 1,
        "end": 871,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 871,
          "column": 2,
          "position": 12625
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/index.test.ts",
        "start": 1,
        "end": 871,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 871,
          "column": 2,
          "position": 12625
        }
      }
    },
    {
      "format": "typescript",
      "lines": 43,
      "fragment": "import { expect, test } from \"vitest\";\n// import * as z from \"zod/v4/core\";\n\ntest(\"z.function\", () => {\n  expect(true).toEqual(true);\n});\n\n// test(\"z.function\", () => {\n//   const a = z.function({\n//     args: z.tuple([z.string()]),\n//     returns: z.string(),\n//   });\n\n//   const myFunc = a.implement((name: string | number) => `Hello, ${name}!`);\n\n//   expect(myFunc(\"world\")).toEqual(\"Hello, world!\");\n//   expect(() => myFunc(123 as any)).toThrow();\n\n//   // this won't run\n//   () => {\n//     // @ts-expect-error\n//     const r = myFunc(123);\n//     expectTypeOf(r).toEqualTypeOf<string>();\n//   };\n// });\n\n// test(\"z.function async\", async () => {\n//   const b = z.function({\n//     args: z.tuple([z.string()]).$check(async (_) => {}),\n//     returns: z.string().$check(async (_) => {}),\n//   });\n//   const myFuncAsync = b.implementAsync(async (name) => `Hello, ${name}!`);\n\n//   expect(await myFuncAsync(\"world\")).toEqual(\"Hello, world!\");\n//   expect(myFuncAsync(123 as any)).rejects.toThrow();\n\n//   // this won't run\n//   () => {\n//     // @ts-expect-error\n//     const r = myFuncAsync(123);\n//     expectTypeOf(r).toEqualTypeOf<Promise<string>>();\n//   };\n// });",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/mini/tests/functions.test.ts",
        "start": 1,
        "end": 43,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 43,
          "column": 7,
          "position": 112
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/functions.test.ts",
        "start": 1,
        "end": 43,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 43,
          "column": 7,
          "position": 112
        }
      }
    },
    {
      "format": "typescript",
      "lines": 22,
      "fragment": "import { expect, test } from \"vitest\";\nimport * as z from \"zod/v4-mini\";\n\ntest(\"no locale by default\", () => {\n  const result = z.safeParse(z.string(), 12);\n  expect(result.success).toEqual(false);\n  expect(result.error!.issues.length).toEqual(1);\n  expect(result.error!.issues[0].message).toEqual(\"Invalid input\");\n});\n\ntest(\"error inheritance\", () => {\n  const e1 = z.string().safeParse(123).error!;\n  expect(e1).toBeInstanceOf(z.core.$ZodError);\n  // expect(e1).not.toBeInstanceOf(Error);\n\n  try {\n    z.string().parse(123);\n  } catch (e2) {\n    expect(e2).toBeInstanceOf(z.core.$ZodRealError);\n    expect(e2).toBeInstanceOf(Error);\n  }\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/mini/tests/error.test.ts",
        "start": 1,
        "end": 22,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 22,
          "column": 2,
          "position": 240
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/error.test.ts",
        "start": 1,
        "end": 22,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 22,
          "column": 2,
          "position": 240
        }
      }
    },
    {
      "format": "typescript",
      "lines": 36,
      "fragment": "import { expect, test } from \"vitest\";\nimport * as z from \"zod/v4-mini\";\nimport { util as zc } from \"zod/v4/core\";\n\ntest(\"min/max\", () => {\n  const a = z.number().check(z.minimum(5), z.minimum(6), z.minimum(7), z.maximum(10), z.maximum(11), z.maximum(12));\n\n  expect(a._zod.bag.minimum).toEqual(7);\n  expect(a._zod.bag.maximum).toEqual(10);\n});\n\ntest(\"multipleOf\", () => {\n  const b = z.number().check(z.multipleOf(5));\n  expect(b._zod.bag.multipleOf).toEqual(5);\n});\n\ntest(\"int64 format\", () => {\n  const c = z.int64();\n  expect(c._zod.bag.format).toEqual(\"int64\");\n  expect(c._zod.bag.minimum).toEqual(zc.BIGINT_FORMAT_RANGES.int64[0]);\n  expect(c._zod.bag.maximum).toEqual(zc.BIGINT_FORMAT_RANGES.int64[1]);\n});\n\ntest(\"int32 format\", () => {\n  const d = z.int32();\n  expect(d._zod.bag.format).toEqual(\"int32\");\n  expect(d._zod.bag.minimum).toEqual(zc.NUMBER_FORMAT_RANGES.int32[0]);\n  expect(d._zod.bag.maximum).toEqual(zc.NUMBER_FORMAT_RANGES.int32[1]);\n});\n\ntest(\"array size\", () => {\n  const e = z.array(z.string()).check(z.length(5));\n  expect(e._zod.bag.length).toEqual(5);\n  expect(e._zod.bag.minimum).toEqual(5);\n  expect(e._zod.bag.maximum).toEqual(5);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/mini/tests/computed.test.ts",
        "start": 1,
        "end": 36,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 36,
          "column": 2,
          "position": 519
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/computed.test.ts",
        "start": 1,
        "end": 36,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 36,
          "column": 2,
          "position": 519
        }
      }
    },
    {
      "format": "typescript",
      "lines": 144,
      "fragment": "import { expect, test } from \"vitest\";\nimport * as z from \"../index.js\";\n\n// lt;\ntest(\"z.lt\", () => {\n  const a = z.number().check(z.lt(10));\n  expect(z.safeParse(a, 9).success).toEqual(true);\n  expect(z.safeParse(a, 9).data).toEqual(9);\n  expect(z.safeParse(a, 10).success).toEqual(false);\n});\n\n// lte;\ntest(\"z.lte\", () => {\n  const a = z.number().check(z.lte(10));\n  expect(z.safeParse(a, 10).success).toEqual(true);\n  expect(z.safeParse(a, 10).data).toEqual(10);\n  expect(z.safeParse(a, 11).success).toEqual(false);\n});\n\n// min;\ntest(\"z.max\", () => {\n  const a = z.number().check(z.maximum(10));\n  expect(z.safeParse(a, 10).success).toEqual(true);\n  expect(z.safeParse(a, 10).data).toEqual(10);\n  expect(z.safeParse(a, 11).success).toEqual(false);\n});\n\n// gt;\ntest(\"z.gt\", () => {\n  const a = z.number().check(z.gt(10));\n  expect(z.safeParse(a, 11).success).toEqual(true);\n  expect(z.safeParse(a, 11).data).toEqual(11);\n  expect(z.safeParse(a, 10).success).toEqual(false);\n});\n\n// gte;\ntest(\"z.gte\", () => {\n  const a = z.number().check(z.gte(10));\n  expect(z.safeParse(a, 10).success).toEqual(true);\n  expect(z.safeParse(a, 10).data).toEqual(10);\n  expect(z.safeParse(a, 9).success).toEqual(false);\n});\n\n// min;\ntest(\"z.min\", () => {\n  const a = z.number().check(z.minimum(10));\n  expect(z.safeParse(a, 10).success).toEqual(true);\n  expect(z.safeParse(a, 10).data).toEqual(10);\n  expect(z.safeParse(a, 9).success).toEqual(false);\n});\n\n// maxSize;\ntest(\"z.maxLength\", () => {\n  const a = z.array(z.string()).check(z.maxLength(3));\n  expect(z.safeParse(a, [\"a\", \"b\", \"c\"]).success).toEqual(true);\n  expect(z.safeParse(a, [\"a\", \"b\", \"c\", \"d\"]).success).toEqual(false);\n});\n\n// minSize;\ntest(\"z.minLength\", () => {\n  const a = z.array(z.string()).check(z.minLength(3));\n  expect(z.safeParse(a, [\"a\", \"b\"]).success).toEqual(false);\n  expect(z.safeParse(a, [\"a\", \"b\", \"c\"]).success).toEqual(true);\n});\n\n// size;\ntest(\"z.length\", () => {\n  const a = z.array(z.string()).check(z.length(3));\n  expect(z.safeParse(a, [\"a\", \"b\"]).success).toEqual(false);\n  expect(z.safeParse(a, [\"a\", \"b\", \"c\"]).success).toEqual(true);\n  expect(z.safeParse(a, [\"a\", \"b\", \"c\", \"d\"]).success).toEqual(false);\n});\n\n// regex;\ntest(\"z.regex\", () => {\n  const a = z.string().check(z.regex(/^aaa$/));\n  expect(z.safeParse(a, \"aaa\")).toMatchObject({ success: true, data: \"aaa\" });\n  expect(z.safeParse(a, \"aa\")).toMatchObject({ success: false });\n});\n\n// includes;\ntest(\"z.includes\", () => {\n  const a = z.string().check(z.includes(\"asdf\"));\n  z.parse(a, \"qqqasdfqqq\");\n  z.parse(a, \"asdf\");\n  z.parse(a, \"qqqasdf\");\n  z.parse(a, \"asdfqqq\");\n  expect(z.safeParse(a, \"qqq\")).toMatchObject({ success: false });\n});\n\n// startsWith;\ntest(\"z.startsWith\", () => {\n  const a = z.string().check(z.startsWith(\"asdf\"));\n  z.parse(a, \"asdf\");\n  z.parse(a, \"asdfqqq\");\n  expect(z.safeParse(a, \"qqq\")).toMatchObject({ success: false });\n});\n\n// endsWith;\ntest(\"z.endsWith\", () => {\n  const a = z.string().check(z.endsWith(\"asdf\"));\n  z.parse(a, \"asdf\");\n  z.parse(a, \"qqqasdf\");\n  expect(z.safeParse(a, \"asdfqqq\")).toMatchObject({ success: false });\n});\n\n// lowercase;\ntest(\"z.lowercase\", () => {\n  const a = z.string().check(z.lowercase());\n  z.parse(a, \"asdf\");\n  expect(z.safeParse(a, \"ASDF\")).toMatchObject({ success: false });\n});\n\n// uppercase;\ntest(\"z.uppercase\", () => {\n  const a = z.string().check(z.uppercase());\n  z.parse(a, \"ASDF\");\n  expect(z.safeParse(a, \"asdf\")).toMatchObject({ success: false });\n});\n\n// filename;\n// fileType;\n// overwrite;\ntest(\"z.overwrite\", () => {\n  const a = z.string().check(z.overwrite((val) => val.toUpperCase()));\n  expect(z.safeParse(a, \"asdf\")).toMatchObject({ data: \"ASDF\" });\n});\n\n// normalize;\n// trim;\n// toLowerCase;\n// toUpperCase;\n// property\n\ntest(\"abort early\", () => {\n  const schema = z.string().check(\n    z.refine((val) => val.length > 1),\n    z.refine((val) => val.length > 2, { abort: true }),\n    z.refine((val) => val.length > 3)\n  );\n  const data = \"\";\n  const result = z.safeParse(schema, data);\n  expect(result.error!.issues.length).toEqual(2);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/mini/tests/checks.test.ts",
        "start": 1,
        "end": 144,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 144,
          "column": 2,
          "position": 1857
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/checks.test.ts",
        "start": 1,
        "end": 144,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 144,
          "column": 2,
          "position": 1857
        }
      }
    },
    {
      "format": "typescript",
      "lines": 51,
      "fragment": "import { expectTypeOf, test } from \"vitest\";\nimport * as z from \"../index.js\";\n\ntest(\"branded types\", () => {\n  const mySchema = z\n    .object({\n      name: z.string(),\n    })\n    .brand<\"superschema\">();\n\n  // simple branding\n  type MySchema = z.infer<typeof mySchema>;\n  // Using true for type equality assertion\n  expectTypeOf<MySchema>().toEqualTypeOf<{ name: string } & z.$brand<\"superschema\">>();\n\n  const doStuff = (arg: MySchema) => arg;\n  doStuff(z.parse(mySchema, { name: \"hello there\" }));\n\n  // inheritance\n  const extendedSchema = mySchema.brand<\"subschema\">();\n  type ExtendedSchema = z.infer<typeof extendedSchema>;\n  expectTypeOf<ExtendedSchema>().toEqualTypeOf<{ name: string } & z.$brand<\"superschema\"> & z.$brand<\"subschema\">>();\n\n  doStuff(z.parse(extendedSchema, { name: \"hello again\" }));\n\n  // number branding\n  const numberSchema = z.number().brand<42>();\n  type NumberSchema = z.infer<typeof numberSchema>;\n  expectTypeOf<NumberSchema>().toEqualTypeOf<number & { [z.$brand]: { 42: true } }>();\n\n  // symbol branding\n  const MyBrand: unique symbol = Symbol(\"hello\");\n  type MyBrand = typeof MyBrand;\n  const symbolBrand = z.number().brand<\"sup\">().brand<typeof MyBrand>();\n  type SymbolBrand = z.infer<typeof symbolBrand>;\n  // number & { [z.$brand]: { sup: true, [MyBrand]: true } }\n  expectTypeOf<SymbolBrand>().toEqualTypeOf<number & z.$brand<\"sup\"> & z.$brand<MyBrand>>();\n\n  // keeping brands out of input types\n  const age = z.number().brand<\"age\">();\n  type Age1 = z.infer<typeof age>;\n  type AgeInput1 = z.input<typeof age>;\n\n  // Using not for type inequality assertion\n  expectTypeOf<AgeInput1>().not.toEqualTypeOf<Age1>();\n  expectTypeOf<number>().toEqualTypeOf<AgeInput1>();\n  expectTypeOf<number & z.$brand<\"age\">>().toEqualTypeOf<Age1>();\n\n  // @ts-expect-error\n  doStuff({ name: \"hello there!\" });\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/mini/tests/brand.test.ts",
        "start": 1,
        "end": 51,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 51,
          "column": 2,
          "position": 618
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/brand.test.ts",
        "start": 1,
        "end": 51,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 51,
          "column": 2,
          "position": 618
        }
      }
    },
    {
      "format": "typescript",
      "lines": 129,
      "fragment": "import { test } from \"vitest\";\n\nimport * as z from \"zod/v4-mini\";\n\ntest(\"assignability\", () => {\n  // $ZodString\n  z.string() satisfies z.core.$ZodString;\n\n  // $ZodNumber\n  z.number() satisfies z.core.$ZodNumber;\n\n  // $ZodBigInt\n  z.bigint() satisfies z.core.$ZodBigInt;\n\n  // $ZodBoolean\n  z.boolean() satisfies z.core.$ZodBoolean;\n\n  // $ZodDate\n  z.date() satisfies z.core.$ZodDate;\n\n  // $ZodSymbol\n  z.symbol() satisfies z.core.$ZodSymbol;\n\n  // $ZodUndefined\n  z.undefined() satisfies z.core.$ZodUndefined;\n\n  // $ZodNullable\n  z.nullable(z.string()) satisfies z.core.$ZodNullable;\n\n  // $ZodNull\n  z.null() satisfies z.core.$ZodNull;\n\n  // $ZodAny\n  z.any() satisfies z.core.$ZodAny;\n\n  // $ZodUnknown\n  z.unknown() satisfies z.core.$ZodUnknown;\n\n  // $ZodNever\n  z.never() satisfies z.core.$ZodNever;\n\n  // $ZodVoid\n  z.void() satisfies z.core.$ZodVoid;\n\n  // $ZodArray\n  z.array(z.string()) satisfies z.core.$ZodArray;\n\n  // $ZodObject\n  z.object({ key: z.string() }) satisfies z.core.$ZodObject;\n\n  // $ZodUnion\n  z.union([z.string(), z.number()]) satisfies z.core.$ZodUnion;\n\n  // $ZodIntersection\n  z.intersection(z.string(), z.number()) satisfies z.core.$ZodIntersection;\n\n  // $ZodTuple\n  z.tuple([z.string(), z.number()]) satisfies z.core.$ZodTuple;\n\n  // $ZodRecord\n  z.record(z.string(), z.number()) satisfies z.core.$ZodRecord;\n\n  // $ZodMap\n  z.map(z.string(), z.number()) satisfies z.core.$ZodMap;\n\n  // $ZodSet\n  z.set(z.string()) satisfies z.core.$ZodSet;\n\n  // $ZodLiteral\n  z.literal(\"example\") satisfies z.core.$ZodLiteral;\n\n  // $ZodEnum\n  z.enum([\"a\", \"b\", \"c\"]) satisfies z.core.$ZodEnum;\n\n  // $ZodPromise\n  z.promise(z.string()) satisfies z.core.$ZodPromise;\n\n  // $ZodLazy\n  const lazySchema = z.lazy(() => z.string());\n  lazySchema satisfies z.core.$ZodLazy;\n\n  // $ZodOptional\n  z.optional(z.string()) satisfies z.core.$ZodOptional;\n\n  // $ZodDefault\n  z._default(z.string(), \"default\") satisfies z.core.$ZodDefault;\n\n  // $ZodTemplateLiteral\n  z.templateLiteral([z.literal(\"a\"), z.literal(\"b\")]) satisfies z.core.$ZodTemplateLiteral;\n\n  // $ZodCustom\n  z.custom<string>((val) => typeof val === \"string\") satisfies z.core.$ZodCustom;\n\n  // $ZodTransform\n  z.transform((val) => val as string) satisfies z.core.$ZodTransform;\n\n  // $ZodNonOptional\n  z.nonoptional(z.optional(z.string())) satisfies z.core.$ZodNonOptional;\n\n  // $ZodReadonly\n  z.readonly(z.object({ key: z.string() })) satisfies z.core.$ZodReadonly;\n\n  // $ZodNaN\n  z.nan() satisfies z.core.$ZodNaN;\n\n  // $ZodPipe\n  z.pipe(z.unknown(), z.number()) satisfies z.core.$ZodPipe;\n\n  // $ZodSuccess\n  z.success(z.string()) satisfies z.core.$ZodSuccess;\n\n  // $ZodCatch\n  z.catch(z.string(), \"fallback\") satisfies z.core.$ZodCatch;\n\n  // $ZodFile\n  z.file() satisfies z.core.$ZodFile;\n});\n\ntest(\"assignability with type narrowing\", () => {\n  type _RefinedSchema<T extends z.ZodMiniType<object> | z.ZodMiniUnion> = T extends z.ZodMiniUnion\n    ? RefinedUnionSchema<T> // <-- Type instantiation is excessively deep and possibly infinite.\n    : T extends z.ZodMiniType<object>\n      ? RefinedTypeSchema<z.output<T>> // <-- Type instantiation is excessively deep and possibly infinite.\n      : never;\n\n  type RefinedTypeSchema<T extends object> = T;\n\n  type RefinedUnionSchema<T extends z.ZodMiniUnion> = T;\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/mini/tests/assignability.test.ts",
        "start": 1,
        "end": 129,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 129,
          "column": 2,
          "position": 1147
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/tests/assignability.test.ts",
        "start": 1,
        "end": 129,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 129,
          "column": 2,
          "position": 1147
        }
      }
    },
    {
      "format": "typescript",
      "lines": 46,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v3\";\n\ntest(\"test\", () => {\n  expect(true).toBe(true);\n});\n\ntest(\"test2\", () => {\n  expect(() => z.string().parse(234)).toThrowErrorMatchingInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"invalid_type\",\n        \"expected\": \"string\",\n        \"received\": \"number\",\n        \"path\": [],\n        \"message\": \"Expected string, received number\"\n      }\n    ]]\n  `);\n});\n\ntest(\"async validation\", async () => {\n  const testTuple = z\n    .tuple([z.string().refine(async () => true), z.number().refine(async () => true)])\n    .refine(async () => true);\n  expectTypeOf<typeof testTuple._output>().toEqualTypeOf<[string, number]>();\n\n  const val = await testTuple.parseAsync([\"asdf\", 1234]);\n  expect(val).toEqual(val);\n\n  const r1 = await testTuple.safeParseAsync([\"asdf\", \"asdf\"]);\n  expect(r1.success).toEqual(false);\n  expect(r1.error!).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"invalid_type\",\n        \"expected\": \"number\",\n        \"received\": \"string\",\n        \"path\": [\n          1\n        ],\n        \"message\": \"Expected number, received string\"\n      }\n    ]]\n  `);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/core/tests/index.test.ts",
        "start": 1,
        "end": 46,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 46,
          "column": 2,
          "position": 301
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/tests/index.test.ts",
        "start": 1,
        "end": 46,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 46,
          "column": 2,
          "position": 301
        }
      }
    },
    {
      "format": "typescript",
      "lines": 12,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\ntest(\"void\", () => {\n  const v = z.void();\n  v.parse(undefined);\n\n  expect(() => v.parse(null)).toThrow();\n  expect(() => v.parse(\"\")).toThrow();\n\n  type v = z.infer<typeof v>;\n  expectTypeOf<v>().toEqualTypeOf<void>();\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/void.test.ts",
        "start": 1,
        "end": 12,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 12,
          "column": 2,
          "position": 146
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/void.test.ts",
        "start": 1,
        "end": 12,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 12,
          "column": 2,
          "position": 146
        }
      }
    },
    {
      "format": "typescript",
      "lines": 283,
      "fragment": "import { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\ntest(\"string length\", async () => {\n  try {\n    await z.string().length(4).parseAsync(\"asd\");\n  } catch (err) {\n    // (\"String must contain exactly 4 character(s)\");\n    expect((err as z.ZodError).issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"too_small\",\n          \"exact\": true,\n          \"inclusive\": true,\n          \"message\": \"Too small: expected string to have >=4 characters\",\n          \"minimum\": 4,\n          \"origin\": \"string\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n\n  try {\n    await z.string().length(4).parseAsync(\"asdaa\");\n  } catch (err) {\n    // (\"String must contain exactly 4 character(s)\");\n    expect((err as z.ZodError).issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"too_big\",\n          \"exact\": true,\n          \"inclusive\": true,\n          \"maximum\": 4,\n          \"message\": \"Too big: expected string to have <=4 characters\",\n          \"origin\": \"string\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"string min/max\", async () => {\n  try {\n    await z.string().min(4).parseAsync(\"asd\");\n  } catch (err) {\n    // (\"String must contain at least 4 character(s)\");\n    expect((err as z.ZodError).issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"too_small\",\n          \"inclusive\": true,\n          \"message\": \"Too small: expected string to have >=4 characters\",\n          \"minimum\": 4,\n          \"origin\": \"string\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"string max\", async () => {\n  try {\n    await z.string().max(4).parseAsync(\"aasdfsdfsd\");\n  } catch (err) {\n    // (\"String must contain at most 4 character(s)\");\n    expect((err as z.ZodError).issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"too_big\",\n          \"inclusive\": true,\n          \"maximum\": 4,\n          \"message\": \"Too big: expected string to have <=4 characters\",\n          \"origin\": \"string\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"number min\", async () => {\n  try {\n    await z.number().min(3).parseAsync(2);\n  } catch (err) {\n    // (\"Number must be greater than or equal to 3\");\n    expect((err as z.ZodError).issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"too_small\",\n          \"inclusive\": true,\n          \"message\": \"Too small: expected number to be >=3\",\n          \"minimum\": 3,\n          \"origin\": \"number\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"number gte\", async () => {\n  try {\n    await z.number().gte(3).parseAsync(2);\n  } catch (err) {\n    // (\"Number must be greater than or equal to 3\");\n    expect((err as z.ZodError).issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"too_small\",\n          \"inclusive\": true,\n          \"message\": \"Too small: expected number to be >=3\",\n          \"minimum\": 3,\n          \"origin\": \"number\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"number gt\", async () => {\n  try {\n    await z.number().gt(3).parseAsync(3);\n  } catch (err) {\n    // (\"Number must be greater than or equal to 3\");\n    expect((err as z.ZodError).issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"too_small\",\n          \"inclusive\": false,\n          \"message\": \"Too small: expected number to be >3\",\n          \"minimum\": 3,\n          \"origin\": \"number\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"number max\", async () => {\n  try {\n    await z.number().max(3).parseAsync(4);\n  } catch (err) {\n    // (\"Number must be less than or equal to 3\");\n    expect((err as z.ZodError).issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"too_big\",\n          \"inclusive\": true,\n          \"maximum\": 3,\n          \"message\": \"Too big: expected number to be <=3\",\n          \"origin\": \"number\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"number lte\", async () => {\n  try {\n    await z.number().lte(3).parseAsync(4);\n  } catch (err) {\n    // (\"Number must be less than or equal to 3\");\n    expect((err as z.ZodError).issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"too_big\",\n          \"inclusive\": true,\n          \"maximum\": 3,\n          \"message\": \"Too big: expected number to be <=3\",\n          \"origin\": \"number\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"number lt\", async () => {\n  try {\n    await z.number().lt(3).parseAsync(3);\n  } catch (err) {\n    // (\"Number must be less than or equal to 3\");\n    expect((err as z.ZodError).issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"too_big\",\n          \"inclusive\": false,\n          \"maximum\": 3,\n          \"message\": \"Too big: expected number to be <3\",\n          \"origin\": \"number\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"number nonnegative\", async () => {\n  try {\n    await z.number().nonnegative().parseAsync(-1);\n  } catch (err) {\n    // (\"Number must be greater than or equal to 0\");\n    expect((err as z.ZodError).issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"too_small\",\n          \"inclusive\": true,\n          \"message\": \"Too small: expected number to be >=0\",\n          \"minimum\": 0,\n          \"origin\": \"number\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"number nonpositive\", async () => {\n  try {\n    await z.number().nonpositive().parseAsync(1);\n  } catch (err) {\n    // (\"Number must be less than or equal to 0\");\n    expect((err as z.ZodError).issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"too_big\",\n          \"inclusive\": true,\n          \"maximum\": 0,\n          \"message\": \"Too big: expected number to be <=0\",\n          \"origin\": \"number\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"number negative\", async () => {\n  try {\n    await z.number().negative().parseAsync(1);\n  } catch (err) {\n    // (\"Number must be less than 0\");\n    expect((err as z.ZodError).issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"too_big\",\n          \"inclusive\": false,\n          \"maximum\": 0,\n          \"message\": \"Too big: expected number to be <0\",\n          \"origin\": \"number\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"number positive\", async () => {\n  try {\n    await z.number().positive().parseAsync(-1);\n  } catch (err) {\n    // (\"Number must be greater than 0\");\n    expect((err as z.ZodError).issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"too_small\",\n          \"inclusive\": false,\n          \"message\": \"Too small: expected number to be >0\",\n          \"minimum\": 0,\n          \"origin\": \"number\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/validations.test.ts",
        "start": 1,
        "end": 283,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 283,
          "column": 2,
          "position": 1170
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/validations.test.ts",
        "start": 1,
        "end": 283,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 283,
          "column": 2,
          "position": 1170
        }
      }
    },
    {
      "format": "typescript",
      "lines": 94,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\ntest(\"function parsing\", () => {\n  const schema = z.union([z.string().refine(() => false), z.number().refine(() => false)]);\n  const result = schema.safeParse(\"asdf\");\n  expect(result.success).toEqual(false);\n});\n\ntest(\"union 2\", () => {\n  const result = z.union([z.number(), z.string().refine(() => false)]).safeParse(\"a\");\n  expect(result.success).toEqual(false);\n});\n\ntest(\"return valid over invalid\", () => {\n  const schema = z.union([\n    z.object({\n      email: z.string().email(),\n    }),\n    z.string(),\n  ]);\n  expect(schema.parse(\"asdf\")).toEqual(\"asdf\");\n  expect(schema.parse({ email: \"asdlkjf@lkajsdf.com\" })).toEqual({\n    email: \"asdlkjf@lkajsdf.com\",\n  });\n});\n\ntest(\"return errors from both union arms\", () => {\n  const result = z.union([z.number(), z.string().refine(() => false)]).safeParse(\"a\");\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"invalid_union\",\n          \"errors\": [\n            [\n              {\n                \"code\": \"invalid_type\",\n                \"expected\": \"number\",\n                \"message\": \"Invalid input: expected number, received string\",\n                \"path\": [],\n              },\n            ],\n            [\n              {\n                \"code\": \"custom\",\n                \"message\": \"Invalid input\",\n                \"path\": [],\n              },\n            ],\n          ],\n          \"message\": \"Invalid input\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"options getter\", async () => {\n  const union = z.union([z.string(), z.number()]);\n  union.options[0].parse(\"asdf\");\n  union.options[1].parse(1234);\n  await union.options[0].parseAsync(\"asdf\");\n  await union.options[1].parseAsync(1234);\n});\n\ntest(\"readonly union\", async () => {\n  const options = [z.string(), z.number()] as const;\n  const union = z.union(options);\n  union.parse(\"asdf\");\n  union.parse(12);\n});\n\ntest(\"union inferred types\", () => {\n  const test = z.object({}).or(z.array(z.object({})));\n\n  type Test = z.output<typeof test>; // < any\n  expectTypeOf<Test>().toEqualTypeOf<Record<string, never> | Array<Record<string, never>>>();\n});\n\ntest(\"union values\", () => {\n  const schema = z.union([z.literal(\"a\"), z.literal(\"b\"), z.literal(\"c\")]);\n\n  expect(schema._zod.values).toMatchInlineSnapshot(`\n    Set {\n      \"a\",\n      \"b\",\n      \"c\",\n    }\n  `);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/union.test.ts",
        "start": 1,
        "end": 94,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 94,
          "column": 2,
          "position": 785
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/union.test.ts",
        "start": 1,
        "end": 94,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 94,
          "column": 2,
          "position": 785
        }
      }
    },
    {
      "format": "typescript",
      "lines": 163,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ntest(\"successful validation\", () => {\n  const testTuple = z.tuple([z.string(), z.number()]);\n  expectTypeOf<typeof testTuple._output>().toEqualTypeOf<[string, number]>();\n\n  const val = testTuple.parse([\"asdf\", 1234]);\n  expect(val).toEqual(val);\n\n  const r1 = testTuple.safeParse([\"asdf\", \"asdf\"]);\n  expect(r1.success).toEqual(false);\n  expect(r1.error!).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"expected\": \"number\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          1\n        ],\n        \"message\": \"Invalid input: expected number, received string\"\n      }\n    ]]\n  `);\n\n  const r2 = testTuple.safeParse([\"asdf\", 1234, true]);\n  expect(r2.success).toEqual(false);\n  expect(r2.error!).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"origin\": \"array\",\n        \"code\": \"too_big\",\n        \"maximum\": 2,\n        \"path\": [],\n        \"message\": \"Too big: expected array to have <2 items\"\n      }\n    ]]\n  `);\n\n  const r3 = testTuple.safeParse({});\n  expect(r3.success).toEqual(false);\n  expect(r3.error!).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"expected\": \"tuple\",\n        \"code\": \"invalid_type\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected tuple, received object\"\n      }\n    ]]\n  `);\n});\n\ntest(\"async validation\", async () => {\n  const testTuple = z\n    .tuple([z.string().refine(async () => true), z.number().refine(async () => true)])\n    .refine(async () => true);\n  expectTypeOf<typeof testTuple._output>().toEqualTypeOf<[string, number]>();\n\n  const val = await testTuple.parseAsync([\"asdf\", 1234]);\n  expect(val).toEqual(val);\n\n  const r1 = await testTuple.safeParseAsync([\"asdf\", \"asdf\"]);\n  expect(r1.success).toEqual(false);\n  expect(r1.error!).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"expected\": \"number\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          1\n        ],\n        \"message\": \"Invalid input: expected number, received string\"\n      }\n    ]]\n  `);\n\n  const r2 = await testTuple.safeParseAsync([\"asdf\", 1234, true]);\n  expect(r2.success).toEqual(false);\n  expect(r2.error!).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"origin\": \"array\",\n        \"code\": \"too_big\",\n        \"maximum\": 2,\n        \"path\": [],\n        \"message\": \"Too big: expected array to have <2 items\"\n      }\n    ]]\n  `);\n\n  const r3 = await testTuple.safeParseAsync({});\n  expect(r3.success).toEqual(false);\n  expect(r3.error!).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"expected\": \"tuple\",\n        \"code\": \"invalid_type\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected tuple, received object\"\n      }\n    ]]\n  `);\n});\n\ntest(\"tuple with optional elements\", () => {\n  const myTuple = z.tuple([z.string(), z.number().optional(), z.string().optional()]).rest(z.boolean());\n  expectTypeOf<typeof myTuple._output>().toEqualTypeOf<[string, number?, string?, ...boolean[]]>();\n\n  const goodData = [[\"asdf\"], [\"asdf\", 1234], [\"asdf\", 1234, \"asdf\"], [\"asdf\", 1234, \"asdf\", true, false, true]];\n  for (const data of goodData) {\n    expect(myTuple.parse(data)).toEqual(data);\n  }\n\n  const badData = [\n    [\"asdf\", \"asdf\"],\n    [\"asdf\", 1234, \"asdf\", \"asdf\"],\n    [\"asdf\", 1234, \"asdf\", true, false, \"asdf\"],\n  ];\n  for (const data of badData) {\n    expect(() => myTuple.parse(data)).toThrow();\n  }\n});\n\ntest(\"tuple with optional elements followed by required\", () => {\n  const myTuple = z.tuple([z.string(), z.number().optional(), z.string()]).rest(z.boolean());\n  expectTypeOf<typeof myTuple._output>().toEqualTypeOf<[string, number | undefined, string, ...boolean[]]>();\n\n  const goodData = [\n    [\"asdf\", 1234, \"asdf\"],\n    [\"asdf\", 1234, \"asdf\", true, false, true],\n  ];\n  for (const data of goodData) {\n    expect(myTuple.parse(data)).toEqual(data);\n  }\n\n  const badData = [\n    [\"asdf\"],\n    [\"asdf\", 1234],\n    [\"asdf\", 1234, \"asdf\", \"asdf\"],\n    [\"asdf\", 1234, \"asdf\", true, false, \"asdf\"],\n  ];\n  for (const data of badData) {\n    expect(() => myTuple.parse(data)).toThrow();\n  }\n});\n\ntest(\"tuple with rest schema\", () => {\n  const myTuple = z.tuple([z.string(), z.number()]).rest(z.boolean());\n  expect(myTuple.parse([\"asdf\", 1234, true, false, true])).toEqual([\"asdf\", 1234, true, false, true]);\n\n  expect(myTuple.parse([\"asdf\", 1234])).toEqual([\"asdf\", 1234]);\n\n  expect(() => myTuple.parse([\"asdf\", 1234, \"asdf\"])).toThrow();\n  type t1 = z.output<typeof myTuple>;\n\n  expectTypeOf<t1>().toEqualTypeOf<[string, number, ...boolean[]]>();\n});\n\ntest(\"sparse array input\", () => {\n  const schema = z.tuple([z.string(), z.number()]);\n  expect(() => schema.parse(new Array(2))).toThrow();\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/tuple.test.ts",
        "start": 1,
        "end": 163,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 163,
          "column": 2,
          "position": 1438
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/tuple.test.ts",
        "start": 1,
        "end": 163,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 163,
          "column": 2,
          "position": 1438
        }
      }
    },
    {
      "format": "typescript",
      "lines": 250,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ntest(\"transform ctx.addIssue with parse\", () => {\n  const strs = [\"foo\", \"bar\"];\n  const schema = z.string().transform((data, ctx) => {\n    const i = strs.indexOf(data);\n    if (i === -1) {\n      ctx.addIssue({\n        input: data,\n        code: \"custom\",\n        message: `${data} is not one of our allowed strings`,\n      });\n    }\n    return data.length;\n  });\n  const result = schema.safeParse(\"asdf\");\n  expect(result.success).toEqual(false);\n  expect(result.error!).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"message\": \"asdf is not one of our allowed strings\",\n        \"path\": []\n      }\n    ]]\n  `);\n});\n\ntest(\"transform ctx.addIssue with parseAsync\", async () => {\n  const strs = [\"foo\", \"bar\"];\n\n  const result = await z\n    .string()\n    .transform(async (data, ctx) => {\n      const i = strs.indexOf(data);\n      if (i === -1) {\n        ctx.addIssue({\n          input: data,\n          code: \"custom\",\n          message: `${data} is not one of our allowed strings`,\n        });\n      }\n      return data.length;\n    })\n    .safeParseAsync(\"asdf\");\n\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"message\": \"asdf is not one of our allowed strings\",\n        \"path\": []\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"z.NEVER in transform\", () => {\n  const foo = z\n    .number()\n    .optional()\n    .transform((val, ctx) => {\n      if (!val) {\n        ctx.addIssue({\n          input: val,\n          code: z.ZodIssueCode.custom,\n          message: \"bad\",\n        });\n        return z.NEVER;\n      }\n      return val;\n    });\n  type foo = z.infer<typeof foo>;\n  expectTypeOf<foo>().toEqualTypeOf<number>();\n  const arg = foo.safeParse(undefined);\n  if (!arg.success) {\n    expect(arg.error.issues[0].message).toEqual(\"bad\");\n  }\n});\n\ntest(\"basic transformations\", () => {\n  const r1 = z\n    .string()\n    .transform((data) => data.length)\n    .parse(\"asdf\");\n  expect(r1).toEqual(4);\n});\n\ntest(\"coercion\", () => {\n  const numToString = z.number().transform((n) => String(n));\n  const data = z\n    .object({\n      id: numToString,\n    })\n    .parse({ id: 5 });\n\n  expect(data).toEqual({ id: \"5\" });\n});\n\ntest(\"async coercion\", async () => {\n  const numToString = z.number().transform(async (n) => String(n));\n  const data = await z\n    .object({\n      id: numToString,\n    })\n    .parseAsync({ id: 5 });\n\n  expect(data).toEqual({ id: \"5\" });\n});\n\ntest(\"sync coercion async error\", async () => {\n  const asyncNumberToString = z.number().transform(async (n) => String(n));\n  expect(() =>\n    z\n      .object({\n        id: asyncNumberToString,\n      })\n      .parse({ id: 5 })\n  ).toThrow();\n  // expect(data).toEqual({ id: '5' });\n});\n\ntest(\"default\", () => {\n  const data = z.string().default(\"asdf\").parse(undefined); // => \"asdf\"\n  expect(data).toEqual(\"asdf\");\n});\n\ntest(\"dynamic default\", () => {\n  const data = z\n    .string()\n    .default(() => \"string\")\n    .parse(undefined); // => \"asdf\"\n  expect(data).toEqual(\"string\");\n});\n\ntest(\"default when property is null or undefined\", () => {\n  const data = z\n    .object({\n      foo: z.boolean().nullable().default(true),\n      bar: z.boolean().default(true),\n    })\n    .parse({ foo: null });\n\n  expect(data).toEqual({ foo: null, bar: true });\n});\n\ntest(\"default with falsy values\", () => {\n  const schema = z.object({\n    emptyStr: z.string().default(\"def\"),\n    zero: z.number().default(5),\n    falseBoolean: z.boolean().default(true),\n  });\n  const input = { emptyStr: \"\", zero: 0, falseBoolean: true };\n  const output = schema.parse(input);\n  // defaults are not supposed to be used\n  expect(output).toEqual(input);\n});\n\ntest(\"object typing\", () => {\n  const stringToNumber = z.string().transform((arg) => Number.parseFloat(arg));\n\n  const t1 = z.object({\n    stringToNumber,\n  });\n\n  type t1 = z.input<typeof t1>;\n  type t2 = z.output<typeof t1>;\n\n  expectTypeOf<t1>().toEqualTypeOf<{ stringToNumber: string }>();\n  expectTypeOf<t2>().toEqualTypeOf<{ stringToNumber: number }>();\n});\n\ntest(\"transform method overloads\", () => {\n  const t1 = z.string().transform((val) => val.toUpperCase());\n  expect(t1.parse(\"asdf\")).toEqual(\"ASDF\");\n\n  const t2 = z.string().transform((val) => val.length);\n  expect(t2.parse(\"asdf\")).toEqual(4);\n});\n\ntest(\"multiple transformers\", () => {\n  const stringToNumber = z.string().transform((arg) => Number.parseFloat(arg));\n\n  const doubler = stringToNumber.transform((val) => {\n    return val * 2;\n  });\n  expect(doubler.parse(\"5\")).toEqual(10);\n});\n\ntest(\"short circuit on dirty\", () => {\n  const schema = z\n    .string()\n    .refine(() => false)\n    .transform((val) => val.toUpperCase());\n  const result = schema.safeParse(\"asdf\");\n  expect(result.success).toEqual(false);\n\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"Invalid input\"\n      }\n    ]]\n  `);\n\n  const result2 = schema.safeParse(1234);\n  expect(result2.success).toEqual(false);\n  if (!result2.success) {\n    expect(result2.error.issues[0].code).toEqual(z.ZodIssueCode.invalid_type);\n  }\n});\n\ntest(\"async short circuit on dirty\", async () => {\n  const schema = z\n    .string()\n    .refine(() => false)\n    .transform((val) => val.toUpperCase());\n  const result = await schema.spa(\"asdf\");\n  expect(result.success).toEqual(false);\n\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"Invalid input\"\n      }\n    ]]\n  `);\n\n  const result2 = await schema.spa(1234);\n  expect(result2.success).toEqual(false);\n\n  expect(result2.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected string, received number\"\n      }\n    ]]\n  `);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/transform.test.ts",
        "start": 1,
        "end": 250,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 250,
          "column": 2,
          "position": 2046
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/transform.test.ts",
        "start": 1,
        "end": 250,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 250,
          "column": 2,
          "position": 2046
        }
      }
    },
    {
      "format": "typescript",
      "lines": 758,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\nconst empty = z.templateLiteral([]);\nconst hello = z.templateLiteral([\"hello\"]);\nconst world = z.templateLiteral([\"\", z.literal(\"world\")]);\nconst one = z.templateLiteral([1]);\nconst two = z.templateLiteral([\"\", z.literal(2)]);\nconst truee = z.templateLiteral([true]);\nconst anotherTrue = z.templateLiteral([\"\", z.literal(true)]);\nconst falsee = z.templateLiteral([false]);\nconst anotherFalse = z.templateLiteral([\"\", z.literal(false)]);\nconst nulll = z.templateLiteral([null]);\nconst anotherNull = z.templateLiteral([\"\", z.null()]);\nconst undefinedd = z.templateLiteral([undefined]);\nconst anotherUndefined = z.templateLiteral([\"\", z.undefined()]);\nconst anyString = z.templateLiteral([\"\", z.string()]);\nconst lazyString = z.templateLiteral([\"\", z.lazy(() => z.string())]);\nconst anyNumber = z.templateLiteral([\"\", z.number()]);\nconst anyInt = z.templateLiteral([\"\", z.number().int()]);\n// const anyFiniteNumber = z.templateLiteral([\"\", z.number().finite()]);\n// const anyNegativeNumber = z.templateLiteral([\"\", z.number().negative()]);\n// const anyPositiveNumber = z.templateLiteral([\"\", z.number().positive()]);\n// const zeroButInADumbWay = z.templateLiteral([\"\", z.number().nonnegative().nonpositive()]);\n// const finiteButInADumbWay = z.templateLiteral([\"\", z.number().min(5).max(10)]);\nconst bool = z.templateLiteral([\"\", z.boolean()]);\nconst bigone = z.templateLiteral([\"\", z.literal(BigInt(1))]);\nconst anyBigint = z.templateLiteral([\"\", z.bigint()]);\nconst nullableYo = z.templateLiteral([\"\", z.nullable(z.literal(\"yo\"))]);\nconst nullableString = z.templateLiteral([\"\", z.nullable(z.string())]);\nconst optionalYeah = z.templateLiteral([\"\", z.literal(\"yeah\").optional()]);\n\nconst optionalString = z.templateLiteral([\"\", z.string().optional()]);\nconst optionalNumber = z.templateLiteral([\"\", z.number().optional()]);\nconst nullishBruh = z.templateLiteral([\"\", z.literal(\"bruh\").nullish()]);\nconst nullishString = z.templateLiteral([\"\", z.string().nullish()]);\nconst cuid = z.templateLiteral([\"\", z.string().cuid()]);\nconst cuidZZZ = z.templateLiteral([\"\", z.string().cuid(), \"ZZZ\"]);\nconst cuid2 = z.templateLiteral([\"\", z.string().cuid2()]);\nconst datetime = z.templateLiteral([\"\", z.string().datetime()]);\nconst email = z.templateLiteral([\"\", z.string().email()]);\n// const ip = z.templateLiteral([\"\", z.string().ip()]);\nconst ipv4 = z.templateLiteral([\"\", z.string().ipv4()]);\nconst ipv6 = z.templateLiteral([\"\", z.string().ipv6()]);\nconst ulid = z.templateLiteral([\"\", z.string().ulid()]);\nconst uuid = z.templateLiteral([\"\", z.string().uuid()]);\nconst stringAToZ = z.templateLiteral([\"\", z.string().regex(/^[a-z]+$/)]);\nconst stringStartsWith = z.templateLiteral([\"\", z.string().startsWith(\"hello\")]);\nconst stringEndsWith = z.templateLiteral([\"\", z.string().endsWith(\"world\")]);\nconst stringMax5 = z.templateLiteral([\"\", z.string().max(5)]);\nconst stringMin5 = z.templateLiteral([\"\", z.string().min(5)]);\nconst stringLen5 = z.templateLiteral([\"\", z.string().length(5)]);\nconst stringMin5Max10 = z.templateLiteral([\"\", z.string().min(5).max(10)]);\nconst stringStartsWithMax5 = z.templateLiteral([\"\", z.string().startsWith(\"hello\").max(5)]);\nconst brandedString = z.templateLiteral([\"\", z.string().min(1).brand(\"myBrand\")]);\n// const anything = z.templateLiteral([\"\", z.any()]);\n\nconst url = z.templateLiteral([\"https://\", z.string().regex(/\\w+/), \".\", z.enum([\"com\", \"net\"])]);\n\nconst measurement = z.templateLiteral([\n  \"\",\n  z.number().finite(),\n  z.enum([\"px\", \"em\", \"rem\", \"vh\", \"vw\", \"vmin\", \"vmax\"]).optional(),\n]);\n\nconst connectionString = z.templateLiteral([\n  \"mongodb://\",\n  z\n    .templateLiteral([\n      \"\",\n      z.string().regex(/\\w+/).describe(\"username\"),\n      \":\",\n      z.string().regex(/\\w+/).describe(\"password\"),\n      \"@\",\n    ])\n    .optional(),\n  z.string().regex(/\\w+/).describe(\"host\"),\n  \":\",\n  z.number().finite().int().positive().describe(\"port\"),\n  z\n    .templateLiteral([\n      \"/\",\n      z.string().regex(/\\w+/).optional().describe(\"defaultauthdb\"),\n      z\n        .templateLiteral([\n          \"?\",\n          z\n            .string()\n            .regex(/^\\w+=\\w+(&\\w+=\\w+)*$/)\n            .optional()\n            .describe(\"options\"),\n        ])\n        .optional(),\n    ])\n    .optional(),\n]);\n\ntest(\"template literal type inference\", () => {\n  expectTypeOf<z.infer<typeof empty>>().toEqualTypeOf<``>();\n  expectTypeOf<z.infer<typeof hello>>().toEqualTypeOf<`hello`>();\n  expectTypeOf<z.infer<typeof world>>().toEqualTypeOf<`world`>();\n  expectTypeOf<z.infer<typeof one>>().toEqualTypeOf<`1`>();\n  expectTypeOf<z.infer<typeof two>>().toEqualTypeOf<`2`>();\n  expectTypeOf<z.infer<typeof truee>>().toEqualTypeOf<`true`>();\n  expectTypeOf<z.infer<typeof anotherTrue>>().toEqualTypeOf<`true`>();\n  expectTypeOf<z.infer<typeof falsee>>().toEqualTypeOf<`false`>();\n  expectTypeOf<z.infer<typeof anotherFalse>>().toEqualTypeOf<`false`>();\n  expectTypeOf<z.infer<typeof nulll>>().toEqualTypeOf<`null`>();\n  expectTypeOf<z.infer<typeof anotherNull>>().toEqualTypeOf<`null`>();\n  expectTypeOf<z.infer<typeof undefinedd>>().toEqualTypeOf<``>();\n  expectTypeOf<z.infer<typeof anotherUndefined>>().toEqualTypeOf<``>();\n  expectTypeOf<z.infer<typeof anyString>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof lazyString>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof anyNumber>>().toEqualTypeOf<`${number}`>();\n  expectTypeOf<z.infer<typeof anyInt>>().toEqualTypeOf<`${number}`>();\n  // expectTypeOf<z.infer<typeof anyFiniteNumber>>().toEqualTypeOf<`${number}`>();\n  // expectTypeOf<z.infer<typeof anyNegativeNumber>>().toEqualTypeOf<`${number}`>();\n  // expectTypeOf<z.infer<typeof anyPositiveNumber>>().toEqualTypeOf<`${number}`>();\n  // expectTypeOf<z.infer<typeof zeroButInADumbWay>>().toEqualTypeOf<`${number}`>();\n  // expectTypeOf<z.infer<typeof finiteButInADumbWay>>().toEqualTypeOf<`${number}`>();\n  expectTypeOf<z.infer<typeof bool>>().toEqualTypeOf<`true` | `false`>();\n  expectTypeOf<z.infer<typeof bigone>>().toEqualTypeOf<`${bigint}`>();\n  expectTypeOf<z.infer<typeof anyBigint>>().toEqualTypeOf<`${bigint}`>();\n  expectTypeOf<z.infer<typeof nullableYo>>().toEqualTypeOf<`yo` | `null`>();\n  expectTypeOf<z.infer<typeof nullableString>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof optionalYeah>>().toEqualTypeOf<`yeah` | ``>();\n  expectTypeOf<z.infer<typeof optionalString>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof optionalNumber>>().toEqualTypeOf<`${number}` | ``>();\n  expectTypeOf<z.infer<typeof nullishBruh>>().toEqualTypeOf<`bruh` | `null` | ``>();\n  expectTypeOf<z.infer<typeof nullishString>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof cuid>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof cuidZZZ>>().toEqualTypeOf<`${string}ZZZ`>();\n  expectTypeOf<z.infer<typeof cuid2>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof datetime>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof email>>().toEqualTypeOf<string>();\n  // expectTypeOf<z.infer<typeof ip>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof ipv4>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof ipv6>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof ulid>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof uuid>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof stringAToZ>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof stringStartsWith>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof stringEndsWith>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof stringMax5>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof stringMin5>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof stringLen5>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof stringMin5Max10>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof stringStartsWithMax5>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof brandedString>>().toEqualTypeOf<`${string & z.core.$brand<\"myBrand\">}`>();\n\n  // expectTypeOf<z.infer<typeof anything>>().toEqualTypeOf<`${any}`>();\n\n  expectTypeOf<z.infer<typeof url>>().toEqualTypeOf<`https://${string}.com` | `https://${string}.net`>();\n\n  expectTypeOf<z.infer<typeof measurement>>().toEqualTypeOf<\n    | `${number}`\n    | `${number}px`\n    | `${number}em`\n    | `${number}rem`\n    | `${number}vh`\n    | `${number}vw`\n    | `${number}vmin`\n    | `${number}vmax`\n  >();\n\n  expectTypeOf<z.infer<typeof connectionString>>().toEqualTypeOf<\n    | `mongodb://${string}:${number}`\n    | `mongodb://${string}:${number}/${string}`\n    | `mongodb://${string}:${number}/${string}?${string}`\n    | `mongodb://${string}:${string}@${string}:${number}`\n    | `mongodb://${string}:${string}@${string}:${number}/${string}`\n    | `mongodb://${string}:${string}@${string}:${number}/${string}?${string}`\n  >();\n});\n\ntest(\"template literal unsupported args\", () => {\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.object({})])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.array(z.object({}))])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.union([z.object({}), z.string()])])\n  ).toThrow();\n  // @ts-expect-error\n  expect(() => z.templateLiteral([z.date()])).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.custom<object>((_) => true)])\n  ).toThrow();\n  expect(() =>\n    z.templateLiteral([\n      // @ts-expect-error\n      z.discriminatedUnion(\"discriminator\", [z.object({}), z.object({})]),\n    ])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.function()])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.instanceof(class MyClass {})])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.intersection(z.object({}), z.object({}))])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.map(z.string(), z.string())])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.nullable(z.object({}))])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.optional(z.object({}))])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.promise()])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.record(z.unknown())])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.set(z.string())])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.symbol()])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.tuple([z.string()])])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.unknown()])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.void()])\n  ).toThrow();\n\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.never()])\n  ).toThrow();\n  // @ts-expect-error\n  expect(() => z.templateLiteral([z.nan()])).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.pipe(z.string(), z.string())])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.preprocess(() => true, z.boolean())])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.object({}).brand(\"brand\")])\n  ).toThrow();\n\n  // these constraints aren't enforced but they shouldn't throw\n  z.templateLiteral([z.number().multipleOf(2)]);\n  z.templateLiteral([z.string().emoji()]);\n  z.templateLiteral([z.string().url()]);\n  z.templateLiteral([z.string().url()]);\n  z.templateLiteral([z.string().trim()]);\n  z.templateLiteral([z.string().includes(\"train\")]);\n  z.templateLiteral([z.string().toLowerCase()]);\n  z.templateLiteral([z.string().toUpperCase()]);\n});\n\ntest(\"template literal parsing - success - basic cases\", () => {\n  expect(() => z.templateLiteral([]).parse(7)).toThrow();\n\n  empty.parse(\"\");\n  hello.parse(\"hello\");\n  world.parse(\"world\");\n  one.parse(\"1\");\n  two.parse(\"2\");\n  truee.parse(\"true\");\n  anotherTrue.parse(\"true\");\n  falsee.parse(\"false\");\n  anotherFalse.parse(\"false\");\n  nulll.parse(\"null\");\n  anotherNull.parse(\"null\");\n  undefinedd.parse(\"undefined\");\n  anotherUndefined.parse(\"undefined\");\n  anyString.parse(\"blahblahblah\");\n  anyString.parse(\"\");\n  lazyString.parse(\"blahblahblah\");\n  lazyString.parse(\"\");\n  anyNumber.parse(\"123\");\n  anyNumber.parse(\"1.23\");\n  anyNumber.parse(\"0\");\n  anyNumber.parse(\"-1.23\");\n  anyNumber.parse(\"-123\");\n  // anyNumber.parse(\"Infinity\");\n  // anyNumber.parse(\"-Infinity\");\n  anyInt.parse(\"123\");\n  // anyInt.parse(\"-123\");\n  // anyFiniteNumber.parse(\"123\");\n  // anyFiniteNumber.parse(\"1.23\");\n  // anyFiniteNumber.parse(\"0\");\n  // anyFiniteNumber.parse(\"-1.23\");\n  // anyFiniteNumber.parse(\"-123\");\n  // anyNegativeNumber.parse(\"-123\");\n  // anyNegativeNumber.parse(\"-1.23\");\n  // anyNegativeNumber.parse(\"-Infinity\");\n  // anyPositiveNumber.parse(\"123\");\n  // anyPositiveNumber.parse(\"1.23\");\n  // anyPositiveNumber.parse(\"Infinity\");\n  // zeroButInADumbWay.parse(\"0\");\n  // zeroButInADumbWay.parse(\"00000\");\n  // finiteButInADumbWay.parse(\"5\");\n  // finiteButInADumbWay.parse(\"10\");\n  // finiteButInADumbWay.parse(\"6.66\");\n  bool.parse(\"true\");\n  bool.parse(\"false\");\n  bigone.parse(\"1\");\n  anyBigint.parse(\"123456\");\n  anyBigint.parse(\"0\");\n  // anyBigint.parse(\"-123456\");\n  nullableYo.parse(\"yo\");\n  nullableYo.parse(\"null\");\n  nullableString.parse(\"abc\");\n  nullableString.parse(\"null\");\n  optionalYeah.parse(\"yeah\");\n  optionalYeah.parse(\"\");\n  optionalString.parse(\"abc\");\n  optionalString.parse(\"\");\n  optionalNumber.parse(\"123\");\n  optionalNumber.parse(\"1.23\");\n  optionalNumber.parse(\"0\");\n  optionalNumber.parse(\"-1.23\");\n  optionalNumber.parse(\"-123\");\n  // optionalNumber.parse(\"Infinity\");\n  // optionalNumber.parse(\"-Infinity\");\n  nullishBruh.parse(\"bruh\");\n  nullishBruh.parse(\"null\");\n  nullishBruh.parse(\"\");\n  cuid.parse(\"cjld2cyuq0000t3rmniod1foy\");\n  cuidZZZ.parse(\"cjld2cyuq0000t3rmniod1foyZZZ\");\n  cuid2.parse(\"tz4a98xxat96iws9zmbrgj3a\");\n  datetime.parse(new Date().toISOString());\n  email.parse(\"info@example.com\");\n  // ip.parse(\"213.174.246.205\");\n  // ip.parse(\"c359:f57c:21e5:39eb:1187:e501:f936:b452\");\n  ipv4.parse(\"213.174.246.205\");\n  ipv6.parse(\"c359:f57c:21e5:39eb:1187:e501:f936:b452\");\n  ulid.parse(\"01GW3D2QZJBYB6P1Z1AE997VPW\");\n  uuid.parse(\"808989fd-3a6e-4af2-b607-737323a176f6\");\n  stringAToZ.parse(\"asudgaskhdgashd\");\n  stringStartsWith.parse(\"hello world\");\n  stringEndsWith.parse(\"hello world\");\n  stringMax5.parse(\"hello\");\n  stringMin5.parse(\"hello\");\n  stringLen5.parse(\"hello\");\n  stringMin5Max10.parse(\"hello worl\");\n  stringStartsWithMax5.parse(\"hello\");\n  brandedString.parse(\"branded string\");\n});\n\ntest(\"template literal parsing - failure - basic cases\", () => {\n  expect(() => empty.parse(\"a\")).toThrow();\n  expect(() => hello.parse(\"hello!\")).toThrow();\n  expect(() => hello.parse(\"!hello\")).toThrow();\n  expect(() => world.parse(\"world!\")).toThrow();\n  expect(() => world.parse(\"!world\")).toThrow();\n  expect(() => one.parse(\"2\")).toThrow();\n  expect(() => one.parse(\"12\")).toThrow();\n  expect(() => one.parse(\"21\")).toThrow();\n  expect(() => two.parse(\"1\")).toThrow();\n  expect(() => two.parse(\"21\")).toThrow();\n  expect(() => two.parse(\"12\")).toThrow();\n  expect(() => truee.parse(\"false\")).toThrow();\n  expect(() => truee.parse(\"1true\")).toThrow();\n  expect(() => truee.parse(\"true1\")).toThrow();\n  expect(() => anotherTrue.parse(\"false\")).toThrow();\n  expect(() => anotherTrue.parse(\"1true\")).toThrow();\n  expect(() => anotherTrue.parse(\"true1\")).toThrow();\n  expect(() => falsee.parse(\"true\")).toThrow();\n  expect(() => falsee.parse(\"1false\")).toThrow();\n  expect(() => falsee.parse(\"false1\")).toThrow();\n  expect(() => anotherFalse.parse(\"true\")).toThrow();\n  expect(() => anotherFalse.parse(\"1false\")).toThrow();\n  expect(() => anotherFalse.parse(\"false1\")).toThrow();\n  expect(() => nulll.parse(\"123\")).toThrow();\n  expect(() => nulll.parse(\"null1\")).toThrow();\n  expect(() => nulll.parse(\"1null\")).toThrow();\n  expect(() => anotherNull.parse(\"123\")).toThrow();\n  expect(() => anotherNull.parse(\"null1\")).toThrow();\n  expect(() => anotherNull.parse(\"1null\")).toThrow();\n  expect(() => undefinedd.parse(\"123\")).toThrow();\n  expect(() => undefinedd.parse(\"undefined1\")).toThrow();\n  expect(() => undefinedd.parse(\"1undefined\")).toThrow();\n  expect(() => anotherUndefined.parse(\"123\")).toThrow();\n  expect(() => anotherUndefined.parse(\"undefined1\")).toThrow();\n  expect(() => anotherUndefined.parse(\"1undefined\")).toThrow();\n  expect(() => anyNumber.parse(\"2a\")).toThrow();\n  expect(() => anyNumber.parse(\"a2\")).toThrow();\n  expect(() => anyNumber.parse(\"-2a\")).toThrow();\n  expect(() => anyNumber.parse(\"a-2\")).toThrow();\n  expect(() => anyNumber.parse(\"2.5a\")).toThrow();\n  expect(() => anyNumber.parse(\"a2.5\")).toThrow();\n  expect(() => anyNumber.parse(\"Infinitya\")).toThrow();\n  expect(() => anyNumber.parse(\"aInfinity\")).toThrow();\n  expect(() => anyNumber.parse(\"-Infinitya\")).toThrow();\n  expect(() => anyNumber.parse(\"a-Infinity\")).toThrow();\n  expect(() => anyNumber.parse(\"2e5\")).toThrow();\n  expect(() => anyNumber.parse(\"2e-5\")).toThrow();\n  expect(() => anyNumber.parse(\"2e+5\")).toThrow();\n  expect(() => anyNumber.parse(\"-2e5\")).toThrow();\n  expect(() => anyNumber.parse(\"-2e-5\")).toThrow();\n  expect(() => anyNumber.parse(\"-2e+5\")).toThrow();\n  expect(() => anyNumber.parse(\"2.1e5\")).toThrow();\n  expect(() => anyNumber.parse(\"2.1e-5\")).toThrow();\n  expect(() => anyNumber.parse(\"2.1e+5\")).toThrow();\n  expect(() => anyNumber.parse(\"-2.1e5\")).toThrow();\n  expect(() => anyNumber.parse(\"-2.1e-5\")).toThrow();\n  expect(() => anyNumber.parse(\"-2.1e+5\")).toThrow();\n  expect(() => anyNumber.parse(\"-Infinity\")).toThrow();\n  expect(() => anyNumber.parse(\"Infinity\")).toThrow();\n  expect(() => anyInt.parse(\"1.23\")).toThrow();\n  expect(() => anyInt.parse(\"-1.23\")).toThrow();\n  expect(() => anyInt.parse(\"d1\")).toThrow();\n  expect(() => anyInt.parse(\"1d\")).toThrow();\n  // expect(() => anyFiniteNumber.parse(\"Infinity\")).toThrow();\n  // expect(() => anyFiniteNumber.parse(\"-Infinity\")).toThrow();\n  // expect(() => anyFiniteNumber.parse(\"123a\")).toThrow();\n  // expect(() => anyFiniteNumber.parse(\"a123\")).toThrow();\n  // expect(() => anyNegativeNumber.parse(\"0\")).toThrow();\n  // expect(() => anyNegativeNumber.parse(\"1\")).toThrow();\n  // expect(() => anyNegativeNumber.parse(\"Infinity\")).toThrow();\n  // expect(() => anyPositiveNumber.parse(\"0\")).toThrow();\n  // expect(() => anyPositiveNumber.parse(\"-1\")).toThrow();\n  // expect(() => anyPositiveNumber.parse(\"-Infinity\")).toThrow();\n  // expect(() => zeroButInADumbWay.parse(\"1\")).toThrow();\n  // expect(() => zeroButInADumbWay.parse(\"-1\")).toThrow();\n  // expect(() => finiteButInADumbWay.parse(\"Infinity\")).toThrow();\n  // expect(() => finiteButInADumbWay.parse(\"-Infinity\")).toThrow();\n  // expect(() => finiteButInADumbWay.parse(\"-5\")).toThrow();\n  // expect(() => finiteButInADumbWay.parse(\"10a\")).toThrow();\n  // expect(() => finiteButInADumbWay.parse(\"a10\")).toThrow();\n  expect(() => bool.parse(\"123\")).toThrow();\n  expect(() => bigone.parse(\"2\")).toThrow();\n  expect(() => bigone.parse(\"c1\")).toThrow();\n  expect(() => anyBigint.parse(\"1.23\")).toThrow();\n  expect(() => anyBigint.parse(\"-1.23\")).toThrow();\n  expect(() => anyBigint.parse(\"c123\")).toThrow();\n  expect(() => nullableYo.parse(\"yo1\")).toThrow();\n  expect(() => nullableYo.parse(\"1yo\")).toThrow();\n  expect(() => nullableYo.parse(\"null1\")).toThrow();\n  expect(() => nullableYo.parse(\"1null\")).toThrow();\n  expect(() => optionalYeah.parse(\"yeah1\")).toThrow();\n  expect(() => optionalYeah.parse(\"1yeah\")).toThrow();\n  expect(() => optionalYeah.parse(\"undefined\")).toThrow();\n  expect(() => optionalNumber.parse(\"123a\")).toThrow();\n  expect(() => optionalNumber.parse(\"a123\")).toThrow();\n  // expect(() => optionalNumber.parse(\"Infinitya\")).toThrow();\n  // expect(() => optionalNumber.parse(\"aInfinity\")).toThrow();\n  expect(() => nullishBruh.parse(\"bruh1\")).toThrow();\n  expect(() => nullishBruh.parse(\"1bruh\")).toThrow();\n  expect(() => nullishBruh.parse(\"null1\")).toThrow();\n  expect(() => nullishBruh.parse(\"1null\")).toThrow();\n  expect(() => nullishBruh.parse(\"undefined\")).toThrow();\n  expect(() => cuid.parse(\"bjld2cyuq0000t3rmniod1foy\")).toThrow();\n  expect(() => cuid.parse(\"cjld2cyu\")).toThrow();\n  expect(() => cuid.parse(\"cjld2 cyu\")).toThrow();\n  expect(() => cuid.parse(\"cjld2cyuq0000t3rmniod1foy \")).toThrow();\n  expect(() => cuid.parse(\"1cjld2cyuq0000t3rmniod1foy\")).toThrow();\n  expect(() => cuidZZZ.parse(\"cjld2cyuq0000t3rmniod1foy\")).toThrow();\n  expect(() => cuidZZZ.parse(\"cjld2cyuq0000t3rmniod1foyZZY\")).toThrow();\n  expect(() => cuidZZZ.parse(\"cjld2cyuq0000t3rmniod1foyZZZ1\")).toThrow();\n  expect(() => cuidZZZ.parse(\"1cjld2cyuq0000t3rmniod1foyZZZ\")).toThrow();\n  expect(() => cuid2.parse(\"A9z4a98xxat96iws9zmbrgj3a\")).toThrow();\n  expect(() => cuid2.parse(\"tz4a98xxat96iws9zmbrgj3!\")).toThrow();\n  expect(() => datetime.parse(\"2022-01-01 00:00:00\")).toThrow();\n  expect(() => email.parse(\"info@example.com@\")).toThrow();\n  // expect(() => ip.parse(\"213.174.246:205\")).toThrow();\n  // expect(() => ip.parse(\"c359.f57c:21e5:39eb:1187:e501:f936:b452\")).toThrow();\n  expect(() => ipv4.parse(\"1213.174.246.205\")).toThrow();\n  expect(() => ipv4.parse(\"c359:f57c:21e5:39eb:1187:e501:f936:b452\")).toThrow();\n  expect(() => ipv6.parse(\"c359:f57c:21e5:39eb:1187:e501:f936:b4521\")).toThrow();\n  expect(() => ipv6.parse(\"213.174.246.205\")).toThrow();\n  expect(() => ulid.parse(\"01GW3D2QZJBYB6P1Z1AE997VPW!\")).toThrow();\n  expect(() => uuid.parse(\"808989fd-3a6e-4af2-b607-737323a176f6Z\")).toThrow();\n  expect(() => uuid.parse(\"Z808989fd-3a6e-4af2-b607-737323a176f6\")).toThrow();\n  expect(() => stringAToZ.parse(\"asdasdasd1\")).toThrow();\n  expect(() => stringAToZ.parse(\"1asdasdasd\")).toThrow();\n  expect(() => stringStartsWith.parse(\"ahello\")).toThrow();\n  expect(() => stringEndsWith.parse(\"worlda\")).toThrow();\n  expect(() => stringMax5.parse(\"123456\")).toThrow();\n  expect(() => stringMin5.parse(\"1234\")).toThrow();\n  expect(() => stringLen5.parse(\"123456\")).toThrow();\n  expect(() => stringLen5.parse(\"1234\")).toThrow();\n  expect(() => stringMin5Max10.parse(\"1234\")).toThrow();\n  expect(() => stringMin5Max10.parse(\"12345678901\")).toThrow();\n\n  // the \"startswith\" overrides the max length\n  // expect(() => stringStartsWithMax5.parse(\"hello1\")).toThrow();\n  expect(() => stringStartsWithMax5.parse(\"1hell\")).toThrow();\n  expect(() => brandedString.parse(\"\")).toThrow();\n});\n\ntest(\"regexes\", () => {\n  expect(empty._zod.pattern.source).toMatchInlineSnapshot(`\"^$\"`);\n  expect(hello._zod.pattern.source).toMatchInlineSnapshot(`\"^hello$\"`);\n  expect(world._zod.pattern.source).toMatchInlineSnapshot(`\"^(world)$\"`);\n  expect(one._zod.pattern.source).toMatchInlineSnapshot(`\"^1$\"`);\n  expect(two._zod.pattern.source).toMatchInlineSnapshot(`\"^(2)$\"`);\n  expect(truee._zod.pattern.source).toMatchInlineSnapshot(`\"^true$\"`);\n  expect(anotherTrue._zod.pattern.source).toMatchInlineSnapshot(`\"^(true)$\"`);\n  expect(falsee._zod.pattern.source).toMatchInlineSnapshot(`\"^false$\"`);\n  expect(anotherFalse._zod.pattern.source).toMatchInlineSnapshot(`\"^(false)$\"`);\n  expect(nulll._zod.pattern.source).toMatchInlineSnapshot(`\"^null$\"`);\n  expect(anotherNull._zod.pattern.source).toMatchInlineSnapshot(`\"^null$\"`);\n  expect(undefinedd._zod.pattern.source).toMatchInlineSnapshot(`\"^undefined$\"`);\n  expect(anotherUndefined._zod.pattern.source).toMatchInlineSnapshot(`\"^undefined$\"`);\n  expect(anyString._zod.pattern.source).toMatchInlineSnapshot(`\"^[\\\\s\\\\S]{0,}$\"`);\n  expect(lazyString._zod.pattern.source).toMatchInlineSnapshot(`\"^[\\\\s\\\\S]{0,}$\"`);\n  expect(anyNumber._zod.pattern.source).toMatchInlineSnapshot(`\"^-?\\\\d+(?:\\\\.\\\\d+)?$\"`);\n  expect(anyInt._zod.pattern.source).toMatchInlineSnapshot(`\"^\\\\d+$\"`);\n  // expect(anyFiniteNumber._zod.pattern.source).toMatchInlineSnapshot(`\"^-?\\\\d+(?:\\\\.\\\\d+)?$\"`);\n  // expect(anyNegativeNumber._zod.pattern.source).toMatchInlineSnapshot(`\"^-?\\\\d+(?:\\\\.\\\\d+)?$\"`);\n  // expect(anyPositiveNumber._zod.pattern.source).toMatchInlineSnapshot(`\"^-?\\\\d+(?:\\\\.\\\\d+)?$\"`);\n  // expect(zeroButInADumbWay._zod.pattern.source).toMatchInlineSnapshot(`\"^-?\\\\d+(?:\\\\.\\\\d+)?$\"`);\n  // expect(finiteButInADumbWay._zod.pattern.source).toMatchInlineSnapshot(`\"^-?\\\\d+(?:\\\\.\\\\d+)?$\"`);\n  expect(bool._zod.pattern.source).toMatchInlineSnapshot(`\"^true|false$\"`);\n  expect(bigone._zod.pattern.source).toMatchInlineSnapshot(`\"^(1)$\"`);\n  expect(anyBigint._zod.pattern.source).toMatchInlineSnapshot(`\"^\\\\d+n?$\"`);\n  expect(nullableYo._zod.pattern.source).toMatchInlineSnapshot(`\"^((yo)|null)$\"`);\n  expect(nullableString._zod.pattern.source).toMatchInlineSnapshot(`\"^([\\\\s\\\\S]{0,}|null)$\"`);\n  expect(optionalYeah._zod.pattern.source).toMatchInlineSnapshot(`\"^((yeah))?$\"`);\n  expect(optionalString._zod.pattern.source).toMatchInlineSnapshot(`\"^([\\\\s\\\\S]{0,})?$\"`);\n  expect(optionalNumber._zod.pattern.source).toMatchInlineSnapshot(`\"^(-?\\\\d+(?:\\\\.\\\\d+)?)?$\"`);\n  expect(nullishBruh._zod.pattern.source).toMatchInlineSnapshot(`\"^(((bruh)|null))?$\"`);\n  expect(nullishString._zod.pattern.source).toMatchInlineSnapshot(`\"^(([\\\\s\\\\S]{0,}|null))?$\"`);\n  expect(cuid._zod.pattern.source).toMatchInlineSnapshot(`\"^[cC][^\\\\s-]{8,}$\"`);\n  expect(cuidZZZ._zod.pattern.source).toMatchInlineSnapshot(`\"^[cC][^\\\\s-]{8,}ZZZ$\"`);\n  expect(cuid2._zod.pattern.source).toMatchInlineSnapshot(`\"^[0-9a-z]+$\"`);\n  expect(datetime._zod.pattern.source).toMatchInlineSnapshot(\n    `\"^(?:(?:\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\\\d|30)|(?:02)-(?:0[1-9]|1\\\\d|2[0-8])))T(?:(?:[01]\\\\d|2[0-3]):[0-5]\\\\d(?::[0-5]\\\\d(?:\\\\.\\\\d+)?)?(?:Z))$\"`\n  );\n  expect(email._zod.pattern.source).toMatchInlineSnapshot(\n    `\"^(?!\\\\.)(?!.*\\\\.\\\\.)([A-Za-z0-9_'+\\\\-\\\\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\\\\-]*\\\\.)+[A-Za-z]{2,}$\"`\n  );\n  // expect(ip._zod.pattern.source).toMatchInlineSnapshot(\n  //   `\"^(^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$)|(^(([a-fA-F0-9]{1,4}:){7}|::([a-fA-F0-9]{1,4}:){0,6}|([a-fA-F0-9]{1,4}:){1}:([a-fA-F0-9]{1,4}:){0,5}|([a-fA-F0-9]{1,4}:){2}:([a-fA-F0-9]{1,4}:){0,4}|([a-fA-F0-9]{1,4}:){3}:([a-fA-F0-9]{1,4}:){0,3}|([a-fA-F0-9]{1,4}:){4}:([a-fA-F0-9]{1,4}:){0,2}|([a-fA-F0-9]{1,4}:){5}:([a-fA-F0-9]{1,4}:){0,1})([a-fA-F0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$)$\"`\n  // );\n  expect(ipv4._zod.pattern.source).toMatchInlineSnapshot(\n    `\"^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$\"`\n  );\n  expect(ipv6._zod.pattern.source).toMatchInlineSnapshot(\n    `\"^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$\"`\n  );\n  expect(ulid._zod.pattern.source).toMatchInlineSnapshot(`\"^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$\"`);\n  expect(uuid._zod.pattern.source).toMatchInlineSnapshot(\n    `\"^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$\"`\n  );\n  expect(stringAToZ._zod.pattern.source).toMatchInlineSnapshot(`\"^[a-z]+$\"`);\n  expect(stringStartsWith._zod.pattern.source).toMatchInlineSnapshot(`\"^hello.*$\"`);\n  expect(stringEndsWith._zod.pattern.source).toMatchInlineSnapshot(`\"^.*world$\"`);\n  expect(stringMax5._zod.pattern.source).toMatchInlineSnapshot(`\"^[\\\\s\\\\S]{0,5}$\"`);\n  expect(stringMin5._zod.pattern.source).toMatchInlineSnapshot(`\"^[\\\\s\\\\S]{5,}$\"`);\n  expect(stringLen5._zod.pattern.source).toMatchInlineSnapshot(`\"^[\\\\s\\\\S]{5,5}$\"`);\n  expect(stringMin5Max10._zod.pattern.source).toMatchInlineSnapshot(`\"^[\\\\s\\\\S]{5,10}$\"`);\n  expect(brandedString._zod.pattern.source).toMatchInlineSnapshot(`\"^[\\\\s\\\\S]{1,}$\"`);\n  expect(url._zod.pattern.source).toMatchInlineSnapshot(`\"^https:\\\\/\\\\/\\\\w+\\\\.(com|net)$\"`);\n  expect(measurement._zod.pattern.source).toMatchInlineSnapshot(`\"^-?\\\\d+(?:\\\\.\\\\d+)?((px|em|rem|vh|vw|vmin|vmax))?$\"`);\n  expect(connectionString._zod.pattern.source).toMatchInlineSnapshot(\n    `\"^mongodb:\\\\/\\\\/(\\\\w+:\\\\w+@)?\\\\w+:\\\\d+(\\\\/(\\\\w+)?(\\\\?(\\\\w+=\\\\w+(&\\\\w+=\\\\w+)*)?)?)?$\"`\n  );\n});\n\ntest(\"template literal parsing - success - complex cases\", () => {\n  url.parse(\"https://example.com\");\n  url.parse(\"https://speedtest.net\");\n\n  // measurement.parse(1);\n  // measurement.parse(1.1);\n  // measurement.parse(0);\n  // measurement.parse(-1.1);\n  // measurement.parse(-1);\n  measurement.parse(\"1\");\n  measurement.parse(\"1.1\");\n  measurement.parse(\"0\");\n  measurement.parse(\"-1\");\n  measurement.parse(\"-1.1\");\n  measurement.parse(\"1px\");\n  measurement.parse(\"1.1px\");\n  measurement.parse(\"0px\");\n  measurement.parse(\"-1px\");\n  measurement.parse(\"-1.1px\");\n  measurement.parse(\"1em\");\n  measurement.parse(\"1.1em\");\n  measurement.parse(\"0em\");\n  measurement.parse(\"-1em\");\n  measurement.parse(\"-1.1em\");\n  measurement.parse(\"1rem\");\n  measurement.parse(\"1.1rem\");\n  measurement.parse(\"0rem\");\n  measurement.parse(\"-1rem\");\n  measurement.parse(\"-1.1rem\");\n  measurement.parse(\"1vh\");\n  measurement.parse(\"1.1vh\");\n  measurement.parse(\"0vh\");\n  measurement.parse(\"-1vh\");\n  measurement.parse(\"-1.1vh\");\n  measurement.parse(\"1vw\");\n  measurement.parse(\"1.1vw\");\n  measurement.parse(\"0vw\");\n  measurement.parse(\"-1vw\");\n  measurement.parse(\"-1.1vw\");\n  measurement.parse(\"1vmin\");\n  measurement.parse(\"1.1vmin\");\n  measurement.parse(\"0vmin\");\n  measurement.parse(\"-1vmin\");\n  measurement.parse(\"-1.1vmin\");\n  measurement.parse(\"1vmax\");\n  measurement.parse(\"1.1vmax\");\n  measurement.parse(\"0vmax\");\n  measurement.parse(\"-1vmax\");\n  measurement.parse(\"-1.1vmax\");\n\n  connectionString.parse(\"mongodb://host:1234\");\n  connectionString.parse(\"mongodb://host:1234/\");\n  connectionString.parse(\"mongodb://host:1234/defaultauthdb\");\n  connectionString.parse(\"mongodb://host:1234/defaultauthdb?authSource=admin\");\n  connectionString.parse(\"mongodb://host:1234/defaultauthdb?authSource=admin&connectTimeoutMS=300000\");\n  connectionString.parse(\"mongodb://host:1234/?authSource=admin\");\n  connectionString.parse(\"mongodb://host:1234/?authSource=admin&connectTimeoutMS=300000\");\n  connectionString.parse(\"mongodb://username:password@host:1234\");\n  connectionString.parse(\"mongodb://username:password@host:1234/\");\n  connectionString.parse(\"mongodb://username:password@host:1234/defaultauthdb\");\n  connectionString.parse(\"mongodb://username:password@host:1234/defaultauthdb?authSource=admin\");\n  connectionString.parse(\n    \"mongodb://username:password@host:1234/defaultauthdb?authSource=admin&connectTimeoutMS=300000\"\n  );\n  connectionString.parse(\"mongodb://username:password@host:1234/?authSource=admin\");\n  connectionString.parse(\"mongodb://username:password@host:1234/?authSource=admin&connectTimeoutMS=300000\");\n});\n\ntest(\"template literal parsing - failure - complex cases\", () => {\n  expect(() => url.parse(\"http://example.com\")).toThrow();\n  expect(() => url.parse(\"https://.com\")).toThrow();\n  expect(() => url.parse(\"https://examplecom\")).toThrow();\n  expect(() => url.parse(\"https://example.org\")).toThrow();\n  expect(() => url.parse(\"https://example.net.il\")).toThrow();\n\n  expect(() => measurement.parse(\"1.1.1\")).toThrow();\n  expect(() => measurement.parse(\"Infinity\")).toThrow();\n  expect(() => measurement.parse(\"-Infinity\")).toThrow();\n  expect(() => measurement.parse(\"NaN\")).toThrow();\n  expect(() => measurement.parse(\"1%\")).toThrow();\n\n  expect(() => connectionString.parse(\"mongod://host:1234\")).toThrow();\n  expect(() => connectionString.parse(\"mongodb://:1234\")).toThrow();\n  expect(() => connectionString.parse(\"mongodb://host1234\")).toThrow();\n  expect(() => connectionString.parse(\"mongodb://host:d234\")).toThrow();\n  expect(() => connectionString.parse(\"mongodb://host:12.34\")).toThrow();\n  expect(() => connectionString.parse(\"mongodb://host:-1234\")).toThrow();\n  expect(() => connectionString.parse(\"mongodb://host:-12.34\")).toThrow();\n  expect(() => connectionString.parse(\"mongodb://host:\")).toThrow();\n  expect(() => connectionString.parse(\"mongodb://:password@host:1234\")).toThrow();\n  expect(() => connectionString.parse(\"mongodb://usernamepassword@host:1234\")).toThrow();\n  expect(() => connectionString.parse(\"mongodb://username:@host:1234\")).toThrow();\n  expect(() => connectionString.parse(\"mongodb://@host:1234\")).toThrow();\n  expect(() => connectionString.parse(\"mongodb://host:1234/defaultauthdb?authSourceadmin\")).toThrow();\n  expect(() => connectionString.parse(\"mongodb://host:1234/?authSourceadmin\")).toThrow();\n  expect(() => connectionString.parse(\"mongodb://host:1234/defaultauthdb?&authSource=admin\")).toThrow();\n  expect(() => connectionString.parse(\"mongodb://host:1234/?&authSource=admin\")).toThrow();\n});\n\ntest(\"template literal parsing - failure - issue format\", () => {\n  expect(anotherNull.safeParse(\"1null\")).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"template_literal\",\n        \"pattern\": \"^null$\",\n        \"path\": [],\n        \"message\": \"Invalid input\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(cuidZZZ.safeParse(\"1cjld2cyuq0000t3rmniod1foyZZZ\")).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"template_literal\",\n        \"pattern\": \"^[cC][^\\\\\\\\s-]{8,}ZZZ$\",\n        \"path\": [],\n        \"message\": \"Invalid input\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(stringMin5Max10.safeParse(\"1234\")).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"template_literal\",\n        \"pattern\": \"^[\\\\\\\\s\\\\\\\\S]{5,10}$\",\n        \"path\": [],\n        \"message\": \"Invalid input\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(connectionString.safeParse(\"mongodb://host:1234/defaultauthdb?authSourceadmin\")).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"template_literal\",\n        \"pattern\": \"^mongodb:\\\\\\\\/\\\\\\\\/(\\\\\\\\w+:\\\\\\\\w+@)?\\\\\\\\w+:\\\\\\\\d+(\\\\\\\\/(\\\\\\\\w+)?(\\\\\\\\?(\\\\\\\\w+=\\\\\\\\w+(&\\\\\\\\w+=\\\\\\\\w+)*)?)?)?$\",\n        \"path\": [],\n        \"message\": \"Invalid input\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n\n  expect(stringStartsWithMax5.safeParse(\"1hell\")).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"template_literal\",\n        \"pattern\": \"^hello.*$\",\n        \"path\": [],\n        \"message\": \"Invalid input\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/template-literal.test.ts",
        "start": 1,
        "end": 758,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 758,
          "column": 2,
          "position": 9329
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/template-literal.test.ts",
        "start": 1,
        "end": 758,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 758,
          "column": 2,
          "position": 9329
        }
      }
    },
    {
      "format": "typescript",
      "lines": 66,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ntest(\"z.stringbool\", () => {\n  const a = z.stringbool();\n  type a = z.infer<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<boolean>();\n  type a_in = z.input<typeof a>;\n  expectTypeOf<a_in>().toEqualTypeOf<string>();\n\n  expect(z.parse(a, \"true\")).toEqual(true);\n  expect(z.parse(a, \"yes\")).toEqual(true);\n  expect(z.parse(a, \"1\")).toEqual(true);\n  expect(z.parse(a, \"on\")).toEqual(true);\n  expect(z.parse(a, \"y\")).toEqual(true);\n  expect(z.parse(a, \"enabled\")).toEqual(true);\n  expect(z.parse(a, \"TRUE\")).toEqual(true);\n\n  expect(z.parse(a, \"false\")).toEqual(false);\n  expect(z.parse(a, \"no\")).toEqual(false);\n  expect(z.parse(a, \"0\")).toEqual(false);\n  expect(z.parse(a, \"off\")).toEqual(false);\n  expect(z.parse(a, \"n\")).toEqual(false);\n  expect(z.parse(a, \"disabled\")).toEqual(false);\n  expect(z.parse(a, \"FALSE\")).toEqual(false);\n\n  expect(z.safeParse(a, \"other\")).toMatchObject({ success: false });\n  expect(z.safeParse(a, \"\")).toMatchObject({ success: false });\n  expect(z.safeParse(a, undefined)).toMatchObject({ success: false });\n  expect(z.safeParse(a, {})).toMatchObject({ success: false });\n  expect(z.safeParse(a, true)).toMatchObject({ success: false });\n  expect(z.safeParse(a, false)).toMatchObject({ success: false });\n});\n\ntest(\"custom values\", () => {\n  const b = z.stringbool({\n    truthy: [\"y\"],\n    falsy: [\"N\"],\n  });\n  expect(z.parse(b, \"y\")).toEqual(true);\n  expect(z.parse(b, \"Y\")).toEqual(true);\n  expect(z.parse(b, \"n\")).toEqual(false);\n  expect(z.parse(b, \"N\")).toEqual(false);\n  expect(z.safeParse(b, \"true\")).toMatchObject({ success: false });\n  expect(z.safeParse(b, \"false\")).toMatchObject({ success: false });\n});\n\ntest(\"custom values - case sensitive\", () => {\n  const c = z.stringbool({\n    truthy: [\"y\"],\n    falsy: [\"N\"],\n    case: \"sensitive\",\n  });\n  expect(z.parse(c, \"y\")).toEqual(true);\n  expect(z.safeParse(c, \"Y\")).toMatchObject({ success: false });\n  expect(z.parse(c, \"N\")).toEqual(false);\n  expect(z.safeParse(c, \"n\")).toMatchObject({ success: false });\n  expect(z.safeParse(c, \"TRUE\")).toMatchObject({ success: false });\n});\n\n// test custom error messages\ntest(\"z.stringbool with custom error messages\", () => {\n  const a = z.stringbool(\"wrong!\");\n\n  expect(() => a.parse(\"\")).toThrowError(\"wrong!\");\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/stringbool.test.ts",
        "start": 1,
        "end": 66,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 66,
          "column": 2,
          "position": 998
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/stringbool.test.ts",
        "start": 1,
        "end": 66,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 66,
          "column": 2,
          "position": 998
        }
      }
    },
    {
      "format": "typescript",
      "lines": 881,
      "fragment": "import { randomBytes } from \"node:crypto\";\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\nconst minFive = z.string().min(5, \"min5\");\nconst maxFive = z.string().max(5, \"max5\");\nconst justFive = z.string().length(5);\nconst nonempty = z.string().min(1, \"nonempty\");\nconst includes = z.string().includes(\"includes\");\nconst includesFromIndex2 = z.string().includes(\"includes\", { position: 2 });\nconst startsWith = z.string().startsWith(\"startsWith\");\nconst endsWith = z.string().endsWith(\"endsWith\");\n\ntest(\"length checks\", () => {\n  minFive.parse(\"12345\");\n  minFive.parse(\"123456\");\n  maxFive.parse(\"12345\");\n  maxFive.parse(\"1234\");\n  nonempty.parse(\"1\");\n  justFive.parse(\"12345\");\n\n  expect(() => minFive.parse(\"1234\")).toThrow();\n  expect(() => maxFive.parse(\"123456\")).toThrow();\n  expect(() => nonempty.parse(\"\")).toThrow();\n  expect(() => justFive.parse(\"1234\")).toThrow();\n  expect(() => justFive.parse(\"123456\")).toThrow();\n});\n\ntest(\"includes\", () => {\n  includes.parse(\"XincludesXX\");\n  includesFromIndex2.parse(\"XXXincludesXX\");\n\n  expect(() => includes.parse(\"XincludeXX\")).toThrow();\n  expect(() => includesFromIndex2.parse(\"XincludesXX\")).toThrow();\n});\n\ntest(\"startswith/endswith\", () => {\n  startsWith.parse(\"startsWithX\");\n  endsWith.parse(\"XendsWith\");\n\n  expect(() => startsWith.parse(\"x\")).toThrow();\n  expect(() => endsWith.parse(\"x\")).toThrow();\n});\n\ntest(\"email validations\", () => {\n  const validEmails = [\n    `email@domain.com`,\n    `firstname.lastname@domain.com`,\n    `email@subdomain.domain.com`,\n    `firstname+lastname@domain.com`,\n    `1234567890@domain.com`,\n    `email@domain-one.com`,\n    `_______@domain.com`,\n    `email@domain.name`,\n    `email@domain.co.jp`,\n    `firstname-lastname@domain.com`,\n    `very.common@example.com`,\n    `disposable.style.email.with+symbol@example.com`,\n    `other.email-with-hyphen@example.com`,\n    `fully-qualified-domain@example.com`,\n    `user.name+tag+sorting@example.com`,\n    `x@example.com`,\n    `mojojojo@asdf.example.com`,\n    `example-indeed@strange-example.com`,\n    `example@s.example`,\n    `user-@example.org`,\n    `user@my-example.com`,\n    `a@b.cd`,\n    `work+user@mail.com`,\n    `tom@test.te-st.com`,\n    `something@subdomain.domain-with-hyphens.tld`,\n    `common'name@domain.com`,\n    `francois@etu.inp-n7.fr`,\n  ];\n  const invalidEmails = [\n    // no \"printable characters\"\n    // `user%example.com@example.org`,\n    // `mailhost!username@example.org`,\n    // `test/test@test.com`,\n\n    // double @\n    `francois@@etu.inp-n7.fr`,\n    // do not support quotes\n    `\"email\"@domain.com`,\n    `\"e asdf sadf ?<>ail\"@domain.com`,\n    `\" \"@example.org`,\n    `\"john..doe\"@example.org`,\n    `\"very.(),:;<>[]\\\".VERY.\\\"very@\\\\ \\\"very\\\".unusual\"@strange.example.com`,\n    // do not support comma\n    `a,b@domain.com`,\n\n    // do not support IPv4\n    `email@123.123.123.123`,\n    `email@[123.123.123.123]`,\n    `postmaster@123.123.123.123`,\n    `user@[68.185.127.196]`,\n    `ipv4@[85.129.96.247]`,\n    `valid@[79.208.229.53]`,\n    `valid@[255.255.255.255]`,\n    `valid@[255.0.55.2]`,\n    `valid@[255.0.55.2]`,\n\n    // do not support ipv6\n    `hgrebert0@[IPv6:4dc8:ac7:ce79:8878:1290:6098:5c50:1f25]`,\n    `bshapiro4@[IPv6:3669:c709:e981:4884:59a3:75d1:166b:9ae]`,\n    `jsmith@[IPv6:2001:db8::1]`,\n    `postmaster@[IPv6:2001:0db8:85a3:0000:0000:8a2e:0370:7334]`,\n    `postmaster@[IPv6:2001:0db8:85a3:0000:0000:8a2e:0370:192.168.1.1]`,\n\n    // microsoft test cases\n    `plainaddress`,\n    `#@%^%#$@#$@#.com`,\n    `@domain.com`,\n    `Joe Smith &lt;email@domain.com&gt;`,\n    `email.domain.com`,\n    `email@domain@domain.com`,\n    `.email@domain.com`,\n    `email.@domain.com`,\n    `email..email@domain.com`,\n    `@domain.com`,\n    `email@domain.com (Joe Smith)`,\n    `email@domain`,\n    `email@-domain.com`,\n    `email@111.222.333.44444`,\n    `email@domain..com`,\n    `Abc.example.com`,\n    `A@b@c@example.com`,\n    `colin..hacks@domain.com`,\n    `a\"b(c)d,e:f;g<h>i[j\\k]l@example.com`,\n    `just\"not\"right@example.com`,\n    `this is\"not\\allowed@example.com`,\n    `this\\ still\\\"not\\\\allowed@example.com`,\n\n    // random\n    `i_like_underscore@but_its_not_allowed_in_this_part.example.com`,\n    `QA[icon]CHOCOLATE[icon]@test.com`,\n    `invalid@-start.com`,\n    `invalid@end.com-`,\n    `a.b@c.d`,\n    `invalid@[1.1.1.-1]`,\n    `invalid@[68.185.127.196.55]`,\n    `temp@[192.168.1]`,\n    `temp@[9.18.122.]`,\n    `double..point@test.com`,\n    `asdad@test..com`,\n    `asdad@hghg...sd...au`,\n    `asdad@hghg........au`,\n    `invalid@[256.2.2.48]`,\n    `invalid@[256.2.2.48]`,\n    `invalid@[999.465.265.1]`,\n    `jkibbey4@[IPv6:82c4:19a8::70a9:2aac:557::ea69:d985:28d]`,\n    `mlivesay3@[9952:143f:b4df:2179:49a1:5e82:b92e:6b6]`,\n    `gbacher0@[IPv6:bc37:4d3f:5048:2e26:37cc:248e:df8e:2f7f:af]`,\n    `invalid@[IPv6:5348:4ed3:5d38:67fb:e9b:acd2:c13:192.168.256.1]`,\n    `test@.com`,\n    `aaaaaaaaaaaaaaalongemailthatcausesregexDoSvulnerability@test.c`,\n  ];\n  const emailSchema = z.string().email();\n\n  expect(\n    validEmails.every((email) => {\n      return emailSchema.safeParse(email).success;\n    })\n  ).toBe(true);\n  expect(\n    invalidEmails.every((email) => {\n      return emailSchema.safeParse(email).success === false;\n    })\n  ).toBe(true);\n});\n\ntest(\"base64 validations\", () => {\n  const validBase64Strings = [\n    \"SGVsbG8gV29ybGQ=\", // \"Hello World\"\n    \"VGhpcyBpcyBhbiBlbmNvZGVkIHN0cmluZw==\", // \"This is an encoded string\"\n    \"TWFueSBoYW5kcyBtYWtlIGxpZ2h0IHdvcms=\", // \"Many hands make light work\"\n    \"UGF0aWVuY2UgaXMgdGhlIGtleSB0byBzdWNjZXNz\", // \"Patience is the key to success\"\n    \"QmFzZTY0IGVuY29kaW5nIGlzIGZ1bg==\", // \"Base64 encoding is fun\"\n    \"MTIzNDU2Nzg5MA==\", // \"1234567890\"\n    \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo=\", // \"abcdefghijklmnopqrstuvwxyz\"\n    \"QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVo=\", // \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    \"ISIkJSMmJyonKCk=\", // \"!\\\"#$%&'()*\"\n    \"\", // Empty string is technically a valid base64\n  ];\n\n  for (const str of validBase64Strings) {\n    expect(str + z.string().base64().safeParse(str).success).toBe(`${str}true`);\n  }\n\n  const invalidBase64Strings = [\n    \"12345\", // Not padded correctly, not a multiple of 4 characters\n    \"SGVsbG8gV29ybGQ\", // Missing padding\n    \"VGhpcyBpcyBhbiBlbmNvZGVkIHN0cmluZw\", // Missing padding\n    \"!UGF0aWVuY2UgaXMgdGhlIGtleSB0byBzdWNjZXNz\", // Invalid character '!'\n    \"?QmFzZTY0IGVuY29kaW5nIGlzIGZ1bg==\", // Invalid character '?'\n    \".MTIzND2Nzg5MC4=\", // Invalid character '.'\n    \"QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVo\", // Missing padding\n  ];\n\n  for (const str of invalidBase64Strings) {\n    expect(str + z.string().base64().safeParse(str).success).toBe(`${str}false`);\n  }\n});\n\ntest(\"base64url validations\", () => {\n  const base64url = z.string().base64url();\n\n  const validBase64URLStrings = [\n    \"SGVsbG8gV29ybGQ\", // \"Hello World\"\n\n    \"VGhpcyBpcyBhbiBlbmNvZGVkIHN0cmluZw\", // \"This is an encoded string\"\n\n    \"TWFueSBoYW5kcyBtYWtlIGxpZ2h0IHdvcms\", // \"Many hands make light work\"\n\n    \"UGF0aWVuY2UgaXMgdGhlIGtleSB0byBzdWNjZXNz\", // \"Patience is the key to success\"\n    \"QmFzZTY0IGVuY29kaW5nIGlzIGZ1bg\", // \"Base64 encoding is fun\"\n\n    \"MTIzNDU2Nzg5MA\", // \"1234567890\"\n\n    \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo\", // \"abcdefghijklmnopqrstuvwxyz\"\n\n    \"QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVo\", // \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n    \"ISIkJSMmJyonKCk\", // \"!\\\"#$%&'()*\"\n\n    \"\", // Empty string is technically valid base64url\n    \"w7_Dv8O-w74K\", // \n    \"123456\",\n  ];\n\n  for (const str of validBase64URLStrings) {\n    expect(str + base64url.safeParse(str).success).toBe(`${str}true`);\n  }\n\n  const invalidBase64URLStrings = [\n    \"w7/Dv8O+w74K\", // Has + and / characters (is base64)\n    \"12345\", // Invalid length (not a multiple of 4 characters when adding allowed number of padding characters)\n    \"12345===\", // Not padded correctly\n    \"!UGF0aWVuY2UgaXMgdGhlIGtleSB0byBzdWNjZXNz\", // Invalid character '!'\n    \"?QmFzZTY0IGVuY29kaW5nIGlzIGZ1bg==\", // Invalid character '?'\n    \".MTIzND2Nzg5MC4=\", // Invalid character '.'\n\n    // disallow valid padding\n    \"SGVsbG8gV29ybGQ=\", // \"Hello World\" with padding\n    \"VGhpcyBpcyBhbiBlbmNvZGVkIHN0cmluZw==\", // \"This is an encoded string\" with padding\n    \"TWFueSBoYW5kcyBtYWtlIGxpZ2h0IHdvcms=\", // \"Many hands make light work\" with padding\n    \"QmFzZTY0IGVuY29kaW5nIGlzIGZ1bg==\", // \"Base64 encoding is fun\" with padding\n    \"MTIzNDU2Nzg5MA==\", // \"1234567890\" with padding\n    \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo=\", // \"abcdefghijklmnopqrstuvwxyz with padding\"\n    \"QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVo=\", // \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" with padding\n    \"ISIkJSMmJyonKCk=\", // \"!\\\"#$%&'()*\" with padding\n  ];\n\n  for (const str of invalidBase64URLStrings) {\n    expect(str + base64url.safeParse(str).success).toBe(`${str}false`);\n  }\n});\n\ntest(\"big base64 and base64url\", () => {\n  const bigbase64 = randomBytes(1024 * 1024 * 10).toString(\"base64\");\n  z.base64().parse(bigbase64);\n  const bigbase64url = randomBytes(1024 * 1024 * 10).toString(\"base64url\");\n  z.base64url().parse(bigbase64url);\n});\n\nfunction makeJwt(header: object, payload: object) {\n  const headerBase64 = Buffer.from(JSON.stringify(header)).toString(\"base64url\");\n  const payloadBase64 = Buffer.from(JSON.stringify(payload)).toString(\"base64url\");\n  const signature = \"signature\"; // Placeholder for the signature\n  return `${headerBase64}.${payloadBase64}.${signature}`;\n}\n\ntest(\"jwt token\", () => {\n  const jwt = z.string().jwt();\n  expect(() => jwt.parse(\"invalid\")).toThrow();\n  expect(() => jwt.parse(\"invalid.invalid\")).toThrow();\n  expect(() => jwt.parse(\"invalid.invalid.invalid\")).toThrow();\n\n  // Valid JWTs\n  const es256jwt = z.string().jwt({ alg: \"ES256\" });\n  const d1 = makeJwt({ typ: \"JWT\", alg: \"ES256\" }, {});\n  jwt.parse(d1);\n  es256jwt.parse(d1);\n\n  // Invalid header\n  const d2 = makeJwt({}, {});\n  expect(() => jwt.parse(d2)).toThrow();\n\n  // Wrong algorithm\n  const d3 = makeJwt({ typ: \"JWT\", alg: \"RS256\" }, {});\n  expect(() => es256jwt.parse(d3)).toThrow();\n\n  // missing typ is fine\n  const d4 = makeJwt({ alg: \"HS256\" }, {});\n  jwt.parse(d4);\n\n  // type isn't JWT\n  const d5 = makeJwt({ typ: \"SUP\", alg: \"HS256\" }, { foo: \"bar\" });\n  expect(() => jwt.parse(d5)).toThrow();\n});\n\ntest(\"url validations\", () => {\n  const url = z.string().url();\n  url.parse(\"http://google.com\");\n  url.parse(\"https://google.com/asdf?asdf=ljk3lk4&asdf=234#asdf\");\n  url.parse(\"https://anonymous:flabada@developer.mozilla.org/en-US/docs/Web/API/URL/password\");\n  url.parse(\"https://localhost\");\n  url.parse(\"https://my.local\");\n  url.parse(\"http://aslkfjdalsdfkjaf\");\n  url.parse(\"http://localhost\");\n\n  url.parse(\"c:\");\n\n  expect(() => url.parse(\"asdf\")).toThrow();\n  expect(() => url.parse(\"https:/\")).toThrow();\n  expect(() => url.parse(\"asdfj@lkjsdf.com\")).toThrow();\n  expect(() => url.parse(\"https://\")).toThrow();\n});\n\ntest(\"httpurl\", () => {\n  const httpUrl = z.url({\n    protocol: /^https?$/,\n    hostname: z.regexes.domain,\n    // /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,}$/\n  });\n\n  httpUrl.parse(\"https://example.com\");\n  httpUrl.parse(\"http://example.com\");\n  // ports\n  httpUrl.parse(\"https://example.com:8080\");\n  httpUrl.parse(\"http://example.com:8080\");\n  // subdomains\n  httpUrl.parse(\"https://sub.example.com\");\n  httpUrl.parse(\"http://sub.example.com\");\n  // paths\n  httpUrl.parse(\"https://example.com/path/to/resource\");\n  httpUrl.parse(\"http://example.com/path/to/resource\");\n  // query parameters\n  httpUrl.parse(\"https://example.com/path?query=param\");\n  httpUrl.parse(\"http://example.com/path?query=param\");\n  // fragment identifiers\n  httpUrl.parse(\"https://example.com/path#fragment\");\n  httpUrl.parse(\"http://example.com/path#fragment\");\n  // fails\n  expect(() => httpUrl.parse(\"ftp://example.com\")).toThrow();\n  expect(() => httpUrl.parse(\"shttp://example.com\")).toThrow();\n  expect(() => httpUrl.parse(\"httpz://example.com\")).toThrow();\n  expect(() => httpUrl.parse(\"http://\")).toThrow();\n  expect(() => httpUrl.parse(\"http://localhost\")).toThrow();\n  expect(() => httpUrl.parse(\"http://-asdf.com\")).toThrow();\n  expect(() =>\n    httpUrl.parse(\n      \"http://asdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdf.com\"\n    )\n  ).toThrow();\n  expect(() => httpUrl.parse(\"http://asdf.c\")).toThrow();\n  expect(() => httpUrl.parse(\"mailto:asdf@lckj.com\")).toThrow();\n});\n\ntest(\"url error overrides\", () => {\n  try {\n    z.string().url().parse(\"https\");\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"Invalid URL\");\n  }\n  try {\n    z.string().url(\"badurl\").parse(\"https\");\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"badurl\");\n  }\n  try {\n    z.string().url({ message: \"badurl\" }).parse(\"https\");\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"badurl\");\n  }\n});\n\ntest(\"emoji validations\", () => {\n  const emoji = z.string().emoji();\n\n  emoji.parse(\"\");\n  emoji.parse(\"\");\n  emoji.parse(\"\");\n  emoji.parse(\"\");\n  emoji.parse(\"\");\n  emoji.parse(\n    \"##**00112233445566778899\"\n  );\n  expect(() => emoji.parse(\":-)\")).toThrow();\n  expect(() => emoji.parse(\" is an emoji\")).toThrow();\n  expect(() => emoji.parse(\"stuff\")).toThrow();\n  expect(() => emoji.parse(\"stuff\")).toThrow();\n});\n\ntest(\"nanoid\", () => {\n  const nanoid = z.string().nanoid(\"custom error\");\n  nanoid.parse(\"lfNZluvAxMkf7Q8C5H-QS\");\n  nanoid.parse(\"mIU_4PJWikaU8fMbmkouz\");\n  nanoid.parse(\"Hb9ZUtUa2JDm_dD-47EGv\");\n  nanoid.parse(\"5Noocgv_8vQ9oPijj4ioQ\");\n  const result = nanoid.safeParse(\"Xq90uDyhddC53KsoASYJGX\");\n  expect(result).toMatchObject({ success: false });\n\n  expect(result.error!.issues[0].message).toEqual(\"custom error\");\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"origin\": \"string\",\n        \"code\": \"invalid_format\",\n        \"format\": \"nanoid\",\n        \"pattern\": \"/^[a-zA-Z0-9_-]{21}$/\",\n        \"path\": [],\n        \"message\": \"custom error\"\n      }\n    ]]\n  `);\n});\n\ntest(\"bad nanoid\", () => {\n  const nanoid = z.string().nanoid(\"custom error\");\n  nanoid.parse(\"ySh_984wpDUu7IQRrLXAp\");\n  const result = nanoid.safeParse(\"invalid nanoid\");\n  expect(result).toMatchObject({ success: false });\n\n  expect(result.error!.issues[0].message).toEqual(\"custom error\");\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"origin\": \"string\",\n        \"code\": \"invalid_format\",\n        \"format\": \"nanoid\",\n        \"pattern\": \"/^[a-zA-Z0-9_-]{21}$/\",\n        \"path\": [],\n        \"message\": \"custom error\"\n      }\n    ]]\n  `);\n});\n\ntest(\"good uuid\", () => {\n  const uuid = z.string().uuid(\"custom error\");\n  const goodUuids = [\n    \"9491d710-3185-1e06-bea0-6a2f275345e0\",\n    \"9491d710-3185-2e06-bea0-6a2f275345e0\",\n    \"9491d710-3185-3e06-bea0-6a2f275345e0\",\n    \"9491d710-3185-4e06-bea0-6a2f275345e0\",\n    \"9491d710-3185-5e06-bea0-6a2f275345e0\",\n    \"9491d710-3185-5e06-aea0-6a2f275345e0\",\n    \"9491d710-3185-5e06-8ea0-6a2f275345e0\",\n    \"9491d710-3185-5e06-9ea0-6a2f275345e0\",\n    \"00000000-0000-0000-0000-000000000000\",\n  ];\n\n  for (const goodUuid of goodUuids) {\n    const result = uuid.safeParse(goodUuid);\n    expect(result.success).toEqual(true);\n  }\n});\n\ntest(`bad uuid`, () => {\n  const uuid = z.string().uuid(\"custom error\");\n  for (const badUuid of [\n    \"9491d710-3185-0e06-bea0-6a2f275345e0\",\n    \"9491d710-3185-5e06-0ea0-6a2f275345e0\",\n    \"d89e7b01-7598-ed11-9d7a-0022489382fd\", // new sequential id\n    \"b3ce60f8-e8b9-40f5-1150-172ede56ff74\", // Variant 0 - RFC 4122: Reserved, NCS backward compatibility\n    \"92e76bf9-28b3-4730-cd7f-cb6bc51f8c09\", // Variant 2 - RFC 4122: Reserved, Microsoft Corporation backward compatibility\n    \"invalid uuid\",\n    \"9491d710-3185-4e06-bea0-6a2f275345e0X\",\n    \"ffffffff-ffff-ffff-ffff-ffffffffffff\",\n  ]) {\n    const result = uuid.safeParse(badUuid);\n    expect(result).toMatchObject({ success: false });\n    expect(result.error?.issues[0].message).toEqual(\"custom error\");\n  }\n});\n\ntest(\"good guid\", () => {\n  const guid = z.string().guid(\"custom error\");\n  for (const goodGuid of [\n    \"9491d710-3185-4e06-bea0-6a2f275345e0\",\n    \"d89e7b01-7598-ed11-9d7a-0022489382fd\", // new sequential id\n    \"b3ce60f8-e8b9-40f5-1150-172ede56ff74\", // Variant 0 - RFC 4122: Reserved, NCS backward compatibility\n    \"92e76bf9-28b3-4730-cd7f-cb6bc51f8c09\", // Variant 2 - RFC 4122: Reserved, Microsoft Corporation backward compatibility\n    \"00000000-0000-0000-0000-000000000000\",\n    \"ffffffff-ffff-ffff-ffff-ffffffffffff\",\n  ]) {\n    const result = guid.safeParse(goodGuid);\n    expect(result.success).toEqual(true);\n  }\n});\n\ntest(\"bad guid\", () => {\n  const guid = z.string().guid(\"custom error\");\n  for (const badGuid of [\"9491d710-3185-4e06-bea0-6a2f275345e0X\"]) {\n    const result = guid.safeParse(badGuid);\n    expect(result).toMatchObject({ success: false });\n    expect(result.error?.issues[0].message).toEqual(\"custom error\");\n  }\n});\n\ntest(\"cuid\", () => {\n  const cuid = z.string().cuid();\n  cuid.parse(\"ckopqwooh000001la8mbi2im9\");\n  const result = cuid.safeParse(\"cifjhdsfhsd-invalid-cuid\");\n  expect(result).toMatchObject({ success: false });\n\n  expect(result.error!.issues[0].message).toEqual(\"Invalid cuid\");\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"origin\": \"string\",\n        \"code\": \"invalid_format\",\n        \"format\": \"cuid\",\n        \"pattern\": \"/^[cC][^\\\\\\\\s-]{8,}$/\",\n        \"path\": [],\n        \"message\": \"Invalid cuid\"\n      }\n    ]]\n  `);\n});\n\ntest(\"cuid2\", () => {\n  const cuid2 = z.string().cuid2();\n  const validStrings = [\n    \"a\", // short string\n    \"tz4a98xxat96iws9zmbrgj3a\", // normal string\n    \"kf5vz6ssxe4zjcb409rjgo747tc5qjazgptvotk6\", // longer than require(\"@paralleldrive/cuid2\").bigLength\n  ];\n  for (const s of validStrings) {\n    cuid2.parse(s);\n  }\n\n  const invalidStrings = [\n    \"\", // empty string\n    \"tz4a98xxat96iws9zMbrgj3a\", // include uppercase\n    \"tz4a98xxat96iws-zmbrgj3a\", // involve symbols\n  ];\n  const results = invalidStrings.map((s) => cuid2.safeParse(s));\n  expect(results.every((r) => !r.success)).toEqual(true);\n  if (!results[0].success) {\n    expect(results[0].error.issues[0].message).toEqual(\"Invalid cuid2\");\n  }\n});\n\ntest(\"ulid\", () => {\n  const ulid = z.string().ulid();\n  ulid.parse(\"01ARZ3NDEKTSV4RRFFQ69G5FAV\");\n  const result = ulid.safeParse(\"invalidulid\");\n  expect(result).toMatchObject({ success: false });\n  const tooLong = \"01ARZ3NDEKTSV4RRFFQ69G5FAVA\";\n  expect(ulid.safeParse(tooLong)).toMatchObject({ success: false });\n\n  const caseInsensitive = ulid.safeParse(\"01arZ3nDeKTsV4RRffQ69G5FAV\");\n  expect(caseInsensitive.success).toEqual(true);\n\n  expect(result.error!.issues[0].message).toEqual(\"Invalid ULID\");\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"origin\": \"string\",\n        \"code\": \"invalid_format\",\n        \"format\": \"ulid\",\n        \"pattern\": \"/^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/\",\n        \"path\": [],\n        \"message\": \"Invalid ULID\"\n      }\n    ]]\n  `);\n});\n\ntest(\"xid\", () => {\n  const xid = z.string().xid();\n  xid.parse(\"9m4e2mr0ui3e8a215n4g\");\n  const result = xid.safeParse(\"invalidxid\");\n  expect(result).toMatchObject({ success: false });\n\n  expect(result.error!.issues[0].message).toEqual(\"Invalid XID\");\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"origin\": \"string\",\n        \"code\": \"invalid_format\",\n        \"format\": \"xid\",\n        \"pattern\": \"/^[0-9a-vA-V]{20}$/\",\n        \"path\": [],\n        \"message\": \"Invalid XID\"\n      }\n    ]]\n  `);\n});\n\ntest(\"ksuid\", () => {\n  const ksuid = z.string().ksuid();\n  ksuid.parse(\"0o0t9hkGxgFLtd3lmJ4TSTeY0Vb\");\n  const result = ksuid.safeParse(\"invalidksuid\");\n  expect(result).toMatchObject({ success: false });\n  const tooLong = \"0o0t9hkGxgFLtd3lmJ4TSTeY0VbA\";\n  expect(ksuid.safeParse(tooLong)).toMatchObject({ success: false });\n  expect(result.error!.issues).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"ksuid\",\n        \"message\": \"Invalid KSUID\",\n        \"origin\": \"string\",\n        \"path\": [],\n        \"pattern\": \"/^[A-Za-z0-9]{27}$/\",\n      },\n    ]\n  `);\n});\n\ntest(\"regex\", () => {\n  z.string()\n    .regex(/^moo+$/)\n    .parse(\"mooooo\");\n  expect(() => z.string().uuid().parse(\"purr\")).toThrow();\n});\n\ntest(\"regexp error message\", () => {\n  const result = z\n    .string()\n    .regex(/^moo+$/)\n    .safeParse(\"boooo\");\n  expect(result.error!.issues).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"regex\",\n        \"message\": \"Invalid string: must match pattern /^moo+$/\",\n        \"origin\": \"string\",\n        \"path\": [],\n        \"pattern\": \"/^moo+$/\",\n      },\n    ]\n  `);\n\n  expect(() => z.string().uuid().parse(\"purr\")).toThrow();\n});\n\ntest(\"regexp error custom message\", () => {\n  const result = z\n    .string()\n    .regex(/^moo+$/, { message: \"Custom error message\" })\n    .safeParse(\"boooo\");\n  expect(result.error!.issues).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"regex\",\n        \"message\": \"Custom error message\",\n        \"origin\": \"string\",\n        \"path\": [],\n        \"pattern\": \"/^moo+$/\",\n      },\n    ]\n  `);\n\n  expect(() => z.string().uuid().parse(\"purr\")).toThrow();\n});\n\ntest(\"regex lastIndex reset\", () => {\n  const schema = z.string().regex(/^\\d+$/g);\n  expect(schema.safeParse(\"123\").success).toEqual(true);\n  expect(schema.safeParse(\"123\").success).toEqual(true);\n  expect(schema.safeParse(\"123\").success).toEqual(true);\n  expect(schema.safeParse(\"123\").success).toEqual(true);\n  expect(schema.safeParse(\"123\").success).toEqual(true);\n});\n\ntest(\"format\", () => {\n  expect(z.string().email().format).toEqual(\"email\");\n  expect(z.string().url().format).toEqual(\"url\");\n  expect(z.string().jwt().format).toEqual(\"jwt\");\n  expect(z.string().emoji().format).toEqual(\"emoji\");\n  expect(z.string().guid().format).toEqual(\"guid\");\n  expect(z.string().uuid().format).toEqual(\"uuid\");\n  expect(z.string().uuidv4().format).toEqual(\"uuid\");\n  expect(z.string().uuidv6().format).toEqual(\"uuid\");\n  expect(z.string().uuidv7().format).toEqual(\"uuid\");\n  expect(z.string().nanoid().format).toEqual(\"nanoid\");\n  expect(z.string().guid().format).toEqual(\"guid\");\n  expect(z.string().cuid().format).toEqual(\"cuid\");\n  expect(z.string().cuid2().format).toEqual(\"cuid2\");\n  expect(z.string().ulid().format).toEqual(\"ulid\");\n  expect(z.string().base64().format).toEqual(\"base64\");\n  // expect(z.string().jsonString().format).toEqual(\"json_string\");\n  // expect(z.string().json().format).toEqual(\"json_string\");\n  expect(z.string().xid().format).toEqual(\"xid\");\n  expect(z.string().ksuid().format).toEqual(\"ksuid\");\n  // expect(z.string().ip().format).toEqual(\"ip\");\n  expect(z.string().ipv4().format).toEqual(\"ipv4\");\n  expect(z.string().ipv6().format).toEqual(\"ipv6\");\n  expect(z.string().e164().format).toEqual(\"e164\");\n  expect(z.string().datetime().format).toEqual(\"datetime\");\n  expect(z.string().date().format).toEqual(\"date\");\n  expect(z.string().time().format).toEqual(\"time\");\n  expect(z.string().duration().format).toEqual(\"duration\");\n});\n\ntest(\"min max getters\", () => {\n  expect(z.string().min(5).minLength).toEqual(5);\n  expect(z.string().min(5).min(10).minLength).toEqual(10);\n  expect(z.string().minLength).toEqual(null);\n\n  expect(z.string().max(5).maxLength).toEqual(5);\n  expect(z.string().max(5).max(1).maxLength).toEqual(1);\n  expect(z.string().max(5).max(10).maxLength).toEqual(5);\n  expect(z.string().maxLength).toEqual(null);\n});\n\ntest(\"trim\", () => {\n  expect(z.string().trim().min(2).parse(\" 12 \")).toEqual(\"12\");\n\n  // ordering of methods is respected\n  expect(z.string().min(2).trim().parse(\" 1 \")).toEqual(\"1\");\n  expect(() => z.string().trim().min(2).parse(\" 1 \")).toThrow();\n});\n\ntest(\"lowerCase\", () => {\n  expect(z.string().toLowerCase().parse(\"ASDF\")).toEqual(\"asdf\");\n  expect(z.string().toUpperCase().parse(\"asdf\")).toEqual(\"ASDF\");\n});\n\n// test(\"IP validation\", () => {\n//   const ipSchema = z.string().ip();\n\n//   // General IP validation (accepts both v4 and v6)\n//   expect(ipSchema.safeParse(\"114.71.82.94\").success).toBe(true);\n//   expect(ipSchema.safeParse(\"0.0.0.0\").success).toBe(true);\n//   expect(ipSchema.safeParse(\"37.85.236.115\").success).toBe(true);\n//   expect(ipSchema.safeParse(\"1e5e:e6c8:daac:514b:114b:e360:d8c0:682c\").success).toBe(true);\n//   expect(ipSchema.safeParse(\"9d4:c956:420f:5788:4339:9b3b:2418:75c3\").success).toBe(true);\n//   expect(ipSchema.safeParse(\"a6ea::2454:a5ce:94.105.123.75\").success).toBe(true);\n//   expect(ipSchema.safeParse(\"474f:4c83::4e40:a47:ff95:0cda\").success).toBe(true);\n//   expect(ipSchema.safeParse(\"d329:0:25b4:db47:a9d1:0:4926:0000\").success).toBe(true);\n//   expect(ipSchema.safeParse(\"e48:10fb:1499:3e28:e4b6:dea5:4692:912c\").success).toBe(true);\n\n//   expect(ipSchema.safeParse(\"d329:1be4:25b4:db47:a9d1:dc71:4926:992c:14af\").success).toBe(false);\n//   expect(ipSchema.safeParse(\"d5e7:7214:2b78::3906:85e6:53cc:709:32ba\").success).toBe(false);\n//   expect(ipSchema.safeParse(\"8f69::c757:395e:976e::3441\").success).toBe(false);\n//   expect(ipSchema.safeParse(\"54cb::473f:d516:0.255.256.22\").success).toBe(false);\n//   expect(ipSchema.safeParse(\"54cb::473f:d516:192.168.1\").success).toBe(false);\n//   expect(ipSchema.safeParse(\"256.0.4.4\").success).toBe(false);\n//   expect(ipSchema.safeParse(\"-1.0.555.4\").success).toBe(false);\n//   expect(ipSchema.safeParse(\"0.0.0.0.0\").success).toBe(false);\n//   expect(ipSchema.safeParse(\"1.1.1\").success).toBe(false);\n// });\n\ntest(\"IPv4 validation\", () => {\n  const ipv4 = z.string().ipv4();\n\n  // Valid IPv4 addresses\n  expect(ipv4.safeParse(\"114.71.82.94\").success).toBe(true);\n  expect(ipv4.safeParse(\"0.0.0.0\").success).toBe(true);\n  expect(ipv4.safeParse(\"37.85.236.115\").success).toBe(true);\n  expect(ipv4.safeParse(\"192.168.0.1\").success).toBe(true);\n  expect(ipv4.safeParse(\"255.255.255.255\").success).toBe(true);\n  expect(ipv4.safeParse(\"1.2.3.4\").success).toBe(true);\n\n  // Invalid IPv4 addresses\n  expect(ipv4.safeParse(\"256.0.4.4\").success).toBe(false);\n  expect(ipv4.safeParse(\"-1.0.555.4\").success).toBe(false);\n  expect(ipv4.safeParse(\"0.0.0.0.0\").success).toBe(false);\n  expect(ipv4.safeParse(\"1.1.1\").success).toBe(false);\n  expect(ipv4.safeParse(\"1e5e:e6c8:daac:514b:114b:e360:d8c0:682c\").success).toBe(false);\n  expect(ipv4.safeParse(\"a6ea::2454:a5ce:94.105.123.75\").success).toBe(false);\n  expect(ipv4.safeParse(\"not an ip\").success).toBe(false);\n  expect(ipv4.safeParse(\"1.2.3\").success).toBe(false);\n  expect(ipv4.safeParse(\"1.2.3.4.5\").success).toBe(false);\n  expect(ipv4.safeParse(\"1.2.3.256\").success).toBe(false);\n\n  // Test specific error\n  expect(() => ipv4.parse(\"6097:adfa:6f0b:220d:db08:5021:6191:7990\")).toThrow();\n});\n\ntest(\"IPv6 validation\", () => {\n  const ipv6 = z.string().ipv6();\n\n  // Valid IPv6 addresses\n  expect(ipv6.safeParse(\"1e5e:e6c8:daac:514b:114b:e360:d8c0:682c\").success).toBe(true);\n  expect(ipv6.safeParse(\"9d4:c956:420f:5788:4339:9b3b:2418:75c3\").success).toBe(true);\n  expect(ipv6.safeParse(\"a6ea::2454:a5ce:94.105.123.75\").success).toBe(true);\n  expect(ipv6.safeParse(\"474f:4c83::4e40:a47:ff95:0cda\").success).toBe(true);\n  expect(ipv6.safeParse(\"d329:0:25b4:db47:a9d1:0:4926:0000\").success).toBe(true);\n  expect(ipv6.safeParse(\"e48:10fb:1499:3e28:e4b6:dea5:4692:912c\").success).toBe(true);\n  expect(ipv6.safeParse(\"::1\").success).toBe(true);\n  expect(ipv6.safeParse(\"2001:db8::\").success).toBe(true);\n  expect(ipv6.safeParse(\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\").success).toBe(true);\n  expect(ipv6.safeParse(\"2001:db8::192.168.0.1\").success).toBe(true);\n  expect(ipv6.safeParse(\"::ffff:192.168.0.1\").success).toBe(true);\n  expect(ipv6.safeParse(\"::ffff:c000:0280\").success).toBe(true); // IPv4-mapped IPv6 address\n  expect(ipv6.safeParse(\"64:ff9b::192.168.0.1\").success).toBe(true); // IPv4/IPv6 translation\n\n  // Invalid IPv6 addresses\n  expect(ipv6.safeParse(\"d329:1be4:25b4:db47:a9d1:dc71:4926:992c:14af\").success).toBe(false);\n  expect(ipv6.safeParse(\"d5e7:7214:2b78::3906:85e6:53cc:709:32ba\").success).toBe(false);\n  expect(ipv6.safeParse(\"8f69::c757:395e:976e::3441\").success).toBe(false);\n  expect(ipv6.safeParse(\"54cb::473f:d516:0.255.256.22\").success).toBe(false);\n  expect(ipv6.safeParse(\"54cb::473f:d516:192.168.1\").success).toBe(false);\n  expect(ipv6.safeParse(\"114.71.82.94\").success).toBe(false);\n  expect(ipv6.safeParse(\"not an ip\").success).toBe(false);\n  expect(ipv6.safeParse(\"g123::1234:5678\").success).toBe(false);\n\n  // Test specific error\n  expect(() => ipv6.parse(\"254.164.77.1\")).toThrow();\n});\n\ntest(\"CIDR v4 validation\", () => {\n  const cidrV4 = z.string().cidrv4();\n\n  // Valid CIDR v4 addresses\n  expect(cidrV4.safeParse(\"192.168.0.0/24\").success).toBe(true);\n  expect(cidrV4.safeParse(\"10.0.0.0/8\").success).toBe(true);\n  expect(cidrV4.safeParse(\"172.16.0.0/12\").success).toBe(true);\n  expect(cidrV4.safeParse(\"0.0.0.0/0\").success).toBe(true);\n  expect(cidrV4.safeParse(\"255.255.255.255/32\").success).toBe(true);\n\n  // Invalid CIDR v4 addresses\n  expect(cidrV4.safeParse(\"192.168.0.0\").success).toBe(false); // Missing prefix\n  expect(cidrV4.safeParse(\"192.168.0.0/33\").success).toBe(false); // Invalid prefix length\n  expect(cidrV4.safeParse(\"256.0.0.0/24\").success).toBe(false); // Invalid IP\n  expect(cidrV4.safeParse(\"192.168.0.0/-1\").success).toBe(false); // Negative prefix length\n  expect(cidrV4.safeParse(\"not a cidr\").success).toBe(false); // Invalid format\n});\n\ntest(\"CIDR v6 validation\", () => {\n  const cidrV6 = z.string().cidrv6();\n\n  // Valid CIDR v6 addresses\n  expect(cidrV6.safeParse(\"2001:db8::/32\").success).toBe(true);\n  expect(cidrV6.safeParse(\"::/0\").success).toBe(true);\n  expect(cidrV6.safeParse(\"fe80::/10\").success).toBe(true);\n  expect(cidrV6.safeParse(\"::1/128\").success).toBe(true);\n  expect(cidrV6.safeParse(\"2001:0db8:85a3::/64\").success).toBe(true);\n\n  // Invalid CIDR v6 addresses\n  expect(cidrV6.safeParse(\"2001:db8::\").success).toBe(false); // Missing prefix\n  expect(cidrV6.safeParse(\"2001:db8::/129\").success).toBe(false); // Invalid prefix length\n  expect(cidrV6.safeParse(\"2001:db8::/abc\").success).toBe(false); // Invalid prefix format\n  expect(cidrV6.safeParse(\"not a cidr\").success).toBe(false); // Invalid format\n  expect(cidrV6.safeParse(\"192.168.0.0/24\").success).toBe(false); // IPv4 CIDR in v6 validation\n});\n\ntest(\"E.164 validation\", () => {\n  const e164Number = z.string().e164();\n  expect(e164Number.safeParse(\"+1555555\").success).toBe(true);\n\n  const validE164Numbers = [\n    \"+1555555\", // min-length (7 digits + '+')\n    \"+15555555\",\n    \"+155555555\",\n    \"+1555555555\",\n    \"+15555555555\",\n    \"+155555555555\",\n    \"+1555555555555\",\n    \"+15555555555555\",\n    \"+155555555555555\",\n    \"+105555555555555\",\n    \"+100555555555555\", // max-length (15 digits + '+')\n  ];\n\n  const invalidE164Numbers = [\n    \"\", // empty\n    \"+\", // only plus sign\n    \"-\", // wrong sign\n    \" 555555555\", // starts with space\n    \"555555555\", // missing plus sign\n    \"+1 555 555 555\", // space after plus sign\n    \"+1555 555 555\", // space between numbers\n    \"+1555+555\", // multiple plus signs\n    \"+1555555555555555\", // too long\n    \"+115abc55\", // non numeric characters in number part\n    \"+1555555 \", // space after number\n  ];\n\n  expect(validE164Numbers.every((number) => e164Number.safeParse(number).success)).toBe(true);\n  expect(invalidE164Numbers.every((number) => e164Number.safeParse(number).success === false)).toBe(true);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/string.test.ts",
        "start": 1,
        "end": 881,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 881,
          "column": 2,
          "position": 7686
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/string.test.ts",
        "start": 1,
        "end": 881,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 881,
          "column": 2,
          "position": 7686
        }
      }
    },
    {
      "format": "typescript",
      "lines": 109,
      "fragment": "import { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\ntest(\"string format methods\", () => {\n  const a = z.email().min(10);\n  const b = z.email().max(10);\n  const c = z.email().length(10);\n  const d = z.email().uppercase();\n  const e = z.email().lowercase();\n\n  // Positive and negative cases for `a`\n  expect(a.safeParse(\"longemail@example.com\").success).toBe(true); // Positive\n  expect(a.safeParse(\"ort@e.co\").success).toBe(false); // Negative\n\n  // Positive and negative cases for `b`\n  expect(b.safeParse(\"sho@e.co\").success).toBe(true); // Positive\n  expect(b.safeParse(\"longemail@example.com\").success).toBe(false); // Negative\n\n  // Positive and negative cases for `c`\n  expect(c.safeParse(\"56780@e.co\").success).toBe(true); // Positive\n  expect(c.safeParse(\"shoasdfasdfrt@e.co\").success).toBe(false); // Negative\n\n  // Positive and negative cases for `d`\n  expect(d.safeParse(\"EMAIL@EXAMPLE.COM\").success).toBe(true); // Positive\n  expect(d.safeParse(\"email@example.com\").success).toBe(false); // Negative\n\n  // Positive and negative cases for `e`\n  expect(e.safeParse(\"email@example.com\").success).toBe(true); // Positive\n  expect(e.safeParse(\"EMAIL@EXAMPLE.COM\").success).toBe(false); // Negative\n});\n\ntest(\"z.stringFormat\", () => {\n  const ccRegex = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\n\n  const a = z\n    .stringFormat(\"creditCard\", (val) => ccRegex.test(val), {\n      error: `Invalid credit card number`,\n    })\n    .refine((_) => false, \"Also bad\");\n\n  expect(a.safeParse(\"asdf\")).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"creditCard\",\n        \"path\": [],\n        \"message\": \"Invalid credit card number\"\n      },\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"Also bad\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(a.safeParse(\"1234-5678-9012-3456\")).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"Also bad\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(a.def.pattern).toMatchInlineSnapshot(`undefined`);\n\n  const b = z\n    .stringFormat(\"creditCard\", ccRegex, {\n      abort: true,\n      error: `Invalid credit card number`,\n    })\n    .refine((_) => false, \"Also bad\");\n\n  expect(b.safeParse(\"asdf\")).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"creditCard\",\n        \"path\": [],\n        \"message\": \"Invalid credit card number\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(b.safeParse(\"1234-5678-9012-3456\")).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"Also bad\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(b.def.pattern).toMatchInlineSnapshot(\n    `/\\\\^\\\\(\\\\?:\\\\\\\\d\\\\{14,19\\\\}\\\\|\\\\\\\\d\\\\{4\\\\}\\\\(\\\\?: \\\\\\\\d\\\\{3,6\\\\}\\\\)\\\\{2,4\\\\}\\\\|\\\\\\\\d\\\\{4\\\\}\\\\(\\\\?:-\\\\\\\\d\\\\{3,6\\\\}\\\\)\\\\{2,4\\\\}\\\\)\\\\$/u`\n  );\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/string-formats.test.ts",
        "start": 1,
        "end": 109,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 109,
          "column": 2,
          "position": 619
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/string-formats.test.ts",
        "start": 1,
        "end": 109,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 109,
          "column": 2,
          "position": 619
        }
      }
    },
    {
      "format": "typescript",
      "lines": 57,
      "fragment": "import { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\ntest(\"length checks\", async () => {\n  const schema = z.string();\n  const result = await schema[\"~standard\"].validate(12);\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"issues\": [\n        {\n          \"code\": \"invalid_type\",\n          \"expected\": \"string\",\n          \"message\": \"Invalid input: expected string, received number\",\n          \"path\": [],\n        },\n      ],\n    }\n  `);\n});\n\ntest(\"length checks\", async () => {\n  const schema = z.string();\n  const result = await schema[\"~standard\"].validate(\"asdf\");\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"value\": \"asdf\",\n    }\n  `);\n});\n\ntest(\"length checks\", async () => {\n  const schema = z.string().refine(async (val) => val.length > 5);\n  const result = await schema[\"~standard\"].validate(12);\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"issues\": [\n        {\n          \"code\": \"invalid_type\",\n          \"expected\": \"string\",\n          \"message\": \"Invalid input: expected string, received number\",\n          \"path\": [],\n        },\n      ],\n    }\n  `);\n});\n\ntest(\"length checks\", async () => {\n  const schema = z.string().refine(async (val) => val.length > 5);\n  const result = await schema[\"~standard\"].validate(\"234134134\");\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"value\": \"234134134\",\n    }\n  `);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/standard-schema.test.ts",
        "start": 1,
        "end": 57,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 57,
          "column": 2,
          "position": 326
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/standard-schema.test.ts",
        "start": 1,
        "end": 57,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 57,
          "column": 2,
          "position": 326
        }
      }
    },
    {
      "format": "typescript",
      "lines": 179,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\nconst stringSet = z.set(z.string());\ntype stringSet = z.infer<typeof stringSet>;\n\nconst minTwo = z.set(z.string()).min(2);\nconst maxTwo = z.set(z.string()).max(2);\nconst justTwo = z.set(z.string()).size(2);\nconst nonEmpty = z.set(z.string()).nonempty();\nconst nonEmptyMax = z.set(z.string()).nonempty().max(2);\n\ntest(\"type inference\", () => {\n  expectTypeOf<stringSet>().toEqualTypeOf<Set<string>>();\n});\n\ntest(\"valid parse\", () => {\n  const result = stringSet.safeParse(new Set([\"first\", \"second\"]));\n  expect(result.success).toEqual(true);\n  expect(result.data!.has(\"first\")).toEqual(true);\n  expect(result.data!.has(\"second\")).toEqual(true);\n  expect(result.data!.has(\"third\")).toEqual(false);\n\n  expect(() => {\n    minTwo.parse(new Set([\"a\", \"b\"]));\n    minTwo.parse(new Set([\"a\", \"b\", \"c\"]));\n    maxTwo.parse(new Set([\"a\", \"b\"]));\n    maxTwo.parse(new Set([\"a\"]));\n    justTwo.parse(new Set([\"a\", \"b\"]));\n    nonEmpty.parse(new Set([\"a\"]));\n    nonEmptyMax.parse(new Set([\"a\"]));\n  }).not.toThrow();\n});\n\ntest(\"valid parse async\", async () => {\n  const result = await stringSet.spa(new Set([\"first\", \"second\"]));\n  expect(result.success).toEqual(true);\n  expect(result.data!.has(\"first\")).toEqual(true);\n  expect(result.data!.has(\"second\")).toEqual(true);\n  expect(result.data!.has(\"third\")).toEqual(false);\n\n  const asyncResult = await stringSet.safeParse(new Set([\"first\", \"second\"]));\n  expect(asyncResult.success).toEqual(true);\n  expect(asyncResult.data!.has(\"first\")).toEqual(true);\n  expect(asyncResult.data!.has(\"second\")).toEqual(true);\n  expect(asyncResult.data!.has(\"third\")).toEqual(false);\n});\n\ntest(\"valid parse: size-related methods\", () => {\n  expect(() => {\n    minTwo.parse(new Set([\"a\", \"b\"]));\n    minTwo.parse(new Set([\"a\", \"b\", \"c\"]));\n    maxTwo.parse(new Set([\"a\", \"b\"]));\n    maxTwo.parse(new Set([\"a\"]));\n    justTwo.parse(new Set([\"a\", \"b\"]));\n    nonEmpty.parse(new Set([\"a\"]));\n    nonEmptyMax.parse(new Set([\"a\"]));\n  }).not.toThrow();\n\n  const sizeZeroResult = stringSet.parse(new Set());\n  expect(sizeZeroResult.size).toBe(0);\n\n  const sizeTwoResult = minTwo.parse(new Set([\"a\", \"b\"]));\n  expect(sizeTwoResult.size).toBe(2);\n});\n\ntest(\"failing when parsing empty set in nonempty \", () => {\n  const result = nonEmpty.safeParse(new Set());\n  expect(result.success).toEqual(false);\n  expect(result.error!.issues.length).toEqual(1);\n  expect(result.error!.issues[0].code).toEqual(\"too_small\");\n});\n\ntest(\"failing when set is smaller than min() \", () => {\n  const result = minTwo.safeParse(new Set([\"just_one\"]));\n  expect(result.success).toEqual(false);\n  expect(result.error!.issues.length).toEqual(1);\n  expect(result.error!.issues[0].code).toEqual(\"too_small\");\n});\n\ntest(\"failing when set is bigger than max() \", () => {\n  const result = maxTwo.safeParse(new Set([\"one\", \"two\", \"three\"]));\n  expect(result.success).toEqual(false);\n  expect(result.error!.issues.length).toEqual(1);\n  expect(result.error!.issues[0].code).toEqual(\"too_big\");\n});\n\ntest(\"doesnt throw when an empty set is given\", () => {\n  const result = stringSet.safeParse(new Set([]));\n  expect(result.success).toEqual(true);\n});\n\ntest(\"throws when a Map is given\", () => {\n  const result = stringSet.safeParse(new Map([]));\n  expect(result.success).toEqual(false);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"expected\": \"set\",\n        \"code\": \"invalid_type\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected set, received Map\"\n      }\n    ]]\n  `);\n});\n\ntest(\"throws when the given set has invalid input\", () => {\n  const result = stringSet.safeParse(new Set([Symbol()]));\n  expect(result.success).toEqual(false);\n  expect(result.error!.issues.length).toEqual(1);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected string, received symbol\"\n      }\n    ]]\n  `);\n});\n\ntest(\"throws when the given set has multiple invalid entries\", () => {\n  const result = stringSet.safeParse(new Set([1, 2] as any[]));\n  expect(result.success).toEqual(false);\n  expect(result.error!.issues.length).toEqual(2);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected string, received number\"\n      },\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected string, received number\"\n      }\n    ]]\n  `);\n});\n\ntest(\"min/max\", async () => {\n  const schema = z.set(z.string()).min(4).max(5);\n\n  const r1 = schema.safeParse(new Set([\"a\", \"b\", \"c\", \"d\"]));\n  expect(r1.success).toEqual(true);\n\n  const r2 = schema.safeParse(new Set([\"a\", \"b\", \"c\"]));\n  expect(r2.success).toEqual(false);\n  expect(r2.error!.issues).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"too_small\",\n        \"message\": \"Too small: expected set to have >4 items\",\n        \"minimum\": 4,\n        \"origin\": \"set\",\n        \"path\": [],\n      },\n    ]\n  `);\n\n  const r3 = schema.safeParse(new Set([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]));\n  expect(r3.success).toEqual(false);\n  expect(r3.error!.issues).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"too_big\",\n        \"maximum\": 5,\n        \"message\": \"Too big: expected set to have <5 items\",\n        \"origin\": \"set\",\n        \"path\": [],\n      },\n    ]\n  `);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/set.test.ts",
        "start": 1,
        "end": 179,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 179,
          "column": 2,
          "position": 1754
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/set.test.ts",
        "start": 1,
        "end": 179,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 179,
          "column": 2,
          "position": 1754
        }
      }
    },
    {
      "format": "typescript",
      "lines": 204,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ntest(\"globalRegistry\", () => {\n  const reg = z.registry();\n\n  const a = z.string();\n  reg.add(a);\n  expect(reg.has(a)).toEqual(true);\n\n  reg.remove(a);\n  expect(reg.has(a)).toEqual(false);\n\n  a.register(z.globalRegistry, { field: \"sup\" });\n  expect(z.globalRegistry.has(a)).toEqual(true);\n  expect(z.globalRegistry.get(a)).toEqual({ field: \"sup\" });\n\n  z.globalRegistry.remove(a);\n  expect(z.globalRegistry.has(a)).toEqual(false);\n});\n\ntest(\"z.registry\", () => {\n  const fieldRegistry = z.registry<{ name: string; description: string }>();\n\n  const a = z.string();\n  fieldRegistry.add(a, { name: \"hello\", description: \"world\" });\n  const a_meta = fieldRegistry.get(a);\n  expect(a_meta).toEqual({ name: \"hello\", description: \"world\" });\n\n  fieldRegistry.remove(a);\n  expect(fieldRegistry.has(a)).toEqual(false);\n  expect(fieldRegistry.get(a)).toEqual(undefined);\n});\n\ntest(\"z.registry no metadata\", () => {\n  const fieldRegistry = z.registry();\n\n  const a = z.string();\n  fieldRegistry.add(a);\n  fieldRegistry.add(z.number());\n  expect(fieldRegistry.get(a)).toEqual(undefined);\n  expect(fieldRegistry.has(a)).toEqual(true);\n});\n\ntest(\"z.registry with schema constraints\", () => {\n  const fieldRegistry = z.registry<{ name: string; description: string }, z.ZodString>();\n\n  const a = z.string();\n  fieldRegistry.add(a, { name: \"hello\", description: \"world\" });\n  // @ts-expect-error\n  fieldRegistry.add(z.number(), { name: \"test\" });\n  // @ts-expect-error\n  z.number().register(fieldRegistry, { name: \"test\", description: \"test\" });\n});\n\n// test(\"z.namedRegistry\", () => {\n//   const namedReg = z\n//     .namedRegistry<{ name: string; description: string }>()\n//     .add(z.string(), { name: \"hello\", description: \"world\" })\n//     .add(z.number(), { name: \"number\", description: \"number\" });\n\n//   expect(namedReg.get(\"hello\")).toEqual({\n//     name: \"hello\",\n//     description: \"world\",\n//   });\n//   expect(namedReg.has(\"hello\")).toEqual(true);\n//   expect(namedReg.get(\"number\")).toEqual({\n//     name: \"number\",\n//     description: \"number\",\n//   });\n\n//   // @ts-expect-error\n//   namedReg.get(\"world\");\n//   // @ts-expect-error\n//   expect(namedReg.get(\"world\")).toEqual(undefined);\n\n//   const hello = namedReg.get(\"hello\");\n//   expect(hello).toEqual({ name: \"hello\", description: \"world\" });\n//   expectTypeOf<typeof hello>().toEqualTypeOf<{\n//     name: \"hello\";\n//     description: \"world\";\n//   }>();\n//   expectTypeOf<typeof namedReg.items>().toEqualTypeOf<{\n//     hello: { name: \"hello\"; description: \"world\" };\n//     number: { name: \"number\"; description: \"number\" };\n//   }>();\n// });\n\ntest(\"output type in registry meta\", () => {\n  const reg = z.registry<{ out: z.$output }>();\n  const a = z.string();\n  reg.add(a, { out: \"asdf\" });\n  // @ts-expect-error\n  reg.add(a, 1234);\n  expectTypeOf(reg.get(a)).toEqualTypeOf<{ out: string } | undefined>();\n});\n\ntest(\"output type in registry meta - objects and arrays\", () => {\n  const reg = z.registry<{ name: string; examples: z.$output[] }>();\n  const a = z.string();\n  reg.add(a, { name: \"hello\", examples: [\"world\"] });\n\n  // @ts-expect-error\n  reg.add(a, { name: \"hello\", examples: \"world\" });\n  expectTypeOf(reg.get(a)).toEqualTypeOf<{ name: string; examples: string[] } | undefined>();\n});\n\ntest(\"input type in registry meta\", () => {\n  const reg = z.registry<{ in: z.$input }>();\n  const a = z.pipe(z.number(), z.transform(String));\n  reg.add(a, { in: 1234 });\n  // @ts-expect-error\n  reg.add(a, \"1234\");\n  expectTypeOf(reg.get(a)).toEqualTypeOf<{ in: number } | undefined>();\n});\n\ntest(\"input type in registry meta - objects and arrays\", () => {\n  const reg = z.registry<{ name: string; examples: z.$input[] }>();\n  const a = z.pipe(z.number(), z.transform(String));\n  reg.add(a, { name: \"hello\", examples: [1234] });\n\n  // @ts-expect-error\n  reg.add(a, { name: \"hello\", examples: \"world\" });\n  expectTypeOf(reg.get(a)).toEqualTypeOf<{ name: string; examples: number[] } | undefined>();\n});\n\ntest(\".meta method\", () => {\n  const a1 = z.string();\n  const a2 = a1.meta({ name: \"hello\" });\n\n  expect(a1.meta()).toEqual(undefined);\n  expect(a2.meta()).toEqual({ name: \"hello\" });\n  expect(a1 === a2).toEqual(false);\n});\n\ntest(\".meta metadata does not bubble up\", () => {\n  const a1 = z.string().meta({ name: \"hello\" });\n  const a2 = a1.optional();\n\n  expect(a1.meta()).toEqual({ name: \"hello\" });\n  expect(a2.meta()).toEqual(undefined);\n});\n\ntest(\".describe\", () => {\n  const a1 = z.string();\n  const a2 = a1.describe(\"Hello\");\n\n  expect(a1.description).toEqual(undefined);\n  expect(a2.description).toEqual(\"Hello\");\n});\n\ntest(\"inherit across clone\", () => {\n  const A = z.string().meta({ a: true });\n  expect(A.meta()).toEqual({ a: true });\n  const B = A.meta({ b: true });\n  expect(B.meta()).toEqual({ a: true, b: true });\n  const C = B.describe(\"hello\");\n  expect(C.meta()).toEqual({ a: true, b: true, description: \"hello\" });\n});\n\ntest(\"loose examples\", () => {\n  z.string().register(z.globalRegistry, {\n    examples: [\"example\"],\n  });\n});\n\ntest(\"function meta witout replacement\", () => {\n  const myReg = z.registry<{\n    defaulter: (arg: string, test: boolean) => number;\n  }>();\n\n  const mySchema = z.date();\n  myReg.add(mySchema, {\n    defaulter: (arg, _test) => {\n      return arg.length;\n    },\n  });\n\n  expect(myReg.get(mySchema)!.defaulter(\"hello\", true)).toEqual(5);\n});\n\ntest(\"function meta with replacement\", () => {\n  const myReg = z.registry<{\n    defaulter: (arg: z.$input, test: boolean) => z.$output;\n  }>();\n\n  const mySchema = z.string().transform((val) => val.length);\n  myReg.add(mySchema, {\n    defaulter: (arg, _test) => {\n      return arg.length;\n    },\n  });\n\n  expect(myReg.get(mySchema)!.defaulter(\"hello\", true)).toEqual(5);\n});\n\ntest(\"test .clear()\", () => {\n  const reg = z.registry();\n  const a = z.string();\n  reg.add(a);\n  expect(reg.has(a)).toEqual(true);\n  reg.clear();\n  expect(reg.has(a)).toEqual(false);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/registries.test.ts",
        "start": 1,
        "end": 204,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 204,
          "column": 2,
          "position": 2192
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/registries.test.ts",
        "start": 1,
        "end": 204,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 204,
          "column": 2,
          "position": 2192
        }
      }
    },
    {
      "format": "typescript",
      "lines": 532,
      "fragment": "import { describe, expect, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ndescribe(\"basic refinement functionality\", () => {\n  test(\"should create a new schema instance when refining\", () => {\n    const obj1 = z.object({\n      first: z.string(),\n      second: z.string(),\n    });\n    const obj2 = obj1.partial().strict();\n    const obj3 = obj2.refine((data) => data.first || data.second, \"Either first or second should be filled in.\");\n\n    expect(obj1 === (obj2 as any)).toEqual(false);\n    expect(obj2 === (obj3 as any)).toEqual(false);\n  });\n\n  test(\"should validate according to refinement logic\", () => {\n    const schema = z\n      .object({\n        first: z.string(),\n        second: z.string(),\n      })\n      .partial()\n      .strict()\n      .refine((data) => data.first || data.second, \"Either first or second should be filled in.\");\n\n    // Should fail on empty object\n    expect(() => schema.parse({})).toThrow();\n\n    // Should pass with first property\n    expect(schema.parse({ first: \"a\" })).toEqual({ first: \"a\" });\n\n    // Should pass with second property\n    expect(schema.parse({ second: \"a\" })).toEqual({ second: \"a\" });\n\n    // Should pass with both properties\n    expect(schema.parse({ first: \"a\", second: \"a\" })).toEqual({ first: \"a\", second: \"a\" });\n  });\n\n  test(\"should validate strict mode correctly\", () => {\n    const schema = z\n      .object({\n        first: z.string(),\n        second: z.string(),\n      })\n      .partial()\n      .strict();\n\n    // Should throw on extra properties\n    expect(() => schema.parse({ third: \"adsf\" })).toThrow();\n  });\n});\n\ndescribe(\"refinement with custom error messages\", () => {\n  test(\"should use custom error message when validation fails\", () => {\n    const validationSchema = z\n      .object({\n        email: z.string().email(),\n        password: z.string(),\n        confirmPassword: z.string(),\n      })\n      .refine((data) => data.password === data.confirmPassword, \"Both password and confirmation must match\");\n\n    const result = validationSchema.safeParse({\n      email: \"aaaa@gmail.com\",\n      password: \"aaaaaaaa\",\n      confirmPassword: \"bbbbbbbb\",\n    });\n\n    expect(result.success).toEqual(false);\n    if (!result.success) {\n      expect(result.error.issues[0].message).toEqual(\"Both password and confirmation must match\");\n    }\n  });\n});\n\ndescribe(\"async refinements\", () => {\n  test(\"should support async refinement functions\", async () => {\n    const validationSchema = z\n      .object({\n        email: z.string().email(),\n        password: z.string(),\n        confirmPassword: z.string(),\n      })\n      .refine(\n        (data) => Promise.resolve().then(() => data.password === data.confirmPassword),\n        \"Both password and confirmation must match\"\n      );\n\n    // Should pass with matching passwords\n    const validData = {\n      email: \"aaaa@gmail.com\",\n      password: \"password\",\n      confirmPassword: \"password\",\n    };\n\n    await expect(validationSchema.parseAsync(validData)).resolves.toEqual(validData);\n\n    // Should fail with non-matching passwords\n    await expect(\n      validationSchema.parseAsync({\n        email: \"aaaa@gmail.com\",\n        password: \"password\",\n        confirmPassword: \"different\",\n      })\n    ).rejects.toThrow();\n  });\n});\n\ndescribe(\"early termination options\", () => {\n  test(\"should abort early with continue: false\", () => {\n    const schema = z\n      .string()\n      .superRefine((val, ctx) => {\n        if (val.length < 2) {\n          ctx.addIssue({\n            code: \"custom\",\n            message: \"BAD\",\n            continue: false,\n          });\n        }\n      })\n      .refine((_) => false);\n\n    const result = schema.safeParse(\"\");\n    expect(result.success).toEqual(false);\n    if (!result.success) {\n      expect(result.error.issues.length).toEqual(1);\n      expect(result.error.issues[0].message).toEqual(\"BAD\");\n    }\n  });\n\n  test(\"should abort early with fatal: true\", () => {\n    const schema = z\n      .string()\n      .superRefine((val, ctx) => {\n        if (val.length < 2) {\n          ctx.addIssue({\n            code: \"custom\",\n            fatal: true,\n            message: \"BAD\",\n          });\n        }\n      })\n      .refine((_) => false);\n\n    const result = schema.safeParse(\"\");\n    expect(result.success).toEqual(false);\n    if (!result.success) {\n      expect(result.error.issues.length).toEqual(1);\n      expect(result.error.issues[0].message).toEqual(\"BAD\");\n    }\n  });\n\n  test(\"should abort early with abort flag\", () => {\n    const schema = z\n      .string()\n      .refine((_) => false, { abort: true })\n      .refine((_) => false);\n\n    const result = schema.safeParse(\"\");\n    expect(result.success).toEqual(false);\n    if (!result.success) {\n      expect(result.error.issues.length).toEqual(1);\n    }\n  });\n});\n\ndescribe(\"custom error paths\", () => {\n  test(\"should use custom path in error message\", async () => {\n    const result = await z\n      .object({ password: z.string(), confirm: z.string() })\n      .refine((data) => data.confirm === data.password, { path: [\"confirm\"] })\n      .safeParse({ password: \"asdf\", confirm: \"qewr\" });\n\n    expect(result.success).toEqual(false);\n    if (!result.success) {\n      expect(result.error.issues[0].path).toEqual([\"confirm\"]);\n    }\n  });\n});\n\ndescribe(\"superRefine functionality\", () => {\n  test(\"should support multiple validation rules\", () => {\n    const Strings = z.array(z.string()).superRefine((val, ctx) => {\n      if (val.length > 3) {\n        ctx.addIssue({\n          input: val,\n          code: \"too_big\",\n          origin: \"array\",\n          maximum: 3,\n          inclusive: true,\n          exact: true,\n          message: \"Too many items \",\n        });\n      }\n\n      if (val.length !== new Set(val).size) {\n        ctx.addIssue({\n          input: val,\n          code: \"custom\",\n          message: `No duplicates allowed.`,\n        });\n      }\n    });\n\n    // Should fail with too many items and duplicates\n    const result = Strings.safeParse([\"asfd\", \"asfd\", \"asfd\", \"asfd\"]);\n    expect(result.success).toEqual(false);\n    if (!result.success) {\n      expect(result.error.issues.length).toEqual(2);\n      expect(result.error.issues[0].message).toEqual(\"Too many items \");\n      expect(result.error.issues[1].message).toEqual(\"No duplicates allowed.\");\n    }\n\n    // Should pass with valid input\n    const validArray = [\"asfd\", \"qwer\"];\n    expect(Strings.parse(validArray)).toEqual(validArray);\n  });\n\n  test(\"should support async superRefine\", async () => {\n    const Strings = z.array(z.string()).superRefine(async (val, ctx) => {\n      if (val.length > 3) {\n        ctx.addIssue({\n          input: val,\n          code: \"too_big\",\n          origin: \"array\",\n          maximum: 3,\n          inclusive: true,\n          message: \"Too many items \",\n        });\n      }\n\n      if (val.length !== new Set(val).size) {\n        ctx.addIssue({\n          input: val,\n          code: \"custom\",\n          message: `No duplicates allowed.`,\n        });\n      }\n    });\n\n    // Should fail with too many items and duplicates\n    const result = await Strings.safeParseAsync([\"asfd\", \"asfd\", \"asfd\", \"asfd\"]);\n    expect(result.success).toEqual(false);\n    if (!result.success) {\n      expect(result.error.issues.length).toEqual(2);\n    }\n\n    // Should pass with valid input\n    const validArray = [\"asfd\", \"qwer\"];\n    await expect(Strings.parseAsync(validArray)).resolves.toEqual(validArray);\n  });\n\n  test(\"should accept string as shorthand for custom error message\", () => {\n    const schema = z.string().superRefine((_, ctx) => {\n      ctx.addIssue(\"bad stuff\");\n    });\n\n    const result = schema.safeParse(\"asdf\");\n    expect(result.success).toEqual(false);\n    if (!result.success) {\n      expect(result.error.issues).toHaveLength(1);\n      expect(result.error.issues[0].message).toEqual(\"bad stuff\");\n    }\n  });\n\n  test(\"should respect fatal flag in superRefine\", () => {\n    const schema = z\n      .string()\n      .superRefine((val, ctx) => {\n        if (val === \"\") {\n          ctx.addIssue({\n            input: val,\n            code: \"custom\",\n            message: \"foo\",\n            fatal: true,\n          });\n        }\n      })\n      .superRefine((val, ctx) => {\n        if (val !== \" \") {\n          ctx.addIssue({\n            input: val,\n            code: \"custom\",\n            message: \"bar\",\n          });\n        }\n      });\n\n    const result = schema.safeParse(\"\");\n    expect(result.success).toEqual(false);\n    if (!result.success) {\n      expect(result.error.issues.length).toEqual(1);\n      expect(result.error.issues[0].message).toEqual(\"foo\");\n    }\n  });\n});\n\ndescribe(\"chained refinements\", () => {\n  test(\"should collect all validation errors when appropriate\", () => {\n    const objectSchema = z\n      .object({\n        length: z.number(),\n        size: z.number(),\n      })\n      .refine(({ length }) => length > 5, {\n        path: [\"length\"],\n        message: \"length greater than 5\",\n      })\n      .refine(({ size }) => size > 7, {\n        path: [\"size\"],\n        message: \"size greater than 7\",\n      });\n\n    // Should fail with one error\n    const r1 = objectSchema.safeParse({\n      length: 4,\n      size: 9,\n    });\n    expect(r1.success).toEqual(false);\n    if (!r1.success) {\n      expect(r1.error.issues.length).toEqual(1);\n      expect(r1.error.issues[0].path).toEqual([\"length\"]);\n    }\n\n    // Should fail with two errors\n    const r2 = objectSchema.safeParse({\n      length: 4,\n      size: 3,\n    });\n    expect(r2.success).toEqual(false);\n    if (!r2.success) {\n      expect(r2.error.issues.length).toEqual(2);\n    }\n\n    // Should pass with valid input\n    const validData = {\n      length: 6,\n      size: 8,\n    };\n    expect(objectSchema.parse(validData)).toEqual(validData);\n  });\n});\n\n// Commented tests can be uncommented once type-checking issues are resolved\n/*\ndescribe(\"type refinement\", () => {\n  test(\"refinement type guard\", () => {\n    const validationSchema = z.object({\n      a: z.string().refine((s): s is \"a\" => s === \"a\"),\n    });\n    type Input = z.input<typeof validationSchema>;\n    type Schema = z.infer<typeof validationSchema>;\n\n    expectTypeOf<Input[\"a\"]>().not.toEqualTypeOf<\"a\">();\n    expectTypeOf<Input[\"a\"]>().toEqualTypeOf<string>();\n\n    expectTypeOf<Schema[\"a\"]>().toEqualTypeOf<\"a\">();\n    expectTypeOf<Schema[\"a\"]>().not.toEqualTypeOf<string>();\n  });\n\n  test(\"superRefine - type narrowing\", () => {\n    type NarrowType = { type: string; age: number };\n    const schema = z\n      .object({\n        type: z.string(),\n        age: z.number(),\n      })\n      .nullable()\n      .superRefine((arg, ctx): arg is NarrowType => {\n        if (!arg) {\n          // still need to make a call to ctx.addIssue\n          ctx.addIssue({\n            input: arg,\n            code: \"custom\",\n            message: \"cannot be null\",\n            fatal: true,\n          });\n          return false;\n        }\n        return true;\n      });\n\n    expectTypeOf<z.infer<typeof schema>>().toEqualTypeOf<NarrowType>();\n\n    expect(schema.safeParse({ type: \"test\", age: 0 }).success).toEqual(true);\n    expect(schema.safeParse(null).success).toEqual(false);\n  });\n\n  test(\"chained mixed refining types\", () => {\n    type firstRefinement = { first: string; second: number; third: true };\n    type secondRefinement = { first: \"bob\"; second: number; third: true };\n    type thirdRefinement = { first: \"bob\"; second: 33; third: true };\n    const schema = z\n      .object({\n        first: z.string(),\n        second: z.number(),\n        third: z.boolean(),\n      })\n      .nullable()\n      .refine((arg): arg is firstRefinement => !!arg?.third)\n      .superRefine((arg, ctx): arg is secondRefinement => {\n        expectTypeOf<typeof arg>().toEqualTypeOf<firstRefinement>();\n        if (arg.first !== \"bob\") {\n          ctx.addIssue({\n            input: arg,\n            code: \"custom\",\n            message: \"`first` property must be `bob`\",\n          });\n          return false;\n        }\n        return true;\n      })\n      .refine((arg): arg is thirdRefinement => {\n        expectTypeOf<typeof arg>().toEqualTypeOf<secondRefinement>();\n        return arg.second === 33;\n      });\n\n    expectTypeOf<z.infer<typeof schema>>().toEqualTypeOf<thirdRefinement>();\n  });\n});\n*/\n\ntest(\"when\", () => {\n  const schema = z\n    .strictObject({\n      password: z.string().min(8),\n      confirmPassword: z.string(),\n      other: z.string(),\n    })\n    .refine(\n      (data) => {\n        console.log(\"running check...\");\n        console.log(data);\n        console.log(data.password);\n        return data.password === data.confirmPassword;\n      },\n      {\n        message: \"Passwords do not match\",\n        path: [\"confirmPassword\"],\n        when(payload) {\n          if (payload.value === undefined) return false;\n          if (payload.value === null) return false;\n          // no issues with confirmPassword or password\n          return payload.issues.every((iss) => iss.path?.[0] !== \"confirmPassword\" && iss.path?.[0] !== \"password\");\n        },\n      }\n    );\n\n  expect(schema.safeParse(undefined)).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"object\",\n        \"code\": \"invalid_type\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected object, received undefined\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(schema.safeParse(null)).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"object\",\n        \"code\": \"invalid_type\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected object, received null\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(\n    schema.safeParse({\n      password: \"asdf\",\n      confirmPassword: \"asdfg\",\n      other: \"qwer\",\n    })\n  ).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"origin\": \"string\",\n        \"code\": \"too_small\",\n        \"minimum\": 8,\n        \"inclusive\": true,\n        \"path\": [\n          \"password\"\n        ],\n        \"message\": \"Too small: expected string to have >=8 characters\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n\n  expect(\n    schema.safeParse({\n      password: \"asdf\",\n      confirmPassword: \"asdfg\",\n      other: 1234,\n    })\n  ).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"origin\": \"string\",\n        \"code\": \"too_small\",\n        \"minimum\": 8,\n        \"inclusive\": true,\n        \"path\": [\n          \"password\"\n        ],\n        \"message\": \"Too small: expected string to have >=8 characters\"\n      },\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"other\"\n        ],\n        \"message\": \"Invalid input: expected string, received number\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/refine.test.ts",
        "start": 1,
        "end": 532,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 532,
          "column": 2,
          "position": 3602
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/refine.test.ts",
        "start": 1,
        "end": 532,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 532,
          "column": 2,
          "position": 3602
        }
      }
    },
    {
      "format": "typescript",
      "lines": 356,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport { z } from \"zod/v4\";\n\ntest(\"recursion with z.lazy\", () => {\n  const data = {\n    name: \"I\",\n    subcategories: [\n      {\n        name: \"A\",\n        subcategories: [\n          {\n            name: \"1\",\n            subcategories: [\n              {\n                name: \"a\",\n                subcategories: [],\n              },\n            ],\n          },\n        ],\n      },\n    ],\n  };\n\n  const Category = z.object({\n    name: z.string(),\n    get subcategories() {\n      return z.array(Category).optional().nullable();\n    },\n  });\n  type Category = z.infer<typeof Category>;\n  interface _Category {\n    name: string;\n    subcategories?: _Category[] | undefined | null;\n  }\n  expectTypeOf<Category>().toEqualTypeOf<_Category>();\n  Category.parse(data);\n});\n\ntest(\"recursion involving union type\", () => {\n  const data = {\n    value: 1,\n    next: {\n      value: 2,\n      next: {\n        value: 3,\n        next: {\n          value: 4,\n          next: null,\n        },\n      },\n    },\n  };\n\n  const LL = z.object({\n    value: z.number(),\n    get next() {\n      return LL.nullable();\n    },\n  });\n  type LL = z.infer<typeof LL>;\n  type _LL = {\n    value: number;\n    next: _LL | null;\n  };\n  expectTypeOf<LL>().toEqualTypeOf<_LL>();\n\n  LL.parse(data);\n});\n\ntest(\"mutual recursion - native\", () => {\n  const Alazy = z.object({\n    val: z.number(),\n    get b() {\n      return Blazy;\n    },\n  });\n\n  const Blazy = z.object({\n    val: z.number(),\n    get a() {\n      return Alazy.optional();\n    },\n  });\n  const testData = {\n    val: 1,\n    b: {\n      val: 5,\n      a: {\n        val: 3,\n        b: {\n          val: 4,\n          a: {\n            val: 2,\n            b: {\n              val: 1,\n            },\n          },\n        },\n      },\n    },\n  };\n\n  type Alazy = z.infer<typeof Alazy>;\n  type Blazy = z.infer<typeof Blazy>;\n  interface _Alazy {\n    val: number;\n    b: _Blazy;\n  }\n  interface _Blazy {\n    val: number;\n    a?: _Alazy | undefined;\n  }\n  expectTypeOf<Alazy>().toEqualTypeOf<_Alazy>();\n  expectTypeOf<Blazy>().toEqualTypeOf<_Blazy>();\n  Alazy.parse(testData);\n  Blazy.parse(testData.b);\n\n  expect(() => Alazy.parse({ val: \"asdf\" })).toThrow();\n});\n\ntest(\"pick and omit with getter\", () => {\n  const Category = z.strictObject({\n    name: z.string(),\n    get subcategories() {\n      return z.array(Category);\n    },\n  });\n\n  type Category = z.infer<typeof Category>;\n\n  interface _Category {\n    name: string;\n    subcategories: _Category[];\n  }\n  expectTypeOf<Category>().toEqualTypeOf<_Category>();\n\n  const PickedCategory = Category.pick({ name: true });\n  const OmittedCategory = Category.omit({ subcategories: true });\n\n  const picked = { name: \"test\" };\n  const omitted = { name: \"test\" };\n\n  PickedCategory.parse(picked);\n  OmittedCategory.parse(omitted);\n\n  expect(() => PickedCategory.parse({ name: \"test\", subcategories: [] })).toThrow();\n  expect(() => OmittedCategory.parse({ name: \"test\", subcategories: [] })).toThrow();\n});\n\ntest(\"deferred self-recursion\", () => {\n  const Feature = z.object({\n    title: z.string(),\n    get features(): z.ZodOptional<z.ZodArray<typeof Feature>> {\n      return z.optional(z.array(Feature)); //.optional();\n    },\n  });\n  // type Feature = z.infer<typeof Feature>;\n\n  const Output = z.object({\n    id: z.int(), //.nonnegative(),\n    name: z.string(),\n    get features(): z.ZodArray<typeof Feature> {\n      return Feature.array();\n    },\n  });\n  type Output = z.output<typeof Output>;\n\n  type _Feature = {\n    title: string;\n    features?: _Feature[] | undefined;\n  };\n\n  type _Output = {\n    id: number;\n    name: string;\n    features: _Feature[];\n  };\n\n  // expectTypeOf<Feature>().toEqualTypeOf<_Feature>();\n  expectTypeOf<Output>().toEqualTypeOf<_Output>();\n});\n\ntest(\"deferred mutual recursion\", () => {\n  const Slot = z.object({\n    slotCode: z.string(),\n\n    get blocks() {\n      return z.array(Block);\n    },\n  });\n  type Slot = z.infer<typeof Slot>;\n\n  const Block = z.object({\n    blockCode: z.string(),\n    get slots() {\n      return z.array(Slot).optional();\n    },\n  });\n  type Block = z.infer<typeof Block>;\n\n  const Page = z.object({\n    slots: z.array(Slot),\n  });\n  type Page = z.infer<typeof Page>;\n\n  type _Slot = {\n    slotCode: string;\n    blocks: _Block[];\n  };\n  type _Block = {\n    blockCode: string;\n    slots?: _Slot[] | undefined;\n  };\n  type _Page = {\n    slots: _Slot[];\n  };\n  expectTypeOf<Slot>().toEqualTypeOf<_Slot>();\n  expectTypeOf<Block>().toEqualTypeOf<_Block>();\n  expectTypeOf<Page>().toEqualTypeOf<_Page>();\n});\n\ntest(\"mutual recursion with meta\", () => {\n  const A = z\n    .object({\n      name: z.string(),\n      get b() {\n        return B;\n      },\n    })\n    .readonly()\n    .meta({ id: \"A\" })\n    .optional();\n\n  const B = z\n    .object({\n      name: z.string(),\n      get a() {\n        return A;\n      },\n    })\n    .readonly()\n    .meta({ id: \"B\" });\n\n  type A = z.infer<typeof A>;\n  type B = z.infer<typeof B>;\n\n  type _A =\n    | Readonly<{\n        name: string;\n        b: _B;\n      }>\n    | undefined;\n  // | undefined;\n  type _B = Readonly<{\n    name: string;\n    a?: _A;\n  }>;\n  expectTypeOf<A>().toEqualTypeOf<_A>();\n  expectTypeOf<B>().toEqualTypeOf<_B>();\n});\n\ntest(\"recursion compatibility\", () => {\n  // array\n  const A = z.object({\n    get array() {\n      return A.array();\n    },\n    get optional() {\n      return A.optional();\n    },\n    get nullable() {\n      return A.nullable();\n    },\n    get nonoptional() {\n      return A.nonoptional();\n    },\n    get readonly() {\n      return A.readonly();\n    },\n    get describe() {\n      return A.describe(\"A recursive type\");\n    },\n    get meta() {\n      return A.meta({ description: \"A recursive type\" });\n    },\n    get pipe() {\n      return A.pipe(z.any());\n    },\n    get strict() {\n      return A.strict();\n    },\n    get tuple() {\n      return z.tuple([A, A]);\n    },\n    get object() {\n      return z\n        .object({\n          subcategories: A,\n        })\n        .strict()\n        .loose();\n    },\n    get union() {\n      return z.union([A, A]);\n    },\n    get intersection() {\n      return z.intersection(A, A);\n    },\n    get record() {\n      return z.record(z.string(), A);\n    },\n    get map() {\n      return z.map(z.string(), A);\n    },\n    get set() {\n      return z.set(A);\n    },\n    get lazy() {\n      return z.lazy(() => A);\n    },\n    get promise() {\n      return z.promise(A);\n    },\n  });\n});\n\n// biome-ignore lint: sadf\nexport type RecursiveA = z.ZodUnion<\n  [\n    z.ZodObject<{\n      a: z.ZodDefault<RecursiveA>;\n      b: z.ZodPrefault<RecursiveA>;\n      c: z.ZodNonOptional<RecursiveA>;\n      d: z.ZodOptional<RecursiveA>;\n      e: z.ZodNullable<RecursiveA>;\n      g: z.ZodReadonly<RecursiveA>;\n      h: z.ZodPipe<RecursiveA, z.ZodString>;\n      i: z.ZodArray<RecursiveA>;\n      j: z.ZodSet<RecursiveA>;\n      k: z.ZodMap<RecursiveA, RecursiveA>;\n      l: z.ZodRecord<z.ZodString, RecursiveA>;\n      m: z.ZodUnion<[RecursiveA, RecursiveA]>;\n      n: z.ZodIntersection<RecursiveA, RecursiveA>;\n      o: z.ZodLazy<RecursiveA>;\n      p: z.ZodPromise<RecursiveA>;\n      q: z.ZodCatch<RecursiveA>;\n      r: z.ZodSuccess<RecursiveA>;\n      s: z.ZodTransform<RecursiveA, string>;\n      t: z.ZodTuple<[RecursiveA, RecursiveA]>;\n      u: z.ZodObject<{\n        a: RecursiveA;\n      }>;\n    }>,\n  ]\n>;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/recursive-types.test.ts",
        "start": 1,
        "end": 356,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 356,
          "column": 2,
          "position": 2976
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/recursive-types.test.ts",
        "start": 1,
        "end": 356,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 356,
          "column": 2,
          "position": 2976
        }
      }
    },
    {
      "format": "typescript",
      "lines": 342,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ntest(\"type inference\", () => {\n  const booleanRecord = z.record(z.string(), z.boolean());\n  type booleanRecord = typeof booleanRecord._output;\n\n  const recordWithEnumKeys = z.record(z.enum([\"Tuna\", \"Salmon\"]), z.string());\n  type recordWithEnumKeys = z.infer<typeof recordWithEnumKeys>;\n\n  const recordWithLiteralKey = z.record(z.literal([\"Tuna\", \"Salmon\"]), z.string());\n  type recordWithLiteralKey = z.infer<typeof recordWithLiteralKey>;\n\n  const recordWithLiteralUnionKeys = z.record(z.union([z.literal(\"Tuna\"), z.literal(\"Salmon\")]), z.string());\n  type recordWithLiteralUnionKeys = z.infer<typeof recordWithLiteralUnionKeys>;\n\n  expectTypeOf<booleanRecord>().toEqualTypeOf<Record<string, boolean>>();\n  expectTypeOf<recordWithEnumKeys>().toEqualTypeOf<Record<\"Tuna\" | \"Salmon\", string>>();\n  expectTypeOf<recordWithLiteralKey>().toEqualTypeOf<Record<\"Tuna\" | \"Salmon\", string>>();\n  expectTypeOf<recordWithLiteralUnionKeys>().toEqualTypeOf<Record<\"Tuna\" | \"Salmon\", string>>();\n});\n\ntest(\"enum exhaustiveness\", () => {\n  const schema = z.record(z.enum([\"Tuna\", \"Salmon\"]), z.string());\n  expect(\n    schema.parse({\n      Tuna: \"asdf\",\n      Salmon: \"asdf\",\n    })\n  ).toEqual({\n    Tuna: \"asdf\",\n    Salmon: \"asdf\",\n  });\n\n  expect(schema.safeParse({ Tuna: \"asdf\", Salmon: \"asdf\", Trout: \"asdf\" })).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"unrecognized_keys\",\n        \"keys\": [\n          \"Trout\"\n        ],\n        \"path\": [],\n        \"message\": \"Unrecognized key: \\\\\"Trout\\\\\"\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(schema.safeParse({ Tuna: \"asdf\" })).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"Salmon\"\n        ],\n        \"message\": \"Invalid input: expected string, received undefined\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"literal exhaustiveness\", () => {\n  const schema = z.record(z.literal([\"Tuna\", \"Salmon\"]), z.string());\n  schema.parse({\n    Tuna: \"asdf\",\n    Salmon: \"asdf\",\n  });\n\n  expect(schema.safeParse({ Tuna: \"asdf\", Salmon: \"asdf\", Trout: \"asdf\" })).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"unrecognized_keys\",\n        \"keys\": [\n          \"Trout\"\n        ],\n        \"path\": [],\n        \"message\": \"Unrecognized key: \\\\\"Trout\\\\\"\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(schema.safeParse({ Tuna: \"asdf\" })).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"Salmon\"\n        ],\n        \"message\": \"Invalid input: expected string, received undefined\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"pipe exhaustiveness\", () => {\n  const schema = z.record(z.enum([\"Tuna\", \"Salmon\"]).pipe(z.any()), z.string());\n  expect(schema.parse({ Tuna: \"asdf\", Salmon: \"asdf\" })).toEqual({\n    Tuna: \"asdf\",\n    Salmon: \"asdf\",\n  });\n\n  expect(schema.safeParse({ Tuna: \"asdf\", Salmon: \"asdf\", Trout: \"asdf\" })).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"unrecognized_keys\",\n        \"keys\": [\n          \"Trout\"\n        ],\n        \"path\": [],\n        \"message\": \"Unrecognized key: \\\\\"Trout\\\\\"\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(schema.safeParse({ Tuna: \"asdf\" })).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"Salmon\"\n        ],\n        \"message\": \"Invalid input: expected string, received undefined\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"union exhaustiveness\", () => {\n  const schema = z.record(z.union([z.literal(\"Tuna\"), z.literal(\"Salmon\")]), z.string());\n  expect(schema.parse({ Tuna: \"asdf\", Salmon: \"asdf\" })).toEqual({\n    Tuna: \"asdf\",\n    Salmon: \"asdf\",\n  });\n\n  expect(schema.safeParse({ Tuna: \"asdf\", Salmon: \"asdf\", Trout: \"asdf\" })).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"unrecognized_keys\",\n        \"keys\": [\n          \"Trout\"\n        ],\n        \"path\": [],\n        \"message\": \"Unrecognized key: \\\\\"Trout\\\\\"\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(schema.safeParse({ Tuna: \"asdf\" })).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"Salmon\"\n        ],\n        \"message\": \"Invalid input: expected string, received undefined\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"string record parse - pass\", () => {\n  const schema = z.record(z.string(), z.boolean());\n  schema.parse({\n    k1: true,\n    k2: false,\n    1234: false,\n  });\n\n  expect(schema.safeParse({ asdf: 1234 }).success).toEqual(false);\n  expect(schema.safeParse(\"asdf\")).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"record\",\n        \"code\": \"invalid_type\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected record, received string\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"key and value getters\", () => {\n  const rec = z.record(z.string(), z.number());\n\n  rec.keyType.parse(\"asdf\");\n  rec.valueType.parse(1234);\n});\n\ntest(\"is not vulnerable to prototype pollution\", async () => {\n  const rec = z.record(\n    z.string(),\n    z.object({\n      a: z.string(),\n    })\n  );\n\n  const data = JSON.parse(`\n    {\n      \"__proto__\": {\n        \"a\": \"evil\"\n      },\n      \"b\": {\n        \"a\": \"good\"\n      }\n    }\n  `);\n\n  const obj1 = rec.parse(data);\n  expect(obj1.a).toBeUndefined();\n\n  const obj2 = rec.safeParse(data);\n  expect(obj2.success).toBe(true);\n  if (obj2.success) {\n    expect(obj2.data.a).toBeUndefined();\n  }\n\n  const obj3 = await rec.parseAsync(data);\n  expect(obj3.a).toBeUndefined();\n\n  const obj4 = await rec.safeParseAsync(data);\n  expect(obj4.success).toBe(true);\n  if (obj4.success) {\n    expect(obj4.data.a).toBeUndefined();\n  }\n});\n\ntest(\"dont remove undefined values\", () => {\n  const result1 = z.record(z.string(), z.any()).parse({ foo: undefined });\n\n  expect(result1).toEqual({\n    foo: undefined,\n  });\n});\n\ntest(\"allow undefined values\", () => {\n  const schema = z.record(z.string(), z.undefined());\n\n  expect(\n    Object.keys(\n      schema.parse({\n        _test: undefined,\n      })\n    )\n  ).toEqual([\"_test\"]);\n});\n\ntest(\"async parsing\", async () => {\n  const schema = z\n    .record(\n      z.string(),\n      z\n        .string()\n        .optional()\n        .refine(async () => true)\n    )\n    .refine(async () => true);\n\n  const data = {\n    foo: \"bar\",\n    baz: \"qux\",\n  };\n  const result = await schema.safeParseAsync(data);\n  expect(result.data).toEqual(data);\n});\n\ntest(\"async parsing\", async () => {\n  const schema = z\n    .record(\n      z.string(),\n      z\n        .string()\n        .optional()\n        .refine(async () => false)\n    )\n    .refine(async () => false);\n\n  const data = {\n    foo: \"bar\",\n    baz: \"qux\",\n  };\n  const result = await schema.safeParseAsync(data);\n  expect(result.success).toEqual(false);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [\n          \"foo\"\n        ],\n        \"message\": \"Invalid input\"\n      },\n      {\n        \"code\": \"custom\",\n        \"path\": [\n          \"baz\"\n        ],\n        \"message\": \"Invalid input\"\n      },\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"Invalid input\"\n      }\n    ]]\n  `);\n});\n\ntest(\"partial record\", () => {\n  const schema = z.partialRecord(z.string(), z.string());\n  type schema = z.infer<typeof schema>;\n  expectTypeOf<schema>().toEqualTypeOf<Partial<Record<string, string>>>();\n\n  const Keys = z.enum([\"id\", \"name\", \"email\"]).or(z.never());\n  const Person = z.partialRecord(Keys, z.string());\n  expectTypeOf<z.infer<typeof Person>>().toEqualTypeOf<Partial<Record<\"id\" | \"name\" | \"email\", string>>>();\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/record.test.ts",
        "start": 1,
        "end": 342,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 342,
          "column": 2,
          "position": 2072
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/record.test.ts",
        "start": 1,
        "end": 342,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 342,
          "column": 2,
          "position": 2072
        }
      }
    },
    {
      "format": "typescript",
      "lines": 252,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\nenum testEnum {\n  A = 0,\n  B = 1,\n}\n\ntest(\"flat inference\", () => {\n  const readonlyString = z.string().readonly();\n  const readonlyNumber = z.number().readonly();\n  const readonlyNaN = z.nan().readonly();\n  const readonlyBigInt = z.bigint().readonly();\n  const readonlyBoolean = z.boolean().readonly();\n  const readonlyDate = z.date().readonly();\n  const readonlyUndefined = z.undefined().readonly();\n  const readonlyNull = z.null().readonly();\n  const readonlyAny = z.any().readonly();\n  const readonlyUnknown = z.unknown().readonly();\n  const readonlyVoid = z.void().readonly();\n  const readonlyStringArray = z.array(z.string()).readonly();\n  const readonlyTuple = z.tuple([z.string(), z.number()]).readonly();\n  const readonlyMap = z.map(z.string(), z.date()).readonly();\n  const readonlySet = z.set(z.string()).readonly();\n  const readonlyStringRecord = z.record(z.string(), z.string()).readonly();\n  const readonlyNumberRecord = z.record(z.string(), z.number()).readonly();\n  const readonlyObject = z.object({ a: z.string(), 1: z.number() }).readonly();\n  const readonlyEnum = z.nativeEnum(testEnum).readonly();\n  const readonlyPromise = z.promise(z.string()).readonly();\n\n  expectTypeOf<typeof readonlyString._output>().toEqualTypeOf<string>();\n  expectTypeOf<typeof readonlyNumber._output>().toEqualTypeOf<number>();\n  expectTypeOf<typeof readonlyNaN._output>().toEqualTypeOf<number>();\n  expectTypeOf<typeof readonlyBigInt._output>().toEqualTypeOf<bigint>();\n  expectTypeOf<typeof readonlyBoolean._output>().toEqualTypeOf<boolean>();\n  expectTypeOf<typeof readonlyDate._output>().toEqualTypeOf<Date>();\n  expectTypeOf<typeof readonlyUndefined._output>().toEqualTypeOf<undefined>();\n  expectTypeOf<typeof readonlyNull._output>().toEqualTypeOf<null>();\n  expectTypeOf<typeof readonlyAny._output>().toEqualTypeOf<any>();\n  expectTypeOf<typeof readonlyUnknown._output>().toEqualTypeOf<Readonly<unknown>>();\n  expectTypeOf<typeof readonlyVoid._output>().toEqualTypeOf<void>();\n  expectTypeOf<typeof readonlyStringArray._output>().toEqualTypeOf<readonly string[]>();\n  expectTypeOf<typeof readonlyTuple._output>().toEqualTypeOf<readonly [string, number]>();\n  expectTypeOf<typeof readonlyMap._output>().toEqualTypeOf<ReadonlyMap<string, Date>>();\n  expectTypeOf<typeof readonlySet._output>().toEqualTypeOf<ReadonlySet<string>>();\n  expectTypeOf<typeof readonlyStringRecord._output>().toEqualTypeOf<Readonly<Record<string, string>>>();\n  expectTypeOf<typeof readonlyNumberRecord._output>().toEqualTypeOf<Readonly<Record<string, number>>>();\n  expectTypeOf<typeof readonlyObject._output>().toEqualTypeOf<{ readonly a: string; readonly 1: number }>();\n  expectTypeOf<typeof readonlyEnum._output>().toEqualTypeOf<Readonly<testEnum>>();\n  expectTypeOf<typeof readonlyPromise._output>().toEqualTypeOf<string>();\n});\n\n// test(\"deep inference\", () => {\n//   expectTypeOf<z.infer<(typeof deepReadonlySchemas_0)[0]>>().toEqualTypeOf<string>();\n//   expectTypeOf<z.infer<(typeof deepReadonlySchemas_0)[1]>>().toEqualTypeOf<number>();\n//   expectTypeOf<z.infer<(typeof deepReadonlySchemas_0)[2]>>().toEqualTypeOf<number>();\n//   expectTypeOf<z.infer<(typeof deepReadonlySchemas_0)[3]>>().toEqualTypeOf<bigint>();\n//   expectTypeOf<z.infer<(typeof deepReadonlySchemas_0)[4]>>().toEqualTypeOf<boolean>();\n//   expectTypeOf<z.infer<(typeof deepReadonlySchemas_0)[5]>>().toEqualTypeOf<Date>();\n//   expectTypeOf<z.infer<(typeof deepReadonlySchemas_0)[6]>>().toEqualTypeOf<undefined>();\n//   expectTypeOf<z.infer<(typeof deepReadonlySchemas_0)[7]>>().toEqualTypeOf<null>();\n//   expectTypeOf<z.infer<(typeof deepReadonlySchemas_0)[8]>>().toEqualTypeOf<any>();\n//   expectTypeOf<\n//     z.infer<(typeof deepReadonlySchemas_0)[9]>\n//   >().toEqualTypeOf<Readonly<unknown>>();\n//   expectTypeOf<z.infer<(typeof deepReadonlySchemas_0)[10]>>().toEqualTypeOf<void>();\n//   expectTypeOf<\n//     z.infer<(typeof deepReadonlySchemas_0)[11]>\n//   >().toEqualTypeOf<(args_0: string, args_1: number, ...args_2: unknown[]) => unknown>();\n//   expectTypeOf<\n//     z.infer<(typeof deepReadonlySchemas_0)[12]>\n//   >().toEqualTypeOf<readonly string[]>();\n//   expectTypeOf<\n//     z.infer<(typeof deepReadonlySchemas_0)[13]>\n//   >().toEqualTypeOf<readonly [string, number]>();\n//   expectTypeOf<\n//     z.infer<(typeof deepReadonlySchemas_0)[14]>\n//   >().toEqualTypeOf<ReadonlyMap<string, Date>>();\n//   expectTypeOf<\n//     z.infer<(typeof deepReadonlySchemas_0)[15]>\n//   >().toEqualTypeOf<ReadonlySet<Promise<string>>>();\n//   expectTypeOf<\n//     z.infer<(typeof deepReadonlySchemas_0)[16]>\n//   >().toEqualTypeOf<Readonly<Record<string, string>>>();\n//   expectTypeOf<\n//     z.infer<(typeof deepReadonlySchemas_0)[17]>\n//   >().toEqualTypeOf<Readonly<Record<string, number>>>();\n//   expectTypeOf<\n//     z.infer<(typeof deepReadonlySchemas_0)[18]>\n//   >().toEqualTypeOf<{ readonly a: string; readonly 1: number }>();\n//   expectTypeOf<\n//     z.infer<(typeof deepReadonlySchemas_0)[19]>\n//   >().toEqualTypeOf<Readonly<testEnum>>();\n//   expectTypeOf<\n//     z.infer<(typeof deepReadonlySchemas_0)[20]>\n//   >().toEqualTypeOf<Promise<string>>();\n\n//   expectTypeOf<\n//     z.infer<typeof crazyDeepReadonlySchema>\n//   >().toEqualTypeOf<ReadonlyMap<\n//     ReadonlySet<readonly [string, number]>,\n//     {\n//       readonly a: {\n//         readonly [x: string]: readonly any[];\n//       };\n//       readonly b: {\n//         readonly c: {\n//           readonly d: {\n//             readonly e: {\n//               readonly f: {\n//                 readonly g?: {};\n//               };\n//             };\n//           };\n//         };\n//       };\n//     }\n//   >>();\n// });\n\ntest(\"object freezing\", async () => {\n  expect(Object.isFrozen(z.array(z.string()).readonly().parse([\"a\"]))).toBe(true);\n  expect(Object.isFrozen(z.tuple([z.string(), z.number()]).readonly().parse([\"a\", 1]))).toBe(true);\n  expect(\n    Object.isFrozen(\n      z\n        .map(z.string(), z.date())\n        .readonly()\n        .parse(new Map([[\"a\", new Date()]]))\n    )\n  ).toBe(true);\n\n  expect(Object.isFrozen(z.record(z.string(), z.string()).readonly().parse({ a: \"b\" }))).toBe(true);\n  expect(Object.isFrozen(z.record(z.string(), z.number()).readonly().parse({ a: 1 }))).toBe(true);\n  expect(Object.isFrozen(z.object({ a: z.string(), 1: z.number() }).readonly().parse({ a: \"b\", 1: 2 }))).toBe(true);\n  expect(\n    Object.isFrozen(\n      await z\n        .set(z.promise(z.string()))\n        .readonly()\n        .parseAsync(new Set([Promise.resolve(\"a\")]))\n    )\n  ).toBe(true);\n  expect(Object.isFrozen(await z.promise(z.string()).readonly().parseAsync(Promise.resolve(\"a\")))).toBe(true);\n});\n\ntest(\"async object freezing\", async () => {\n  expect(Object.isFrozen(await z.array(z.string()).readonly().parseAsync([\"a\"]))).toBe(true);\n  expect(Object.isFrozen(await z.tuple([z.string(), z.number()]).readonly().parseAsync([\"a\", 1]))).toBe(true);\n  expect(\n    Object.isFrozen(\n      await z\n        .map(z.string(), z.date())\n        .readonly()\n        .parseAsync(new Map([[\"a\", new Date()]]))\n    )\n  ).toBe(true);\n  expect(\n    Object.isFrozen(\n      await z\n        .set(z.promise(z.string()))\n        .readonly()\n        .parseAsync(new Set([Promise.resolve(\"a\")]))\n    )\n  ).toBe(true);\n  expect(Object.isFrozen(await z.record(z.string(), z.string()).readonly().parseAsync({ a: \"b\" }))).toBe(true);\n  expect(Object.isFrozen(await z.record(z.string(), z.number()).readonly().parseAsync({ a: 1 }))).toBe(true);\n  expect(\n    Object.isFrozen(await z.object({ a: z.string(), 1: z.number() }).readonly().parseAsync({ a: \"b\", 1: 2 }))\n  ).toBe(true);\n  expect(Object.isFrozen(await z.promise(z.string()).readonly().parseAsync(Promise.resolve(\"a\")))).toBe(true);\n});\n\ntest(\"readonly inference\", () => {\n  const readonlyStringArray = z.string().array().readonly();\n  const readonlyStringTuple = z.tuple([z.string()]).readonly();\n  const deepReadonly = z.object({ a: z.string() }).readonly();\n\n  type readonlyStringArray = z.infer<typeof readonlyStringArray>;\n  type readonlyStringTuple = z.infer<typeof readonlyStringTuple>;\n  type deepReadonly = z.infer<typeof deepReadonly>;\n\n  expectTypeOf<readonlyStringArray>().toEqualTypeOf<readonly string[]>();\n  expectTypeOf<readonlyStringTuple>().toEqualTypeOf<readonly [string]>();\n  expectTypeOf<deepReadonly>().toEqualTypeOf<{ readonly a: string }>();\n});\n\ntest(\"readonly parse\", () => {\n  const schema = z.array(z.string()).readonly();\n  const readonlyArray = [\"a\", \"b\", \"c\"] as const;\n  const mutableArray = [\"a\", \"b\", \"c\"];\n  const result1 = schema.parse(readonlyArray);\n  const result2 = schema.parse(mutableArray);\n  expect(result1).toEqual(readonlyArray);\n  expect(result2).toEqual(mutableArray);\n});\n\ntest(\"readonly parse with tuples\", () => {\n  const schema = z.tuple([z.string(), z.number()]).readonly();\n  schema.parse([\"a\", 1]);\n});\n\ntest(\"readonly and the get method\", () => {\n  const readonlyString = z.string().readonly();\n  const readonlyNumber1 = z.number().readonly();\n  const readonlyNumber2 = z.number().readonly();\n  const readonlyBigInt = z.bigint().readonly();\n  const readonlyBoolean = z.boolean().readonly();\n  const readonlyDate = z.date().readonly();\n  const readonlyUndefined = z.undefined().readonly();\n  const readonlyNull = z.null().readonly();\n  const readonlyAny = z.any().readonly();\n  const readonlyUnknown = z.unknown().readonly();\n  const readonlyVoid = z.void().readonly();\n  // const readonlyFunction = z.function(z.tuple([z.string(), z.number()]), z.unknown()).readonly();\n  const readonlyStringArray = z.string().array().readonly();\n  const readonlyTuple = z.tuple([z.string(), z.number()]).readonly();\n\n  expectTypeOf<z.infer<typeof readonlyString>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof readonlyNumber1>>().toEqualTypeOf<number>();\n  expectTypeOf<z.infer<typeof readonlyNumber2>>().toEqualTypeOf<number>();\n  expectTypeOf<z.infer<typeof readonlyBigInt>>().toEqualTypeOf<bigint>();\n  expectTypeOf<z.infer<typeof readonlyBoolean>>().toEqualTypeOf<boolean>();\n  expectTypeOf<z.infer<typeof readonlyDate>>().toEqualTypeOf<Date>();\n  expectTypeOf<z.infer<typeof readonlyUndefined>>().toEqualTypeOf<undefined>();\n  expectTypeOf<z.infer<typeof readonlyNull>>().toEqualTypeOf<null>();\n  expectTypeOf<z.infer<typeof readonlyAny>>().toEqualTypeOf<any>();\n  expectTypeOf<z.infer<typeof readonlyUnknown>>().toEqualTypeOf<Readonly<unknown>>();\n  expectTypeOf<z.infer<typeof readonlyVoid>>().toEqualTypeOf<void>();\n  // expectTypeOf<z.infer<typeof readonlyFunction>>().toEqualTypeOf<\n  //   (args_0: string, args_1: number, ...args_2: unknown[]) => unknown\n  // >();\n  expectTypeOf<z.infer<typeof readonlyStringArray>>().toEqualTypeOf<readonly string[]>();\n  expectTypeOf<z.infer<typeof readonlyTuple>>().toEqualTypeOf<readonly [string, number]>();\n\n  expect(readonlyString.parse(\"asdf\")).toEqual(\"asdf\");\n  expect(readonlyNumber1.parse(1234)).toEqual(1234);\n  expect(readonlyNumber2.parse(1234)).toEqual(1234);\n  const bigIntVal = BigInt(1);\n  expect(readonlyBigInt.parse(bigIntVal)).toEqual(bigIntVal);\n  expect(readonlyBoolean.parse(true)).toEqual(true);\n  const dateVal = new Date();\n  expect(readonlyDate.parse(dateVal)).toEqual(dateVal);\n  expect(readonlyUndefined.parse(undefined)).toEqual(undefined);\n  expect(readonlyNull.parse(null)).toEqual(null);\n  expect(readonlyAny.parse(\"whatever\")).toEqual(\"whatever\");\n  expect(readonlyUnknown.parse(\"whatever\")).toEqual(\"whatever\");\n  expect(readonlyVoid.parse(undefined)).toEqual(undefined);\n  // expect(readonlyFunction.parse(() => void 0)).toEqual(() => void 0);\n  expect(readonlyStringArray.parse([\"asdf\"])).toEqual([\"asdf\"]);\n  expect(readonlyTuple.parse([\"asdf\", 1234])).toEqual([\"asdf\", 1234]);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/readonly.test.ts",
        "start": 1,
        "end": 252,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 252,
          "column": 2,
          "position": 3281
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/readonly.test.ts",
        "start": 1,
        "end": 252,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 252,
          "column": 2,
          "position": 3281
        }
      }
    },
    {
      "format": "typescript",
      "lines": 23,
      "fragment": "import { expect, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ndeclare module \"zod/v4\" {\n  interface ZodType {\n    /** @deprecated */\n    _classic(): string;\n  }\n}\n\ntest(\"prototype extension\", () => {\n  z.ZodType.prototype._classic = function () {\n    return \"_classic\";\n  };\n\n  // should pass\n  const result = z.string()._classic();\n  expect(result).toBe(\"_classic\");\n  // expectTypeOf<typeof result>().toEqualTypeOf<string>();\n\n  // clean up\n  z.ZodType.prototype._classic = undefined;\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/prototypes.test.ts",
        "start": 1,
        "end": 23,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 23,
          "column": 2,
          "position": 160
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/prototypes.test.ts",
        "start": 1,
        "end": 23,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 23,
          "column": 2,
          "position": 160
        }
      }
    },
    {
      "format": "typescript",
      "lines": 81,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\nconst promSchema = z.promise(\n  z.object({\n    name: z.string(),\n    age: z.number(),\n  })\n);\n\ntest(\"promise inference\", () => {\n  type promSchemaType = z.infer<typeof promSchema>;\n  expectTypeOf<promSchemaType>().toEqualTypeOf<{ name: string; age: number }>();\n});\n\ntest(\"promise parsing success\", async () => {\n  // expect(() => promSchema.parse(Promise.resolve({ name: \"Bobby\", age: 10 }))).toThrow();\n  const pr = promSchema.parseAsync(Promise.resolve({ name: \"Bobby\", age: 10 }));\n  expect(pr).toBeInstanceOf(Promise);\n  const result = await pr;\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"age\": 10,\n      \"name\": \"Bobby\",\n    }\n  `);\n});\n\ntest(\"promise parsing fail\", async () => {\n  const bad = await promSchema.safeParseAsync(Promise.resolve({ name: \"Bobby\", age: \"10\" }));\n  expect(bad.success).toBe(false);\n  expect(bad.error).toBeInstanceOf(z.ZodError);\n});\n\ntest(\"promise parsing fail 2\", async () => {\n  const result = await promSchema.safeParseAsync(Promise.resolve({ name: \"Bobby\", age: \"10\" }));\n  expect(result.success).toBe(false);\n  expect(result.error).toBeInstanceOf(z.ZodError);\n});\n\ntest(\"promise parsing fail\", () => {\n  const bad = () => promSchema.parse({ then: () => {}, catch: {} });\n  expect(bad).toThrow();\n});\n\ntest(\"sync promise parsing\", () => {\n  expect(() => z.promise(z.string()).parse(Promise.resolve(\"asfd\"))).toThrow();\n});\n\nconst asyncFunction = z.function({\n  input: z.tuple([]),\n  output: promSchema,\n});\n\ntest(\"async function pass\", async () => {\n  const validatedFunction = asyncFunction.implementAsync(async () => {\n    return { name: \"jimmy\", age: 14 };\n  });\n  await expect(validatedFunction()).resolves.toEqual({\n    name: \"jimmy\",\n    age: 14,\n  });\n});\n\ntest(\"async function fail\", async () => {\n  const validatedFunction = asyncFunction.implementAsync(() => {\n    return Promise.resolve(\"asdf\" as any);\n  });\n  await expect(validatedFunction()).rejects.toBeInstanceOf(z.core.$ZodError);\n});\n\ntest(\"async promise parsing\", () => {\n  const res = z.promise(z.number()).parseAsync(Promise.resolve(12));\n  expect(res).toBeInstanceOf(Promise);\n});\n\ntest(\"resolves\", () => {\n  const foo = z.literal(\"foo\");\n  const res = z.promise(foo);\n  expect(res.unwrap()).toEqual(foo);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/promise.test.ts",
        "start": 1,
        "end": 81,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 81,
          "column": 2,
          "position": 855
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/promise.test.ts",
        "start": 1,
        "end": 81,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 81,
          "column": 2,
          "position": 855
        }
      }
    },
    {
      "format": "typescript",
      "lines": 175,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\nconst literalStringSchema = z.literal(\"asdf\");\nconst literalNumberSchema = z.literal(12);\nconst literalBooleanSchema = z.literal(true);\nconst literalBigIntSchema = z.literal(BigInt(42));\n\nconst stringSchema = z.string();\nconst numberSchema = z.number();\nconst bigintSchema = z.bigint();\nconst booleanSchema = z.boolean();\nconst dateSchema = z.date();\nconst symbolSchema = z.symbol();\nconst nullSchema = z.null();\nconst undefinedSchema = z.undefined();\nconst stringSchemaOptional = z.string().optional();\nconst stringSchemaNullable = z.string().nullable();\nconst numberSchemaOptional = z.number().optional();\nconst numberSchemaNullable = z.number().nullable();\nconst bigintSchemaOptional = z.bigint().optional();\nconst bigintSchemaNullable = z.bigint().nullable();\nconst booleanSchemaOptional = z.boolean().optional();\nconst booleanSchemaNullable = z.boolean().nullable();\nconst dateSchemaOptional = z.date().optional();\nconst dateSchemaNullable = z.date().nullable();\nconst symbolSchemaOptional = z.symbol().optional();\nconst symbolSchemaNullable = z.symbol().nullable();\n\ntest(\"literal string schema\", () => {\n  expect(literalStringSchema.parse(\"asdf\")).toBe(\"asdf\");\n  expect(() => literalStringSchema.parse(\"not_asdf\")).toThrow();\n  expect(() => literalStringSchema.parse(123)).toThrow();\n  expect(() => literalStringSchema.parse(true)).toThrow();\n  expect(() => literalStringSchema.parse({})).toThrow();\n});\n\ntest(\"literal number schema\", () => {\n  expect(literalNumberSchema.parse(12)).toBe(12);\n  expect(() => literalNumberSchema.parse(13)).toThrow();\n  expect(() => literalNumberSchema.parse(\"foo\")).toThrow();\n  expect(() => literalNumberSchema.parse(true)).toThrow();\n  expect(() => literalNumberSchema.parse({})).toThrow();\n});\n\ntest(\"literal boolean schema\", () => {\n  expect(literalBooleanSchema.parse(true)).toBe(true);\n  expect(() => literalBooleanSchema.parse(false)).toThrow();\n  expect(() => literalBooleanSchema.parse(\"asdf\")).toThrow();\n  expect(() => literalBooleanSchema.parse(123)).toThrow();\n  expect(() => literalBooleanSchema.parse({})).toThrow();\n});\n\ntest(\"literal bigint schema\", () => {\n  expect(literalBigIntSchema.parse(BigInt(42))).toBe(BigInt(42));\n  expect(() => literalBigIntSchema.parse(BigInt(43))).toThrow();\n  expect(() => literalBigIntSchema.parse(\"asdf\")).toThrow();\n  expect(() => literalBigIntSchema.parse(123)).toThrow();\n  expect(() => literalBigIntSchema.parse({})).toThrow();\n});\n\ntest(\"string schema\", () => {\n  stringSchema.parse(\"foo\");\n  expect(() => stringSchema.parse(Math.random())).toThrow();\n  expect(() => stringSchema.parse(true)).toThrow();\n  expect(() => stringSchema.parse(undefined)).toThrow();\n  expect(() => stringSchema.parse(null)).toThrow();\n});\n\ntest(\"number schema\", () => {\n  numberSchema.parse(Math.random());\n  expect(() => numberSchema.parse(\"foo\")).toThrow();\n  expect(() => numberSchema.parse(BigInt(17))).toThrow();\n  expect(() => numberSchema.parse(true)).toThrow();\n  expect(() => numberSchema.parse(undefined)).toThrow();\n  expect(() => numberSchema.parse(null)).toThrow();\n});\n\ntest(\"bigint schema\", () => {\n  bigintSchema.parse(BigInt(17));\n  expect(() => bigintSchema.parse(\"foo\")).toThrow();\n  expect(() => bigintSchema.parse(Math.random())).toThrow();\n  expect(() => bigintSchema.parse(true)).toThrow();\n  expect(() => bigintSchema.parse(undefined)).toThrow();\n  expect(() => bigintSchema.parse(null)).toThrow();\n});\n\ntest(\"boolean schema\", () => {\n  booleanSchema.parse(true);\n  expect(() => booleanSchema.parse(\"foo\")).toThrow();\n  expect(() => booleanSchema.parse(Math.random())).toThrow();\n  expect(() => booleanSchema.parse(undefined)).toThrow();\n  expect(() => booleanSchema.parse(null)).toThrow();\n});\n\ntest(\"date schema\", async () => {\n  dateSchema.parse(new Date());\n  expect(() => dateSchema.parse(\"foo\")).toThrow();\n  expect(() => dateSchema.parse(Math.random())).toThrow();\n  expect(() => dateSchema.parse(true)).toThrow();\n  expect(() => dateSchema.parse(undefined)).toThrow();\n  expect(() => dateSchema.parse(null)).toThrow();\n  expect(await dateSchema.safeParseAsync(new Date(\"invalid\"))).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"date\",\n        \"code\": \"invalid_type\",\n        \"received\": \"Invalid Date\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected date, received Date\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"symbol schema\", () => {\n  symbolSchema.parse(Symbol(\"foo\"));\n  expect(() => symbolSchema.parse(\"foo\")).toThrow();\n  expect(() => symbolSchema.parse(Math.random())).toThrow();\n  expect(() => symbolSchema.parse(true)).toThrow();\n  expect(() => symbolSchema.parse(new Date())).toThrow();\n  expect(() => symbolSchema.parse(undefined)).toThrow();\n  expect(() => symbolSchema.parse(null)).toThrow();\n});\n\ntest(\"undefined schema\", () => {\n  undefinedSchema.parse(undefined);\n  expect(() => undefinedSchema.parse(\"foo\")).toThrow();\n  expect(() => undefinedSchema.parse(Math.random())).toThrow();\n  expect(() => undefinedSchema.parse(true)).toThrow();\n  expect(() => undefinedSchema.parse(null)).toThrow();\n});\n\ntest(\"null schema\", () => {\n  nullSchema.parse(null);\n  expect(() => nullSchema.parse(\"foo\")).toThrow();\n  expect(() => nullSchema.parse(Math.random())).toThrow();\n  expect(() => nullSchema.parse(true)).toThrow();\n  expect(() => nullSchema.parse(undefined)).toThrow();\n});\n\ntest(\"primitive inference\", () => {\n  expectTypeOf<z.TypeOf<typeof literalStringSchema>>().toEqualTypeOf<\"asdf\">();\n  expectTypeOf<z.TypeOf<typeof literalNumberSchema>>().toEqualTypeOf<12>();\n  expectTypeOf<z.TypeOf<typeof literalBooleanSchema>>().toEqualTypeOf<true>();\n  expectTypeOf<z.TypeOf<typeof literalBigIntSchema>>().toEqualTypeOf<bigint>();\n  expectTypeOf<z.TypeOf<typeof stringSchema>>().toEqualTypeOf<string>();\n  expectTypeOf<z.TypeOf<typeof numberSchema>>().toEqualTypeOf<number>();\n  expectTypeOf<z.TypeOf<typeof bigintSchema>>().toEqualTypeOf<bigint>();\n  expectTypeOf<z.TypeOf<typeof booleanSchema>>().toEqualTypeOf<boolean>();\n  expectTypeOf<z.TypeOf<typeof dateSchema>>().toEqualTypeOf<Date>();\n  expectTypeOf<z.TypeOf<typeof symbolSchema>>().toEqualTypeOf<symbol>();\n  expectTypeOf<z.TypeOf<typeof nullSchema>>().toEqualTypeOf<null>();\n  expectTypeOf<z.TypeOf<typeof undefinedSchema>>().toEqualTypeOf<undefined>();\n  expectTypeOf<z.TypeOf<typeof stringSchemaOptional>>().toEqualTypeOf<string | undefined>();\n  expectTypeOf<z.TypeOf<typeof stringSchemaNullable>>().toEqualTypeOf<string | null>();\n  expectTypeOf<z.TypeOf<typeof numberSchemaOptional>>().toEqualTypeOf<number | undefined>();\n  expectTypeOf<z.TypeOf<typeof numberSchemaNullable>>().toEqualTypeOf<number | null>();\n  expectTypeOf<z.TypeOf<typeof bigintSchemaOptional>>().toEqualTypeOf<bigint | undefined>();\n  expectTypeOf<z.TypeOf<typeof bigintSchemaNullable>>().toEqualTypeOf<bigint | null>();\n  expectTypeOf<z.TypeOf<typeof booleanSchemaOptional>>().toEqualTypeOf<boolean | undefined>();\n  expectTypeOf<z.TypeOf<typeof booleanSchemaNullable>>().toEqualTypeOf<boolean | null>();\n  expectTypeOf<z.TypeOf<typeof dateSchemaOptional>>().toEqualTypeOf<Date | undefined>();\n  expectTypeOf<z.TypeOf<typeof dateSchemaNullable>>().toEqualTypeOf<Date | null>();\n  expectTypeOf<z.TypeOf<typeof symbolSchemaOptional>>().toEqualTypeOf<symbol | undefined>();\n  expectTypeOf<z.TypeOf<typeof symbolSchemaNullable>>().toEqualTypeOf<symbol | null>();\n});\n\ntest(\"get literal values\", () => {\n  expect(literalStringSchema.values).toEqual(new Set([\"asdf\"]));\n  expect(literalStringSchema._zod.def.values).toEqual([\"asdf\"]);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/primitive.test.ts",
        "start": 1,
        "end": 175,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 175,
          "column": 2,
          "position": 2595
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/primitive.test.ts",
        "start": 1,
        "end": 175,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 175,
          "column": 2,
          "position": 2595
        }
      }
    },
    {
      "format": "typescript",
      "lines": 298,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ntest(\"preprocess\", () => {\n  const schema = z.preprocess((data) => [data], z.string().array());\n  const value = schema.parse(\"asdf\");\n  expect(value).toEqual([\"asdf\"]);\n  expectTypeOf<(typeof schema)[\"_input\"]>().toEqualTypeOf<unknown>();\n});\n\ntest(\"async preprocess\", async () => {\n  const schema = z.preprocess(async (data) => {\n    return [data];\n  }, z.string().array());\n  const value = await schema.safeParseAsync(\"asdf\");\n  expect(value.data).toEqual([\"asdf\"]);\n  expect(value).toMatchInlineSnapshot(`\n    {\n      \"data\": [\n        \"asdf\",\n      ],\n      \"success\": true,\n    }\n  `);\n});\n\ntest(\"ctx.addIssue accepts string\", () => {\n  const schema = z.preprocess((_, ctx) => {\n    ctx.addIssue(\"bad stuff\");\n  }, z.string());\n  const result = schema.safeParse(\"asdf\");\n  expect(result.error!.issues).toHaveLength(1);\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"message\": \"bad stuff\",\n        \"code\": \"custom\",\n        \"path\": []\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"preprocess ctx.addIssue with parse\", () => {\n  const a = z.preprocess((data, ctx) => {\n    ctx.addIssue({\n      input: data,\n      code: \"custom\",\n      message: `${data} is not one of our allowed strings`,\n    });\n    return data;\n  }, z.string());\n\n  const result = a.safeParse(\"asdf\");\n\n  // expect(result.error!.toJSON()).toContain(\"not one of our allowed strings\");\n\n  expect(result.error!.issues).toHaveLength(1);\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"message\": \"asdf is not one of our allowed strings\",\n        \"path\": []\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"preprocess ctx.addIssue non-fatal by default\", () => {\n  const schema = z.preprocess((data, ctx) => {\n    ctx.addIssue({\n      code: \"custom\",\n      message: `custom error`,\n    });\n    return data;\n  }, z.string());\n  const result = schema.safeParse(1234);\n\n  expect(result.error!.issues).toHaveLength(2);\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"message\": \"custom error\",\n        \"path\": []\n      },\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected string, received number\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"preprocess ctx.addIssue fatal true\", () => {\n  const schema = z.preprocess((data, ctx) => {\n    ctx.addIssue({\n      input: data,\n      code: \"custom\",\n      origin: \"custom\",\n      message: `custom error`,\n      fatal: true,\n    });\n    return data;\n  }, z.string());\n\n  const result = schema.safeParse(1234);\n\n  expect(result.error!.issues).toHaveLength(1);\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"origin\": \"custom\",\n        \"message\": \"custom error\",\n        \"fatal\": true,\n        \"path\": []\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"async preprocess ctx.addIssue with parseAsync\", async () => {\n  const schema = z.preprocess(async (data, ctx) => {\n    ctx.addIssue({\n      input: data,\n      code: \"custom\",\n      message: `${data} is not one of our allowed strings`,\n    });\n    return data;\n  }, z.string());\n\n  const result = await schema.safeParseAsync(\"asdf\");\n\n  expect(result.error!.issues).toHaveLength(1);\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"message\": \"asdf is not one of our allowed strings\",\n        \"path\": []\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"z.NEVER in preprocess\", () => {\n  const foo = z.preprocess((val, ctx) => {\n    if (!val) {\n      ctx.addIssue({ input: val, code: \"custom\", message: \"bad\" });\n      return z.NEVER;\n    }\n    return val;\n  }, z.number());\n\n  type foo = z.infer<typeof foo>;\n  expectTypeOf<foo>().toEqualTypeOf<number>();\n  const result = foo.safeParse(undefined);\n\n  expect(result.error!.issues).toHaveLength(2);\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"message\": \"bad\",\n        \"path\": []\n      },\n      {\n        \"expected\": \"number\",\n        \"code\": \"invalid_type\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected number, received object\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"preprocess as the second property of object\", () => {\n  const schema = z.object({\n    nonEmptyStr: z.string().min(1),\n    positiveNum: z.preprocess((v) => Number(v), z.number().positive()),\n  });\n  const result = schema.safeParse({\n    nonEmptyStr: \"\",\n    positiveNum: \"\",\n  });\n\n  expect(result.error!.issues).toHaveLength(2);\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"origin\": \"string\",\n        \"code\": \"too_small\",\n        \"minimum\": 1,\n        \"inclusive\": true,\n        \"path\": [\n          \"nonEmptyStr\"\n        ],\n        \"message\": \"Too small: expected string to have >=1 characters\"\n      },\n      {\n        \"origin\": \"number\",\n        \"code\": \"too_small\",\n        \"minimum\": 0,\n        \"inclusive\": false,\n        \"path\": [\n          \"positiveNum\"\n        ],\n        \"message\": \"Too small: expected number to be >0\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"preprocess validates with sibling errors\", () => {\n  const schema = z.object({\n    missing: z.string().refine(() => false),\n    preprocess: z.preprocess((data: any) => data?.trim(), z.string().regex(/ asdf/)),\n  });\n\n  const result = schema.safeParse({ preprocess: \" asdf\" });\n\n  expect(result.error!.issues).toHaveLength(2);\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"missing\"\n        ],\n        \"message\": \"Invalid input: expected string, received undefined\"\n      },\n      {\n        \"origin\": \"string\",\n        \"code\": \"invalid_format\",\n        \"format\": \"regex\",\n        \"pattern\": \"/ asdf/\",\n        \"path\": [\n          \"preprocess\"\n        ],\n        \"message\": \"Invalid string: must match pattern / asdf/\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"perform transform with non-fatal issues\", () => {\n  const A = z\n    .string()\n    .refine((_) => false)\n    .min(4)\n    .transform((val) => val.length)\n    .pipe(z.number())\n    .refine((_) => false);\n  expect(A.safeParse(\"asdfasdf\").error!.issues).toHaveLength(2);\n  expect(A.safeParse(\"asdfasdf\").error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"Invalid input\"\n      },\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"Invalid input\"\n      }\n    ]]\n  `);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/preprocess.test.ts",
        "start": 1,
        "end": 298,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 298,
          "column": 2,
          "position": 1524
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/preprocess.test.ts",
        "start": 1,
        "end": 298,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 298,
          "column": 2,
          "position": 1524
        }
      }
    },
    {
      "format": "typescript",
      "lines": 37,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport { z } from \"zod/v4\";\n\ntest(\"basic prefault\", () => {\n  const a = z.prefault(z.string().trim(), \"  default  \");\n  expect(a).toBeInstanceOf(z.ZodPrefault);\n  expect(a.parse(\"  asdf  \")).toEqual(\"asdf\");\n  expect(a.parse(undefined)).toEqual(\"default\");\n\n  type inp = z.input<typeof a>;\n  expectTypeOf<inp>().toEqualTypeOf<string | undefined>();\n  type out = z.output<typeof a>;\n  expectTypeOf<out>().toEqualTypeOf<string>();\n});\n\ntest(\"prefault inside object\", () => {\n  // test optinality\n  const a = z.object({\n    name: z.string().optional(),\n    age: z.number().default(1234),\n    email: z.string().prefault(\"1234\"),\n  });\n\n  type inp = z.input<typeof a>;\n  expectTypeOf<inp>().toEqualTypeOf<{\n    name?: string | undefined;\n    age?: number | undefined;\n    email?: string | undefined;\n  }>();\n\n  type out = z.output<typeof a>;\n  expectTypeOf<out>().toEqualTypeOf<{\n    name?: string | undefined;\n    age: number;\n    email: string;\n  }>();\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/prefault.test.ts",
        "start": 1,
        "end": 37,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 37,
          "column": 2,
          "position": 413
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/prefault.test.ts",
        "start": 1,
        "end": 37,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 37,
          "column": 2,
          "position": 413
        }
      }
    },
    {
      "format": "typescript",
      "lines": 81,
      "fragment": "import { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\ntest(\"string to number pipe\", () => {\n  const schema = z.string().transform(Number).pipe(z.number());\n  expect(schema.parse(\"1234\")).toEqual(1234);\n});\n\ntest(\"string to number pipe async\", async () => {\n  const schema = z\n    .string()\n    .transform(async (val) => Number(val))\n    .pipe(z.number());\n  expect(await schema.parseAsync(\"1234\")).toEqual(1234);\n});\n\ntest(\"string with default fallback\", () => {\n  const stringWithDefault = z\n    .pipe(\n      z.transform((v) => (v === \"none\" ? undefined : v)),\n      z.string()\n    )\n    .catch(\"default\");\n\n  expect(stringWithDefault.parse(\"ok\")).toBe(\"ok\");\n  expect(stringWithDefault.parse(undefined)).toBe(\"default\");\n  expect(stringWithDefault.parse(\"none\")).toBe(\"default\");\n  expect(stringWithDefault.parse(15)).toBe(\"default\");\n});\n\ntest(\"continue on non-fatal errors\", () => {\n  const schema = z\n    .string()\n    .refine((c) => c === \"1234\", \"A\")\n    .transform((val) => Number(val))\n    .refine((c) => c === 1234, \"B\");\n\n  schema.parse(\"1234\");\n\n  expect(schema.safeParse(\"4321\")).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"A\"\n      },\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"B\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"break on fatal errors\", () => {\n  const schema = z\n    .string()\n    .refine((c) => c === \"1234\", { message: \"A\", abort: true })\n    .transform((val) => Number(val))\n    .refine((c) => c === 1234, \"B\");\n\n  schema.parse(\"1234\");\n\n  expect(schema.safeParse(\"4321\")).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"A\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/pipe.test.ts",
        "start": 1,
        "end": 81,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 81,
          "column": 2,
          "position": 567
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/pipe.test.ts",
        "start": 1,
        "end": 81,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 81,
          "column": 2,
          "position": 567
        }
      }
    },
    {
      "format": "typescript",
      "lines": 127,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\nconst fish = z.object({\n  name: z.string(),\n  age: z.number(),\n  nested: z.object({}),\n});\n\ntest(\"pick type inference\", () => {\n  const nameonlyFish = fish.pick({ name: true });\n  type nameonlyFish = z.infer<typeof nameonlyFish>;\n  expectTypeOf<nameonlyFish>().toEqualTypeOf<{ name: string }>();\n});\n\ntest(\"pick parse - success\", () => {\n  const nameonlyFish = fish.pick({ name: true });\n  nameonlyFish.parse({ name: \"bob\" });\n\n  // @ts-expect-error checking runtime picks `name` only.\n  const anotherNameonlyFish = fish.pick({ name: true, age: false });\n  anotherNameonlyFish.parse({ name: \"bob\" });\n});\n\ntest(\"pick parse - fail\", () => {\n  fish.pick({ name: true }).parse({ name: \"12\" } as any);\n  fish.pick({ name: true }).parse({ name: \"bob\", age: 12 } as any);\n  fish.pick({ age: true }).parse({ age: 12 } as any);\n\n  const nameonlyFish = fish.pick({ name: true }).strict();\n  const bad1 = () => nameonlyFish.parse({ name: 12 } as any);\n  const bad2 = () => nameonlyFish.parse({ name: \"bob\", age: 12 } as any);\n  const bad3 = () => nameonlyFish.parse({ age: 12 } as any);\n\n  // @ts-expect-error checking runtime picks `name` only.\n  const anotherNameonlyFish = fish.pick({ name: true, age: false }).strict();\n  const bad4 = () => anotherNameonlyFish.parse({ name: \"bob\", age: 12 } as any);\n\n  expect(bad1).toThrow();\n  expect(bad2).toThrow();\n  expect(bad3).toThrow();\n  expect(bad4).toThrow();\n});\n\ntest(\"pick - remove optional\", () => {\n  const schema = z.object({ a: z.string(), b: z.string().optional() });\n  expect(\"a\" in schema._zod.def.shape).toEqual(true);\n  expect(\"b\" in schema._zod.def.shape!).toEqual(true);\n  const picked = schema.pick({ a: true });\n  expect(\"a\" in picked._zod.def.shape).toEqual(true);\n  expect(\"b\" in picked._zod.def.shape!).toEqual(false);\n});\n\ntest(\"omit type inference\", () => {\n  const nonameFish = fish.omit({ name: true });\n  type nonameFish = z.infer<typeof nonameFish>;\n\n  expectTypeOf<nonameFish>().toEqualTypeOf<{ age: number; nested: Record<string, never> }>();\n});\n\ntest(\"omit parse - success\", () => {\n  const nonameFish = fish.omit({ name: true });\n  nonameFish.parse({ age: 12, nested: {} });\n\n  // @ts-expect-error checking runtime omits `name` only.\n  const anotherNonameFish = fish.omit({ name: true, age: false });\n  anotherNonameFish.parse({ age: 12, nested: {} });\n});\n\ntest(\"omit parse - fail\", () => {\n  const nonameFish = fish.omit({ name: true });\n  const bad1 = () => nonameFish.parse({ name: 12 } as any);\n  const bad2 = () => nonameFish.parse({ age: 12 } as any);\n  const bad3 = () => nonameFish.parse({} as any);\n\n  // @ts-expect-error checking runtime omits `name` only.\n  const anotherNonameFish = fish.omit({ name: true, age: false });\n  const bad4 = () => anotherNonameFish.parse({ nested: {} } as any);\n\n  expect(bad1).toThrow();\n  expect(bad2).toThrow();\n  expect(bad3).toThrow();\n  expect(bad4).toThrow();\n});\n\ntest(\"omit - remove optional\", () => {\n  const schema = z.object({ a: z.string(), b: z.string().optional() });\n  expect(\"a\" in schema._zod.def.shape).toEqual(true);\n  const omitted = schema.omit({ a: true });\n  expect(\"a\" in omitted._zod.def.shape).toEqual(false);\n});\n\ntest(\"nonstrict inference\", () => {\n  const laxfish = fish.pick({ name: true }).catchall(z.any());\n  type laxfish = z.infer<typeof laxfish>;\n  expectTypeOf<laxfish>().toEqualTypeOf<{ name: string; [k: string]: any }>();\n});\n\ntest(\"nonstrict parsing - pass\", () => {\n  const laxfish = fish.passthrough().pick({ name: true });\n  laxfish.parse({ name: \"asdf\", whatever: \"asdf\" });\n  laxfish.parse({ name: \"asdf\", age: 12, nested: {} });\n});\n\ntest(\"nonstrict parsing - fail\", () => {\n  const laxfish = fish.passthrough().pick({ name: true });\n  const bad = () => laxfish.parse({ whatever: \"asdf\" } as any);\n  expect(bad).toThrow();\n});\n\ntest(\"pick/omit/required/partial - do not allow unknown keys\", () => {\n  const schema = z.object({\n    name: z.string(),\n    age: z.number(),\n  });\n\n  expect(() => schema.pick({ name: true, asdf: true })).toThrow();\n\n  // @ts-expect-error\n  expect(() => schema.pick({ $unknown: true })).toThrow();\n  // @ts-expect-error\n  expect(() => schema.omit({ $unknown: true })).toThrow();\n  // @ts-expect-error\n  expect(() => schema.required({ $unknown: true })).toThrow();\n  // @ts-expect-error\n  expect(() => schema.partial({ $unknown: true })).toThrow();\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/pickomit.test.ts",
        "start": 1,
        "end": 127,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 127,
          "column": 2,
          "position": 1858
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/pickomit.test.ts",
        "start": 1,
        "end": 127,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 127,
          "column": 2,
          "position": 1858
        }
      }
    },
    {
      "format": "typescript",
      "lines": 147,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\nconst nested = z.object({\n  name: z.string(),\n  age: z.number(),\n  outer: z.object({\n    inner: z.string(),\n  }),\n  array: z.array(z.object({ asdf: z.string() })),\n});\n\ntest(\"shallow inference\", () => {\n  const shallow = nested.partial();\n  type shallow = z.infer<typeof shallow>;\n\n  expectTypeOf<shallow>().toEqualTypeOf<{\n    name?: string | undefined;\n    age?: number | undefined;\n    outer?: { inner: string } | undefined;\n    array?: { asdf: string }[] | undefined;\n  }>();\n});\n\ntest(\"shallow partial parse\", () => {\n  const shallow = nested.partial();\n  shallow.parse({});\n  shallow.parse({\n    name: \"asdf\",\n    age: 23143,\n  });\n});\n\ntest(\"required\", () => {\n  const object = z.object({\n    name: z.string(),\n    age: z.number().optional(),\n    field: z.string().optional().default(\"asdf\"),\n    nullableField: z.number().nullable(),\n    nullishField: z.string().nullish(),\n  });\n\n  const requiredObject = object.required();\n  expect(requiredObject.shape.name).toBeInstanceOf(z.ZodNonOptional);\n  expect(requiredObject.shape.name.unwrap()).toBeInstanceOf(z.ZodString);\n  expect(requiredObject.shape.age).toBeInstanceOf(z.ZodNonOptional);\n  expect(requiredObject.shape.age.unwrap()).toBeInstanceOf(z.ZodOptional);\n  expect(requiredObject.shape.field).toBeInstanceOf(z.ZodNonOptional);\n  expect(requiredObject.shape.field.unwrap()).toBeInstanceOf(z.ZodDefault);\n  expect(requiredObject.shape.nullableField).toBeInstanceOf(z.ZodNonOptional);\n  expect(requiredObject.shape.nullableField.unwrap()).toBeInstanceOf(z.ZodNullable);\n  expect(requiredObject.shape.nullishField).toBeInstanceOf(z.ZodNonOptional);\n  expect(requiredObject.shape.nullishField.unwrap()).toBeInstanceOf(z.ZodOptional);\n  expect(requiredObject.shape.nullishField.unwrap().unwrap()).toBeInstanceOf(z.ZodNullable);\n});\n\ntest(\"required inference\", () => {\n  const object = z.object({\n    name: z.string(),\n    age: z.number().optional(),\n    field: z.string().optional().default(\"asdf\"),\n    nullableField: z.number().nullable(),\n    nullishField: z.string().nullish(),\n  });\n\n  const requiredObject = object.required();\n\n  type required = z.infer<typeof requiredObject>;\n  type expected = {\n    name: string;\n    age: number;\n    field: string;\n    nullableField: number | null;\n    nullishField: string | null;\n  };\n  expectTypeOf<expected>().toEqualTypeOf<required>();\n});\n\ntest(\"required with mask\", () => {\n  const object = z.object({\n    name: z.string(),\n    age: z.number().optional(),\n    field: z.string().optional().default(\"asdf\"),\n    country: z.string().optional(),\n  });\n\n  const requiredObject = object.required({ age: true });\n  expect(requiredObject.shape.name).toBeInstanceOf(z.ZodString);\n  expect(requiredObject.shape.age).toBeInstanceOf(z.ZodNonOptional);\n  expect(requiredObject.shape.field).toBeInstanceOf(z.ZodDefault);\n  expect(requiredObject.shape.country).toBeInstanceOf(z.ZodOptional);\n});\n\ntest(\"required with mask -- ignore falsy values\", () => {\n  const object = z.object({\n    name: z.string(),\n    age: z.number().optional(),\n    field: z.string().optional().default(\"asdf\"),\n    country: z.string().optional(),\n  });\n\n  // @ts-expect-error\n  const requiredObject = object.required({ age: true, country: false });\n  expect(requiredObject.shape.name).toBeInstanceOf(z.ZodString);\n  expect(requiredObject.shape.age).toBeInstanceOf(z.ZodNonOptional);\n  expect(requiredObject.shape.field).toBeInstanceOf(z.ZodDefault);\n  expect(requiredObject.shape.country).toBeInstanceOf(z.ZodOptional);\n});\n\ntest(\"partial with mask\", async () => {\n  const object = z.object({\n    name: z.string(),\n    age: z.number().optional(),\n    field: z.string().optional().default(\"asdf\"),\n    country: z.string(),\n  });\n\n  const masked = object.partial({ age: true, field: true, name: true }).strict();\n\n  expect(masked.shape.name).toBeInstanceOf(z.ZodOptional);\n  expect(masked.shape.age).toBeInstanceOf(z.ZodOptional);\n  expect(masked.shape.field).toBeInstanceOf(z.ZodOptional);\n  expect(masked.shape.country).toBeInstanceOf(z.ZodString);\n\n  masked.parse({ country: \"US\" });\n  await masked.parseAsync({ country: \"US\" });\n});\n\ntest(\"partial with mask -- ignore falsy values\", async () => {\n  const object = z.object({\n    name: z.string(),\n    age: z.number().optional(),\n    field: z.string().optional().default(\"asdf\"),\n    country: z.string(),\n  });\n\n  // @ts-expect-error\n  const masked = object.partial({ name: true, country: false }).strict();\n\n  expect(masked.shape.name).toBeInstanceOf(z.ZodOptional);\n  expect(masked.shape.age).toBeInstanceOf(z.ZodOptional);\n  expect(masked.shape.field).toBeInstanceOf(z.ZodDefault);\n  expect(masked.shape.country).toBeInstanceOf(z.ZodString);\n\n  masked.parse({ country: \"US\" });\n  await masked.parseAsync({ country: \"US\" });\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/partial.test.ts",
        "start": 1,
        "end": 147,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 147,
          "column": 2,
          "position": 1760
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/partial.test.ts",
        "start": 1,
        "end": 147,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 147,
          "column": 2,
          "position": 1760
        }
      }
    },
    {
      "format": "typescript",
      "lines": 123,
      "fragment": "// @ts-ignore TS6133\nimport { expect, expectTypeOf, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\ntest(\".optional()\", () => {\n  const schema = z.string().optional();\n  expect(schema.parse(\"adsf\")).toEqual(\"adsf\");\n  expect(schema.parse(undefined)).toEqual(undefined);\n  expect(schema.safeParse(null).success).toEqual(false);\n\n  expectTypeOf<typeof schema._output>().toEqualTypeOf<string | undefined>();\n});\n\ntest(\"unwrap\", () => {\n  const unwrapped = z.string().optional().unwrap();\n  expect(unwrapped).toBeInstanceOf(z.ZodString);\n});\n\ntest(\"optionality\", () => {\n  const a = z.string();\n  expect(a._zod.optin).toEqual(undefined);\n  expect(a._zod.optout).toEqual(undefined);\n\n  const b = z.string().optional();\n  expect(b._zod.optin).toEqual(\"optional\");\n  expect(b._zod.optout).toEqual(\"optional\");\n\n  const c = z.string().default(\"asdf\");\n  expect(c._zod.optin).toEqual(\"optional\");\n  expect(c._zod.optout).toEqual(undefined);\n\n  const d = z.string().optional().nullable();\n  expect(d._zod.optin).toEqual(\"optional\");\n  expect(d._zod.optout).toEqual(\"optional\");\n\n  const e = z.string().default(\"asdf\").nullable();\n  expect(e._zod.optin).toEqual(\"optional\");\n  expect(e._zod.optout).toEqual(undefined);\n\n  // z.undefined should NOT be optional\n  const f = z.undefined();\n  expect(f._zod.optin).toEqual(\"optional\");\n  expect(f._zod.optout).toEqual(\"optional\");\n  expectTypeOf<typeof f._zod.optin>().toEqualTypeOf<\"optional\" | undefined>();\n  expectTypeOf<typeof f._zod.optout>().toEqualTypeOf<\"optional\" | undefined>();\n\n  // z.union should be optional if any of the types are optional\n  const g = z.union([z.string(), z.undefined()]);\n  expect(g._zod.optin).toEqual(\"optional\");\n  expect(g._zod.optout).toEqual(\"optional\");\n  expectTypeOf<typeof g._zod.optin>().toEqualTypeOf<\"optional\" | undefined>();\n  expectTypeOf<typeof g._zod.optout>().toEqualTypeOf<\"optional\" | undefined>();\n\n  const h = z.union([z.string(), z.optional(z.string())]);\n  expect(h._zod.optin).toEqual(\"optional\");\n  expect(h._zod.optout).toEqual(\"optional\");\n  expectTypeOf<typeof h._zod.optin>().toEqualTypeOf<\"optional\">();\n  expectTypeOf<typeof h._zod.optout>().toEqualTypeOf<\"optional\">();\n});\n\ntest(\"pipe optionality\", () => {\n  z.string().optional()._zod.optin;\n  const a = z.string().optional().pipe(z.string());\n  expect(a._zod.optin).toEqual(\"optional\");\n  expect(a._zod.optout).toEqual(undefined);\n  expectTypeOf<typeof a._zod.optin>().toEqualTypeOf<\"optional\">();\n  expectTypeOf<typeof a._zod.optout>().toEqualTypeOf<\"optional\" | undefined>();\n\n  const b = z\n    .string()\n    .transform((val) => (Math.random() ? val : undefined))\n    .pipe(z.string().optional());\n  expect(b._zod.optin).toEqual(undefined);\n  expect(b._zod.optout).toEqual(\"optional\");\n  expectTypeOf<typeof b._zod.optin>().toEqualTypeOf<\"optional\" | undefined>();\n  expectTypeOf<typeof b._zod.optout>().toEqualTypeOf<\"optional\">();\n\n  const c = z.string().default(\"asdf\").pipe(z.string());\n  expect(c._zod.optin).toEqual(\"optional\");\n  expect(c._zod.optout).toEqual(undefined);\n\n  const d = z\n    .string()\n    .transform((val) => (Math.random() ? val : undefined))\n    .pipe(z.string().default(\"asdf\"));\n  expect(d._zod.optin).toEqual(undefined);\n  expect(d._zod.optout).toEqual(undefined);\n});\n\ntest(\"pipe optionality inside objects\", () => {\n  const schema = z.object({\n    a: z.string().optional(),\n    b: z.string().optional().pipe(z.string()),\n    c: z.string().default(\"asdf\").pipe(z.string()),\n    d: z\n      .string()\n      .transform((val) => (Math.random() ? val : undefined))\n      .pipe(z.string().optional()),\n    e: z\n      .string()\n      .transform((val) => (Math.random() ? val : undefined))\n      .pipe(z.string().default(\"asdf\")),\n  });\n\n  type SchemaIn = z.input<typeof schema>;\n  expectTypeOf<SchemaIn>().toEqualTypeOf<{\n    a?: string | undefined;\n    b?: string | undefined;\n    c?: string | undefined;\n    d: string;\n    e: string;\n  }>();\n\n  type SchemaOut = z.output<typeof schema>;\n  expectTypeOf<SchemaOut>().toEqualTypeOf<{\n    a?: string | undefined;\n    b: string;\n    c: string;\n    d?: string | undefined;\n    e: string;\n  }>();\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/optional.test.ts",
        "start": 1,
        "end": 123,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 123,
          "column": 2,
          "position": 1615
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/optional.test.ts",
        "start": 1,
        "end": 123,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 123,
          "column": 2,
          "position": 1615
        }
      }
    },
    {
      "format": "typescript",
      "lines": 563,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\nimport * as core from \"zod/v4/core\";\n\nconst Test = z.object({\n  f1: z.number(),\n  f2: z.string().optional(),\n  f3: z.string().nullable(),\n  f4: z.array(z.object({ t: z.union([z.string(), z.boolean()]) })),\n});\n\ntest(\"object type inference\", () => {\n  type TestType = {\n    f1: number;\n    f2?: string | undefined;\n    f3: string | null;\n    f4: { t: string | boolean }[];\n  };\n\n  expectTypeOf<z.TypeOf<typeof Test>>().toEqualTypeOf<TestType>();\n});\n\ntest(\"unknown throw\", () => {\n  const asdf: unknown = 35;\n  expect(() => Test.parse(asdf)).toThrow();\n});\n\ntest(\"shape() should return schema of particular key\", () => {\n  const f1Schema = Test.shape.f1;\n  const f2Schema = Test.shape.f2;\n  const f3Schema = Test.shape.f3;\n  const f4Schema = Test.shape.f4;\n\n  expect(f1Schema).toBeInstanceOf(z.ZodNumber);\n  expect(f2Schema).toBeInstanceOf(z.ZodOptional);\n  expect(f3Schema).toBeInstanceOf(z.ZodNullable);\n  expect(f4Schema).toBeInstanceOf(z.ZodArray);\n});\n\ntest(\"correct parsing\", () => {\n  Test.parse({\n    f1: 12,\n    f2: \"string\",\n    f3: \"string\",\n    f4: [\n      {\n        t: \"string\",\n      },\n    ],\n  });\n\n  Test.parse({\n    f1: 12,\n    f3: null,\n    f4: [\n      {\n        t: false,\n      },\n    ],\n  });\n});\n\ntest(\"nonstrict by default\", () => {\n  z.object({ points: z.number() }).parse({\n    points: 2314,\n    unknown: \"asdf\",\n  });\n});\n\ntest(\"parse optional keys \", () => {\n  const schema = z.object({\n    a: z.string().optional(),\n  });\n  expect(schema.parse({ a: \"asdf\" })).toEqual({ a: \"asdf\" });\n});\n\ntest(\"empty object\", () => {\n  const schema = z.object({});\n  expect(schema.parse({})).toEqual({});\n  expect(schema.parse({ name: \"asdf\" })).toEqual({});\n  expect(schema.safeParse(null).success).toEqual(false);\n  expect(schema.safeParse(\"asdf\").success).toEqual(false);\n  expectTypeOf<z.output<typeof schema>>().toEqualTypeOf<Record<string, never>>();\n});\n\nconst data = {\n  points: 2314,\n  unknown: \"asdf\",\n};\n\ntest(\"strip by default\", () => {\n  const val = z.object({ points: z.number() }).parse(data);\n  expect(val).toEqual({ points: 2314 });\n});\n\ntest(\"unknownkeys override\", () => {\n  const val = z.object({ points: z.number() }).strict().passthrough().strip().passthrough().parse(data);\n\n  expect(val).toEqual(data);\n});\n\ntest(\"passthrough unknown\", () => {\n  const val = z.object({ points: z.number() }).passthrough().parse(data);\n\n  expect(val).toEqual(data);\n});\n\ntest(\"strip unknown\", () => {\n  const val = z.object({ points: z.number() }).strip().parse(data);\n\n  expect(val).toEqual({ points: 2314 });\n});\n\ntest(\"strict\", () => {\n  const val = z.object({ points: z.number() }).strict().safeParse(data);\n\n  expect(val.success).toEqual(false);\n});\n\ntest(\"catchall inference\", () => {\n  const o1 = z\n    .object({\n      first: z.string(),\n    })\n    .catchall(z.number());\n\n  const d1 = o1.parse({ first: \"asdf\", num: 1243 });\n  // expectTypeOf<(typeof d1)[\"asdf\"]>().toEqualTypeOf<number>();\n  expectTypeOf<(typeof d1)[\"first\"]>().toEqualTypeOf<string>();\n});\n\ntest(\"catchall overrides strict\", () => {\n  const o1 = z.object({ first: z.string().optional() }).strict().catchall(z.number());\n\n  // should run fine\n  // setting a catchall overrides the unknownKeys behavior\n  o1.parse({\n    asdf: 1234,\n  });\n\n  // should only run catchall validation\n  // against unknown keys\n  o1.parse({\n    first: \"asdf\",\n    asdf: 1234,\n  });\n});\n\ntest(\"catchall overrides strict\", () => {\n  const o1 = z\n    .object({\n      first: z.string(),\n    })\n    .strict()\n    .catchall(z.number());\n\n  // should run fine\n  // setting a catchall overrides the unknownKeys behavior\n  o1.parse({\n    first: \"asdf\",\n    asdf: 1234,\n  });\n});\n\ntest(\"optional keys are unset\", async () => {\n  const SNamedEntity = z.object({\n    id: z.string(),\n    set: z.string().optional(),\n    unset: z.string().optional(),\n  });\n  const result = await SNamedEntity.parse({\n    id: \"asdf\",\n    set: undefined,\n  });\n  expect(Object.keys(result)).toEqual([\"id\", \"set\"]);\n});\n\ntest(\"catchall parsing\", async () => {\n  const result = z.object({ name: z.string() }).catchall(z.number()).parse({ name: \"Foo\", validExtraKey: 61 });\n\n  expect(result).toEqual({ name: \"Foo\", validExtraKey: 61 });\n\n  const result2 = z\n    .object({ name: z.string() })\n    .catchall(z.number())\n    .safeParse({ name: \"Foo\", validExtraKey: 61, invalid: \"asdf\" });\n\n  expect(result2.success).toEqual(false);\n});\n\ntest(\"nonexistent keys\", async () => {\n  const Schema = z.union([z.object({ a: z.string() }), z.object({ b: z.number() })]);\n  const obj = { a: \"A\" };\n  const result = await Schema.spa(obj); // Works with 1.11.10, breaks with 2.0.0-beta.21\n  expect(result.success).toBe(true);\n});\n\ntest(\"test async union\", async () => {\n  const Schema2 = z.union([\n    z.object({\n      ty: z.string(),\n    }),\n    z.object({\n      ty: z.number(),\n    }),\n  ]);\n\n  const obj = { ty: \"A\" };\n  const result = await Schema2.spa(obj); // Works with 1.11.10, breaks with 2.0.0-beta.21\n  expect(result.success).toEqual(true);\n});\n\ntest(\"test inferred merged type\", async () => {\n  const asdf = z.object({ a: z.string() }).merge(z.object({ a: z.number() }));\n  type asdf = z.infer<typeof asdf>;\n\n  expectTypeOf<asdf>().toEqualTypeOf<{ a: number }>();\n});\n\ntest(\"inferred type with Record shape\", () => {\n  type A = z.ZodObject<Record<string, z.ZodType<string, number>>>;\n  expectTypeOf<z.infer<A>>().toEqualTypeOf<Record<string, string>>();\n  expectTypeOf<z.input<A>>().toEqualTypeOf<Record<string, number>>();\n\n  type B = z.ZodObject;\n  expectTypeOf<z.infer<B>>().toEqualTypeOf<Record<string, unknown>>();\n  expectTypeOf<z.input<B>>().toEqualTypeOf<Record<string, unknown>>();\n});\n\ntest(\"inferred merged object type with optional properties\", async () => {\n  const Merged = z\n    .object({ a: z.string(), b: z.string().optional() })\n    .merge(z.object({ a: z.string().optional(), b: z.string() }));\n  type Merged = z.infer<typeof Merged>;\n  expectTypeOf<Merged>().toEqualTypeOf<{ a?: string; b: string }>();\n  expectTypeOf<Merged>().toEqualTypeOf<{ a?: string; b: string }>();\n});\n\ntest(\"inferred unioned object type with optional properties\", async () => {\n  const Unioned = z.union([\n    z.object({ a: z.string(), b: z.string().optional() }),\n    z.object({ a: z.string().optional(), b: z.string() }),\n  ]);\n  type Unioned = z.infer<typeof Unioned>;\n  expectTypeOf<Unioned>().toEqualTypeOf<{ a: string; b?: string } | { a?: string; b: string }>();\n});\n\ntest(\"inferred enum type\", async () => {\n  const Enum = z.object({ a: z.string(), b: z.string().optional() }).keyof();\n\n  expect(Enum.enum).toEqual({\n    a: \"a\",\n    b: \"b\",\n  });\n\n  expect(Enum._zod.def.entries).toEqual({\n    a: \"a\",\n    b: \"b\",\n  });\n  type Enum = z.infer<typeof Enum>;\n  expectTypeOf<Enum>().toEqualTypeOf<\"a\" | \"b\">();\n});\n\ntest(\"inferred partial object type with optional properties\", async () => {\n  const Partial = z.object({ a: z.string(), b: z.string().optional() }).partial();\n  type Partial = z.infer<typeof Partial>;\n  expectTypeOf<Partial>().toEqualTypeOf<{ a?: string; b?: string }>();\n});\n\ntest(\"inferred picked object type with optional properties\", async () => {\n  const Picked = z.object({ a: z.string(), b: z.string().optional() }).pick({ b: true });\n  type Picked = z.infer<typeof Picked>;\n  expectTypeOf<Picked>().toEqualTypeOf<{ b?: string }>();\n});\n\ntest(\"inferred type for unknown/any keys\", () => {\n  const myType = z.object({\n    anyOptional: z.any().optional(),\n    anyRequired: z.any(),\n    unknownOptional: z.unknown().optional(),\n    unknownRequired: z.unknown(),\n  });\n  type myType = z.infer<typeof myType>;\n  expectTypeOf<myType>().toEqualTypeOf<{\n    anyOptional?: any;\n    anyRequired: any;\n    unknownOptional?: unknown;\n    unknownRequired: unknown;\n  }>();\n});\n\ntest(\"strictObject\", async () => {\n  const strictObj = z.strictObject({\n    name: z.string(),\n  });\n\n  const syncResult = strictObj.safeParse({ name: \"asdf\", unexpected: 13 });\n  expect(syncResult.success).toEqual(false);\n\n  const asyncResult = await strictObj.spa({ name: \"asdf\", unexpected: 13 });\n  expect(asyncResult.success).toEqual(false);\n});\n\ntest(\"object with refine\", async () => {\n  const schema = z\n    .object({\n      a: z.string().default(\"foo\"),\n      b: z.number(),\n    })\n    .refine(() => true);\n  expect(schema.parse({ b: 5 })).toEqual({ b: 5, a: \"foo\" });\n  const result = await schema.parseAsync({ b: 5 });\n  expect(result).toEqual({ b: 5, a: \"foo\" });\n});\n\ntest(\"intersection of object with date\", async () => {\n  const schema = z.object({\n    a: z.date(),\n  });\n  expect(z.intersection(schema, schema).parse({ a: new Date(1637353595983) })).toEqual({\n    a: new Date(1637353595983),\n  });\n  const result = await schema.parseAsync({ a: new Date(1637353595983) });\n  expect(result).toEqual({ a: new Date(1637353595983) });\n});\n\ntest(\"intersection of object with refine with date\", async () => {\n  const schema = z\n    .object({\n      a: z.date(),\n    })\n    .refine(() => true);\n  expect(z.intersection(schema, schema).parse({ a: new Date(1637353595983) })).toEqual({\n    a: new Date(1637353595983),\n  });\n  const result = await schema.parseAsync({ a: new Date(1637353595983) });\n  expect(result).toEqual({ a: new Date(1637353595983) });\n});\n\ntest(\"constructor key\", () => {\n  const person = z\n    .object({\n      name: z.string(),\n    })\n    .strict();\n\n  expect(() =>\n    person.parse({\n      name: \"bob dylan\",\n      constructor: 61,\n    })\n  ).toThrow();\n});\n\ntest(\"constructor key\", () => {\n  const Example = z.object({\n    prop: z.string(),\n    opt: z.number().optional(),\n    arr: z.string().array(),\n  });\n\n  type Example = z.infer<typeof Example>;\n  expectTypeOf<keyof Example>().toEqualTypeOf<\"prop\" | \"opt\" | \"arr\">();\n});\n\ntest(\"catchall\", () => {\n  const a = z.object({});\n  expect(a._zod.def.catchall).toBeUndefined();\n\n  const b = z.strictObject({});\n  expect(b._zod.def.catchall).toBeInstanceOf(core.$ZodNever);\n\n  const c = z.looseObject({});\n  expect(c._zod.def.catchall).toBeInstanceOf(core.$ZodUnknown);\n\n  const d = z.object({}).catchall(z.number());\n  expect(d._zod.def.catchall).toBeInstanceOf(core.$ZodNumber);\n});\n\ntest(\"unknownkeys merging\", () => {\n  // This one is \"strict\"\n  const a = z.looseObject({\n    a: z.string(),\n  });\n\n  const b = z.strictObject({ b: z.string() });\n\n  // incoming object overrides\n  const c = a.merge(b);\n  expect(c._zod.def.catchall).toBeInstanceOf(core.$ZodNever);\n});\n\nconst personToExtend = z.object({\n  firstName: z.string(),\n  lastName: z.string(),\n});\n\ntest(\"extend() should return schema with new key\", () => {\n  const PersonWithNickname = personToExtend.extend({ nickName: z.string() });\n  type PersonWithNickname = z.infer<typeof PersonWithNickname>;\n\n  const expected = { firstName: \"f\", nickName: \"n\", lastName: \"l\" };\n  const actual = PersonWithNickname.parse(expected);\n\n  expect(actual).toEqual(expected);\n  expectTypeOf<keyof PersonWithNickname>().toEqualTypeOf<\"firstName\" | \"lastName\" | \"nickName\">();\n  expectTypeOf<PersonWithNickname>().toEqualTypeOf<{ firstName: string; lastName: string; nickName: string }>();\n});\n\ntest(\"extend() should have power to override existing key\", () => {\n  const PersonWithNumberAsLastName = personToExtend.extend({\n    lastName: z.number(),\n  });\n  type PersonWithNumberAsLastName = z.infer<typeof PersonWithNumberAsLastName>;\n\n  const expected = { firstName: \"f\", lastName: 42 };\n  const actual = PersonWithNumberAsLastName.parse(expected);\n\n  expect(actual).toEqual(expected);\n  expectTypeOf<PersonWithNumberAsLastName>().toEqualTypeOf<{ firstName: string; lastName: number }>();\n});\n\ntest(\"passthrough index signature\", () => {\n  const a = z.object({ a: z.string() });\n  type a = z.infer<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<{ a: string }>();\n  const b = a.passthrough();\n  type b = z.infer<typeof b>;\n  expectTypeOf<b>().toEqualTypeOf<{ a: string; [k: string]: unknown }>();\n});\n\n// test(\"xor\", () => {\n//   type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };\n//   type XOR<T, U> = T extends object ? (U extends object ? (Without<T, U> & U) | (Without<U, T> & T) : U) : T;\n\n//   type A = { name: string; a: number };\n//   type B = { name: string; b: number };\n//   type C = XOR<A, B>;\n//   type Outer = { data: C };\n//   const Outer = z.object({\n//     data: z.union([z.object({ name: z.string(), a: z.number() }), z.object({ name: z.string(), b: z.number() })]),\n//   }) satisfies z.ZodType<Outer, any>;\n// });\n\ntest(\"assignability\", () => {\n  z.object({ a: z.string() }) satisfies z.ZodObject<{ a: z.ZodString }>;\n  z.object({ a: z.string() }).catchall(z.number()) satisfies z.ZodObject<{ a: z.ZodString }>;\n  z.object({ a: z.string() }).strict() satisfies z.ZodObject;\n  z.object({}) satisfies z.ZodObject;\n\n  z.looseObject({ name: z.string() }) satisfies z.ZodObject<\n    {\n      name: z.ZodString;\n    },\n    z.core.$loose\n  >;\n  z.looseObject({ name: z.string() }) satisfies z.ZodObject<{\n    name: z.ZodString;\n  }>;\n  z.strictObject({ name: z.string() }) satisfies z.ZodObject<\n    {\n      name: z.ZodString;\n    },\n    z.core.$loose\n  >;\n  z.strictObject({ name: z.string() }) satisfies z.ZodObject<\n    {\n      name: z.ZodString;\n    },\n    z.core.$strict\n  >;\n  z.object({ name: z.string() }) satisfies z.ZodObject<{\n    name: z.ZodString;\n  }>;\n  z.object({\n    a: z.string(),\n    b: z.number(),\n    c: z.boolean(),\n  }) satisfies z.core.$ZodObject;\n});\n\ntest(\"null prototype\", () => {\n  const schema = z.object({ a: z.string() });\n  const obj = Object.create(null);\n  obj.a = \"foo\";\n  expect(schema.parse(obj)).toEqual({ a: \"foo\" });\n});\n\ntest(\"empty objects\", () => {\n  const A = z.looseObject({});\n  type Ain = z.input<typeof A>;\n  expectTypeOf<Ain>().toEqualTypeOf<Record<string, unknown>>();\n  type Aout = z.output<typeof A>;\n  expectTypeOf<Aout>().toEqualTypeOf<Record<string, unknown>>();\n\n  const B = z.object({});\n  type Bout = z.output<typeof B>;\n  expectTypeOf<Bout>().toEqualTypeOf<Record<string, never>>();\n  type Bin = z.input<typeof B>;\n  expectTypeOf<Bin>().toEqualTypeOf<Record<string, never>>();\n\n  const C = z.strictObject({});\n  type Cout = z.output<typeof C>;\n  expectTypeOf<Cout>().toEqualTypeOf<Record<string, never>>();\n  type Cin = z.input<typeof C>;\n  expectTypeOf<Cin>().toEqualTypeOf<Record<string, never>>();\n});\n\ntest(\"preserve key order\", () => {\n  const schema = z.object({\n    a: z.string().optional(),\n    b: z.string(),\n  });\n  const r1 = schema.safeParse({ a: \"asdf\", b: \"qwer\" });\n  const r2 = schema.safeParse({ a: \"asdf\", b: \"qwer\" }, { jitless: true });\n\n  expect(Object.keys(r1.data!)).toMatchInlineSnapshot(`\n    [\n      \"a\",\n      \"b\",\n    ]\n  `);\n  expect(Object.keys(r1.data!)).toEqual(Object.keys(r2.data!));\n});\n\ntest(\"empty shape\", () => {\n  const a = z.object({});\n\n  a.parse({});\n  a.parse({}, { jitless: true });\n  a.parse(Object.create(null));\n  a.parse(Object.create(null), { jitless: true });\n\n  expect(() => a.parse([])).toThrow();\n  expect(() => a.parse([], { jitless: true })).toThrow();\n});\n\ntest(\"zodtype assignability\", () => {\n  // Does not error\n  z.object({ hello: z.string().optional() }) satisfies z.ZodType<{ hello?: string | undefined }>;\n  z.object({ hello: z.string() }) satisfies z.ZodType<{ hello?: string | undefined }>;\n  // @ts-expect-error\n  z.object({}) satisfies z.ZodType<{ hello: string | undefined }>;\n  // @ts-expect-error\n  z.object({ hello: z.string().optional() }) satisfies z.ZodType<{ hello: string | undefined }>;\n  // @ts-expect-error\n  z.object({ hello: z.string().optional() }) satisfies z.ZodType<{ hello: string }>;\n  // @ts-expect-error\n  z.object({ hello: z.number() }) satisfies z.ZodType<{ hello?: string | undefined }>;\n});\n\ntest(\"index signature in shape\", () => {\n  function makeZodObj<const T extends string>(key: T) {\n    return z.looseObject({\n      [key]: z.string(),\n    });\n  }\n\n  const schema = makeZodObj(\"foo\");\n  type schema = z.infer<typeof schema>;\n\n  expectTypeOf<schema>().toEqualTypeOf<Record<string, string>>();\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/object.test.ts",
        "start": 1,
        "end": 563,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 563,
          "column": 2,
          "position": 6473
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/object.test.ts",
        "start": 1,
        "end": 563,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 563,
          "column": 2,
          "position": 6473
        }
      }
    },
    {
      "format": "typescript",
      "lines": 247,
      "fragment": "import { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\ntest(\"z.number() basic validation\", () => {\n  const schema = z.number();\n  expect(schema.parse(1234)).toEqual(1234);\n});\n\ntest(\"NaN validation\", () => {\n  const schema = z.number();\n  expect(() => schema.parse(Number.NaN)).toThrow();\n});\n\ntest(\"Infinity validation\", () => {\n  const schema = z.number();\n  expect(schema.safeParse(Number.POSITIVE_INFINITY)).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"number\",\n        \"code\": \"invalid_type\",\n        \"received\": \"Infinity\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected number, received number\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(schema.safeParse(Number.NEGATIVE_INFINITY)).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"number\",\n        \"code\": \"invalid_type\",\n        \"received\": \"Infinity\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected number, received number\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\".gt() validation\", () => {\n  const schema = z.number().gt(0).gt(5);\n  expect(schema.parse(6)).toEqual(6);\n  expect(() => schema.parse(5)).toThrow();\n});\n\ntest(\".gte() validation\", () => {\n  const schema = z.number().gt(0).gte(1).gte(5);\n  expect(schema.parse(5)).toEqual(5);\n  expect(() => schema.parse(4)).toThrow();\n});\n\ntest(\".min() validation\", () => {\n  const schema = z.number().min(0).min(5);\n  expect(schema.parse(5)).toEqual(5);\n  expect(() => schema.parse(4)).toThrow();\n});\n\ntest(\".lt() validation\", () => {\n  const schema = z.number().lte(10).lt(5);\n  expect(schema.parse(4)).toEqual(4);\n  expect(() => schema.parse(5)).toThrow();\n});\n\ntest(\".lte() validation\", () => {\n  const schema = z.number().lte(10).lte(5);\n  expect(schema.parse(5)).toEqual(5);\n  expect(() => schema.parse(6)).toThrow();\n});\n\ntest(\".max() validation\", () => {\n  const schema = z.number().max(10).max(5);\n  expect(schema.parse(5)).toEqual(5);\n  expect(() => schema.parse(6)).toThrow();\n});\n\ntest(\".int() validation\", () => {\n  const schema = z.number().int();\n  expect(schema.parse(4)).toEqual(4);\n  expect(() => schema.parse(3.14)).toThrow();\n});\n\ntest(\".positive() validation\", () => {\n  const schema = z.number().positive();\n  expect(schema.parse(1)).toEqual(1);\n  expect(() => schema.parse(0)).toThrow();\n  expect(() => schema.parse(-1)).toThrow();\n});\n\ntest(\".negative() validation\", () => {\n  const schema = z.number().negative();\n  expect(schema.parse(-1)).toEqual(-1);\n  expect(() => schema.parse(0)).toThrow();\n  expect(() => schema.parse(1)).toThrow();\n});\n\ntest(\".nonpositive() validation\", () => {\n  const schema = z.number().nonpositive();\n  expect(schema.parse(0)).toEqual(0);\n  expect(schema.parse(-1)).toEqual(-1);\n  expect(() => schema.parse(1)).toThrow();\n});\n\ntest(\".nonnegative() validation\", () => {\n  const schema = z.number().nonnegative();\n  expect(schema.parse(0)).toEqual(0);\n  expect(schema.parse(1)).toEqual(1);\n  expect(() => schema.parse(-1)).toThrow();\n});\n\ntest(\".multipleOf() with positive divisor\", () => {\n  const schema = z.number().multipleOf(5);\n  expect(schema.parse(15)).toEqual(15);\n  expect(schema.parse(-15)).toEqual(-15);\n  expect(() => schema.parse(7.5)).toThrow();\n  expect(() => schema.parse(-7.5)).toThrow();\n});\n\ntest(\".multipleOf() with negative divisor\", () => {\n  const schema = z.number().multipleOf(-5);\n  expect(schema.parse(-15)).toEqual(-15);\n  expect(schema.parse(15)).toEqual(15);\n  expect(() => schema.parse(-7.5)).toThrow();\n  expect(() => schema.parse(7.5)).toThrow();\n});\n\ntest(\".step() validation\", () => {\n  const schemaPointOne = z.number().step(0.1);\n  const schemaPointZeroZeroZeroOne = z.number().step(0.0001);\n  const schemaSixPointFour = z.number().step(6.4);\n\n  expect(schemaPointOne.parse(6)).toEqual(6);\n  expect(schemaPointOne.parse(6.1)).toEqual(6.1);\n  expect(schemaSixPointFour.parse(12.8)).toEqual(12.8);\n  expect(schemaPointZeroZeroZeroOne.parse(3.01)).toEqual(3.01);\n  expect(() => schemaPointOne.parse(6.11)).toThrow();\n  expect(() => schemaPointOne.parse(6.1000000001)).toThrow();\n  expect(() => schemaSixPointFour.parse(6.41)).toThrow();\n});\n\ntest(\".finite() validation\", () => {\n  const schema = z.number().finite();\n  expect(schema.parse(123)).toEqual(123);\n  expect(schema.safeParse(Number.POSITIVE_INFINITY)).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"number\",\n        \"code\": \"invalid_type\",\n        \"received\": \"Infinity\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected number, received number\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(schema.safeParse(Number.NEGATIVE_INFINITY)).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"number\",\n        \"code\": \"invalid_type\",\n        \"received\": \"Infinity\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected number, received number\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\".safe() validation\", () => {\n  const schema = z.number().safe();\n  expect(schema.parse(Number.MIN_SAFE_INTEGER)).toEqual(Number.MIN_SAFE_INTEGER);\n  expect(schema.parse(Number.MAX_SAFE_INTEGER)).toEqual(Number.MAX_SAFE_INTEGER);\n  expect(() => schema.parse(Number.MIN_SAFE_INTEGER - 1)).toThrow();\n  expect(() => schema.parse(Number.MAX_SAFE_INTEGER + 1)).toThrow();\n});\n\ntest(\"min value getters\", () => {\n  expect(z.number().minValue).toBeNull;\n  expect(z.number().lt(5).minValue).toBeNull;\n  expect(z.number().lte(5).minValue).toBeNull;\n  expect(z.number().max(5).minValue).toBeNull;\n  expect(z.number().negative().minValue).toBeNull;\n  expect(z.number().nonpositive().minValue).toBeNull;\n  expect(z.number().int().minValue).toBeNull;\n  expect(z.number().multipleOf(5).minValue).toBeNull;\n  expect(z.number().finite().minValue).toBeNull;\n  expect(z.number().gt(5).minValue).toEqual(5);\n  expect(z.number().gte(5).minValue).toEqual(5);\n  expect(z.number().min(5).minValue).toEqual(5);\n  expect(z.number().min(5).min(10).minValue).toEqual(10);\n  expect(z.number().positive().minValue).toEqual(0);\n  expect(z.number().nonnegative().minValue).toEqual(0);\n  expect(z.number().safe().minValue).toEqual(Number.MIN_SAFE_INTEGER);\n});\n\ntest(\"max value getters\", () => {\n  expect(z.number().maxValue).toBeNull;\n  expect(z.number().gt(5).maxValue).toBeNull;\n  expect(z.number().gte(5).maxValue).toBeNull;\n  expect(z.number().min(5).maxValue).toBeNull;\n  expect(z.number().positive().maxValue).toBeNull;\n  expect(z.number().nonnegative().maxValue).toBeNull;\n  expect(z.number().int().minValue).toBeNull;\n  expect(z.number().multipleOf(5).minValue).toBeNull;\n  expect(z.number().finite().minValue).toBeNull;\n  expect(z.number().lt(5).maxValue).toEqual(5);\n  expect(z.number().lte(5).maxValue).toEqual(5);\n  expect(z.number().max(5).maxValue).toEqual(5);\n  expect(z.number().max(5).max(1).maxValue).toEqual(1);\n  expect(z.number().negative().maxValue).toEqual(0);\n  expect(z.number().nonpositive().maxValue).toEqual(0);\n  expect(z.number().safe().maxValue).toEqual(Number.MAX_SAFE_INTEGER);\n});\n\ntest(\"int getter\", () => {\n  expect(z.number().isInt).toEqual(false);\n  expect(z.number().int().isInt).toEqual(true);\n  expect(z.number().safe().isInt).toEqual(true);\n  expect(z.number().multipleOf(5).isInt).toEqual(true);\n});\n\n/** In Zod 4, number schemas don't accept infinite values. */\ntest(\"finite getter\", () => {\n  expect(z.number().isFinite).toEqual(true);\n});\n\ntest(\"string format methods\", () => {\n  const a = z.int32().min(5);\n  expect(a.parse(6)).toEqual(6);\n  expect(() => a.parse(1)).toThrow();\n});\n\ntest(\"error customization\", () => {\n  z.number().gte(5, { error: (iss) => \"Min: \" + iss.minimum.valueOf() });\n  z.number().lte(5, { error: (iss) => \"Max: \" + iss.maximum.valueOf() });\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/number.test.ts",
        "start": 1,
        "end": 247,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 247,
          "column": 2,
          "position": 2797
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/number.test.ts",
        "start": 1,
        "end": 247,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 247,
          "column": 2,
          "position": 2797
        }
      }
    },
    {
      "format": "typescript",
      "lines": 22,
      "fragment": "import { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\ntest(\".nullable()\", () => {\n  const nullable = z.string().nullable();\n  expect(nullable.parse(null)).toBe(null);\n  expect(nullable.parse(\"asdf\")).toBe(\"asdf\");\n  expect(() => nullable.parse(123)).toThrow();\n});\n\ntest(\".nullable unwrap\", () => {\n  const schema = z.string().nullable();\n  expect(schema).toBeInstanceOf(z.ZodNullable);\n  expect(schema.unwrap()).toBeInstanceOf(z.ZodString);\n});\n\ntest(\"z.null\", () => {\n  const n = z.null();\n  expect(n.parse(null)).toBe(null);\n  expect(() => n.parse(\"asdf\")).toThrow();\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/nullable.test.ts",
        "start": 1,
        "end": 22,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 22,
          "column": 2,
          "position": 254
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/nullable.test.ts",
        "start": 1,
        "end": 22,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 22,
          "column": 2,
          "position": 254
        }
      }
    },
    {
      "format": "typescript",
      "lines": 86,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport { z } from \"zod/v4\";\n\ntest(\"nonoptional\", () => {\n  const schema = z.string().nonoptional();\n  expectTypeOf<typeof schema._input>().toEqualTypeOf<string>();\n  expectTypeOf<typeof schema._output>().toEqualTypeOf<string>();\n\n  const result = schema.safeParse(undefined);\n  expect(result.success).toBe(false);\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected string, received undefined\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"nonoptional with default\", () => {\n  const schema = z.string().optional().nonoptional();\n  expectTypeOf<typeof schema._input>().toEqualTypeOf<string>();\n  expectTypeOf<typeof schema._output>().toEqualTypeOf<string>();\n\n  const result = schema.safeParse(undefined);\n  expect(result.success).toBe(false);\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"invalid_type\",\n        \"expected\": \"nonoptional\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected nonoptional, received undefined\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"nonoptional in object\", () => {\n  const schema = z.object({ hi: z.string().optional().nonoptional() });\n\n  expectTypeOf<typeof schema._input>().toEqualTypeOf<{ hi: string }>();\n  expectTypeOf<typeof schema._output>().toEqualTypeOf<{ hi: string }>();\n  const r1 = schema.safeParse({ hi: \"asdf\" });\n  expect(r1.success).toEqual(true);\n\n  const r2 = schema.safeParse({ hi: undefined });\n  // expect(schema.safeParse({ hi: undefined }).success).toEqual(false);\n  expect(r2.success).toEqual(false);\n  expect(r2.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"invalid_type\",\n        \"expected\": \"nonoptional\",\n        \"path\": [\n          \"hi\"\n        ],\n        \"message\": \"Invalid input: expected nonoptional, received undefined\"\n      }\n    ]]\n  `);\n\n  const r3 = schema.safeParse({});\n  expect(r3.success).toEqual(false);\n  expect(r3.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"invalid_type\",\n        \"expected\": \"nonoptional\",\n        \"path\": [\n          \"hi\"\n        ],\n        \"message\": \"Invalid input: expected nonoptional, received undefined\"\n      }\n    ]]\n  `);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/nonoptional.test.ts",
        "start": 1,
        "end": 86,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 86,
          "column": 2,
          "position": 509
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/nonoptional.test.ts",
        "start": 1,
        "end": 86,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 86,
          "column": 2,
          "position": 509
        }
      }
    },
    {
      "format": "typescript",
      "lines": 168,
      "fragment": "import { expect, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ntest(\"nested refinements\", () => {\n  const zodSchema = z\n    .object({\n      password: z.string().min(1),\n      nested: z\n        .object({\n          confirm: z\n            .string()\n            .min(1)\n            .refine((value) => value.length > 2, {\n              message: \"Confirm length should be > 2\",\n            }),\n        })\n        .refine(\n          (data) => {\n            return data.confirm === \"bar\";\n          },\n          {\n            path: [\"confirm\"],\n            error: 'Value must be \"bar\"',\n          }\n        ),\n    })\n    .refine(\n      (data) => {\n        return data.nested.confirm === data.password;\n      },\n      {\n        path: [\"nested\", \"confirm\"],\n        error: \"Password and confirm must match\",\n      }\n    );\n\n  const DATA = {\n    password: \"bar\",\n    nested: { confirm: \"\" },\n  };\n  expect(zodSchema.safeParse(DATA)).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"origin\": \"string\",\n        \"code\": \"too_small\",\n        \"minimum\": 1,\n        \"inclusive\": true,\n        \"path\": [\n          \"nested\",\n          \"confirm\"\n        ],\n        \"message\": \"Too small: expected string to have >=1 characters\"\n      },\n      {\n        \"code\": \"custom\",\n        \"path\": [\n          \"nested\",\n          \"confirm\"\n        ],\n        \"message\": \"Confirm length should be > 2\"\n      },\n      {\n        \"code\": \"custom\",\n        \"path\": [\n          \"nested\",\n          \"confirm\"\n        ],\n        \"message\": \"Value must be \\\\\"bar\\\\\"\"\n      },\n      {\n        \"code\": \"custom\",\n        \"path\": [\n          \"nested\",\n          \"confirm\"\n        ],\n        \"message\": \"Password and confirm must match\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n\n  expect(zodSchema.safeParse(DATA, { jitless: true })).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"origin\": \"string\",\n        \"code\": \"too_small\",\n        \"minimum\": 1,\n        \"inclusive\": true,\n        \"path\": [\n          \"nested\",\n          \"confirm\"\n        ],\n        \"message\": \"Too small: expected string to have >=1 characters\"\n      },\n      {\n        \"code\": \"custom\",\n        \"path\": [\n          \"nested\",\n          \"confirm\"\n        ],\n        \"message\": \"Confirm length should be > 2\"\n      },\n      {\n        \"code\": \"custom\",\n        \"path\": [\n          \"nested\",\n          \"confirm\"\n        ],\n        \"message\": \"Value must be \\\\\"bar\\\\\"\"\n      },\n      {\n        \"code\": \"custom\",\n        \"path\": [\n          \"nested\",\n          \"confirm\"\n        ],\n        \"message\": \"Password and confirm must match\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n\n  expect(zodSchema[\"~standard\"].validate(DATA)).toMatchInlineSnapshot(`\n    {\n      \"issues\": [\n        {\n          \"code\": \"too_small\",\n          \"inclusive\": true,\n          \"message\": \"Too small: expected string to have >=1 characters\",\n          \"minimum\": 1,\n          \"origin\": \"string\",\n          \"path\": [\n            \"nested\",\n            \"confirm\",\n          ],\n        },\n        {\n          \"code\": \"custom\",\n          \"message\": \"Confirm length should be > 2\",\n          \"path\": [\n            \"nested\",\n            \"confirm\",\n          ],\n        },\n        {\n          \"code\": \"custom\",\n          \"message\": \"Value must be \"bar\"\",\n          \"path\": [\n            \"nested\",\n            \"confirm\",\n          ],\n        },\n        {\n          \"code\": \"custom\",\n          \"message\": \"Password and confirm must match\",\n          \"path\": [\n            \"nested\",\n            \"confirm\",\n          ],\n        },\n      ],\n    }\n  `);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/nested-refine.test.ts",
        "start": 1,
        "end": 168,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 168,
          "column": 2,
          "position": 367
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/nested-refine.test.ts",
        "start": 1,
        "end": 168,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 168,
          "column": 2,
          "position": 367
        }
      }
    },
    {
      "format": "typescript",
      "lines": 21,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\nconst schema = z.nan();\n\ntest(\"passing validations\", () => {\n  schema.parse(Number.NaN);\n  schema.parse(Number(\"Not a number\"));\n  expectTypeOf<typeof schema._output>().toEqualTypeOf<number>();\n});\n\ntest(\"failing validations\", () => {\n  expect(() => schema.parse(5)).toThrow();\n  expect(() => schema.parse(\"John\")).toThrow();\n  expect(() => schema.parse(true)).toThrow();\n  expect(() => schema.parse(null)).toThrow();\n  expect(() => schema.parse(undefined)).toThrow();\n  expect(() => schema.parse({})).toThrow();\n  expect(() => schema.parse([])).toThrow();\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/nan.test.ts",
        "start": 1,
        "end": 21,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 21,
          "column": 2,
          "position": 271
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/nan.test.ts",
        "start": 1,
        "end": 21,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 21,
          "column": 2,
          "position": 271
        }
      }
    },
    {
      "format": "typescript",
      "lines": 196,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\nconst stringMap = z.map(z.string(), z.string());\ntype stringMap = z.infer<typeof stringMap>;\n\ntest(\"type inference\", () => {\n  expectTypeOf<stringMap>().toEqualTypeOf<Map<string, string>>();\n});\n\ntest(\"valid parse\", () => {\n  const result = stringMap.safeParse(\n    new Map([\n      [\"first\", \"foo\"],\n      [\"second\", \"bar\"],\n    ])\n  );\n  expect(result.success).toEqual(true);\n  expect(result.data).toMatchInlineSnapshot(`\n    Map {\n      \"first\" => \"foo\",\n      \"second\" => \"bar\",\n    }\n  `);\n});\n\ntest(\"valid parse async\", async () => {\n  const asyncMap = z.map(\n    z.string().refine(async () => false, \"bad key\"),\n    z.string().refine(async () => false, \"bad value\")\n  );\n  const result = await asyncMap.safeParseAsync(new Map([[\"first\", \"foo\"]]));\n  expect(result.success).toEqual(false);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [\n          \"first\"\n        ],\n        \"message\": \"bad key\"\n      },\n      {\n        \"code\": \"custom\",\n        \"path\": [\n          \"first\"\n        ],\n        \"message\": \"bad value\"\n      }\n    ]]\n  `);\n});\n\ntest(\"throws when a Set is given\", () => {\n  const result = stringMap.safeParse(new Set([]));\n  expect(result.success).toEqual(false);\n  if (result.success === false) {\n    expect(result.error.issues.length).toEqual(1);\n    expect(result.error.issues[0].code).toEqual(\"invalid_type\");\n  }\n});\n\ntest(\"throws when the given map has invalid key and invalid input\", () => {\n  const result = stringMap.safeParse(new Map([[42, Symbol()]]));\n  expect(result.success).toEqual(false);\n  if (result.success === false) {\n    expect(result.error.issues.length).toEqual(2);\n    expect(result.error).toMatchInlineSnapshot(`\n      [ZodError: [\n        {\n          \"expected\": \"string\",\n          \"code\": \"invalid_type\",\n          \"path\": [\n            42\n          ],\n          \"message\": \"Invalid input: expected string, received number\"\n        },\n        {\n          \"expected\": \"string\",\n          \"code\": \"invalid_type\",\n          \"path\": [\n            42\n          ],\n          \"message\": \"Invalid input: expected string, received symbol\"\n        }\n      ]]\n    `);\n  }\n});\n\ntest(\"throws when the given map has multiple invalid entries\", () => {\n  // const result = stringMap.safeParse(new Map([[42, Symbol()]]));\n\n  const result = stringMap.safeParse(\n    new Map([\n      [1, \"foo\"],\n      [\"bar\", 2],\n    ] as [any, any][]) as Map<any, any>\n  );\n\n  // const result = stringMap.safeParse(new Map([[42, Symbol()]]));\n  expect(result.success).toEqual(false);\n  if (result.success === false) {\n    expect(result.error.issues.length).toEqual(2);\n    expect(result.error.issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"invalid_type\",\n          \"expected\": \"string\",\n          \"message\": \"Invalid input: expected string, received number\",\n          \"path\": [\n            1,\n          ],\n        },\n        {\n          \"code\": \"invalid_type\",\n          \"expected\": \"string\",\n          \"message\": \"Invalid input: expected string, received number\",\n          \"path\": [\n            \"bar\",\n          ],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"dirty\", async () => {\n  const map = z.map(\n    z.string().refine((val) => val === val.toUpperCase(), {\n      message: \"Keys must be uppercase\",\n    }),\n    z.string()\n  );\n  const result = await map.spa(\n    new Map([\n      [\"first\", \"foo\"],\n      [\"second\", \"bar\"],\n    ])\n  );\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues.length).toEqual(2);\n    expect(result.error).toMatchInlineSnapshot(`\n      [ZodError: [\n        {\n          \"code\": \"custom\",\n          \"path\": [\n            \"first\"\n          ],\n          \"message\": \"Keys must be uppercase\"\n        },\n        {\n          \"code\": \"custom\",\n          \"path\": [\n            \"second\"\n          ],\n          \"message\": \"Keys must be uppercase\"\n        }\n      ]]\n    `);\n  }\n});\n\ntest(\"map with object keys\", () => {\n  const map = z.map(\n    z.object({\n      name: z.string(),\n      age: z.number(),\n    }),\n    z.string()\n  );\n  const data = new Map([\n    [{ name: \"John\", age: 30 }, \"foo\"],\n    [{ name: \"Jane\", age: 25 }, \"bar\"],\n  ]);\n  const result = map.safeParse(data);\n  expect(result.success).toEqual(true);\n  expect(result.data!).toEqual(data);\n\n  const badData = new Map([[\"bad\", \"foo\"]]);\n  const badResult = map.safeParse(badData);\n  expect(badResult.success).toEqual(false);\n  expect(badResult.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"expected\": \"object\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"bad\"\n        ],\n        \"message\": \"Invalid input: expected object, received string\"\n      }\n    ]]\n  `);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/map.test.ts",
        "start": 1,
        "end": 196,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 196,
          "column": 2,
          "position": 1149
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/map.test.ts",
        "start": 1,
        "end": 196,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 196,
          "column": 2,
          "position": 1149
        }
      }
    },
    {
      "format": "typescript",
      "lines": 92,
      "fragment": "import { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\nconst literalTuna = z.literal(\"tuna\");\nconst literalTunaCustomMessage = z.literal(\"tuna\", {\n  message: \"That's not a tuna\",\n});\nconst literalFortyTwo = z.literal(42);\nconst literalTrue = z.literal(true);\n\ntest(\"passing validations\", () => {\n  literalTuna.parse(\"tuna\");\n  literalFortyTwo.parse(42);\n  literalTrue.parse(true);\n});\n\ntest(\"failing validations\", () => {\n  expect(() => literalTuna.parse(\"shark\")).toThrow();\n  expect(() => literalFortyTwo.parse(43)).toThrow();\n  expect(() => literalTrue.parse(false)).toThrow();\n});\n\ntest(\"invalid_literal should have `input` field with data\", () => {\n  const data = \"shark\";\n  const result = literalTuna.safeParse(data);\n\n  const issue = result.error!.issues[0];\n  expect(issue.code).toBe(\"invalid_value\");\n  expect(issue).toMatchInlineSnapshot(`\n    {\n      \"code\": \"invalid_value\",\n      \"message\": \"Invalid input: expected \"tuna\"\",\n      \"path\": [],\n      \"values\": [\n        \"tuna\",\n      ],\n    }\n  `);\n});\n\ntest(\"invalid_literal should return default message\", () => {\n  const data = \"shark\";\n  const result = literalTuna.safeParse(data);\n\n  const issue = result.error!.issues[0];\n  expect(issue.message).toEqual(`Invalid input: expected \\\"tuna\\\"`);\n});\n\ntest(\"invalid_literal should return custom message\", () => {\n  const data = \"shark\";\n  const result = literalTunaCustomMessage.safeParse(data);\n\n  const issue = result.error!.issues[0];\n  expect(issue.message).toEqual(`That's not a tuna`);\n});\n\ntest(\"literal default error message\", () => {\n  const result = z.literal(\"Tuna\").safeParse(\"Trout\");\n  expect(result.success).toEqual(false);\n  expect(result.error!.issues.length).toEqual(1);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"invalid_value\",\n        \"values\": [\n          \"Tuna\"\n        ],\n        \"path\": [],\n        \"message\": \"Invalid input: expected \\\\\"Tuna\\\\\"\"\n      }\n    ]]\n  `);\n});\n\ntest(\"literal bigint default error message\", () => {\n  const result = z.literal(BigInt(12)).safeParse(BigInt(13));\n  expect(result.success).toBe(false);\n\n  expect(result.error!.issues.length).toEqual(1);\n  expect(result.error!.issues[0].message).toEqual(`Invalid input: expected 12n`);\n});\n\ntest(\".value getter\", () => {\n  expect(z.literal(\"tuna\").value).toEqual(\"tuna\");\n  expect(() => z.literal([1, 2, 3]).value).toThrow();\n});\n\ntest(\"readonly\", () => {\n  const a = [\"asdf\"] as const;\n  z.literal(a);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/literal.test.ts",
        "start": 1,
        "end": 92,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 92,
          "column": 2,
          "position": 750
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/literal.test.ts",
        "start": 1,
        "end": 92,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 92,
          "column": 2,
          "position": 750
        }
      }
    },
    {
      "format": "typescript",
      "lines": 227,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\ntest(\"opt passthrough\", () => {\n  const object = z.object({\n    a: z.lazy(() => z.string()),\n    b: z.lazy(() => z.string().optional()),\n    c: z.lazy(() => z.string().default(\"default\")),\n  });\n\n  type ObjectTypeIn = z.input<typeof object>;\n  expectTypeOf<ObjectTypeIn>().toEqualTypeOf<{\n    a: string;\n    b?: string | undefined;\n    c?: string | undefined;\n  }>();\n\n  type ObjectTypeOut = z.output<typeof object>;\n  expectTypeOf<ObjectTypeOut>().toEqualTypeOf<{\n    a: string;\n    b?: string | undefined;\n    c: string;\n  }>();\n\n  const result = object.parse(\n    {\n      a: \"hello\",\n      b: undefined,\n    },\n    { jitless: true }\n  );\n  expect(result).toEqual({\n    a: \"hello\",\n    // b: undefined,\n    c: \"default\",\n  });\n\n  expect(z.lazy(() => z.string())._zod.optin).toEqual(undefined);\n  expect(z.lazy(() => z.string())._zod.optout).toEqual(undefined);\n\n  expect(z.lazy(() => z.string().optional())._zod.optin).toEqual(\"optional\");\n  expect(z.lazy(() => z.string().optional())._zod.optout).toEqual(\"optional\");\n\n  expect(z.lazy(() => z.string().default(\"asdf\"))._zod.optin).toEqual(\"optional\");\n  expect(z.lazy(() => z.string().default(\"asdf\"))._zod.optout).toEqual(undefined);\n});\n\n//////////////   LAZY   //////////////\n\ntest(\"schema getter\", () => {\n  z.lazy(() => z.string()).parse(\"asdf\");\n});\n\ntest(\"lazy proxy\", () => {\n  const schema = z.lazy(() => z.string())._zod.innerType.min(6);\n  schema.parse(\"123456\");\n  expect(schema.safeParse(\"12345\").success).toBe(false);\n});\n\ninterface Category {\n  name: string;\n  subcategories: Category[];\n}\n\nconst testCategory: Category = {\n  name: \"I\",\n  subcategories: [\n    {\n      name: \"A\",\n      subcategories: [\n        {\n          name: \"1\",\n          subcategories: [\n            {\n              name: \"a\",\n              subcategories: [],\n            },\n          ],\n        },\n      ],\n    },\n  ],\n};\n\ntest(\"recursion with z.lazy\", () => {\n  const Category: z.ZodType<Category> = z.lazy(() =>\n    z.object({\n      name: z.string(),\n      subcategories: z.array(Category),\n    })\n  );\n  Category.parse(testCategory);\n});\n\ntype LinkedList = null | { value: number; next: LinkedList };\n\nconst linkedListExample = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: null,\n      },\n    },\n  },\n};\n\ntest(\"recursive union wit z.lazy\", () => {\n  const LinkedListSchema: z.ZodType<LinkedList> = z.lazy(() =>\n    z.union([\n      z.null(),\n      z.object({\n        value: z.number(),\n        next: LinkedListSchema,\n      }),\n    ])\n  );\n  LinkedListSchema.parse(linkedListExample);\n});\n\ninterface A {\n  val: number;\n  b: B;\n}\n\ninterface B {\n  val: number;\n  a?: A | undefined;\n}\n\ntest(\"mutual recursion with lazy\", () => {\n  const Alazy: z.ZodType<A> = z.lazy(() =>\n    z.object({\n      val: z.number(),\n      b: Blazy,\n    })\n  );\n\n  const Blazy: z.ZodType<B> = z.lazy(() =>\n    z.object({\n      val: z.number(),\n      a: Alazy.optional(),\n    })\n  );\n\n  const testData = {\n    val: 1,\n    b: {\n      val: 5,\n      a: {\n        val: 3,\n        b: {\n          val: 4,\n          a: {\n            val: 2,\n            b: {\n              val: 1,\n            },\n          },\n        },\n      },\n    },\n  };\n\n  Alazy.parse(testData);\n  Blazy.parse(testData.b);\n\n  expect(() => Alazy.parse({ val: \"asdf\" })).toThrow();\n});\n\n// TODO\ntest(\"mutual recursion with cyclical data\", () => {\n  const a: any = { val: 1 };\n  const b: any = { val: 2 };\n  a.b = b;\n  b.a = a;\n});\n\ntest(\"complicated self-recursion\", () => {\n  const Category = z.object({\n    name: z.string(),\n    age: z.optional(z.number()),\n    get nullself() {\n      return Category.nullable();\n    },\n    get optself() {\n      return Category.optional();\n    },\n    get self() {\n      return Category;\n    },\n    get subcategories() {\n      return z.array(Category);\n    },\n    nested: z.object({\n      get sub() {\n        return Category;\n      },\n    }),\n  });\n\n  type _Category = z.output<typeof Category>;\n});\n\ntest(\"lazy initialization\", () => {\n  const a: any = z.lazy(() => a).optional();\n  const b: any = z.lazy(() => b).nullable();\n  const c: any = z.lazy(() => c).default({} as any);\n  const d: any = z.lazy(() => d).prefault({} as any);\n  const e: any = z.lazy(() => e).nonoptional();\n  const f: any = z.lazy(() => f).catch({} as any);\n  const g: any = z.lazy(() => z.object({ g })).readonly();\n\n  const baseCategorySchema = z.object({\n    name: z.string(),\n  });\n  type Category = z.infer<typeof baseCategorySchema> & {\n    subcategories: Category[];\n  };\n  const categorySchema: z.ZodType<Category> = baseCategorySchema.extend({\n    subcategories: z.lazy(() => categorySchema.array()),\n  });\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/lazy.test.ts",
        "start": 1,
        "end": 227,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 227,
          "column": 2,
          "position": 2061
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/lazy.test.ts",
        "start": 1,
        "end": 227,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 227,
          "column": 2,
          "position": 2061
        }
      }
    },
    {
      "format": "typescript",
      "lines": 108,
      "fragment": "import { test } from \"vitest\";\n// import * as z from \"zod/v4\";\n\ntest(() => {});\n// test(\"overload types\", () => {\n//   const schema = z.string().json();\n//   util.assertEqual<typeof schema, z.ZodString>(true);\n//   const schema2 = z.string().json(z.number());\n//   util.assertEqual<typeof schema2, z.ZodPipe<z.ZodTransform<any, string>, z.ZodNumber>>(true);\n//   const r2 = schema2.parse(\"12\");\n//   util.assertEqual<number, typeof r2>(true);\n// });\n// test(\"parse string to json\", async () => {\n//   const Env = z.object({\n//     myJsonConfig: z.string().jsonString(z.object({ foo: z.number() })),\n//     someOtherValue: z.string(),\n//   });\n\n//   expect(\n//     Env.parse({\n//       myJsonConfig: '{ \"foo\": 123 }',\n//       someOtherValue: \"abc\",\n//     })\n//   ).toEqual({\n//     myJsonConfig: { foo: 123 },\n//     someOtherValue: \"abc\",\n//   });\n\n//   const invalidValues = Env.safeParse({\n//     myJsonConfig: '{\"foo\": \"not a number!\"}',\n//     someOtherValue: null,\n//   });\n//   expect(JSON.parse(JSON.stringify(invalidValues))).toEqual({\n//     success: false,\n//     error: {\n//       name: \"ZodError\",\n//       issues: [\n//         {\n//           code: \"invalid_type\",\n//           expected: \"number\",\n//           input: \"not a number!\",\n//           received: \"string\",\n//           path: [\"myJsonConfig\", \"foo\"],\n//           message: \"Expected number, received string\",\n//         },\n//         {\n//           code: \"invalid_type\",\n//           expected: \"string\",\n//           input: null,\n//           received: \"null\",\n//           path: [\"someOtherValue\"],\n//           message: \"Expected string, received null\",\n//         },\n//       ],\n//     },\n//   });\n\n//   const invalidJsonSyntax = Env.safeParse({\n//     myJsonConfig: \"This is not valid json\",\n//     someOtherValue: null,\n//   });\n//   expect(JSON.parse(JSON.stringify(invalidJsonSyntax))).toMatchObject({\n//     success: false,\n//     error: {\n//       name: \"ZodError\",\n//       issues: [\n//         {\n//           code: \"invalid_string\",\n//           input: {\n//             _def: {\n//               catchall: {\n//                 _def: {\n//                   typeName: \"ZodNever\",\n//                 },\n//               },\n//               typeName: \"ZodObject\",\n//               unknownKeys: \"strip\",\n//             },\n//           },\n//           validation: \"json\",\n//           message: \"Invalid json\",\n//           path: [\"myJsonConfig\"],\n//         },\n//         {\n//           code: \"invalid_type\",\n//           expected: \"string\",\n//           input: null,\n//           received: \"null\",\n//           path: [\"someOtherValue\"],\n//           message: \"Expected string, received null\",\n//         },\n//       ],\n//     },\n//   });\n// });\n\n// test(\"no argument\", () => {\n//   const schema = z.string().json();\n//   util.assertEqual<typeof schema, z.ZodString>(true);\n//   z.string().json().parse(`{}`);\n//   z.string().json().parse(`null`);\n//   z.string().json().parse(`12`);\n//   z.string().json().parse(`{ \"test\": \"test\"}`);\n//   expect(() => z.string().json().parse(`asdf`)).toThrow();\n//   expect(() => z.string().json().parse(`{ \"test\": undefined }`)).toThrow();\n//   expect(() => z.string().json().parse(`{ \"test\": 12n }`)).toThrow();\n//   expect(() => z.string().json().parse(`{ test: \"test\" }`)).toThrow();\n// });",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/json.test.ts",
        "start": 1,
        "end": 108,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 108,
          "column": 7,
          "position": 230
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/json.test.ts",
        "start": 1,
        "end": 108,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 108,
          "column": 7,
          "position": 230
        }
      }
    },
    {
      "format": "typescript",
      "lines": 171,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport type { util } from \"zod/v4/core\";\n\nimport * as z from \"zod/v4\";\n\ntest(\"object intersection\", () => {\n  const A = z.object({ a: z.string() });\n  const B = z.object({ b: z.string() });\n\n  const C = z.intersection(A, B); // BaseC.merge(HasID);\n  type C = z.infer<typeof C>;\n  expectTypeOf<C>().toEqualTypeOf<{ a: string } & { b: string }>();\n  const data = { a: \"foo\", b: \"foo\" };\n  expect(C.parse(data)).toEqual(data);\n  expect(() => C.parse({ a: \"foo\" })).toThrow();\n});\n\ntest(\"object intersection: loose\", () => {\n  const A = z.looseObject({ a: z.string() });\n  const B = z.object({ b: z.string() });\n\n  const C = z.intersection(A, B); // BaseC.merge(HasID);\n  type C = z.infer<typeof C>;\n  expectTypeOf<C>().toEqualTypeOf<{ a: string; [x: string]: unknown } & { b: string }>();\n  const data = { a: \"foo\", b: \"foo\", c: \"extra\" };\n  expect(C.parse(data)).toEqual(data);\n  expect(() => C.parse({ a: \"foo\" })).toThrow();\n});\n\ntest(\"object intersection: strict\", () => {\n  const A = z.strictObject({ a: z.string() });\n  const B = z.object({ b: z.string() });\n\n  const C = z.intersection(A, B); // BaseC.merge(HasID);\n  type C = z.infer<typeof C>;\n  expectTypeOf<C>().toEqualTypeOf<{ a: string } & { b: string }>();\n  const data = { a: \"foo\", b: \"foo\", c: \"extra\" };\n\n  const result = C.safeParse(data);\n  expect(result.success).toEqual(false);\n});\n\ntest(\"deep intersection\", () => {\n  const Animal = z.object({\n    properties: z.object({\n      is_animal: z.boolean(),\n    }),\n  });\n  const Cat = z.intersection(\n    z.object({\n      properties: z.object({\n        jumped: z.boolean(),\n      }),\n    }),\n    Animal\n  );\n\n  type Cat = util.Flatten<z.infer<typeof Cat>>;\n  expectTypeOf<Cat>().toEqualTypeOf<{ properties: { is_animal: boolean } & { jumped: boolean } }>();\n  const a = Cat.safeParse({ properties: { is_animal: true, jumped: true } });\n  expect(a.data!.properties).toEqual({ is_animal: true, jumped: true });\n});\n\ntest(\"deep intersection of arrays\", async () => {\n  const Author = z.object({\n    posts: z.array(\n      z.object({\n        post_id: z.number(),\n      })\n    ),\n  });\n  const Registry = z.intersection(\n    Author,\n    z.object({\n      posts: z.array(\n        z.object({\n          title: z.string(),\n        })\n      ),\n    })\n  );\n\n  const posts = [\n    { post_id: 1, title: \"Novels\" },\n    { post_id: 2, title: \"Fairy tales\" },\n  ];\n  const cat = Registry.parse({ posts });\n  expect(cat.posts).toEqual(posts);\n  const asyncCat = await Registry.parseAsync({ posts });\n  expect(asyncCat.posts).toEqual(posts);\n});\n\ntest(\"invalid intersection types\", async () => {\n  const numberIntersection = z.intersection(\n    z.number(),\n    z.number().transform((x) => x + 1)\n  );\n\n  expect(() => {\n    numberIntersection.parse(1234);\n  }).toThrowErrorMatchingInlineSnapshot(`[Error: Unmergable intersection. Error path: []]`);\n});\n\ntest(\"invalid array merge (incompatible lengths)\", async () => {\n  const stringArrInt = z.intersection(\n    z.string().array(),\n    z\n      .string()\n      .array()\n      .transform((val) => [...val, \"asdf\"])\n  );\n\n  expect(() => stringArrInt.safeParse([\"asdf\", \"qwer\"])).toThrowErrorMatchingInlineSnapshot(\n    `[Error: Unmergable intersection. Error path: []]`\n  );\n});\n\ntest(\"invalid array merge (incompatible elements)\", async () => {\n  const stringArrInt = z.intersection(\n    z.string().array(),\n    z\n      .string()\n      .array()\n      .transform((val) => [...val.slice(0, -1), \"asdf\"])\n  );\n\n  expect(() => stringArrInt.safeParse([\"asdf\", \"qwer\"])).toThrowErrorMatchingInlineSnapshot(\n    `[Error: Unmergable intersection. Error path: [1]]`\n  );\n});\n\ntest(\"invalid object merge\", async () => {\n  const Cat = z.object({\n    phrase: z.string().transform((val) => `${val} Meow`),\n  });\n  const Dog = z.object({\n    phrase: z.string().transform((val) => `${val} Woof`),\n  });\n  const CatDog = z.intersection(Cat, Dog);\n\n  expect(() => CatDog.parse({ phrase: \"Hello, my name is CatDog.\" })).toThrowErrorMatchingInlineSnapshot(\n    `[Error: Unmergable intersection. Error path: [\"phrase\"]]`\n  );\n});\n\ntest(\"invalid deep merge of object and array combination\", async () => {\n  const University = z.object({\n    students: z.array(\n      z.object({\n        name: z.string().transform((val) => `Student name: ${val}`),\n      })\n    ),\n  });\n  const Registry = z.intersection(\n    University,\n    z.object({\n      students: z.array(\n        z.object({\n          name: z.string(),\n          surname: z.string(),\n        })\n      ),\n    })\n  );\n\n  const students = [{ name: \"John\", surname: \"Doe\" }];\n\n  expect(() => Registry.parse({ students })).toThrowErrorMatchingInlineSnapshot(\n    `[Error: Unmergable intersection. Error path: [\"students\",0,\"name\"]]`\n  );\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/intersection.test.ts",
        "start": 1,
        "end": 171,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 171,
          "column": 2,
          "position": 1891
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/intersection.test.ts",
        "start": 1,
        "end": 171,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 171,
          "column": 2,
          "position": 1891
        }
      }
    },
    {
      "format": "typescript",
      "lines": 34,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ntest(\"instanceof\", async () => {\n  class Test {}\n  class Subtest extends Test {}\n  abstract class AbstractBar {\n    constructor(public val: string) {}\n  }\n  class Bar extends AbstractBar {}\n\n  const TestSchema = z.instanceof(Test);\n  const SubtestSchema = z.instanceof(Subtest);\n  const AbstractSchema = z.instanceof(AbstractBar);\n  const BarSchema = z.instanceof(Bar);\n\n  TestSchema.parse(new Test());\n  TestSchema.parse(new Subtest());\n  SubtestSchema.parse(new Subtest());\n  AbstractSchema.parse(new Bar(\"asdf\"));\n  const bar = BarSchema.parse(new Bar(\"asdf\"));\n  expect(bar.val).toEqual(\"asdf\");\n\n  await expect(() => SubtestSchema.parse(new Test())).toThrow();\n  await expect(() => TestSchema.parse(12)).toThrow();\n\n  expectTypeOf<Test>().toEqualTypeOf<z.infer<typeof TestSchema>>();\n});\n\ntest(\"instanceof fatal\", () => {\n  const schema = z.instanceof(Date).refine((d) => d.toString());\n  const res = schema.safeParse(null);\n  expect(res.success).toBe(false);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/instanceof.test.ts",
        "start": 1,
        "end": 34,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 34,
          "column": 2,
          "position": 406
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/instanceof.test.ts",
        "start": 1,
        "end": 34,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 34,
          "column": 2,
          "position": 406
        }
      }
    },
    {
      "format": "typescript",
      "lines": 829,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\nimport type { util } from \"zod/v4/core\";\n\ntest(\"z.boolean\", () => {\n  const a = z.boolean();\n  expect(z.parse(a, true)).toEqual(true);\n  expect(z.parse(a, false)).toEqual(false);\n  expect(() => z.parse(a, 123)).toThrow();\n  expect(() => z.parse(a, \"true\")).toThrow();\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<boolean>();\n});\n\ntest(\"z.bigint\", () => {\n  const a = z.bigint();\n  expect(z.parse(a, BigInt(123))).toEqual(BigInt(123));\n  expect(() => z.parse(a, 123)).toThrow();\n  expect(() => z.parse(a, \"123\")).toThrow();\n});\n\ntest(\"z.symbol\", () => {\n  const a = z.symbol();\n  const sym = Symbol();\n  expect(z.parse(a, sym)).toEqual(sym);\n  expect(() => z.parse(a, \"symbol\")).toThrow();\n});\n\ntest(\"z.date\", () => {\n  const a = z.date();\n  const date = new Date();\n  expect(z.parse(a, date)).toEqual(date);\n  expect(() => z.parse(a, \"date\")).toThrow();\n});\n\ntest(\"z.coerce.string\", () => {\n  const a = z.coerce.string();\n  expect(z.parse(a, 123)).toEqual(\"123\");\n  expect(z.parse(a, true)).toEqual(\"true\");\n  expect(z.parse(a, null)).toEqual(\"null\");\n  expect(z.parse(a, undefined)).toEqual(\"undefined\");\n});\n\ntest(\"z.coerce.number\", () => {\n  const a = z.coerce.number();\n  expect(z.parse(a, \"123\")).toEqual(123);\n  expect(z.parse(a, \"123.45\")).toEqual(123.45);\n  expect(z.parse(a, true)).toEqual(1);\n  expect(z.parse(a, false)).toEqual(0);\n  expect(() => z.parse(a, \"abc\")).toThrow();\n});\n\ntest(\"z.coerce.boolean\", () => {\n  const a = z.coerce.boolean();\n  // test booleans\n  expect(z.parse(a, true)).toEqual(true);\n  expect(z.parse(a, false)).toEqual(false);\n  expect(z.parse(a, \"true\")).toEqual(true);\n  expect(z.parse(a, \"false\")).toEqual(true);\n  expect(z.parse(a, 1)).toEqual(true);\n  expect(z.parse(a, 0)).toEqual(false);\n  expect(z.parse(a, {})).toEqual(true);\n  expect(z.parse(a, [])).toEqual(true);\n  expect(z.parse(a, undefined)).toEqual(false);\n  expect(z.parse(a, null)).toEqual(false);\n  expect(z.parse(a, \"\")).toEqual(false);\n});\n\ntest(\"z.coerce.bigint\", () => {\n  const a = z.coerce.bigint();\n  expect(z.parse(a, \"123\")).toEqual(BigInt(123));\n  expect(z.parse(a, 123)).toEqual(BigInt(123));\n  expect(() => z.parse(a, \"abc\")).toThrow();\n});\n\ntest(\"z.coerce.date\", () => {\n  const a = z.coerce.date();\n  const date = new Date();\n  expect(z.parse(a, date.toISOString())).toEqual(date);\n  expect(z.parse(a, date.getTime())).toEqual(date);\n  expect(() => z.parse(a, \"invalid date\")).toThrow();\n});\n\ntest(\"z.iso.datetime\", () => {\n  const d1 = \"2021-01-01T00:00:00Z\";\n  const d2 = \"2021-01-01T00:00:00.123Z\";\n  const d3 = \"2021-01-01T00:00:00\";\n  const d4 = \"2021-01-01T00:00:00+07:00\";\n  const d5 = \"bad data\";\n\n  // local: false, offset: false, precision: null\n  const a = z.iso.datetime();\n  expect(z.safeParse(a, d1).success).toEqual(true);\n  expect(z.safeParse(a, d2).success).toEqual(true);\n  expect(z.safeParse(a, d3).success).toEqual(false);\n  expect(z.safeParse(a, d4).success).toEqual(false);\n  expect(z.safeParse(a, d5).success).toEqual(false);\n\n  const b = z.iso.datetime({ local: true });\n  expect(z.safeParse(b, d1).success).toEqual(true);\n  expect(z.safeParse(b, d2).success).toEqual(true);\n  expect(z.safeParse(b, d3).success).toEqual(true);\n  expect(z.safeParse(b, d4).success).toEqual(false);\n  expect(z.safeParse(b, d5).success).toEqual(false);\n\n  const c = z.iso.datetime({ offset: true });\n  expect(z.safeParse(c, d1).success).toEqual(true);\n  expect(z.safeParse(c, d2).success).toEqual(true);\n  expect(z.safeParse(c, d3).success).toEqual(false);\n  expect(z.safeParse(c, d4).success).toEqual(true);\n  expect(z.safeParse(c, d5).success).toEqual(false);\n\n  const d = z.iso.datetime({ precision: 3 });\n  expect(z.safeParse(d, d1).success).toEqual(false);\n  expect(z.safeParse(d, d2).success).toEqual(true);\n  expect(z.safeParse(d, d3).success).toEqual(false);\n  expect(z.safeParse(d, d4).success).toEqual(false);\n  expect(z.safeParse(d, d5).success).toEqual(false);\n});\n\ntest(\"z.iso.date\", () => {\n  const d1 = \"2021-01-01\";\n  const d2 = \"bad data\";\n\n  const a = z.iso.date();\n  expect(z.safeParse(a, d1).success).toEqual(true);\n  expect(z.safeParse(a, d2).success).toEqual(false);\n\n  const b = z.string().check(z.iso.date());\n  expect(z.safeParse(b, d1).success).toEqual(true);\n  expect(z.safeParse(b, d2).success).toEqual(false);\n});\n\ntest(\"z.iso.time\", () => {\n  const d1 = \"00:00:00\";\n  const d2 = \"00:00:00.123\";\n  const d3 = \"bad data\";\n\n  const a = z.iso.time();\n  expect(z.safeParse(a, d1).success).toEqual(true);\n  expect(z.safeParse(a, d2).success).toEqual(true);\n  expect(z.safeParse(a, d3).success).toEqual(false);\n\n  const b = z.iso.time({ precision: 3 });\n  expect(z.safeParse(b, d1).success).toEqual(false);\n  expect(z.safeParse(b, d2).success).toEqual(true);\n  expect(z.safeParse(b, d3).success).toEqual(false);\n\n  const c = z.string().check(z.iso.time());\n  expect(z.safeParse(c, d1).success).toEqual(true);\n  expect(z.safeParse(c, d2).success).toEqual(true);\n  expect(z.safeParse(c, d3).success).toEqual(false);\n});\n\ntest(\"z.iso.duration\", () => {\n  const d1 = \"P3Y6M4DT12H30M5S\";\n  const d2 = \"bad data\";\n\n  const a = z.iso.duration();\n  expect(z.safeParse(a, d1).success).toEqual(true);\n  expect(z.safeParse(a, d2).success).toEqual(false);\n\n  const b = z.string().check(z.iso.duration());\n  expect(z.safeParse(b, d1).success).toEqual(true);\n  expect(z.safeParse(b, d2).success).toEqual(false);\n});\n\ntest(\"z.undefined\", () => {\n  const a = z.undefined();\n  expect(z.parse(a, undefined)).toEqual(undefined);\n  expect(() => z.parse(a, \"undefined\")).toThrow();\n});\n\ntest(\"z.null\", () => {\n  const a = z.null();\n  expect(z.parse(a, null)).toEqual(null);\n  expect(() => z.parse(a, \"null\")).toThrow();\n});\n\ntest(\"z.any\", () => {\n  const a = z.any();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, 123)).toEqual(123);\n  expect(z.parse(a, true)).toEqual(true);\n  expect(z.parse(a, null)).toEqual(null);\n  expect(z.parse(a, undefined)).toEqual(undefined);\n  z.parse(a, {});\n  z.parse(a, []);\n  z.parse(a, Symbol());\n  z.parse(a, new Date());\n});\n\ntest(\"z.unknown\", () => {\n  const a = z.unknown();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, 123)).toEqual(123);\n  expect(z.parse(a, true)).toEqual(true);\n  expect(z.parse(a, null)).toEqual(null);\n  expect(z.parse(a, undefined)).toEqual(undefined);\n  z.parse(a, {});\n  z.parse(a, []);\n  z.parse(a, Symbol());\n  z.parse(a, new Date());\n});\n\ntest(\"z.never\", () => {\n  const a = z.never();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n});\n\ntest(\"z.void\", () => {\n  const a = z.void();\n  expect(z.parse(a, undefined)).toEqual(undefined);\n  expect(() => z.parse(a, null)).toThrow();\n});\n\ntest(\"z.array\", () => {\n  const a = z.array(z.string());\n  expect(z.parse(a, [\"hello\", \"world\"])).toEqual([\"hello\", \"world\"]);\n  expect(() => z.parse(a, [123])).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n});\n\ntest(\"z.union\", () => {\n  const a = z.union([z.string(), z.number()]);\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, 123)).toEqual(123);\n  expect(() => z.parse(a, true)).toThrow();\n});\n\ntest(\"z.intersection\", () => {\n  const a = z.intersection(z.object({ a: z.string() }), z.object({ b: z.number() }));\n  expect(z.parse(a, { a: \"hello\", b: 123 })).toEqual({ a: \"hello\", b: 123 });\n  expect(() => z.parse(a, { a: \"hello\" })).toThrow();\n  expect(() => z.parse(a, { b: 123 })).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n});\n\ntest(\"z.tuple\", () => {\n  const a = z.tuple([z.string(), z.number()]);\n  expect(z.parse(a, [\"hello\", 123])).toEqual([\"hello\", 123]);\n  expect(() => z.parse(a, [\"hello\", \"world\"])).toThrow();\n  expect(() => z.parse(a, [123, 456])).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n\n  // tuple with rest\n  const b = z.tuple([z.string(), z.number(), z.optional(z.string())], z.boolean());\n  type b = z.output<typeof b>;\n\n  expectTypeOf<b>().toEqualTypeOf<[string, number, string?, ...boolean[]]>();\n  const datas = [\n    [\"hello\", 123],\n    [\"hello\", 123, \"world\"],\n    [\"hello\", 123, \"world\", true],\n    [\"hello\", 123, \"world\", true, false, true],\n  ];\n  for (const data of datas) {\n    expect(z.parse(b, data)).toEqual(data);\n  }\n\n  expect(() => z.parse(b, [\"hello\", 123, 123])).toThrow();\n  expect(() => z.parse(b, [\"hello\", 123, \"world\", 123])).toThrow();\n\n  // tuple with readonly args\n  const cArgs = [z.string(), z.number(), z.optional(z.string())] as const;\n  const c = z.tuple(cArgs, z.boolean());\n  type c = z.output<typeof c>;\n  expectTypeOf<c>().toEqualTypeOf<[string, number, string?, ...boolean[]]>();\n  // type c = z.output<typeof c>;\n});\n\ntest(\"z.record\", () => {\n  // record schema with enum keys\n  const a = z.record(z.string(), z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<Record<string, string>>();\n\n  const b = z.record(z.union([z.string(), z.number(), z.symbol()]), z.string());\n  type b = z.output<typeof b>;\n  expectTypeOf<b>().toEqualTypeOf<Record<string | number | symbol, string>>();\n  expect(z.parse(b, { a: \"hello\", 1: \"world\", [Symbol.for(\"asdf\")]: \"symbol\" })).toEqual({\n    a: \"hello\",\n    1: \"world\",\n    [Symbol.for(\"asdf\")]: \"symbol\",\n  });\n\n  // enum keys\n  const c = z.record(z.enum([\"a\", \"b\", \"c\"]), z.string());\n  type c = z.output<typeof c>;\n  expectTypeOf<c>().toEqualTypeOf<Record<\"a\" | \"b\" | \"c\", string>>();\n  expect(z.parse(c, { a: \"hello\", b: \"world\", c: \"world\" })).toEqual({\n    a: \"hello\",\n    b: \"world\",\n    c: \"world\",\n  });\n  // missing keys\n  expect(() => z.parse(c, { a: \"hello\", b: \"world\" })).toThrow();\n  // extra keys\n  expect(() => z.parse(c, { a: \"hello\", b: \"world\", c: \"world\", d: \"world\" })).toThrow();\n\n  // partial enum\n  const d = z.record(z.enum([\"a\", \"b\"]).or(z.never()), z.string());\n  type d = z.output<typeof d>;\n  expectTypeOf<d>().toEqualTypeOf<Record<\"a\" | \"b\", string>>();\n});\n\ntest(\"z.map\", () => {\n  const a = z.map(z.string(), z.number());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<Map<string, number>>();\n  expect(z.parse(a, new Map([[\"hello\", 123]]))).toEqual(new Map([[\"hello\", 123]]));\n  expect(() => z.parse(a, new Map([[\"hello\", \"world\"]]))).toThrow();\n  expect(() => z.parse(a, new Map([[1243, \"world\"]]))).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n\n  const r1 = z.safeParse(a, new Map([[123, 123]]));\n  expect(r1.error?.issues[0].code).toEqual(\"invalid_type\");\n  expect(r1.error?.issues[0].path).toEqual([123]);\n\n  const r2: any = z.safeParse(a, new Map([[BigInt(123), 123]]));\n  expect(r2.error!.issues[0].code).toEqual(\"invalid_key\");\n  expect(r2.error!.issues[0].path).toEqual([]);\n\n  const r3: any = z.safeParse(a, new Map([[\"hello\", \"world\"]]));\n  expect(r3.error!.issues[0].code).toEqual(\"invalid_type\");\n  expect(r3.error!.issues[0].path).toEqual([\"hello\"]);\n});\n\ntest(\"z.map invalid_element\", () => {\n  const a = z.map(z.bigint(), z.number());\n  const r1 = z.safeParse(a, new Map([[BigInt(123), BigInt(123)]]));\n\n  expect(r1.error!.issues[0].code).toEqual(\"invalid_element\");\n  expect(r1.error!.issues[0].path).toEqual([]);\n});\n\ntest(\"z.map async\", async () => {\n  const a = z.map(z.string().check(z.refine(async () => true)), z.number().check(z.refine(async () => true)));\n  const d1 = new Map([[\"hello\", 123]]);\n  expect(await z.parseAsync(a, d1)).toEqual(d1);\n\n  await expect(z.parseAsync(a, new Map([[123, 123]]))).rejects.toThrow();\n  await expect(z.parseAsync(a, new Map([[\"hi\", \"world\"]]))).rejects.toThrow();\n  await expect(z.parseAsync(a, new Map([[1243, \"world\"]]))).rejects.toThrow();\n  await expect(z.parseAsync(a, \"hello\")).rejects.toThrow();\n\n  const r = await z.safeParseAsync(a, new Map([[123, 123]]));\n  expect(r.success).toEqual(false);\n  expect(r.error!.issues[0].code).toEqual(\"invalid_type\");\n  expect(r.error!.issues[0].path).toEqual([123]);\n});\n\ntest(\"z.set\", () => {\n  const a = z.set(z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<Set<string>>();\n  expect(z.parse(a, new Set([\"hello\", \"world\"]))).toEqual(new Set([\"hello\", \"world\"]));\n  expect(() => z.parse(a, new Set([123]))).toThrow();\n  expect(() => z.parse(a, [\"hello\", \"world\"])).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n\n  const b = z.set(z.number());\n  expect(z.parse(b, new Set([1, 2, 3]))).toEqual(new Set([1, 2, 3]));\n  expect(() => z.parse(b, new Set([\"hello\"]))).toThrow();\n  expect(() => z.parse(b, [1, 2, 3])).toThrow();\n  expect(() => z.parse(b, 123)).toThrow();\n});\n\ntest(\"z.enum\", () => {\n  const a = z.enum([\"A\", \"B\", \"C\"]);\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<\"A\" | \"B\" | \"C\">();\n  expect(z.parse(a, \"A\")).toEqual(\"A\");\n  expect(z.parse(a, \"B\")).toEqual(\"B\");\n  expect(z.parse(a, \"C\")).toEqual(\"C\");\n  expect(() => z.parse(a, \"D\")).toThrow();\n  expect(() => z.parse(a, 123)).toThrow();\n\n  expect(a.enum.A).toEqual(\"A\");\n  expect(a.enum.B).toEqual(\"B\");\n  expect(a.enum.C).toEqual(\"C\");\n  expect((a.enum as any).D).toEqual(undefined);\n});\n\ntest(\"z.enum - native\", () => {\n  enum NativeEnum {\n    A = \"A\",\n    B = \"B\",\n    C = \"C\",\n  }\n  const a = z.enum(NativeEnum);\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<NativeEnum>();\n  expect(z.parse(a, NativeEnum.A)).toEqual(NativeEnum.A);\n  expect(z.parse(a, NativeEnum.B)).toEqual(NativeEnum.B);\n  expect(z.parse(a, NativeEnum.C)).toEqual(NativeEnum.C);\n  expect(() => z.parse(a, \"D\")).toThrow();\n  expect(() => z.parse(a, 123)).toThrow();\n\n  // test a.enum\n  a;\n  expect(a.enum.A).toEqual(NativeEnum.A);\n  expect(a.enum.B).toEqual(NativeEnum.B);\n  expect(a.enum.C).toEqual(NativeEnum.C);\n});\n\ntest(\"z.nativeEnum\", () => {\n  enum NativeEnum {\n    A = \"A\",\n    B = \"B\",\n    C = \"C\",\n  }\n  const a = z.nativeEnum(NativeEnum);\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<NativeEnum>();\n  expect(z.parse(a, NativeEnum.A)).toEqual(NativeEnum.A);\n  expect(z.parse(a, NativeEnum.B)).toEqual(NativeEnum.B);\n  expect(z.parse(a, NativeEnum.C)).toEqual(NativeEnum.C);\n  expect(() => z.parse(a, \"D\")).toThrow();\n  expect(() => z.parse(a, 123)).toThrow();\n\n  // test a.enum\n  a;\n  expect(a.enum.A).toEqual(NativeEnum.A);\n  expect(a.enum.B).toEqual(NativeEnum.B);\n  expect(a.enum.C).toEqual(NativeEnum.C);\n});\n\ntest(\"z.literal\", () => {\n  const a = z.literal(\"hello\");\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<\"hello\">();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(() => z.parse(a, \"world\")).toThrow();\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.file\", () => {\n  const a = z.file();\n  const file = new File([\"content\"], \"filename.txt\", { type: \"text/plain\" });\n  expect(z.parse(a, file)).toEqual(file);\n  expect(() => z.parse(a, \"file\")).toThrow();\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.transform\", () => {\n  const a = z.pipe(\n    z.string(),\n    z.transform((val) => val.toUpperCase())\n  );\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n  expect(z.parse(a, \"hello\")).toEqual(\"HELLO\");\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.transform async\", async () => {\n  const a = z.pipe(\n    z.string(),\n    z.transform(async (val) => val.toUpperCase())\n  );\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n  expect(await z.parseAsync(a, \"hello\")).toEqual(\"HELLO\");\n  await expect(() => z.parseAsync(a, 123)).rejects.toThrow();\n});\n\ntest(\"z.preprocess\", () => {\n  const a = z.pipe(\n    z.transform((val) => String(val).toUpperCase()),\n    z.string()\n  );\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n  expect(z.parse(a, 123)).toEqual(\"123\");\n  expect(z.parse(a, true)).toEqual(\"TRUE\");\n  expect(z.parse(a, BigInt(1234))).toEqual(\"1234\");\n  // expect(() => z.parse(a, Symbol(\"asdf\"))).toThrow();\n});\n\n// test(\"z.preprocess async\", () => {\n//   const a = z.preprocess(async (val) => String(val), z.string());\n//   type a = z.output<typeof a>;\n//   expectTypeOf<a>().toEqualTypeOf<string>();\n//   expect(z.parse(a, 123)).toEqual(\"123\");\n//   expect(z.parse(a, true)).toEqual(\"true\");\n//   expect(() => z.parse(a, {})).toThrow();\n// });\n\ntest(\"z.optional\", () => {\n  const a = z.optional(z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string | undefined>();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, undefined)).toEqual(undefined);\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.nullable\", () => {\n  const a = z.nullable(z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string | null>();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, null)).toEqual(null);\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.default\", () => {\n  const a = z._default(z.string(), \"default\");\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n  expect(z.parse(a, undefined)).toEqual(\"default\");\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(() => z.parse(a, 123)).toThrow();\n\n  const b = z._default(z.string(), () => \"default\");\n  expect(z.parse(b, undefined)).toEqual(\"default\");\n  expect(z.parse(b, \"hello\")).toEqual(\"hello\");\n  expect(() => z.parse(b, 123)).toThrow();\n});\n\ntest(\"z.catch\", () => {\n  const a = z.catch(z.string(), \"default\");\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, 123)).toEqual(\"default\");\n\n  const b = z.catch(z.string(), () => \"default\");\n  expect(z.parse(b, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(b, 123)).toEqual(\"default\");\n\n  const c = z.catch(z.string(), (ctx) => {\n    return `${ctx.error.issues.length}issues`;\n  });\n  expect(z.parse(c, 1234)).toEqual(\"1issues\");\n});\n\ntest(\"z.nan\", () => {\n  const a = z.nan();\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<number>();\n  expect(z.parse(a, Number.NaN)).toEqual(Number.NaN);\n  expect(() => z.parse(a, 123)).toThrow();\n  expect(() => z.parse(a, \"NaN\")).toThrow();\n});\n\ntest(\"z.pipe\", () => {\n  const a = z.pipe(\n    z.pipe(\n      z.string(),\n      z.transform((val) => val.length)\n    ),\n    z.number()\n  );\n  type a_in = z.input<typeof a>;\n  expectTypeOf<a_in>().toEqualTypeOf<string>();\n  type a_out = z.output<typeof a>;\n  expectTypeOf<a_out>().toEqualTypeOf<number>();\n\n  expect(z.parse(a, \"123\")).toEqual(3);\n  expect(z.parse(a, \"hello\")).toEqual(5);\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.readonly\", () => {\n  const a = z.readonly(z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<Readonly<string>>();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.templateLiteral\", () => {\n  const a = z.templateLiteral([z.string(), z.number()]);\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<`${string}${number}`>();\n  expect(z.parse(a, \"hello123\")).toEqual(\"hello123\");\n  expect(() => z.parse(a, \"hello\")).toThrow();\n  expect(() => z.parse(a, 123)).toThrow();\n\n  // multipart\n  const b = z.templateLiteral([z.string(), z.number(), z.string()]);\n  type b = z.output<typeof b>;\n  expectTypeOf<b>().toEqualTypeOf<`${string}${number}${string}`>();\n  expect(z.parse(b, \"hello123world\")).toEqual(\"hello123world\");\n  expect(z.parse(b, \"123\")).toEqual(\"123\");\n  expect(() => z.parse(b, \"hello\")).toThrow();\n  expect(() => z.parse(b, 123)).toThrow();\n\n  // include boolean\n  const c = z.templateLiteral([z.string(), z.boolean()]);\n  type c = z.output<typeof c>;\n  expectTypeOf<c>().toEqualTypeOf<`${string}${boolean}`>();\n  expect(z.parse(c, \"hellotrue\")).toEqual(\"hellotrue\");\n  expect(z.parse(c, \"hellofalse\")).toEqual(\"hellofalse\");\n  expect(() => z.parse(c, \"hello\")).toThrow();\n  expect(() => z.parse(c, 123)).toThrow();\n\n  // include literal prefix\n  const d = z.templateLiteral([z.literal(\"hello\"), z.number()]);\n  type d = z.output<typeof d>;\n  expectTypeOf<d>().toEqualTypeOf<`hello${number}`>();\n  expect(z.parse(d, \"hello123\")).toEqual(\"hello123\");\n  expect(() => z.parse(d, 123)).toThrow();\n  expect(() => z.parse(d, \"world123\")).toThrow();\n\n  // include literal union\n  const e = z.templateLiteral([z.literal([\"aa\", \"bb\"]), z.number()]);\n  type e = z.output<typeof e>;\n  expectTypeOf<e>().toEqualTypeOf<`aa${number}` | `bb${number}`>();\n  expect(z.parse(e, \"aa123\")).toEqual(\"aa123\");\n  expect(z.parse(e, \"bb123\")).toEqual(\"bb123\");\n  expect(() => z.parse(e, \"cc123\")).toThrow();\n  expect(() => z.parse(e, 123)).toThrow();\n});\n\n// this returns both a schema and a check\ntest(\"z.custom schema\", () => {\n  const a = z.custom((val) => {\n    return typeof val === \"string\";\n  });\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.custom check\", () => {\n  // @ts-expect-error Inference not possible, use z.refine()\n  z.date().check(z.custom((val) => val.getTime() > 0));\n});\n\ntest(\"z.check\", () => {\n  // this is a more flexible version of z.custom that accepts an arbitrary _parse logic\n  // the function should return base.$ZodResult\n  const a = z.any().check(\n    z.check<string>((ctx) => {\n      if (typeof ctx.value === \"string\") return;\n      ctx.issues.push({\n        code: \"custom\",\n        origin: \"custom\",\n        message: \"Expected a string\",\n        input: ctx.value,\n      });\n    })\n  );\n  expect(z.safeParse(a, \"hello\")).toMatchObject({\n    success: true,\n    data: \"hello\",\n  });\n  expect(z.safeParse(a, 123)).toMatchObject({\n    success: false,\n    error: { issues: [{ code: \"custom\", message: \"Expected a string\" }] },\n  });\n});\n\ntest(\"z.instanceof\", () => {\n  class A {}\n\n  const a = z.instanceof(A);\n  expect(z.parse(a, new A())).toBeInstanceOf(A);\n  expect(() => z.parse(a, {})).toThrow();\n});\n\ntest(\"z.refine\", () => {\n  const a = z.number().check(\n    z.refine((val) => val > 3),\n    z.refine((val) => val < 10)\n  );\n  expect(z.parse(a, 5)).toEqual(5);\n  expect(() => z.parse(a, 2)).toThrow();\n  expect(() => z.parse(a, 11)).toThrow();\n  expect(() => z.parse(a, \"hi\")).toThrow();\n});\n\n// test(\"z.superRefine\", () => {\n//   const a = z.number([\n//     z.superRefine((val, ctx) => {\n//       if (val < 3) {\n//         return ctx.addIssue({\n//           code: \"custom\",\n//           origin: \"custom\",\n//           message: \"Too small\",\n//           input: val,\n//         });\n//       }\n//       if (val > 10) {\n//         return ctx.addIssue(\"Too big\");\n//       }\n//     }),\n//   ]);\n\n//   expect(z.parse(a, 5)).toEqual(5);\n//   expect(() => z.parse(a, 2)).toThrow();\n//   expect(() => z.parse(a, 11)).toThrow();\n//   expect(() => z.parse(a, \"hi\")).toThrow();\n// });\n\ntest(\"z.transform\", () => {\n  const a = z.transform((val: number) => {\n    return `${val}`;\n  });\n  type a_in = z.input<typeof a>;\n  expectTypeOf<a_in>().toEqualTypeOf<number>();\n  type a_out = z.output<typeof a>;\n  expectTypeOf<a_out>().toEqualTypeOf<string>();\n  expect(z.parse(a, 123)).toEqual(\"123\");\n});\n\ntest(\"z.$brand()\", () => {\n  const a = z.string().brand<\"my-brand\">();\n  type a = z.output<typeof a>;\n  const branded = (_: a) => {};\n  // @ts-expect-error\n  branded(\"asdf\");\n});\n\ntest(\"z.lazy\", () => {\n  const a = z.lazy(() => z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\n// schema that validates JSON-like data\ntest(\"z.json\", () => {\n  const a = z.json();\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<util.JSONType>();\n\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, 123)).toEqual(123);\n  expect(z.parse(a, true)).toEqual(true);\n  expect(z.parse(a, null)).toEqual(null);\n  expect(z.parse(a, {})).toEqual({});\n  expect(z.parse(a, { a: \"hello\" })).toEqual({ a: \"hello\" });\n  expect(z.parse(a, [1, 2, 3])).toEqual([1, 2, 3]);\n  expect(z.parse(a, [{ a: \"hello\" }])).toEqual([{ a: \"hello\" }]);\n\n  // fail cases\n  expect(() => z.parse(a, new Date())).toThrow();\n  expect(() => z.parse(a, Symbol())).toThrow();\n  expect(() => z.parse(a, { a: new Date() })).toThrow();\n  expect(() => z.parse(a, undefined)).toThrow();\n  expect(() => z.parse(a, { a: undefined })).toThrow();\n});\n\n// promise\ntest(\"z.promise\", async () => {\n  const a = z.promise(z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n\n  expect(await z.safeParseAsync(a, Promise.resolve(\"hello\"))).toMatchObject({\n    success: true,\n    data: \"hello\",\n  });\n  expect(await z.safeParseAsync(a, Promise.resolve(123))).toMatchObject({\n    success: false,\n  });\n\n  const b = z.string();\n  expect(() => z.parse(b, Promise.resolve(\"hello\"))).toThrow();\n});\n// test(\"type assertions\", () => {\n//   const schema = z.pipe(\n//     z.string(),\n//     z.transform((val) => val.length)\n//   );\n//   schema.assertInput<string>();\n//   // @ts-expect-error\n//   schema.assertInput<number>();\n\n//   schema.assertOutput<number>();\n//   // @ts-expect-error\n//   schema.assertOutput<string>();\n// });\n\ntest(\"isPlainObject\", () => {\n  expect(z.core.util.isPlainObject({})).toEqual(true);\n  expect(z.core.util.isPlainObject(Object.create(null))).toEqual(true);\n  expect(z.core.util.isPlainObject([])).toEqual(false);\n  expect(z.core.util.isPlainObject(new Date())).toEqual(false);\n  expect(z.core.util.isPlainObject(null)).toEqual(false);\n  expect(z.core.util.isPlainObject(undefined)).toEqual(false);\n  expect(z.core.util.isPlainObject(\"string\")).toEqual(false);\n  expect(z.core.util.isPlainObject(123)).toEqual(false);\n  expect(z.core.util.isPlainObject(Symbol())).toEqual(false);\n});\n\ntest(\"def typing\", () => {\n  z.string().def.type satisfies \"string\";\n  z.number().def.type satisfies \"number\";\n  z.bigint().def.type satisfies \"bigint\";\n  z.boolean().def.type satisfies \"boolean\";\n  z.date().def.type satisfies \"date\";\n  z.symbol().def.type satisfies \"symbol\";\n  z.undefined().def.type satisfies \"undefined\";\n  z.string().nullable().def.type satisfies \"nullable\";\n  z.null().def.type satisfies \"null\";\n  z.any().def.type satisfies \"any\";\n  z.unknown().def.type satisfies \"unknown\";\n  z.never().def.type satisfies \"never\";\n  z.void().def.type satisfies \"void\";\n  z.array(z.string()).def.type satisfies \"array\";\n  z.object({ key: z.string() }).def.type satisfies \"object\";\n  z.union([z.string(), z.number()]).def.type satisfies \"union\";\n  z.intersection(z.string(), z.number()).def.type satisfies \"intersection\";\n  z.tuple([z.string(), z.number()]).def.type satisfies \"tuple\";\n  z.record(z.string(), z.number()).def.type satisfies \"record\";\n  z.map(z.string(), z.number()).def.type satisfies \"map\";\n  z.set(z.string()).def.type satisfies \"set\";\n  z.literal(\"example\").def.type satisfies \"literal\";\n  z.enum([\"a\", \"b\", \"c\"]).def.type satisfies \"enum\";\n  z.promise(z.string()).def.type satisfies \"promise\";\n  z.lazy(() => z.string()).def.type satisfies \"lazy\";\n  z.string().optional().def.type satisfies \"optional\";\n  z.string().default(\"default\").def.type satisfies \"default\";\n  z.templateLiteral([z.literal(\"a\"), z.literal(\"b\")]).def.type satisfies \"template_literal\";\n  z.custom<string>((val) => typeof val === \"string\").def.type satisfies \"custom\";\n  z.transform((val) => val as string).def.type satisfies \"transform\";\n  z.string().optional().nonoptional().def.type satisfies \"nonoptional\";\n  z.object({ key: z.string() }).readonly().def.type satisfies \"readonly\";\n  z.nan().def.type satisfies \"nan\";\n  z.unknown().pipe(z.number()).def.type satisfies \"pipe\";\n  z.success(z.string()).def.type satisfies \"success\";\n  z.string().catch(\"fallback\").def.type satisfies \"catch\";\n  z.file().def.type satisfies \"file\";\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/index.test.ts",
        "start": 1,
        "end": 829,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 829,
          "column": 2,
          "position": 12192
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/index.test.ts",
        "start": 1,
        "end": 829,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 829,
          "column": 2,
          "position": 12192
        }
      }
    },
    {
      "format": "typescript",
      "lines": 72,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\nfunction nest<TData extends z.ZodType>(schema: TData) {\n  return z.object({\n    nested: schema,\n  });\n}\n\ntest(\"generics\", () => {\n  const a = nest(z.object({ a: z.string() }));\n  type a = z.infer<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<{ nested: { a: string } }>();\n\n  const b = nest(z.object({ a: z.string().optional() }));\n  type b = z.infer<typeof b>;\n  expectTypeOf<b>().toEqualTypeOf<{ nested: { a?: string | undefined } }>();\n});\n\ntest(\"generics with optional\", () => {\n  async function stripOuter<TData extends z.ZodType>(schema: TData, data: unknown) {\n    return z\n      .object({\n        nested: schema.optional(),\n      })\n      .transform((data) => {\n        return data.nested;\n      })\n      .parse({ nested: data });\n  }\n\n  const result = stripOuter(z.object({ a: z.string() }), { a: \"asdf\" });\n  expectTypeOf<typeof result>().toEqualTypeOf<Promise<{ a: string } | undefined>>();\n});\n\n// test(\"assignability\", () => {\n//   const createSchemaAndParse = <K extends string, VS extends z.ZodString>(key: K, valueSchema: VS, data: unknown) => {\n//     const schema = z.object({\n//       [key]: valueSchema,\n//     });\n//     // return { [key]: valueSchema };\n//     const parsed = schema.parse(data);\n//     return parsed;\n//     // const inferred: z.infer<z.ZodObject<{ [k in K]: VS }>> = parsed;\n//     // return inferred;\n//   };\n//   const parsed = createSchemaAndParse(\"foo\", z.string(), { foo: \"\" });\n//   expectTypeOf<typeof parsed>().toEqualTypeOf<{ foo: string }>();\n// });\n\ntest(\"nested no undefined\", () => {\n  const inner = z.string().or(z.array(z.string()));\n  const outer = z.object({ inner });\n  type outerSchema = z.infer<typeof outer>;\n  expectTypeOf<outerSchema>().toEqualTypeOf<{ inner: string | string[] }>();\n\n  expect(outer.safeParse({ inner: undefined }).success).toEqual(false);\n});\n\ntest(\"generic on output type\", () => {\n  const createV4Schema = <Output>(opts: {\n    schema: z.ZodType<Output>;\n  }) => {\n    return opts.schema;\n  };\n\n  createV4Schema({\n    schema: z.object({\n      name: z.string(),\n    }),\n  })?._zod?.output?.name;\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/generics.test.ts",
        "start": 1,
        "end": 72,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 72,
          "column": 2,
          "position": 717
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/generics.test.ts",
        "start": 1,
        "end": 72,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 72,
          "column": 2,
          "position": 717
        }
      }
    },
    {
      "format": "typescript",
      "lines": 268,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\nconst args1 = z.tuple([z.string()]);\nconst returns1 = z.number();\nconst func1 = z.function({\n  input: args1,\n\n  output: returns1,\n});\n\ntest(\"function parsing\", () => {\n  const parsed = func1.implement((arg: any) => arg.length);\n  const result = parsed(\"asdf\");\n  expect(result).toBe(4);\n});\n\ntest(\"parsed function fail 1\", () => {\n  // @ts-expect-error\n  const parsed = func1.implement((x: string) => x);\n  expect(() => parsed(\"asdf\")).toThrow();\n});\n\ntest(\"parsed function fail 2\", () => {\n  // @ts-expect-error\n  const parsed = func1.implement((x: string) => x);\n  expect(() => parsed(13 as any)).toThrow();\n});\n\ntest(\"function inference 1\", () => {\n  type func1 = (typeof func1)[\"_input\"];\n  expectTypeOf<func1>().toEqualTypeOf<(k: string) => number>();\n});\n\n// test(\"method parsing\", () => {\n//   const methodObject = z.object({\n//     property: z.number(),\n//     method: z\n//       .function()\n//       .input(z.tuple([z.string()]))\n//       .output(z.number()),\n//   });\n//   const methodInstance = {\n//     property: 3,\n//     method: function (s: string) {\n//       return s.length + this.property;\n//     },\n//   };\n//   const parsed = methodObject.parse(methodInstance);\n//   expect(parsed.method(\"length=8\")).toBe(11); // 8 length + 3 property\n// });\n\n// test(\"async method parsing\", async () => {\n//   const methodObject = z.object({\n//     property: z.number(),\n//     method: z.function().input(z.string()).output(z.promise(z.number())),\n//   });\n//   const methodInstance = {\n//     property: 3,\n//     method: async function (s: string) {\n//       return s.length + this.property;\n//     },\n//   };\n//   const parsed = methodObject.parse(methodInstance);\n//   expect(await parsed.method(\"length=8\")).toBe(11); // 8 length + 3 property\n// });\n\ntest(\"args method\", () => {\n  const t1 = z.function();\n  type t1 = (typeof t1)[\"_input\"];\n  expectTypeOf<t1>().toEqualTypeOf<(...args_1: never[]) => unknown>();\n  t1._input;\n\n  const t2args = z.tuple([z.string()], z.unknown());\n\n  const t2 = t1.input(t2args);\n  type t2 = (typeof t2)[\"_input\"];\n  expectTypeOf<t2>().toEqualTypeOf<(arg: string, ...args_1: unknown[]) => unknown>();\n\n  const t3 = t2.output(z.boolean());\n  type t3 = (typeof t3)[\"_input\"];\n  expectTypeOf<t3>().toEqualTypeOf<(arg: string, ...args_1: unknown[]) => boolean>();\n});\n\n// test(\"custom args\", () => {\n//   const fn = z.function().implement((_a: string, _b: number) => {\n//     return new Date();\n//   });\n\n//   expectTypeOf(fn).toEqualTypeOf<(a: string, b: number) => Date>();\n// });\n\nconst args2 = z.tuple([\n  z.object({\n    f1: z.number(),\n    f2: z.string().nullable(),\n    f3: z.array(z.boolean().optional()).optional(),\n  }),\n]);\nconst returns2 = z.union([z.string(), z.number()]);\n\nconst func2 = z.function({\n  input: args2,\n  output: returns2,\n});\n\ntest(\"function inference 2\", () => {\n  type func2 = (typeof func2)[\"_input\"];\n\n  expectTypeOf<func2>().toEqualTypeOf<\n    (arg: {\n      f3?: (boolean | undefined)[] | undefined;\n      f1: number;\n      f2: string | null;\n    }) => string | number\n  >();\n});\n\ntest(\"valid function run\", () => {\n  const validFunc2Instance = func2.implement((_x) => {\n    _x.f2;\n    _x.f3![0];\n    return \"adf\" as any;\n  });\n\n  validFunc2Instance({\n    f1: 21,\n    f2: \"asdf\",\n    f3: [true, false],\n  });\n});\n\ntest(\"input validation error\", () => {\n  const schema = z.function({\n    input: z.tuple([z.string()]),\n    output: z.void(),\n  });\n  const fn = schema.implement(() => 1234 as any);\n\n  // @ts-expect-error\n  const checker = () => fn();\n\n  try {\n    checker();\n  } catch (e: any) {\n    expect(e.issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"invalid_type\",\n          \"expected\": \"string\",\n          \"message\": \"Invalid input: expected string, received undefined\",\n          \"path\": [\n            0,\n          ],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"array inputs\", () => {\n  const a = z.function({\n    input: [\n      z.object({\n        name: z.string(),\n        age: z.number().int(),\n      }),\n    ],\n    output: z.string(),\n  });\n\n  a.implement((args) => {\n    return `${args.age}`;\n  });\n\n  const b = z.function({\n    input: [\n      z.object({\n        name: z.string(),\n        age: z.number().int(),\n      }),\n    ],\n  });\n  b.implement((args) => {\n    return `${args.age}`;\n  });\n});\n\ntest(\"output validation error\", () => {\n  const schema = z.function({\n    input: z.tuple([]),\n    output: z.string(),\n  });\n  const fn = schema.implement(() => 1234 as any);\n  try {\n    fn();\n  } catch (e: any) {\n    expect(e.issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"invalid_type\",\n          \"expected\": \"string\",\n          \"message\": \"Invalid input: expected string, received number\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"function with async refinements\", async () => {\n  const schema = z\n    .function()\n    .input([z.string().refine(async (val) => val.length > 10)])\n    .output(z.promise(z.number().refine(async (val) => val > 10)));\n\n  const func = schema.implementAsync(async (val) => {\n    return val.length;\n  });\n  const results = [];\n  try {\n    await func(\"asdfasdf\");\n    results.push(\"success\");\n  } catch (_) {\n    results.push(\"fail\");\n  }\n  try {\n    await func(\"asdflkjasdflkjsf\");\n    results.push(\"success\");\n  } catch (_) {\n    results.push(\"fail\");\n  }\n\n  expect(results).toEqual([\"fail\", \"success\"]);\n});\n\ntest(\"non async function with async refinements should fail\", async () => {\n  const func = z\n    .function()\n    .input([z.string().refine(async (val) => val.length > 10)])\n    .output(z.number().refine(async (val) => val > 10))\n    .implement((val) => {\n      return val.length;\n    });\n\n  const results = [];\n  try {\n    await func(\"asdasdfasdffasdf\");\n    results.push(\"success\");\n  } catch (_) {\n    results.push(\"fail\");\n  }\n\n  expect(results).toEqual([\"fail\"]);\n});\n\ntest(\"extra parameters with rest\", () => {\n  const maxLength5 = z\n    .function()\n    .input([z.string()], z.unknown())\n    .output(z.boolean())\n    .implement((str, _arg, _qewr) => {\n      return str.length <= 5;\n    });\n\n  const filteredList = [\"apple\", \"orange\", \"pear\", \"banana\", \"strawberry\"].filter(maxLength5);\n  expect(filteredList.length).toEqual(2);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/function.test.ts",
        "start": 1,
        "end": 268,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 268,
          "column": 2,
          "position": 2118
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/function.test.ts",
        "start": 1,
        "end": 268,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 268,
          "column": 2,
          "position": 2118
        }
      }
    },
    {
      "format": "typescript",
      "lines": 175,
      "fragment": "import { expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\nimport type * as core from \"zod/v4/core\";\n\ntest(\"first party switch\", () => {\n  const myType = z.string() as core.$ZodTypes;\n  const def = myType._zod.def;\n  switch (def.type) {\n    case \"string\":\n      break;\n    case \"number\":\n      break;\n    case \"bigint\":\n      break;\n    case \"boolean\":\n      break;\n    case \"date\":\n      break;\n    case \"symbol\":\n      break;\n    case \"undefined\":\n      break;\n    case \"null\":\n      break;\n    case \"any\":\n      break;\n    case \"unknown\":\n      break;\n    case \"never\":\n      break;\n    case \"void\":\n      break;\n    case \"array\":\n      break;\n    case \"object\":\n      break;\n    case \"union\":\n      break;\n    case \"intersection\":\n      break;\n    case \"tuple\":\n      break;\n    case \"record\":\n      break;\n    case \"map\":\n      break;\n    case \"set\":\n      break;\n    case \"literal\":\n      break;\n    case \"enum\":\n      break;\n    case \"promise\":\n      break;\n    case \"optional\":\n      break;\n    case \"nonoptional\":\n      break;\n    case \"nullable\":\n      break;\n    case \"default\":\n      break;\n    case \"prefault\":\n      break;\n    case \"template_literal\":\n      break;\n    case \"custom\":\n      break;\n    case \"transform\":\n      break;\n    case \"readonly\":\n      break;\n    case \"nan\":\n      break;\n    case \"pipe\":\n      break;\n    case \"success\":\n      break;\n    case \"catch\":\n      break;\n    case \"file\":\n      break;\n    case \"lazy\":\n      break;\n    default:\n      expectTypeOf(def).toEqualTypeOf<never>();\n  }\n});\n\ntest(\"$ZodSchemaTypes\", () => {\n  const type = \"string\" as core.$ZodTypeDef[\"type\"];\n  switch (type) {\n    case \"string\":\n      break;\n    case \"number\":\n      break;\n    case \"int\":\n      break;\n    case \"bigint\":\n      break;\n    case \"boolean\":\n      break;\n    case \"date\":\n      break;\n    case \"symbol\":\n      break;\n    case \"undefined\":\n      break;\n    case \"null\":\n      break;\n    case \"any\":\n      break;\n    case \"unknown\":\n      break;\n    case \"never\":\n      break;\n    case \"void\":\n      break;\n    case \"array\":\n      break;\n    case \"object\":\n      break;\n    case \"union\":\n      break;\n    case \"intersection\":\n      break;\n    case \"tuple\":\n      break;\n    case \"record\":\n      break;\n    case \"map\":\n      break;\n    case \"set\":\n      break;\n    case \"literal\":\n      break;\n    case \"enum\":\n      break;\n    case \"promise\":\n      break;\n    case \"optional\":\n      break;\n    case \"nonoptional\":\n      break;\n    case \"nullable\":\n      break;\n    case \"default\":\n      break;\n    case \"prefault\":\n      break;\n    case \"template_literal\":\n      break;\n    case \"custom\":\n      break;\n    case \"transform\":\n      break;\n    case \"readonly\":\n      break;\n    case \"nan\":\n      break;\n    case \"pipe\":\n      break;\n    case \"success\":\n      break;\n    case \"catch\":\n      break;\n    case \"file\":\n      break;\n    case \"lazy\":\n      break;\n\n    default:\n      expectTypeOf(type).toEqualTypeOf<never>();\n  }\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/firstparty.test.ts",
        "start": 1,
        "end": 175,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 175,
          "column": 2,
          "position": 962
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/firstparty.test.ts",
        "start": 1,
        "end": 175,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 175,
          "column": 2,
          "position": 962
        }
      }
    },
    {
      "format": "typescript",
      "lines": 91,
      "fragment": "// @ts-ignore\nimport { File as WebFile } from \"@web-std/file\";\n\nimport { afterEach, beforeEach, expect, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\nconst minCheck = z.file().min(5);\nconst maxCheck = z.file().max(8);\nconst mimeCheck = z.file().mime([\"text/plain\", \"application/json\"]);\n\nconst originalFile = global.File;\nbeforeEach(async () => {\n  if (!globalThis.File) globalThis.File = WebFile;\n});\nafterEach(() => {\n  if (globalThis.File !== originalFile) {\n    globalThis.File = originalFile;\n  }\n});\n\ntest(\"passing validations\", () => {\n  minCheck.safeParse(new File([\"12345\"], \"test.txt\"));\n  maxCheck.safeParse(new File([\"12345678\"], \"test.txt\"));\n  mimeCheck.safeParse(new File([\"\"], \"test.csv\", { type: \"text/plain\" }));\n  expect(() => mimeCheck.parse(new File([\"\"], \"test.txt\"))).toThrow();\n  expect(() => mimeCheck.parse(new File([\"\"], \"test.txt\", { type: \"text/csv\" }))).toThrow();\n});\n\ntest(\"failing validations\", () => {\n  expect(minCheck.safeParse(new File([\"1234\"], \"test.txt\"))).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"origin\": \"file\",\n        \"code\": \"too_small\",\n        \"minimum\": 5,\n        \"path\": [],\n        \"message\": \"Too small: expected file to have >5 bytes\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(maxCheck.safeParse(new File([\"123456789\"], \"test.txt\"))).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"origin\": \"file\",\n        \"code\": \"too_big\",\n        \"maximum\": 8,\n        \"path\": [],\n        \"message\": \"Too big: expected file to have <8 bytes\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(mimeCheck.safeParse(new File([\"\"], \"test.csv\"))).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"invalid_value\",\n        \"values\": [\n          \"text/plain\",\n          \"application/json\"\n        ],\n        \"path\": [],\n        \"message\": \"Invalid option: expected one of \\\\\"text/plain\\\\\"|\\\\\"application/json\\\\\"\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(mimeCheck.safeParse(new File([\"\"], \"test.csv\", { type: \"text/csv\" }))).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"invalid_value\",\n        \"values\": [\n          \"text/plain\",\n          \"application/json\"\n        ],\n        \"path\": [],\n        \"message\": \"Invalid option: expected one of \\\\\"text/plain\\\\\"|\\\\\"application/json\\\\\"\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/file.test.ts",
        "start": 1,
        "end": 91,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 91,
          "column": 2,
          "position": 492
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/file.test.ts",
        "start": 1,
        "end": 91,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 91,
          "column": 2,
          "position": 492
        }
      }
    },
    {
      "format": "typescript",
      "lines": 711,
      "fragment": "import { inspect } from \"node:util\";\nimport { expect, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ntest(\"error creation\", () => {\n  const err1 = new z.ZodError([]);\n\n  err1.issues.push({\n    code: \"invalid_type\",\n    expected: \"object\",\n    path: [],\n    message: \"\",\n    input: \"adf\",\n  });\n  err1.isEmpty;\n\n  const err2 = new z.ZodError(err1.issues);\n  const err3 = new z.ZodError([]);\n  err3.addIssues(err1.issues);\n  err3.addIssue(err1.issues[0]);\n  err1.message;\n  err2.message;\n  err3.message;\n});\n\ntest(\"do not allow error and message together\", () => {\n  expect(() =>\n    z.string().refine((_) => true, {\n      message: \"override\",\n      error: (iss) => (iss.input === undefined ? \"asdf\" : null),\n    })\n  ).toThrow();\n});\n\nconst errorMap: z.ZodErrorMap = (issue) => {\n  if (issue.code === \"invalid_type\") {\n    if (issue.expected === \"string\") {\n      return { message: \"bad type!\" };\n    }\n  }\n  if (issue.code === \"custom\") {\n    return { message: `less-than-${issue.params?.minimum}` };\n  }\n  return undefined;\n};\n\ntest(\"type error with custom error map\", () => {\n  const result = z.string().safeParse(234, { error: errorMap });\n  expect(result.success).toBe(false);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [],\n        \"message\": \"bad type!\"\n      }\n    ]]\n  `);\n});\n\ntest(\"refinement fail with params\", () => {\n  const result = z\n    .number()\n    .refine((val) => val >= 3, {\n      params: { minimum: 3 },\n    })\n    .safeParse(2, { error: errorMap });\n  expect(result.success).toBe(false);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"params\": {\n          \"minimum\": 3\n        },\n        \"message\": \"less-than-3\"\n      }\n    ]]\n  `);\n});\n\ntest(\"hard coded error  with custom errormap\", () => {\n  const result = z\n    .string()\n    .refine((val) => val.length > 12, {\n      params: { minimum: 13 },\n      message: \"override\",\n    })\n    .safeParse(\"asdf\", { error: () => \"contextual\" });\n\n  expect(result.success).toBe(false);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"params\": {\n          \"minimum\": 13\n        },\n        \"message\": \"override\"\n      }\n    ]]\n  `);\n});\n\ntest(\"default error message\", () => {\n  const result = z\n    .number()\n    .refine((x) => x > 3)\n    .safeParse(2);\n\n  expect(result.success).toBe(false);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"Invalid input\"\n      }\n    ]]\n  `);\n});\n\ntest(\"override error in refine\", () => {\n  const result = z\n    .number()\n    .refine((x) => x > 3, \"override\")\n    .safeParse(2);\n  expect(result.success).toBe(false);\n  expect(result.error!.issues.length).toEqual(1);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"override\"\n      }\n    ]]\n  `);\n});\n\ntest(\"override error in refinement\", () => {\n  const result = z\n    .number()\n    .refine((x) => x > 3, {\n      message: \"override\",\n    })\n    .safeParse(2);\n  expect(result.success).toBe(false);\n  expect(result.error!.issues.length).toEqual(1);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"override\"\n      }\n    ]]\n  `);\n});\n\ntest(\"array minimum\", () => {\n  let result = z.array(z.string()).min(3, \"tooshort\").safeParse([\"asdf\", \"qwer\"]);\n  expect(result.success).toBe(false);\n  expect(result.error!.issues[0].code).toEqual(\"too_small\");\n  expect(result.error!.issues[0].message).toEqual(\"tooshort\");\n\n  result = z.array(z.string()).min(3).safeParse([\"asdf\", \"qwer\"]);\n  expect(result.success).toBe(false);\n  expect(result.error!.issues[0].code).toEqual(\"too_small\");\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"origin\": \"array\",\n        \"code\": \"too_small\",\n        \"minimum\": 3,\n        \"inclusive\": true,\n        \"path\": [],\n        \"message\": \"Too small: expected array to have >=3 items\"\n      }\n    ]]\n  `);\n});\n\ntest(\"literal bigint default error message\", () => {\n  const result = z.literal(BigInt(12)).safeParse(BigInt(13));\n  expect(result.success).toBe(false);\n  expect(result.error!.issues.length).toEqual(1);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"invalid_value\",\n        \"values\": [\n          \"12\"\n        ],\n        \"path\": [],\n        \"message\": \"Invalid input: expected 12n\"\n      }\n    ]]\n  `);\n});\n\ntest(\"custom path in custom error map\", () => {\n  const schema = z.object({\n    items: z.array(z.string()).refine((data) => data.length > 3, {\n      path: [\"items-too-few\"],\n    }),\n  });\n\n  const errorMap: z.ZodErrorMap = (issue) => {\n    expect((issue.path ?? []).length).toBe(2);\n    return { message: \"doesnt matter\" };\n  };\n  const result = schema.safeParse({ items: [\"first\"] }, { error: errorMap });\n  expect(result.success).toBe(false);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [\n          \"items\",\n          \"items-too-few\"\n        ],\n        \"message\": \"doesnt matter\"\n      }\n    ]]\n  `);\n});\n\n// test(\"error metadata from value\", () => {\n//   const dynamicRefine = z.string().refine(\n//     (val) => val === val.toUpperCase(),\n//     (val) => ({ params: { val } })\n//   );\n\n//   const result = dynamicRefine.safeParse(\"asdf\");\n//   expect(result.success).toEqual(false);\n//   if (!result.success) {\n//     const sub = result.error.issues[0];\n//     expect(result.error.issues[0].code).toEqual(\"custom\");\n//     if (sub.code === \"custom\") {\n//       expect(sub.params?.val).toEqual(\"asdf\");\n//     }\n//   }\n// });\n\n// test(\"don't call refine after validation failed\", () => {\n//   const asdf = z\n//     .union([\n//       z.number(),\n//       z.string().transform(z.number(), (val) => {\n//         return parseFloat(val);\n//       }),\n//     ])\n//     .refine((v) => v >= 1);\n\n//   expect(() => asdf.safeParse(\"foo\")).not.toThrow();\n// });\n\ntest(\"root level formatting\", () => {\n  const schema = z.string().email();\n  const result = schema.safeParse(\"asdfsdf\");\n  expect(result.success).toBe(false);\n\n  expect(result.error!.format()).toMatchInlineSnapshot(`\n    {\n      \"_errors\": [\n        \"Invalid email address\",\n      ],\n    }\n  `);\n});\n\ntest(\"custom path\", () => {\n  const schema = z\n    .object({\n      password: z.string(),\n      confirm: z.string(),\n    })\n    .refine((val) => val.confirm === val.password, { path: [\"confirm\"] });\n\n  const result = schema.safeParse({\n    password: \"peanuts\",\n    confirm: \"qeanuts\",\n  });\n\n  expect(result.success).toBe(false);\n  const error = result.error!.format();\n  expect(error._errors).toEqual([]);\n  expect(error.password?._errors).toEqual(undefined);\n  expect(error.confirm?._errors).toEqual([\"Invalid input\"]);\n});\n\ntest(\"custom path\", () => {\n  const schema = z\n    .object({\n      password: z.string().min(6),\n      confirm: z.string().min(6),\n    })\n    .refine((val) => val.confirm === val.password);\n\n  const result = schema.safeParse({\n    password: \"qwer\",\n    confirm: \"asdf\",\n  });\n\n  expect(result.success).toBe(false);\n  expect(result.error!.issues.length).toEqual(3);\n});\n\nconst schema = z.object({\n  inner: z.object({\n    name: z\n      .string()\n      .refine((val) => val.length > 5)\n      .array()\n      .refine((val) => val.length <= 1),\n  }),\n});\n\ntest(\"no abort early on refinements\", () => {\n  const invalidItem = {\n    inner: { name: [\"aasd\", \"asdfasdfasfd\"] },\n  };\n\n  const result1 = schema.safeParse(invalidItem);\n  expect(result1.success).toBe(false);\n  expect(result1.error!.issues.length).toEqual(2);\n});\n\ntest(\"detect issue with input fallback\", () => {\n  const schema = z\n    .string()\n    .transform((val) => val.length)\n    .refine(() => false, { message: \"always fails\" })\n    .refine(\n      (val) => {\n        if (typeof val !== \"number\") throw new Error();\n        return (val ^ 2) > 10;\n      } // should be number but it's a string\n    );\n  expect(() => schema.parse(\"hello\")).toThrow(z.ZodError);\n});\n\ntest(\"formatting\", () => {\n  const invalidItem = {\n    inner: { name: [\"aasd\", \"asdfasdfasfd\"] },\n  };\n  const invalidArray = {\n    inner: { name: [\"asdfasdf\", \"asdfasdfasfd\"] },\n  };\n  const result1 = schema.safeParse(invalidItem);\n  const result2 = schema.safeParse(invalidArray);\n\n  expect(result1.success).toBe(false);\n  expect(result2.success).toBe(false);\n  const error1 = result1.error!.format();\n  expect(error1._errors).toEqual([]);\n  expect(error1.inner?._errors).toEqual([]);\n  expect(error1.inner?.name?.[1]).toEqual(undefined);\n\n  type FormattedError = z.inferFormattedError<typeof schema>;\n  const error2: FormattedError = result2.error!.format();\n  expect(error2._errors).toEqual([]);\n  expect(error2.inner?._errors).toEqual([]);\n  expect(error2.inner?.name?._errors).toEqual([\"Invalid input\"]);\n  expect(error2.inner?.name?.[0]).toEqual(undefined);\n  expect(error2.inner?.name?.[1]).toEqual(undefined);\n  expect(error2.inner?.name?.[2]).toEqual(undefined);\n\n  // test custom mapper\n  type FormattedErrorWithNumber = z.inferFormattedError<typeof schema, number>;\n  const errorWithNumber: FormattedErrorWithNumber = result2.error!.format(() => 5);\n  expect(errorWithNumber._errors).toEqual([]);\n  expect(errorWithNumber.inner?._errors).toEqual([]);\n  expect(errorWithNumber.inner?.name?._errors).toEqual([5]);\n});\n\ntest(\"formatting with nullable and optional fields\", () => {\n  const nameSchema = z.string().refine((val) => val.length > 5);\n  const schema = z.object({\n    nullableObject: z.object({ name: nameSchema }).nullable(),\n    nullableArray: z.array(nameSchema).nullable(),\n    nullableTuple: z.tuple([nameSchema, nameSchema, z.number()]).nullable(),\n    optionalObject: z.object({ name: nameSchema }).optional(),\n    optionalArray: z.array(nameSchema).optional(),\n    optionalTuple: z.tuple([nameSchema, nameSchema, z.number()]).optional(),\n  });\n  const invalidItem = {\n    nullableObject: { name: \"abcd\" },\n    nullableArray: [\"abcd\"],\n    nullableTuple: [\"abcd\", \"abcd\", 1],\n    optionalObject: { name: \"abcd\" },\n    optionalArray: [\"abcd\"],\n    optionalTuple: [\"abcd\", \"abcd\", 1],\n  };\n  const result = schema.safeParse(invalidItem);\n  expect(result.success).toBe(false);\n  const error: z.inferFormattedError<typeof schema> = result.error!.format();\n  expect(error._errors).toEqual([]);\n  expect(error.nullableObject?._errors).toEqual([]);\n  expect(error.nullableObject?.name?._errors).toEqual([\"Invalid input\"]);\n  expect(error.nullableArray?._errors).toEqual([]);\n  expect(error.nullableArray?.[0]?._errors).toEqual([\"Invalid input\"]);\n  expect(error.nullableTuple?._errors).toEqual([]);\n  expect(error.nullableTuple?.[0]?._errors).toEqual([\"Invalid input\"]);\n  expect(error.nullableTuple?.[1]?._errors).toEqual([\"Invalid input\"]);\n  expect(error.optionalObject?._errors).toEqual([]);\n  expect(error.optionalObject?.name?._errors).toEqual([\"Invalid input\"]);\n  expect(error.optionalArray?._errors).toEqual([]);\n  expect(error.optionalArray?.[0]?._errors).toEqual([\"Invalid input\"]);\n  expect(error.optionalTuple?._errors).toEqual([]);\n  expect(error.optionalTuple?.[0]?._errors).toEqual([\"Invalid input\"]);\n  expect(error.optionalTuple?.[1]?._errors).toEqual([\"Invalid input\"]);\n\n  expect(error).toMatchInlineSnapshot(`\n    {\n      \"_errors\": [],\n      \"nullableArray\": {\n        \"0\": {\n          \"_errors\": [\n            \"Invalid input\",\n          ],\n        },\n        \"_errors\": [],\n      },\n      \"nullableObject\": {\n        \"_errors\": [],\n        \"name\": {\n          \"_errors\": [\n            \"Invalid input\",\n          ],\n        },\n      },\n      \"nullableTuple\": {\n        \"0\": {\n          \"_errors\": [\n            \"Invalid input\",\n          ],\n        },\n        \"1\": {\n          \"_errors\": [\n            \"Invalid input\",\n          ],\n        },\n        \"_errors\": [],\n      },\n      \"optionalArray\": {\n        \"0\": {\n          \"_errors\": [\n            \"Invalid input\",\n          ],\n        },\n        \"_errors\": [],\n      },\n      \"optionalObject\": {\n        \"_errors\": [],\n        \"name\": {\n          \"_errors\": [\n            \"Invalid input\",\n          ],\n        },\n      },\n      \"optionalTuple\": {\n        \"0\": {\n          \"_errors\": [\n            \"Invalid input\",\n          ],\n        },\n        \"1\": {\n          \"_errors\": [\n            \"Invalid input\",\n          ],\n        },\n        \"_errors\": [],\n      },\n    }\n  `);\n});\n\ntest(\"inferFlattenedErrors\", () => {\n  const schemaWithTransform = z.object({ foo: z.string() }).transform((o) => ({ bar: o.foo }));\n\n  const result = schemaWithTransform.safeParse({});\n\n  expect(result.success).toBe(false);\n  type ValidationErrors = z.inferFlattenedErrors<typeof schemaWithTransform>;\n  const error: ValidationErrors = result.error!.flatten();\n  expect(error).toMatchInlineSnapshot(`\n    {\n      \"fieldErrors\": {\n        \"foo\": [\n          \"Invalid input: expected string, received undefined\",\n        ],\n      },\n      \"formErrors\": [],\n    }\n  `);\n});\n\nconst stringWithCustomError = z.string({\n  error: () => \"bound\",\n});\n\ntest(\"schema-bound error map\", () => {\n  const result = stringWithCustomError.safeParse(1234);\n  expect(result.success).toBe(false);\n  expect(result.error!.issues[0].message).toEqual(\"bound\");\n});\n\ntest(\"bound error map overrides contextual\", () => {\n  // support contextual override\n  const result = stringWithCustomError.safeParse(undefined, {\n    error: () => ({ message: \"override\" }),\n  });\n  expect(result.success).toBe(false);\n  expect(result.error!.issues[0].message).toEqual(\"bound\");\n});\n\ntest(\"z.config customError \", () => {\n  // support overrideErrorMap\n\n  z.config({ customError: () => ({ message: \"override\" }) });\n  const result = stringWithCustomError.min(10).safeParse(\"tooshort\");\n  expect(result.success).toBe(false);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"origin\": \"string\",\n        \"code\": \"too_small\",\n        \"minimum\": 10,\n        \"inclusive\": true,\n        \"path\": [],\n        \"message\": \"override\"\n      }\n    ]]\n  `);\n  expect(result.error!.issues[0].message).toEqual(\"override\");\n  z.config({ customError: undefined });\n});\n\n// test(\"invalid and required\", () => {\n//   const str = z.string({\n//     invalid_type_error: \"Invalid name\",\n//     required_error: \"Name is required\",\n//   });\n//   const result1 = str.safeParse(1234);\n//   expect(result1.success).toBe(false);\n//   if (!result1.success) {\n//     expect(result1.error.issues[0].message).toEqual(\"Invalid name\");\n//   }\n//   const result2 = str.safeParse(undefined);\n//   expect(result2.success).toBe(false);\n//   if (!result2.success) {\n//     expect(result2.error.issues[0].message).toEqual(\"Name is required\");\n//   }\n// });\n\n// test(\"Fallback to default required error\", () => {\n//   const str = z.string({\n//     invalid_type_error: \"Invalid name\",\n//     // required_error: \"Name is required\",\n//   });\n\n//   const result2 = str.safeParse(undefined);\n//   expect(result2.success).toBe(false);\n//   if (!result2.success) {\n//     expect(result2.error.issues[0].message).toEqual(\"Required\");\n//   }\n// });\n\n// test(\"invalid and required and errorMap\", () => {\n//   expect(() => {\n//     return z.string({\n//       invalid_type_error: \"Invalid name\",\n//       required_error: \"Name is required\",\n//       errorMap: () => ({ message: \"override\" }),\n//     });\n//   }).toThrow();\n// });\n\n// test(\"strict error message\", () => {\n//   const errorMsg = \"Invalid object\";\n//   const obj = z.object({ x: z.string() }).strict(errorMsg);\n//   const result = obj.safeParse({ x: \"a\", y: \"b\" });\n//   expect(result.success).toBe(false);\n//   if (!result.success) {\n//     expect(result.error.issues[0].message).toEqual(errorMsg);\n//   }\n// });\n\ntest(\"empty string error message\", () => {\n  const schema = z.string().max(1, { message: \"\" });\n  const result = schema.safeParse(\"asdf\");\n  expect(result.success).toBe(false);\n  expect(result.error!.issues[0].message).toEqual(\"\");\n});\n\ntest(\"dont short circuit on continuable errors\", () => {\n  const user = z\n    .object({\n      password: z.string().min(6),\n      confirm: z.string(),\n    })\n    .refine((data) => data.password === data.confirm, {\n      message: \"Passwords don't match\",\n      path: [\"confirm\"],\n    });\n  const result = user.safeParse({ password: \"asdf\", confirm: \"qwer\" });\n  expect(result.success).toBe(false);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"origin\": \"string\",\n        \"code\": \"too_small\",\n        \"minimum\": 6,\n        \"inclusive\": true,\n        \"path\": [\n          \"password\"\n        ],\n        \"message\": \"Too small: expected string to have >=6 characters\"\n      },\n      {\n        \"code\": \"custom\",\n        \"path\": [\n          \"confirm\"\n        ],\n        \"message\": \"Passwords don't match\"\n      }\n    ]]\n  `);\n  // expect(result.error!.issues.length).toEqual(2);\n});\n\ntest(\"string error params\", () => {\n  const a = z.string(\"Bad!\");\n  expect(a.safeParse(123).error!.issues[0].message).toBe(\"Bad!\");\n\n  const b = z.string().min(5, \"Too short!\");\n  expect(b.safeParse(\"abc\").error!.issues[0].message).toBe(\"Too short!\");\n\n  const c = z.uuid(\"Bad UUID!\");\n  expect(c.safeParse(\"not-a-uuid\").error!.issues[0].message).toBe(\"Bad UUID!\");\n\n  const d = z.string().datetime({ message: \"Bad date!\" });\n  expect(d.safeParse(\"not-a-date\").error!.issues[0].message).toBe(\"Bad date!\");\n\n  const e = z.array(z.string(), \"Bad array!\");\n  expect(e.safeParse(\"not-an-array\").error!.issues[0].message).toBe(\"Bad array!\");\n\n  const f = z.array(z.string()).min(5, \"Too few items!\");\n  expect(f.safeParse([\"a\", \"b\"]).error!.issues[0].message).toBe(\"Too few items!\");\n\n  const g = z.set(z.string(), \"Bad set!\");\n  expect(g.safeParse(\"not-a-set\").error!.issues[0].message).toBe(\"Bad set!\");\n\n  const h = z.array(z.string(), \"Bad array!\");\n  expect(h.safeParse(123).error!.issues[0].message).toBe(\"Bad array!\");\n\n  const i = z.set(z.string(), \"Bad set!\");\n  expect(i.safeParse(123).error!.issues[0].message).toBe(\"Bad set!\");\n\n  const j = z.array(z.string(), \"Bad array!\");\n  expect(j.safeParse(null).error!.issues[0].message).toBe(\"Bad array!\");\n});\n\ntest(\"error inheritance\", () => {\n  const e1 = z.string().safeParse(123).error!;\n  expect(e1).toBeInstanceOf(z.core.$ZodError);\n  expect(e1).toBeInstanceOf(z.ZodError);\n  expect(e1).toBeInstanceOf(z.ZodRealError);\n  // expect(e1).not.toBeInstanceOf(Error);\n\n  try {\n    z.string().parse(123);\n  } catch (e2) {\n    expect(e1).toBeInstanceOf(z.core.$ZodError);\n    expect(e2).toBeInstanceOf(z.ZodError);\n    expect(e2).toBeInstanceOf(z.ZodRealError);\n    // expect(e2).toBeInstanceOf(Error);\n  }\n});\n\ntest(\"error serialization\", () => {\n  try {\n    z.string().parse(123);\n  } catch (e) {\n    expect(e).toMatchInlineSnapshot(`\n      [ZodError: [\n        {\n          \"expected\": \"string\",\n          \"code\": \"invalid_type\",\n          \"path\": [],\n          \"message\": \"Invalid input: expected string, received number\"\n        }\n      ]]\n    `);\n    expect(inspect(e).split(\"\\n\").slice(0, 8).join(\"\\n\")).toMatchInlineSnapshot(`\n      \"ZodError: [\n        {\n          \"expected\": \"string\",\n          \"code\": \"invalid_type\",\n          \"path\": [],\n          \"message\": \"Invalid input: expected string, received number\"\n        }\n      ]\"\n    `);\n  }\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/error.test.ts",
        "start": 1,
        "end": 711,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 711,
          "column": 2,
          "position": 5148
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/error.test.ts",
        "start": 1,
        "end": 711,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 711,
          "column": 2,
          "position": 5148
        }
      }
    },
    {
      "format": "typescript",
      "lines": 527,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ndeclare const iss: z.core.$ZodIssueCode;\n\nconst Test = z.object({\n  f1: z.number(),\n  f2: z.string().optional(),\n  f3: z.string().nullable(),\n  f4: z.array(z.object({ t: z.union([z.string(), z.boolean()]) })),\n});\n// type TestFlattenedErrors = core.inferFlattenedErrors<typeof Test, { message: string; code: number }>;\n// type TestFormErrors = core.inferFlattenedErrors<typeof Test>;\nconst parsed = Test.safeParse({});\n\ntest(\"regular error\", () => {\n  expect(parsed).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"number\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"f1\"\n        ],\n        \"message\": \"Invalid input: expected number, received undefined\"\n      },\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"f3\"\n        ],\n        \"message\": \"Invalid input: expected string, received undefined\"\n      },\n      {\n        \"expected\": \"array\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"f4\"\n        ],\n        \"message\": \"Invalid input: expected array, received undefined\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\".flatten()\", () => {\n  const flattened = parsed.error!.flatten();\n  // flattened.\n  expectTypeOf(flattened).toMatchTypeOf<{\n    formErrors: string[];\n    fieldErrors: {\n      f2?: string[];\n      f1?: string[];\n      f3?: string[];\n      f4?: string[];\n    };\n  }>();\n\n  expect(flattened).toMatchInlineSnapshot(`\n    {\n      \"fieldErrors\": {\n        \"f1\": [\n          \"Invalid input: expected number, received undefined\",\n        ],\n        \"f3\": [\n          \"Invalid input: expected string, received undefined\",\n        ],\n        \"f4\": [\n          \"Invalid input: expected array, received undefined\",\n        ],\n      },\n      \"formErrors\": [],\n    }\n  `);\n});\n\ntest(\"custom .flatten()\", () => {\n  type ErrorType = { message: string; code: number };\n  const flattened = parsed.error!.flatten((iss) => ({ message: iss.message, code: 1234 }));\n  expectTypeOf(flattened).toMatchTypeOf<{\n    formErrors: ErrorType[];\n    fieldErrors: {\n      f2?: ErrorType[];\n      f1?: ErrorType[];\n      f3?: ErrorType[];\n      f4?: ErrorType[];\n    };\n  }>();\n\n  expect(flattened).toMatchInlineSnapshot(`\n    {\n      \"fieldErrors\": {\n        \"f1\": [\n          {\n            \"code\": 1234,\n            \"message\": \"Invalid input: expected number, received undefined\",\n          },\n        ],\n        \"f3\": [\n          {\n            \"code\": 1234,\n            \"message\": \"Invalid input: expected string, received undefined\",\n          },\n        ],\n        \"f4\": [\n          {\n            \"code\": 1234,\n            \"message\": \"Invalid input: expected array, received undefined\",\n          },\n        ],\n      },\n      \"formErrors\": [],\n    }\n  `);\n});\n\ntest(\".format()\", () => {\n  const formatted = parsed.error!.format();\n  expectTypeOf(formatted).toMatchTypeOf<{\n    _errors: string[];\n    f2?: { _errors: string[] };\n    f1?: { _errors: string[] };\n    f3?: { _errors: string[] };\n    f4?: {\n      [x: number]: {\n        _errors: string[];\n        t?: {\n          _errors: string[];\n        };\n      };\n      _errors: string[];\n    };\n  }>();\n\n  expect(formatted).toMatchInlineSnapshot(`\n    {\n      \"_errors\": [],\n      \"f1\": {\n        \"_errors\": [\n          \"Invalid input: expected number, received undefined\",\n        ],\n      },\n      \"f3\": {\n        \"_errors\": [\n          \"Invalid input: expected string, received undefined\",\n        ],\n      },\n      \"f4\": {\n        \"_errors\": [\n          \"Invalid input: expected array, received undefined\",\n        ],\n      },\n    }\n  `);\n});\n\ntest(\"custom .format()\", () => {\n  type ErrorType = { message: string; code: number };\n  const formatted = parsed.error!.format((iss) => ({ message: iss.message, code: 1234 }));\n  expectTypeOf(formatted).toMatchTypeOf<{\n    _errors: ErrorType[];\n    f2?: { _errors: ErrorType[] };\n    f1?: { _errors: ErrorType[] };\n    f3?: { _errors: ErrorType[] };\n    f4?: {\n      [x: number]: {\n        _errors: ErrorType[];\n        t?: {\n          _errors: ErrorType[];\n        };\n      };\n      _errors: ErrorType[];\n    };\n  }>();\n\n  expect(formatted).toMatchInlineSnapshot(`\n    {\n      \"_errors\": [],\n      \"f1\": {\n        \"_errors\": [\n          {\n            \"code\": 1234,\n            \"message\": \"Invalid input: expected number, received undefined\",\n          },\n        ],\n      },\n      \"f3\": {\n        \"_errors\": [\n          {\n            \"code\": 1234,\n            \"message\": \"Invalid input: expected string, received undefined\",\n          },\n        ],\n      },\n      \"f4\": {\n        \"_errors\": [\n          {\n            \"code\": 1234,\n            \"message\": \"Invalid input: expected array, received undefined\",\n          },\n        ],\n      },\n    }\n  `);\n});\n\ntest(\"all errors\", () => {\n  const propertySchema = z.string();\n  const schema = z\n    .object({\n      a: propertySchema,\n      b: propertySchema,\n    })\n    .refine(\n      (val) => {\n        return val.a === val.b;\n      },\n      { message: \"Must be equal\" }\n    );\n\n  const r1 = schema.safeParse({\n    a: \"asdf\",\n    b: \"qwer\",\n  });\n\n  expect(z.core.flattenError(r1.error!)).toEqual({\n    formErrors: [\"Must be equal\"],\n    fieldErrors: {},\n  });\n\n  const r2 = schema.safeParse({\n    a: null,\n    b: null,\n  });\n\n  // const error = _error as z.ZodError;\n  expect(z.core.flattenError(r2.error!)).toMatchInlineSnapshot(`\n    {\n      \"fieldErrors\": {\n        \"a\": [\n          \"Invalid input: expected string, received null\",\n        ],\n        \"b\": [\n          \"Invalid input: expected string, received null\",\n        ],\n      },\n      \"formErrors\": [],\n    }\n  `);\n\n  expect(z.core.flattenError(r2.error!, (iss) => iss.message.toUpperCase())).toMatchInlineSnapshot(`\n    {\n      \"fieldErrors\": {\n        \"a\": [\n          \"INVALID INPUT: EXPECTED STRING, RECEIVED NULL\",\n        ],\n        \"b\": [\n          \"INVALID INPUT: EXPECTED STRING, RECEIVED NULL\",\n        ],\n      },\n      \"formErrors\": [],\n    }\n  `);\n  // Test identity\n\n  expect(z.core.flattenError(r2.error!, (i: z.ZodIssue) => i)).toMatchInlineSnapshot(`\n    {\n      \"fieldErrors\": {\n        \"a\": [\n          {\n            \"code\": \"invalid_type\",\n            \"expected\": \"string\",\n            \"message\": \"Invalid input: expected string, received null\",\n            \"path\": [\n              \"a\",\n            ],\n          },\n        ],\n        \"b\": [\n          {\n            \"code\": \"invalid_type\",\n            \"expected\": \"string\",\n            \"message\": \"Invalid input: expected string, received null\",\n            \"path\": [\n              \"b\",\n            ],\n          },\n        ],\n      },\n      \"formErrors\": [],\n    }\n  `);\n\n  // Test mapping\n  const f1 = z.core.flattenError(r2.error!, (i: z.ZodIssue) => i.message.length);\n  expect(f1).toMatchInlineSnapshot(`\n    {\n      \"fieldErrors\": {\n        \"a\": [\n          45,\n        ],\n        \"b\": [\n          45,\n        ],\n      },\n      \"formErrors\": [],\n    }\n  `);\n  // expect(f1.fieldErrors.a![0]).toEqual(\"Invalid input: expected string\".length);\n  // expect(f1).toMatchObject({\n  //   formErrors: [],\n  //   fieldErrors: {\n  //     a: [\"Invalid input: expected string\".length],\n  //     b: [\"Invalid input: expected string\".length],\n  //   },\n  // });\n});\n\nconst schema = z.strictObject({\n  username: z.string(),\n  favoriteNumbers: z.array(z.number()),\n  nesting: z.object({\n    a: z.string(),\n  }),\n});\nconst result = schema.safeParse({\n  username: 1234,\n  favoriteNumbers: [1234, \"4567\"],\n  nesting: {\n    a: 123,\n  },\n  extra: 1234,\n});\n\ntest(\"z.treeifyError\", () => {\n  expect(z.treeifyError(result.error!)).toMatchInlineSnapshot(`\n    {\n      \"errors\": [\n        \"Unrecognized key: \"extra\"\",\n      ],\n      \"properties\": {\n        \"favoriteNumbers\": {\n          \"errors\": [],\n          \"items\": [\n            ,\n            {\n              \"errors\": [\n                \"Invalid input: expected number, received string\",\n              ],\n            },\n          ],\n        },\n        \"nesting\": {\n          \"errors\": [],\n          \"properties\": {\n            \"a\": {\n              \"errors\": [\n                \"Invalid input: expected string, received number\",\n              ],\n            },\n          },\n        },\n        \"username\": {\n          \"errors\": [\n            \"Invalid input: expected string, received number\",\n          ],\n        },\n      },\n    }\n  `);\n});\n\ntest(\"z.treeifyError 2\", () => {\n  const schema = z.strictObject({\n    name: z.string(),\n    logLevel: z.union([z.string(), z.number()]),\n    env: z.literal([\"production\", \"development\"]),\n  });\n\n  const data = {\n    name: 1000,\n    logLevel: false,\n    extra: 1000,\n  };\n\n  const result = schema.safeParse(data);\n  const err = z.treeifyError(result.error!);\n  expect(err).toMatchInlineSnapshot(`\n    {\n      \"errors\": [\n        \"Unrecognized key: \"extra\"\",\n      ],\n      \"properties\": {\n        \"env\": {\n          \"errors\": [\n            \"Invalid option: expected one of \"production\"|\"development\"\",\n          ],\n        },\n        \"logLevel\": {\n          \"errors\": [\n            \"Invalid input: expected string, received boolean\",\n            \"Invalid input: expected number, received boolean\",\n          ],\n        },\n        \"name\": {\n          \"errors\": [\n            \"Invalid input: expected string, received number\",\n          ],\n        },\n      },\n    }\n  `);\n});\n\ntest(\"z.prettifyError\", () => {\n  expect(z.prettifyError(result.error!)).toMatchInlineSnapshot(`\n    \" Unrecognized key: \"extra\"\n     Invalid input: expected string, received number\n       at username\n     Invalid input: expected number, received string\n       at favoriteNumbers[1]\n     Invalid input: expected string, received number\n       at nesting.a\"\n  `);\n});\n\ntest(\"z.toDotPath\", () => {\n  expect(z.core.toDotPath([\"a\", \"b\", 0, \"c\"])).toMatchInlineSnapshot(`\"a.b[0].c\"`);\n\n  expect(z.core.toDotPath([\"a\", Symbol(\"b\"), 0, \"c\"])).toMatchInlineSnapshot(`\"a[\"Symbol(b)\"][0].c\"`);\n\n  // Test with periods in keys\n  expect(z.core.toDotPath([\"user.name\", \"first.last\"])).toMatchInlineSnapshot(`\"[\"user.name\"][\"first.last\"]\"`);\n\n  // Test with special characters\n  expect(z.core.toDotPath([\"user\", \"$special\", Symbol(\"#symbol\")])).toMatchInlineSnapshot(\n    `\"user.$special[\"Symbol(#symbol)\"]\"`\n  );\n\n  // Test with dots and quotes\n  expect(z.core.toDotPath([\"search\", `query(\"foo.bar\"=\"abc\")`])).toMatchInlineSnapshot(\n    `\"search[\"query(\\\\\"foo.bar\\\\\"=\\\\\"abc\\\\\")\"]\"`\n  );\n\n  // Test with newlines\n  expect(z.core.toDotPath([\"search\", `foo\\nbar`])).toMatchInlineSnapshot(`\"search[\"foo\\\\nbar\"]\"`);\n\n  // Test with empty strings\n  expect(z.core.toDotPath([\"\", \"empty\"])).toMatchInlineSnapshot(`\".empty\"`);\n\n  // Test with array indices\n  expect(z.core.toDotPath([\"items\", 0, 1, 2])).toMatchInlineSnapshot(`\"items[0][1][2]\"`);\n\n  // Test with mixed path elements\n  expect(z.core.toDotPath([\"users\", \"user.config\", 0, \"settings.theme\"])).toMatchInlineSnapshot(\n    `\"users[\"user.config\"][0][\"settings.theme\"]\"`\n  );\n\n  // Test with square brackets in keys\n  expect(z.core.toDotPath([\"data[0]\", \"value\"])).toMatchInlineSnapshot(`\"[\"data[0]\"].value\"`);\n\n  // Test with empty path\n  expect(z.core.toDotPath([])).toMatchInlineSnapshot(`\"\"`);\n});\n\ntest(\"inheritance\", () => {\n  const e1 = new z.ZodError([]);\n  expect(e1).toBeInstanceOf(z.core.$ZodError);\n  expect(e1).toBeInstanceOf(z.ZodError);\n  // expect(e1).not.toBeInstanceOf(Error);\n\n  const e2 = new z.ZodRealError([]);\n  expect(e2).toBeInstanceOf(z.ZodError);\n  expect(e2).toBeInstanceOf(z.ZodRealError);\n  expect(e2).toBeInstanceOf(Error);\n});\n\ntest(\"disc union treeify/format\", () => {\n  const schema = z.discriminatedUnion(\n    \"foo\",\n    [\n      z.object({\n        foo: z.literal(\"x\"),\n        x: z.string(),\n      }),\n      z.object({\n        foo: z.literal(\"y\"),\n        y: z.string(),\n      }),\n    ],\n    {\n      error: \"Invalid discriminator\",\n    }\n  );\n\n  const error = schema.safeParse({ foo: \"invalid\" }).error;\n  expect(z.treeifyError(error!)).toMatchInlineSnapshot(`\n    {\n      \"errors\": [],\n      \"properties\": {\n        \"foo\": {\n          \"errors\": [\n            \"Invalid discriminator\",\n          ],\n        },\n      },\n    }\n  `);\n  expect(z.prettifyError(error!)).toMatchInlineSnapshot(`\n    \" Invalid discriminator\n       at foo\"\n  `);\n  expect(z.formatError(error!)).toMatchInlineSnapshot(`\n    {\n      \"_errors\": [],\n      \"foo\": {\n        \"_errors\": [\n          \"Invalid discriminator\",\n        ],\n      },\n    }\n  `);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/error-utils.test.ts",
        "start": 1,
        "end": 527,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 527,
          "column": 2,
          "position": 2377
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/error-utils.test.ts",
        "start": 1,
        "end": 527,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 527,
          "column": 2,
          "position": 2377
        }
      }
    },
    {
      "format": "typescript",
      "lines": 285,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ntest(\"enum from string array\", () => {\n  const MyEnum = z.enum([\"Red\", \"Green\", \"Blue\"]);\n  expect(MyEnum.enum.Red).toEqual(\"Red\");\n\n  type MyEnum = z.infer<typeof MyEnum>;\n  expectTypeOf<MyEnum>().toEqualTypeOf<\"Red\" | \"Green\" | \"Blue\">();\n});\n\ntest(\"enum from const object\", () => {\n  const Fruits: { Apple: \"apple\"; Banana: \"banana\" } = {\n    Apple: \"apple\",\n    Banana: \"banana\",\n  };\n  const fruitEnum = z.nativeEnum(Fruits);\n  type fruitEnum = z.infer<typeof fruitEnum>;\n  fruitEnum.parse(\"apple\");\n  fruitEnum.parse(\"banana\");\n  fruitEnum.parse(Fruits.Apple);\n  fruitEnum.parse(Fruits.Banana);\n  expectTypeOf<fruitEnum>().toEqualTypeOf<\"apple\" | \"banana\">();\n});\n\ntest(\"enum from native enum\", () => {\n  enum Fruits {\n    Apple = \"apple\",\n    Banana = \"banana\",\n    Orange = 3,\n  }\n  // @ts-ignore\n  const fruitEnum = z.nativeEnum(Fruits);\n  type fruitEnum = z.infer<typeof fruitEnum>;\n  fruitEnum.parse(\"apple\");\n  fruitEnum.parse(\"banana\");\n  fruitEnum.parse(Fruits.Apple);\n  fruitEnum.parse(Fruits.Banana);\n\n  expect(fruitEnum.safeParse(\"Apple\").success).toEqual(false);\n  expect(fruitEnum.safeParse(\"Cantaloupe\").success).toEqual(false);\n\n  expectTypeOf<fruitEnum>().toMatchTypeOf<Fruits>();\n  expectTypeOf<Fruits>().toMatchTypeOf<fruitEnum>();\n});\n\ntest(\"enum from native enum with numeric keys\", () => {\n  const FruitValues = {\n    Apple: 10,\n    Banana: 20,\n    // @ts-ignore\n  } as const;\n  const fruitEnum = z.nativeEnum(FruitValues);\n  type fruitEnum = z.infer<typeof fruitEnum>;\n  fruitEnum.parse(10);\n  fruitEnum.parse(20);\n  fruitEnum.parse(FruitValues.Apple);\n  fruitEnum.parse(FruitValues.Banana);\n  expectTypeOf<fruitEnum>().toEqualTypeOf<10 | 20>();\n});\n\ntest(\"issue metadata\", () => {\n  const schema = z.enum([\"Red\", \"Green\", \"Blue\"]);\n  const result = schema.safeParse(\"Yellow\");\n  expect(result.error!.issues[0]).toMatchInlineSnapshot(`\n    {\n      \"code\": \"invalid_value\",\n      \"message\": \"Invalid option: expected one of \"Red\"|\"Green\"|\"Blue\"\",\n      \"path\": [],\n      \"values\": [\n        \"Red\",\n        \"Green\",\n        \"Blue\",\n      ],\n    }\n  `);\n});\n\ntest(\"enum from non-const inputs\", () => {\n  const foods = [\"Pasta\", \"Pizza\", \"Tacos\", \"Burgers\", \"Salad\"];\n  const FoodEnum = z.enum(foods);\n\n  expectTypeOf<z.infer<typeof FoodEnum>>().toEqualTypeOf<string>();\n  expect(FoodEnum.safeParse(\"Pasta\").success).toEqual(true);\n  expect(FoodEnum.safeParse(\"Cucumbers\").success).toEqual(false);\n});\n\ntest(\"get options\", () => {\n  expect(z.enum([\"tuna\", \"trout\"]).options).toEqual([\"tuna\", \"trout\"]);\n});\n\ntest(\"readonly enum\", () => {\n  const HTTP_SUCCESS = [\"200\", \"201\"] as const;\n  const arg = z.enum(HTTP_SUCCESS);\n  type arg = z.infer<typeof arg>;\n  expectTypeOf<arg>().toEqualTypeOf<\"200\" | \"201\">();\n\n  arg.parse(\"201\");\n  expect(() => arg.parse(\"202\")).toThrow();\n});\n\ntest(\"error map\", () => {\n  const result = z\n    .enum([\"test\"], { error: (iss) => (iss.input === undefined ? \"REQUIRED\" : undefined) })\n    .safeParse(undefined);\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues[0].message).toEqual(\"REQUIRED\");\n  }\n});\n\ntest(\"type signatures\", () => {\n  const a = z.enum([\"a\", \"b\", \"c\"]);\n  const b = z.enum(a.options);\n  expectTypeOf(a).toEqualTypeOf(b);\n\n  const c = z.enum({ a: 1, b: 2 } as const);\n  expectTypeOf(c.enum).toEqualTypeOf<{\n    readonly a: 1;\n    readonly b: 2;\n  }>();\n\n  enum Fruit {\n    Apple = \"apple\",\n    Banana = \"banana\",\n    Orange = \"orange\",\n  }\n  const d = z.enum(Fruit);\n  expectTypeOf(d.enum).toEqualTypeOf(Fruit);\n\n  const e = z.enum({ a: 1, b: 2 });\n  expectTypeOf(e.enum).toEqualTypeOf<{\n    readonly a: 1;\n    readonly b: 2;\n  }>();\n});\n\ntest(\"extract\", () => {\n  const foods = [\"Pasta\", \"Pizza\", \"Tacos\", \"Burgers\", \"Salad\"] as const;\n  const FoodEnum = z.enum(foods);\n  const ItalianEnum = FoodEnum.extract([\"Pasta\", \"Pizza\"]);\n\n  expect(ItalianEnum.safeParse(\"Pasta\").success).toEqual(true);\n  expect(ItalianEnum.safeParse(\"Tacos\").success).toEqual(false);\n\n  expectTypeOf<z.infer<typeof ItalianEnum>>().toEqualTypeOf<\"Pasta\" | \"Pizza\">();\n});\n\ntest(\"exclude\", () => {\n  const foods = [\"Pasta\", \"Pizza\", \"Tacos\", \"Burgers\", \"Salad\"] as const;\n  const FoodEnum = z.enum(foods);\n  const UnhealthyEnum = FoodEnum.exclude([\"Salad\"]);\n\n  expect(UnhealthyEnum.safeParse(\"Pasta\").success).toEqual(true);\n  expect(UnhealthyEnum.safeParse(\"Salad\").success).toEqual(false);\n  expectTypeOf<z.infer<typeof UnhealthyEnum>>().toEqualTypeOf<\"Pasta\" | \"Pizza\" | \"Tacos\" | \"Burgers\">();\n\n  const EmptyFoodEnum = FoodEnum.exclude(foods);\n  expectTypeOf<typeof EmptyFoodEnum>().toEqualTypeOf<z.ZodEnum<{}>>();\n  expectTypeOf<z.infer<typeof EmptyFoodEnum>>().toEqualTypeOf<never>();\n});\n\ntest(\"error map inheritance\", () => {\n  const foods = [\"Pasta\", \"Pizza\", \"Tacos\", \"Burgers\", \"Salad\"] as const;\n  const FoodEnum = z.enum(foods, { error: () => \"This is not food!\" });\n  const ItalianEnum = FoodEnum.extract([\"Pasta\", \"Pizza\"]);\n\n  const foodsError = FoodEnum.safeParse(\"Cucumbers\");\n  const italianError = ItalianEnum.safeParse(\"Tacos\");\n\n  expect(foodsError.error!.issues[0].message).toEqual(italianError.error!.issues[0].message);\n\n  const UnhealthyEnum = FoodEnum.exclude([\"Salad\"], {\n    error: () => ({ message: \"This is not healthy food!\" }),\n  });\n  const unhealthyError = UnhealthyEnum.safeParse(\"Salad\");\n  if (!unhealthyError.success) {\n    expect(unhealthyError.error.issues[0].message).toEqual(\"This is not healthy food!\");\n  }\n});\n\ntest(\"readonly in ZodEnumDef\", () => {\n  type _a = z.ZodEnum<{ readonly a: \"a\"; readonly b: \"b\" }>;\n  type _b = z.ZodEnum<{ a: \"a\"; b: \"b\" }>;\n});\n\ntest(\"enum error message, invalid enum elementstring\", () => {\n  const result = z.enum([\"Tuna\", \"Trout\"]).safeParse(\"Salmon\");\n  expect(result.success).toEqual(false);\n  expect(result.error!.issues.length).toEqual(1);\n\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"invalid_value\",\n        \"values\": [\n          \"Tuna\",\n          \"Trout\"\n        ],\n        \"path\": [],\n        \"message\": \"Invalid option: expected one of \\\\\"Tuna\\\\\"|\\\\\"Trout\\\\\"\"\n      }\n    ]]\n  `);\n});\n\ntest(\"enum error message, invalid type\", () => {\n  const result = z.enum([\"Tuna\", \"Trout\"]).safeParse(12);\n  expect(result.success).toEqual(false);\n  expect(result.error!.issues.length).toEqual(1);\n  // expect(result.error!.issues[0].message).toEqual('Invalid input: expected one of \"Tuna\"|\"Trout\"');\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"invalid_value\",\n        \"values\": [\n          \"Tuna\",\n          \"Trout\"\n        ],\n        \"path\": [],\n        \"message\": \"Invalid option: expected one of \\\\\"Tuna\\\\\"|\\\\\"Trout\\\\\"\"\n      }\n    ]]\n  `);\n});\n\ntest(\"nativeEnum default error message\", () => {\n  enum Fish {\n    Tuna = \"Tuna\",\n    Trout = \"Trout\",\n  }\n  const result = z.nativeEnum(Fish).safeParse(\"Salmon\");\n  expect(result.success).toEqual(false);\n  expect(result.error!.issues.length).toEqual(1);\n  // expect(result.error!.issues[0].message).toEqual('Invalid input: expected one of \"Tuna\"|\"Trout\"');\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"invalid_value\",\n        \"values\": [\n          \"Tuna\",\n          \"Trout\"\n        ],\n        \"path\": [],\n        \"message\": \"Invalid option: expected one of \\\\\"Tuna\\\\\"|\\\\\"Trout\\\\\"\"\n      }\n    ]]\n  `);\n});\n\ntest(\"enum with message returns the custom error message\", () => {\n  const schema = z.enum([\"apple\", \"banana\"], {\n    message: \"the value provided is invalid\",\n  });\n\n  const result1 = schema.safeParse(\"berries\");\n  expect(result1.success).toEqual(false);\n  if (!result1.success) {\n    expect(result1.error.issues[0].message).toEqual(\"the value provided is invalid\");\n  }\n\n  const result2 = schema.safeParse(undefined);\n  expect(result2.success).toEqual(false);\n  if (!result2.success) {\n    expect(result2.error.issues[0].message).toEqual(\"the value provided is invalid\");\n  }\n\n  const result3 = schema.safeParse(\"banana\");\n  expect(result3.success).toEqual(true);\n\n  const result4 = schema.safeParse(null);\n  expect(result4.success).toEqual(false);\n  if (!result4.success) {\n    expect(result4.error.issues[0].message).toEqual(\"the value provided is invalid\");\n  }\n});\n\ntest(\"enum with diagonal keys\", () => {\n  const schema_02 = z.enum({\n    A: 1,\n    B: \"A\",\n  });\n\n  expect(schema_02.safeParse(\"A\")).toMatchObject({ success: true });\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/enum.test.ts",
        "start": 1,
        "end": 285,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 285,
          "column": 2,
          "position": 2708
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/enum.test.ts",
        "start": 1,
        "end": 285,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 285,
          "column": 2,
          "position": 2708
        }
      }
    },
    {
      "format": "typescript",
      "lines": 619,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\ntest(\"_values\", () => {\n  expect(z.string()._zod.values).toEqual(undefined);\n  expect(z.enum([\"a\", \"b\"])._zod.values).toEqual(new Set([\"a\", \"b\"]));\n  expect(z.nativeEnum({ a: \"A\", b: \"B\" })._zod.values).toEqual(new Set([\"A\", \"B\"]));\n  expect(z.literal(\"test\")._zod.values).toEqual(new Set([\"test\"]));\n  expect(z.literal(123)._zod.values).toEqual(new Set([123]));\n  expect(z.literal(true)._zod.values).toEqual(new Set([true]));\n  expect(z.literal(BigInt(123))._zod.values).toEqual(new Set([BigInt(123)]));\n  expect(z.undefined()._zod.values).toEqual(new Set([undefined]));\n  expect(z.null()._zod.values).toEqual(new Set([null]));\n\n  const t = z.literal(\"test\");\n  expect(t.optional()._zod.values).toEqual(new Set([\"test\", undefined]));\n  expect(t.nullable()._zod.values).toEqual(new Set([\"test\", null]));\n  expect(t.default(\"test\")._zod.values).toEqual(new Set([\"test\"]));\n  expect(t.catch(\"test\")._zod.values).toEqual(new Set([\"test\"]));\n\n  const pre = z.preprocess((val) => String(val), z.string()).pipe(z.literal(\"test\"));\n  expect(pre._zod.values).toEqual(undefined);\n\n  const post = z.literal(\"test\").transform((_) => Math.random());\n  expect(post._zod.values).toEqual(new Set([\"test\"]));\n\n  // Test that readonly literals pass through their values property\n  expect(z.literal(\"test\").readonly()._zod.values).toEqual(new Set([\"test\"]));\n});\n\ntest(\"valid parse - object\", () => {\n  expect(\n    z\n      .discriminatedUnion(\"type\", [\n        z.object({ type: z.literal(\"a\"), a: z.string() }),\n        z.object({ type: z.literal(\"b\"), b: z.string() }),\n      ])\n      .parse({ type: \"a\", a: \"abc\" })\n  ).toEqual({ type: \"a\", a: \"abc\" });\n});\n\ntest(\"valid - include discriminator key (deprecated)\", () => {\n  expect(\n    z\n      .discriminatedUnion(\"type\", [\n        z.object({ type: z.literal(\"a\"), a: z.string() }),\n        z.object({ type: z.literal(\"b\"), b: z.string() }),\n      ])\n      .parse({ type: \"a\", a: \"abc\" })\n  ).toEqual({ type: \"a\", a: \"abc\" });\n});\n\ntest(\"valid - optional discriminator (object)\", () => {\n  const schema = z.discriminatedUnion(\"type\", [\n    z.object({ type: z.literal(\"a\").optional(), a: z.string() }),\n    z.object({ type: z.literal(\"b\"), b: z.string() }),\n  ]);\n  expect(schema.parse({ type: \"a\", a: \"abc\" })).toEqual({ type: \"a\", a: \"abc\" });\n  expect(schema.parse({ a: \"abc\" })).toEqual({ a: \"abc\" });\n});\n\ntest(\"valid - discriminator value of various primitive types\", () => {\n  const schema = z.discriminatedUnion(\"type\", [\n    z.object({ type: z.literal(\"1\"), val: z.string() }),\n    z.object({ type: z.literal(1), val: z.string() }),\n    z.object({ type: z.literal(BigInt(1)), val: z.string() }),\n    z.object({ type: z.literal(\"true\"), val: z.string() }),\n    z.object({ type: z.literal(true), val: z.string() }),\n    z.object({ type: z.literal(\"null\"), val: z.string() }),\n    z.object({ type: z.null(), val: z.string() }),\n    z.object({ type: z.literal(\"undefined\"), val: z.string() }),\n    z.object({ type: z.undefined(), val: z.string() }),\n  ]);\n\n  expect(schema.parse({ type: \"1\", val: \"val\" })).toEqual({ type: \"1\", val: \"val\" });\n  expect(schema.parse({ type: 1, val: \"val\" })).toEqual({ type: 1, val: \"val\" });\n  expect(schema.parse({ type: BigInt(1), val: \"val\" })).toEqual({\n    type: BigInt(1),\n    val: \"val\",\n  });\n  expect(schema.parse({ type: \"true\", val: \"val\" })).toEqual({\n    type: \"true\",\n    val: \"val\",\n  });\n  expect(schema.parse({ type: true, val: \"val\" })).toEqual({\n    type: true,\n    val: \"val\",\n  });\n  expect(schema.parse({ type: \"null\", val: \"val\" })).toEqual({\n    type: \"null\",\n    val: \"val\",\n  });\n  expect(schema.parse({ type: null, val: \"val\" })).toEqual({\n    type: null,\n    val: \"val\",\n  });\n  expect(schema.parse({ type: \"undefined\", val: \"val\" })).toEqual({\n    type: \"undefined\",\n    val: \"val\",\n  });\n  expect(schema.parse({ type: undefined, val: \"val\" })).toEqual({\n    type: undefined,\n    val: \"val\",\n  });\n\n  const fail = schema.safeParse({\n    type: \"not_a_key\",\n    val: \"val\",\n  });\n  expect(fail.error).toBeInstanceOf(z.ZodError);\n});\n\ntest(\"invalid - null\", () => {\n  try {\n    z.discriminatedUnion(\"type\", [\n      z.object({ type: z.literal(\"a\"), a: z.string() }),\n      z.object({ type: z.literal(\"b\"), b: z.string() }),\n    ]).parse(null);\n    throw new Error();\n  } catch (e: any) {\n    // [\n    //   {\n    //     code: z.ZodIssueCode.invalid_type,\n    //     expected: z.ZodParsedType.object,\n    //     input: null,\n    //     message: \"Expected object, received null\",\n    //     received: z.ZodParsedType.null,\n    //     path: [],\n    //   },\n    // ];\n    expect(e.issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"invalid_type\",\n          \"expected\": \"object\",\n          \"message\": \"Invalid input: expected object, received null\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"invalid discriminator value\", () => {\n  const result = z\n    .discriminatedUnion(\"type\", [\n      z.object({ type: z.literal(\"a\"), a: z.string() }),\n      z.object({ type: z.literal(\"b\"), b: z.string() }),\n    ])\n    .safeParse({ type: \"x\", a: \"abc\" });\n\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"invalid_union\",\n        \"errors\": [],\n        \"note\": \"No matching discriminator\",\n        \"path\": [\n          \"type\"\n        ],\n        \"message\": \"Invalid input\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"invalid discriminator value - unionFallback\", () => {\n  const result = z\n    .discriminatedUnion(\n      \"type\",\n      [z.object({ type: z.literal(\"a\"), a: z.string() }), z.object({ type: z.literal(\"b\"), b: z.string() })],\n      { unionFallback: true }\n    )\n    .safeParse({ type: \"x\", a: \"abc\" });\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"invalid_union\",\n        \"errors\": [\n          [\n            {\n              \"code\": \"invalid_value\",\n              \"values\": [\n                \"a\"\n              ],\n              \"path\": [\n                \"type\"\n              ],\n              \"message\": \"Invalid input: expected \\\\\"a\\\\\"\"\n            }\n          ],\n          [\n            {\n              \"code\": \"invalid_value\",\n              \"values\": [\n                \"b\"\n              ],\n              \"path\": [\n                \"type\"\n              ],\n              \"message\": \"Invalid input: expected \\\\\"b\\\\\"\"\n            },\n            {\n              \"expected\": \"string\",\n              \"code\": \"invalid_type\",\n              \"path\": [\n                \"b\"\n              ],\n              \"message\": \"Invalid input: expected string, received undefined\"\n            }\n          ]\n        ],\n        \"path\": [],\n        \"message\": \"Invalid input\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"valid discriminator value, invalid data\", () => {\n  const result = z\n    .discriminatedUnion(\"type\", [\n      z.object({ type: z.literal(\"a\"), a: z.string() }),\n      z.object({ type: z.literal(\"b\"), b: z.string() }),\n    ])\n    .safeParse({ type: \"a\", b: \"abc\" });\n\n  // [\n  //   {\n  //     code: z.ZodIssueCode.invalid_type,\n  //     expected: z.ZodParsedType.string,\n  //     message: \"Required\",\n  //     path: [\"a\"],\n  //     received: z.ZodParsedType.undefined,\n  //   },\n  // ];\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"a\"\n        ],\n        \"message\": \"Invalid input: expected string, received undefined\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"wrong schema - missing discriminator\", () => {\n  try {\n    z.discriminatedUnion(\"type\", [\n      z.object({ type: z.literal(\"a\"), a: z.string() }),\n      z.object({ b: z.string() }) as any,\n    ])._zod.propValues;\n    throw new Error();\n  } catch (e: any) {\n    expect(e.message.includes(\"Invalid discriminated union option\")).toBe(true);\n  }\n});\n\n// removed to account for unions of unions\n// test(\"wrong schema - duplicate discriminator values\", () => {\n//   try {\n//     z.discriminatedUnion(\"type\",[\n//       z.object({ type: z.literal(\"a\"), a: z.string() }),\n//       z.object({ type: z.literal(\"a\"), b: z.string() }),\n//     ]);\n//     throw new Error();\n//   } catch (e: any) {\n//     expect(e.message.includes(\"Duplicate discriminator value\")).toEqual(true);\n//   }\n// });\n\ntest(\"async - valid\", async () => {\n  const schema = await z.discriminatedUnion(\"type\", [\n    z.object({\n      type: z.literal(\"a\"),\n      a: z\n        .string()\n        .refine(async () => true)\n        .transform(async (val) => Number(val)),\n    }),\n    z.object({\n      type: z.literal(\"b\"),\n      b: z.string(),\n    }),\n  ]);\n  const data = { type: \"a\", a: \"1\" };\n  const result = await schema.safeParseAsync(data);\n  expect(result.data).toEqual({ type: \"a\", a: 1 });\n});\n\ntest(\"async - invalid\", async () => {\n  // try {\n  const a = z.discriminatedUnion(\"type\", [\n    z.object({\n      type: z.literal(\"a\"),\n      a: z\n        .string()\n        .refine(async () => true)\n        .transform(async (val) => val),\n    }),\n    z.object({\n      type: z.literal(\"b\"),\n      b: z.string(),\n    }),\n  ]);\n  const result = await a.safeParseAsync({ type: \"a\", a: 1 });\n\n  // expect(JSON.parse(e.message)).toEqual([\n  //   {\n  //     code: \"invalid_type\",\n  //     expected: \"string\",\n  //     input: 1,\n  //     received: \"number\",\n  //     path: [\"a\"],\n  //     message: \"Expected string, received number\",\n  //   },\n  // ]);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"a\"\n        ],\n        \"message\": \"Invalid input: expected string, received number\"\n      }\n    ]]\n  `);\n});\n\ntest(\"valid - literals with .default or .pipe\", () => {\n  const schema = z.discriminatedUnion(\"type\", [\n    z.object({\n      type: z.literal(\"foo\").default(\"foo\"),\n      a: z.string(),\n    }),\n    z.object({\n      type: z.literal(\"custom\"),\n      method: z.string(),\n    }),\n    z.object({\n      type: z.literal(\"bar\").transform((val) => val),\n      c: z.string(),\n    }),\n  ]);\n  expect(schema.parse({ type: \"foo\", a: \"foo\" })).toEqual({\n    type: \"foo\",\n    a: \"foo\",\n  });\n});\n\ntest(\"enum and nativeEnum\", () => {\n  enum MyEnum {\n    d = 0,\n    e = \"e\",\n  }\n\n  const schema = z.discriminatedUnion(\"key\", [\n    z.object({\n      key: z.literal(\"a\"),\n      // Add other properties specific to this option\n    }),\n    z.object({\n      key: z.enum([\"b\", \"c\"]),\n      // Add other properties specific to this option\n    }),\n    z.object({\n      key: z.nativeEnum(MyEnum),\n      // Add other properties specific to this option\n    }),\n  ]);\n\n  type schema = z.infer<typeof schema>;\n  expectTypeOf<schema>().toEqualTypeOf<{ key: \"a\" } | { key: \"b\" | \"c\" } | { key: MyEnum.d | MyEnum.e }>();\n\n  schema.parse({ key: \"a\" });\n  schema.parse({ key: \"b\" });\n  schema.parse({ key: \"c\" });\n  schema.parse({ key: MyEnum.d });\n  schema.parse({ key: MyEnum.e });\n  schema.parse({ key: \"e\" });\n});\n\ntest(\"branded\", () => {\n  const schema = z.discriminatedUnion(\"key\", [\n    z.object({\n      key: z.literal(\"a\"),\n      // Add other properties specific to this option\n    }),\n    z.object({\n      key: z.literal(\"b\").brand<\"asdfasdf\">(),\n      // Add other properties specific to this option\n    }),\n  ]);\n\n  type schema = z.infer<typeof schema>;\n  expectTypeOf<schema>().toEqualTypeOf<{ key: \"a\" } | { key: \"b\" & z.core.$brand<\"asdfasdf\"> }>();\n\n  schema.parse({ key: \"a\" });\n  schema.parse({ key: \"b\" });\n  expect(() => {\n    schema.parse({ key: \"c\" });\n  }).toThrow();\n});\n\ntest(\"optional and nullable\", () => {\n  const schema = z.discriminatedUnion(\"key\", [\n    z.object({\n      key: z.literal(\"a\").optional(),\n      a: z.literal(true),\n    }),\n    z.object({\n      key: z.literal(\"b\").nullable(),\n      b: z.literal(true),\n      // Add other properties specific to this option\n    }),\n  ]);\n\n  type schema = z.infer<typeof schema>;\n  expectTypeOf<schema>().toEqualTypeOf<{ key?: \"a\" | undefined; a: true } | { key: \"b\" | null; b: true }>();\n\n  schema.parse({ key: \"a\", a: true });\n  schema.parse({ key: undefined, a: true });\n  schema.parse({ key: \"b\", b: true });\n  schema.parse({ key: null, b: true });\n  expect(() => {\n    schema.parse({ key: null, a: true });\n  }).toThrow();\n  expect(() => {\n    schema.parse({ key: \"b\", a: true });\n  }).toThrow();\n\n  const value = schema.parse({ key: null, b: true });\n\n  if (!(\"key\" in value)) value.a;\n  if (value.key === undefined) value.a;\n  if (value.key === \"a\") value.a;\n  if (value.key === \"b\") value.b;\n  if (value.key === null) value.b;\n});\n\ntest(\"multiple discriminators\", () => {\n  const FreeConfig = z.object({\n    type: z.literal(\"free\"),\n    min_cents: z.null(),\n  });\n\n  // console.log(FreeConfig.shape.type);\n  const PricedConfig = z.object({\n    type: z.literal(\"fiat-price\"),\n    // min_cents: z.int().nullable(),\n    min_cents: z.null(),\n  });\n\n  const Config = z.discriminatedUnion(\"type\", [FreeConfig, PricedConfig]);\n\n  Config.parse({\n    min_cents: null,\n    type: \"fiat-price\",\n    name: \"Standard\",\n  });\n\n  expect(() => {\n    Config.parse({\n      min_cents: null,\n      type: \"not real\",\n      name: \"Standard\",\n    });\n  }).toThrow();\n});\n\ntest(\"single element union\", () => {\n  const schema = z.object({\n    a: z.literal(\"discKey\"),\n    b: z.enum([\"apple\", \"banana\"]),\n    c: z.object({ id: z.string() }),\n  });\n\n  const input = {\n    a: \"discKey\",\n    b: \"apple\",\n    c: {}, // Invalid, as schema requires `id` property\n  };\n\n  // Validation must fail here, but it doesn't\n\n  const u = z.discriminatedUnion(\"a\", [schema]);\n  const result = u.safeParse(input);\n  expect(result).toMatchObject({ success: false });\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"c\",\n          \"id\"\n        ],\n        \"message\": \"Invalid input: expected string, received undefined\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n\n  expect(u.options.length).toEqual(1);\n});\n\ntest(\"nested discriminated unions\", () => {\n  const BaseError = z.object({ status: z.literal(\"failed\"), message: z.string() });\n  const MyErrors = z.discriminatedUnion(\"code\", [\n    BaseError.extend({ code: z.literal(400) }),\n    BaseError.extend({ code: z.literal(401) }),\n    BaseError.extend({ code: z.literal(500) }),\n  ]);\n\n  const MyResult = z.discriminatedUnion(\"status\", [\n    z.object({ status: z.literal(\"success\"), data: z.string() }),\n    MyErrors,\n  ]);\n\n  expect(MyErrors._zod.propValues).toMatchInlineSnapshot(`\n    {\n      \"code\": Set {\n        400,\n        401,\n        500,\n      },\n      \"status\": Set {\n        \"failed\",\n      },\n    }\n  `);\n  expect(MyResult._zod.propValues).toMatchInlineSnapshot(`\n    {\n      \"code\": Set {\n        400,\n        401,\n        500,\n      },\n      \"status\": Set {\n        \"success\",\n        \"failed\",\n      },\n    }\n  `);\n\n  const result = MyResult.parse({ status: \"success\", data: \"hello\" });\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"data\": \"hello\",\n      \"status\": \"success\",\n    }\n  `);\n  const result2 = MyResult.parse({ status: \"failed\", code: 400, message: \"bad request\" });\n  expect(result2).toMatchInlineSnapshot(`\n    {\n      \"code\": 400,\n      \"message\": \"bad request\",\n      \"status\": \"failed\",\n    }\n  `);\n  const result3 = MyResult.parse({ status: \"failed\", code: 401, message: \"unauthorized\" });\n  expect(result3).toMatchInlineSnapshot(`\n    {\n      \"code\": 401,\n      \"message\": \"unauthorized\",\n      \"status\": \"failed\",\n    }\n  `);\n  const result4 = MyResult.parse({ status: \"failed\", code: 500, message: \"internal server error\" });\n  expect(result4).toMatchInlineSnapshot(`\n    {\n      \"code\": 500,\n      \"message\": \"internal server error\",\n      \"status\": \"failed\",\n    }\n  `);\n});\n\ntest(\"readonly literal discriminator\", () => {\n  const discUnion = z.discriminatedUnion(\"type\", [\n    z.object({ type: z.literal(\"a\").readonly(), a: z.string() }),\n    z.object({ type: z.literal(\"b\"), b: z.number() }),\n  ]);\n\n  // Test that both discriminator values are correctly included in propValues\n  const propValues = discUnion._zod.propValues;\n  expect(propValues?.type?.has(\"a\")).toBe(true);\n  expect(propValues?.type?.has(\"b\")).toBe(true);\n\n  // Test that the discriminated union works correctly\n  const result1 = discUnion.parse({ type: \"a\", a: \"hello\" });\n  expect(result1).toEqual({ type: \"a\", a: \"hello\" });\n\n  const result2 = discUnion.parse({ type: \"b\", b: 42 });\n  expect(result2).toEqual({ type: \"b\", b: 42 });\n\n  // Test that invalid discriminator values are rejected\n  expect(() => {\n    discUnion.parse({ type: \"c\", a: \"hello\" });\n  }).toThrow();\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/discriminated-unions.test.ts",
        "start": 1,
        "end": 619,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 619,
          "column": 2,
          "position": 5470
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/discriminated-unions.test.ts",
        "start": 1,
        "end": 619,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 619,
          "column": 2,
          "position": 5470
        }
      }
    },
    {
      "format": "typescript",
      "lines": 32,
      "fragment": "import { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\nconst description = \"a description\";\n\n// test(\"passing `description` to schema should add a description\", () => {\n//   expect(z.string({ description }).description).toEqual(description);\n//   expect(z.number({ description }).description).toEqual(description);\n//   expect(z.boolean({ description }).description).toEqual(description);\n// });\n\ntest(\".describe\", () => {\n  expect(z.string().describe(description).description).toEqual(description);\n  expect(z.number().describe(description).description).toEqual(description);\n  expect(z.boolean().describe(description).description).toEqual(description);\n});\n\ntest(\"adding description with z.globalRegistry\", () => {\n  const schema = z.string();\n  z.core.globalRegistry.add(schema, { description });\n  z.core.globalRegistry.get(schema);\n  expect(schema.description).toEqual(description);\n});\n\n// in Zod 4 descriptions are not inherited\n// test(\"description should carry over to chained schemas\", () => {\n//   const schema = z.string().describe(description);\n//   expect(schema.description).toEqual(description);\n//   expect(schema.optional().description).toEqual(description);\n//   expect(schema.optional().nullable().default(\"default\").description).toEqual(description);\n// });",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/description.test.ts",
        "start": 1,
        "end": 32,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 32,
          "column": 7,
          "position": 228
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/description.test.ts",
        "start": 1,
        "end": 32,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 32,
          "column": 7,
          "position": 228
        }
      }
    },
    {
      "format": "typescript",
      "lines": 313,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport { z } from \"zod/v4\";\n\ntest(\"basic defaults\", () => {\n  expect(z.string().default(\"default\").parse(undefined)).toBe(\"default\");\n});\n\ntest(\"default with optional\", () => {\n  const schema = z.string().optional().default(\"default\");\n  expect(schema.parse(undefined)).toBe(\"default\");\n  expect(schema.unwrap().parse(undefined)).toBe(undefined);\n});\n\ntest(\"default with transform\", () => {\n  const stringWithDefault = z\n    .string()\n    .transform((val) => val.toUpperCase())\n    .default(\"default\");\n  expect(stringWithDefault.parse(undefined)).toBe(\"default\");\n  expect(stringWithDefault).toBeInstanceOf(z.ZodDefault);\n  expect(stringWithDefault.unwrap()).toBeInstanceOf(z.ZodPipe);\n  expect(stringWithDefault.unwrap().in).toBeInstanceOf(z.ZodString);\n  expect(stringWithDefault.unwrap().out).toBeInstanceOf(z.ZodTransform);\n\n  type inp = z.input<typeof stringWithDefault>;\n  expectTypeOf<inp>().toEqualTypeOf<string | undefined>();\n  type out = z.output<typeof stringWithDefault>;\n  expectTypeOf<out>().toEqualTypeOf<string>();\n});\n\ntest(\"default on existing optional\", () => {\n  const stringWithDefault = z.string().optional().default(\"asdf\");\n  expect(stringWithDefault.parse(undefined)).toBe(\"asdf\");\n  expect(stringWithDefault).toBeInstanceOf(z.ZodDefault);\n  expect(stringWithDefault.unwrap()).toBeInstanceOf(z.ZodOptional);\n  expect(stringWithDefault.unwrap().unwrap()).toBeInstanceOf(z.ZodString);\n\n  type inp = z.input<typeof stringWithDefault>;\n  expectTypeOf<inp>().toEqualTypeOf<string | undefined>();\n  type out = z.output<typeof stringWithDefault>;\n  expectTypeOf<out>().toEqualTypeOf<string>();\n});\n\ntest(\"optional on default\", () => {\n  const stringWithDefault = z.string().default(\"asdf\").optional();\n\n  type inp = z.input<typeof stringWithDefault>;\n  expectTypeOf<inp>().toEqualTypeOf<string | undefined>();\n  type out = z.output<typeof stringWithDefault>;\n  expectTypeOf<out>().toEqualTypeOf<string | undefined>();\n\n  expect(stringWithDefault.parse(undefined)).toBe(\"asdf\");\n});\n\n// test(\"complex chain example\", () => {\n//   const complex = z\n//     .string()\n//     .default(\"asdf\")\n//     .transform((val) => val.toUpperCase())\n//     .default(\"qwer\")\n//     .unwrap()\n//     .optional()\n//     .default(\"asdfasdf\");\n\n//   expect(complex.parse(undefined)).toBe(\"asdfasdf\");\n// });\n\ntest(\"removeDefault\", () => {\n  const stringWithRemovedDefault = z.string().default(\"asdf\").removeDefault();\n\n  type out = z.output<typeof stringWithRemovedDefault>;\n  expectTypeOf<out>().toEqualTypeOf<string>();\n});\n\ntest(\"apply default at output\", () => {\n  const schema = z\n    .string()\n    .transform((_) => (Math.random() > 0 ? undefined : _))\n    .default(\"asdf\");\n  expect(schema.parse(\"\")).toEqual(\"asdf\");\n});\n\ntest(\"nested\", () => {\n  const inner = z.string().default(\"asdf\");\n  const outer = z.object({ inner }).default({\n    inner: \"qwer\",\n  });\n  type input = z.input<typeof outer>;\n  expectTypeOf<input>().toEqualTypeOf<{ inner?: string | undefined } | undefined>();\n  type out = z.output<typeof outer>;\n  expectTypeOf<out>().toEqualTypeOf<{ inner: string }>();\n  expect(outer.parse(undefined)).toEqual({ inner: \"qwer\" });\n  expect(outer.parse({})).toEqual({ inner: \"asdf\" });\n  expect(outer.parse({ inner: undefined })).toEqual({ inner: \"asdf\" });\n});\n\ntest(\"chained defaults\", () => {\n  const stringWithDefault = z.string().default(\"inner\").default(\"outer\");\n  const result = stringWithDefault.parse(undefined);\n  expect(result).toEqual(\"outer\");\n});\n\ntest(\"object optionality\", () => {\n  const schema = z.object({\n    hi: z.string().default(\"hi\"),\n  });\n  type schemaInput = z.input<typeof schema>;\n  type schemaOutput = z.output<typeof schema>;\n  expectTypeOf<schemaInput>().toEqualTypeOf<{ hi?: string | undefined }>();\n  expectTypeOf<schemaOutput>().toEqualTypeOf<{ hi: string }>();\n  expect(schema.parse({})).toEqual({\n    hi: \"hi\",\n  });\n});\n\ntest(\"nested prefault/default\", () => {\n  const a = z\n    .string()\n    .default(\"a\")\n    .refine((val) => val.startsWith(\"a\"));\n  const b = z\n    .string()\n    .refine((val) => val.startsWith(\"b\"))\n    .default(\"b\");\n  const c = z\n    .string()\n    .prefault(\"c\")\n    .refine((val) => val.startsWith(\"c\"));\n  const d = z\n    .string()\n    .refine((val) => val.startsWith(\"d\"))\n    .prefault(\"d\");\n\n  const obj = z.object({\n    a,\n    b,\n    c,\n    d,\n  });\n\n  expect(obj.safeParse({ a: \"a1\", b: \"b1\", c: \"c1\", d: \"d1\" })).toMatchInlineSnapshot(`\n    {\n      \"data\": {\n        \"a\": \"a1\",\n        \"b\": \"b1\",\n        \"c\": \"c1\",\n        \"d\": \"d1\",\n      },\n      \"success\": true,\n    }\n  `);\n\n  expect(obj.safeParse({ a: \"f\", b: \"f\", c: \"f\", d: \"f\" })).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [\n          \"a\"\n        ],\n        \"message\": \"Invalid input\"\n      },\n      {\n        \"code\": \"custom\",\n        \"path\": [\n          \"b\"\n        ],\n        \"message\": \"Invalid input\"\n      },\n      {\n        \"code\": \"custom\",\n        \"path\": [\n          \"c\"\n        ],\n        \"message\": \"Invalid input\"\n      },\n      {\n        \"code\": \"custom\",\n        \"path\": [\n          \"d\"\n        ],\n        \"message\": \"Invalid input\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n\n  expect(obj.safeParse({})).toMatchInlineSnapshot(`\n    {\n      \"data\": {\n        \"a\": \"a\",\n        \"b\": \"b\",\n        \"c\": \"c\",\n        \"d\": \"d\",\n      },\n      \"success\": true,\n    }\n  `);\n\n  expect(obj.safeParse({ a: undefined, b: undefined, c: undefined, d: undefined })).toMatchInlineSnapshot(`\n    {\n      \"data\": {\n        \"a\": \"a\",\n        \"b\": \"b\",\n        \"c\": \"c\",\n        \"d\": \"d\",\n      },\n      \"success\": true,\n    }\n  `);\n\n  const obj2 = z.object({\n    a: a.optional(),\n    b: b.optional(),\n    c: c.optional(),\n    d: d.optional(),\n  });\n  expect(obj2.safeParse({ a: undefined, b: undefined, c: undefined, d: undefined })).toMatchInlineSnapshot(`\n    {\n      \"data\": {\n        \"a\": \"a\",\n        \"b\": \"b\",\n        \"c\": \"c\",\n        \"d\": \"d\",\n      },\n      \"success\": true,\n    }\n  `);\n\n  expect(a.parse(undefined)).toBe(\"a\");\n  expect(b.parse(undefined)).toBe(\"b\");\n  expect(c.parse(undefined)).toBe(\"c\");\n  expect(d.parse(undefined)).toBe(\"d\");\n});\n\ntest(\"failing default\", () => {\n  const a = z\n    .string()\n    .default(\"z\")\n    .refine((val) => val.startsWith(\"a\"));\n  const b = z\n    .string()\n    .refine((val) => val.startsWith(\"b\"))\n    .default(\"z\");\n  const c = z\n    .string()\n    .prefault(\"z\")\n    .refine((val) => val.startsWith(\"c\"));\n  const d = z\n    .string()\n    .refine((val) => val.startsWith(\"d\"))\n    .prefault(\"z\");\n\n  const obj = z.object({\n    a,\n    b,\n    c,\n    d,\n  });\n\n  expect(\n    obj.safeParse({\n      a: undefined,\n      b: undefined,\n      c: undefined,\n      d: undefined,\n    }).error!.issues\n  ).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [\n          \"a\",\n        ],\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [\n          \"c\",\n        ],\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [\n          \"d\",\n        ],\n      },\n    ]\n  `);\n});\n\ntest(\"partial should not clobber defaults\", () => {\n  const objWithDefaults = z.object({\n    a: z.string().default(\"defaultA\"),\n    b: z.string().default(\"defaultB\"),\n    c: z.string().default(\"defaultC\"),\n  });\n\n  const objPartialWithOneRequired = objWithDefaults.partial(); //.required({ a: true });\n\n  const test = objPartialWithOneRequired.parse({});\n  expect(test).toMatchInlineSnapshot(`\n    {\n      \"a\": \"defaultA\",\n      \"b\": \"defaultB\",\n      \"c\": \"defaultC\",\n    }\n  `);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/default.test.ts",
        "start": 1,
        "end": 313,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 313,
          "column": 2,
          "position": 2281
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/default.test.ts",
        "start": 1,
        "end": 313,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 313,
          "column": 2,
          "position": 2281
        }
      }
    },
    {
      "format": "typescript",
      "lines": 296,
      "fragment": "import { checkSync } from \"recheck\";\nimport { expect, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ntest(\"basic datetime parsing\", () => {\n  const datetime = z.string().datetime();\n  datetime.parse(\"1970-01-01T00:00:00.000Z\");\n  datetime.parse(\"2022-10-13T09:52:31.816Z\");\n  datetime.parse(\"2022-10-13T09:52:31.8162314Z\");\n  datetime.parse(\"1970-01-01T00:00:00Z\");\n  datetime.parse(\"2022-10-13T09:52:31Z\");\n  expect(() => datetime.parse(\"\")).toThrow();\n  expect(() => datetime.parse(\"foo\")).toThrow();\n  expect(() => datetime.parse(\"2020-10-14\")).toThrow();\n  expect(() => datetime.parse(\"T18:45:12.123\")).toThrow();\n  expect(() => datetime.parse(\"2020-10-14T17:42:29+00:00\")).toThrow();\n});\n\ntest(\"datetime parsing with precision -1\", () => {\n  const datetimeNoMs = z.string().datetime({ precision: -1, offset: true, local: true });\n  datetimeNoMs.parse(\"1970-01-01T00:00Z\");\n  datetimeNoMs.parse(\"2022-10-13T09:52Z\");\n  datetimeNoMs.parse(\"2022-10-13T09:52+02:00\");\n\n  datetimeNoMs.parse(\"2022-10-13T09:52\");\n  expect(() => datetimeNoMs.parse(\"tuna\")).toThrow();\n  expect(() => datetimeNoMs.parse(\"2022-10-13T09:52+02\")).toThrow();\n  expect(() => datetimeNoMs.parse(\"1970-01-01T00:00:00.000Z\")).toThrow();\n  expect(() => datetimeNoMs.parse(\"1970-01-01T00:00:00.Z\")).toThrow();\n  expect(() => datetimeNoMs.parse(\"2022-10-13T09:52:31.816Z\")).toThrow();\n});\n\ntest(\"datetime parsing with precision 0\", () => {\n  const datetimeNoMs = z.string().datetime({ precision: 0 });\n  datetimeNoMs.parse(\"1970-01-01T00:00:00Z\");\n  datetimeNoMs.parse(\"2022-10-13T09:52:31Z\");\n  expect(() => datetimeNoMs.parse(\"tuna\")).toThrow();\n  expect(() => datetimeNoMs.parse(\"1970-01-01T00:00:00.000Z\")).toThrow();\n  expect(() => datetimeNoMs.parse(\"1970-01-01T00:00:00.Z\")).toThrow();\n  expect(() => datetimeNoMs.parse(\"2022-10-13T09:52:31.816Z\")).toThrow();\n});\n\ntest(\"datetime parsing with precision 3\", () => {\n  const datetime3Ms = z.string().datetime({ precision: 3 });\n  datetime3Ms.parse(\"1970-01-01T00:00:00.000Z\");\n  datetime3Ms.parse(\"2022-10-13T09:52:31.123Z\");\n  expect(() => datetime3Ms.parse(\"tuna\")).toThrow();\n  expect(() => datetime3Ms.parse(\"1970-01-01T00:00:00.1Z\")).toThrow();\n  expect(() => datetime3Ms.parse(\"1970-01-01T00:00:00.12Z\")).toThrow();\n  expect(() => datetime3Ms.parse(\"2022-10-13T09:52:31Z\")).toThrow();\n});\n\ntest(\"datetime parsing with offset\", () => {\n  const datetimeOffset = z.string().datetime({ offset: true });\n  datetimeOffset.parse(\"1970-01-01T00:00:00.000Z\");\n  datetimeOffset.parse(\"2022-10-13T09:52:31.816234134Z\");\n  datetimeOffset.parse(\"1970-01-01T00:00:00Z\");\n  datetimeOffset.parse(\"2022-10-13T09:52:31.4Z\");\n  datetimeOffset.parse(\"2020-10-14T17:42:29+00:00\");\n  datetimeOffset.parse(\"2020-10-14T17:42:29+03:15\");\n  expect(() => datetimeOffset.parse(\"2020-10-14T17:42:29+0315\")).toThrow();\n  expect(() => datetimeOffset.parse(\"2020-10-14T17:42:29+03\")).toThrow();\n  expect(() => datetimeOffset.parse(\"tuna\")).toThrow();\n  expect(() => datetimeOffset.parse(\"2022-10-13T09:52:31.Z\")).toThrow();\n});\n\ntest(\"datetime parsing with offset and precision 0\", () => {\n  const datetimeOffsetNoMs = z.string().datetime({ offset: true, precision: 0 });\n  datetimeOffsetNoMs.parse(\"1970-01-01T00:00:00Z\");\n  datetimeOffsetNoMs.parse(\"2022-10-13T09:52:31Z\");\n  datetimeOffsetNoMs.parse(\"2020-10-14T17:42:29+00:00\");\n  expect(() => datetimeOffsetNoMs.parse(\"2020-10-14T17:42:29+0000\")).toThrow();\n  expect(() => datetimeOffsetNoMs.parse(\"2020-10-14T17:42:29+00\")).toThrow();\n  expect(() => datetimeOffsetNoMs.parse(\"tuna\")).toThrow();\n  expect(() => datetimeOffsetNoMs.parse(\"1970-01-01T00:00:00.000Z\")).toThrow();\n  expect(() => datetimeOffsetNoMs.parse(\"1970-01-01T00:00:00.Z\")).toThrow();\n  expect(() => datetimeOffsetNoMs.parse(\"2022-10-13T09:52:31.816Z\")).toThrow();\n  expect(() => datetimeOffsetNoMs.parse(\"2020-10-14T17:42:29.124+00:00\")).toThrow();\n});\n\ntest(\"datetime parsing with offset and precision 4\", () => {\n  const datetimeOffset4Ms = z.string().datetime({ offset: true, precision: 4 });\n  datetimeOffset4Ms.parse(\"1970-01-01T00:00:00.1234Z\");\n  datetimeOffset4Ms.parse(\"2020-10-14T17:42:29.1234+00:00\");\n  expect(() => datetimeOffset4Ms.parse(\"2020-10-14T17:42:29.1234+0000\")).toThrow();\n  expect(() => datetimeOffset4Ms.parse(\"2020-10-14T17:42:29.1234+00\")).toThrow();\n  expect(() => datetimeOffset4Ms.parse(\"tuna\")).toThrow();\n  expect(() => datetimeOffset4Ms.parse(\"1970-01-01T00:00:00.123Z\")).toThrow();\n  expect(() => datetimeOffset4Ms.parse(\"2020-10-14T17:42:29.124+00:00\")).toThrow();\n});\n\ntest(\"datetime offset normalization\", () => {\n  const a = z.iso.datetime({ offset: true });\n\n  expect(a.safeParse(\"2020-10-14T17:42:29+02\")).toMatchObject({ success: false });\n  expect(a.safeParse(\"2020-10-14T17:42:29+0200\")).toMatchObject({ success: false });\n  a.safeParse(\"2020-10-14T17:42:29+02:00\");\n});\n\ntest(\"datetime parsing with local option\", () => {\n  const a = z.string().datetime({ local: true });\n\n  expect(a.safeParse(\"1970-01-01T00:00\")).toMatchObject({ success: true });\n  expect(a.safeParse(\"1970-01-01T00:00:00\")).toMatchObject({ success: true });\n  expect(a.safeParse(\"2022-10-13T09:52:31.816\")).toMatchObject({ success: true });\n  expect(a.safeParse(\"1970-01-01T00:00:00.000\")).toMatchObject({ success: true });\n  expect(a.safeParse(\"1970-01-01T00\")).toMatchObject({ success: false });\n\n  // Should reject timezone indicators and invalid formats\n\n  expect(() => a.parse(\"2022-10-13T09:52:31+00:00\")).toThrow();\n  expect(() => a.parse(\"2022-10-13 09:52:31\")).toThrow();\n  expect(() => a.parse(\"2022-10-13T24:52:31\")).toThrow();\n  expect(() => a.parse(\"2022-10-13T24:52\")).toThrow();\n  expect(() => a.parse(\"2022-10-13T24:52Z\")).toThrow();\n});\n\ntest(\"datetime parsing with local and offset\", () => {\n  const a = z.string().datetime({ local: true, offset: true });\n\n  // expect(a.parse(\"2022-10-13T12:52\")).toEqual(\"2022-10-13T12:52:00\");\n  a.parse(\"2022-10-13T12:52:00\");\n  a.parse(\"2022-10-13T12:52:00Z\");\n  a.parse(\"2022-10-13T12:52Z\");\n  a.parse(\"2022-10-13T12:52\");\n  a.parse(\"2022-10-13T12:52+02:00\");\n  expect(() => a.parse(\"2022-10-13T12:52:00+02\")).toThrow();\n  // expect(() => a.parse(\"2022-10-13T12:52Z\")).toThrow();\n  // expect(() => a.parse(\"2022-10-13T12:52+02:00\")).toThrow();\n});\n\ntest(\"date parsing\", () => {\n  const date = z.string().date();\n  date.parse(\"1970-01-01\");\n  date.parse(\"2022-01-31\");\n  date.parse(\"2022-03-31\");\n  date.parse(\"2022-04-30\");\n  date.parse(\"2022-05-31\");\n  date.parse(\"2022-06-30\");\n  date.parse(\"2022-07-31\");\n  date.parse(\"2022-08-31\");\n  date.parse(\"2022-09-30\");\n  date.parse(\"2022-10-31\");\n  date.parse(\"2022-11-30\");\n  date.parse(\"2022-12-31\");\n\n  date.parse(\"2000-02-29\");\n  date.parse(\"2400-02-29\");\n  expect(() => date.parse(\"2022-02-29\")).toThrow();\n  expect(() => date.parse(\"2100-02-29\")).toThrow();\n  expect(() => date.parse(\"2200-02-29\")).toThrow();\n  expect(() => date.parse(\"2300-02-29\")).toThrow();\n  expect(() => date.parse(\"2500-02-29\")).toThrow();\n\n  expect(() => date.parse(\"\")).toThrow();\n  expect(() => date.parse(\"foo\")).toThrow();\n  expect(() => date.parse(\"200-01-01\")).toThrow();\n  expect(() => date.parse(\"20000-01-01\")).toThrow();\n  expect(() => date.parse(\"2000-0-01\")).toThrow();\n  expect(() => date.parse(\"2000-011-01\")).toThrow();\n  expect(() => date.parse(\"2000-01-0\")).toThrow();\n  expect(() => date.parse(\"2000-01-011\")).toThrow();\n  expect(() => date.parse(\"2000/01/01\")).toThrow();\n  expect(() => date.parse(\"01-01-2022\")).toThrow();\n  expect(() => date.parse(\"01/01/2022\")).toThrow();\n  expect(() => date.parse(\"2000-01-01 00:00:00Z\")).toThrow();\n  expect(() => date.parse(\"2020-10-14T17:42:29+00:00\")).toThrow();\n  expect(() => date.parse(\"2020-10-14T17:42:29Z\")).toThrow();\n  expect(() => date.parse(\"2020-10-14T17:42:29\")).toThrow();\n  expect(() => date.parse(\"2020-10-14T17:42:29.123Z\")).toThrow();\n\n  expect(() => date.parse(\"2000-00-12\")).toThrow();\n  expect(() => date.parse(\"2000-12-00\")).toThrow();\n  expect(() => date.parse(\"2000-01-32\")).toThrow();\n  expect(() => date.parse(\"2000-13-01\")).toThrow();\n  expect(() => date.parse(\"2000-21-01\")).toThrow();\n\n  expect(() => date.parse(\"2000-02-30\")).toThrow();\n  expect(() => date.parse(\"2000-02-31\")).toThrow();\n  expect(() => date.parse(\"2000-04-31\")).toThrow();\n  expect(() => date.parse(\"2000-06-31\")).toThrow();\n  expect(() => date.parse(\"2000-09-31\")).toThrow();\n  expect(() => date.parse(\"2000-11-31\")).toThrow();\n});\n\ntest(\"time parsing\", () => {\n  const time = z.string().time();\n  time.parse(\"00:00:00\");\n  time.parse(\"23:00:00\");\n  time.parse(\"00:59:00\");\n  time.parse(\"00:00:59\");\n  time.parse(\"23:59:59\");\n  time.parse(\"09:52:31\");\n  time.parse(\"23:59:59.9999999\");\n  time.parse(\"00:00\");\n  expect(() => time.parse(\"\")).toThrow();\n  expect(() => time.parse(\"foo\")).toThrow();\n  expect(() => time.parse(\"00:00:00Z\")).toThrow();\n  expect(() => time.parse(\"0:00:00\")).toThrow();\n  expect(() => time.parse(\"00:0:00\")).toThrow();\n  expect(() => time.parse(\"00:00:0\")).toThrow();\n  expect(() => time.parse(\"00:00:00.000+00:00\")).toThrow();\n  expect(() => time.parse(\"24:00:00\")).toThrow();\n  expect(() => time.parse(\"00:60:00\")).toThrow();\n  expect(() => time.parse(\"00:00:60\")).toThrow();\n  expect(() => time.parse(\"24:60:60\")).toThrow();\n\n  const time2 = z.string().time({ precision: 2 });\n  time2.parse(\"00:00:00.00\");\n  time2.parse(\"09:52:31.12\");\n  time2.parse(\"23:59:59.99\");\n  expect(() => time2.parse(\"\")).toThrow();\n  expect(() => time2.parse(\"foo\")).toThrow();\n  expect(() => time2.parse(\"00:00:00\")).toThrow();\n  expect(() => time2.parse(\"00:00:00.00Z\")).toThrow();\n  expect(() => time2.parse(\"00:00:00.0\")).toThrow();\n  expect(() => time2.parse(\"00:00:00.000\")).toThrow();\n  expect(() => time2.parse(\"00:00:00.00+00:00\")).toThrow();\n\n  const time3 = z.string().time({ precision: z.TimePrecision.Minute });\n  time3.parse(\"00:00\");\n  expect(() => time3.parse(\"00:00:00\")).toThrow();\n});\n\ntest(\"duration\", () => {\n  const duration = z.string().duration();\n\n  const validDurations = [\n    \"P3Y6M4DT12H30M5S\",\n    \"P2Y9M3DT12H31M8.001S\",\n    // \"+P3Y6M4DT12H30M5S\",\n    // \"-PT0.001S\",\n    // \"+PT0.001S\",\n    \"PT0,001S\",\n    \"PT12H30M5S\",\n    // \"-P2M1D\",\n    // \"P-2M-1D\",\n    // \"-P5DT10H\",\n    // \"P-5DT-10H\",\n    \"P1Y\",\n    \"P2MT30M\",\n    \"PT6H\",\n    \"P5W\",\n    // \"P0.5Y\",\n    // \"P0,5Y\",\n    // \"P42YT7.004M\",\n  ];\n\n  const invalidDurations = [\n    \"foo bar\",\n    \"\",\n    \" \",\n    \"P\",\n    \"PT\",\n    \"P1Y2MT\",\n    \"T1H\",\n    \"P0.5Y1D\",\n    \"P0,5Y6M\",\n    \"P1YT\",\n    \"P-2M-1D\",\n    \"P-5DT-10H\",\n    \"P1W2D\",\n    \"-P1D\",\n  ];\n\n  for (const val of validDurations) {\n    const result = duration.safeParse(val);\n    if (!result.success) {\n      throw Error(`Valid duration could not be parsed: ${val}`);\n    }\n  }\n\n  for (const val of invalidDurations) {\n    const result = duration.safeParse(val);\n\n    if (result.success) {\n      throw Error(`Invalid duration was successful parsed: ${val}`);\n    }\n\n    expect(result.error.issues[0].message).toEqual(\"Invalid ISO duration\");\n  }\n});\n\ntest(\"redos checker\", () => {\n  const a = z.iso.datetime();\n  const b = z.string().datetime({ offset: true });\n  const c = z.string().datetime({ local: true });\n  const d = z.string().datetime({ local: true, offset: true, precision: 3 });\n  const e = z.string().date();\n  const f = z.string().time();\n  const g = z.string().duration();\n  for (const schema of [a, b, c, d, e, f, g]) {\n    const result = checkSync(schema._zod.pattern.source, \"\");\n    if (result.status !== \"safe\") throw Error(\"ReDoS issue\");\n  }\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/datetime.test.ts",
        "start": 1,
        "end": 296,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 296,
          "column": 2,
          "position": 3809
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/datetime.test.ts",
        "start": 1,
        "end": 296,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 296,
          "column": 2,
          "position": 3809
        }
      }
    },
    {
      "format": "typescript",
      "lines": 31,
      "fragment": "import { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\nconst beforeBenchmarkDate = new Date(2022, 10, 4);\nconst benchmarkDate = new Date(2022, 10, 5);\nconst afterBenchmarkDate = new Date(2022, 10, 6);\n\nconst minCheck = z.date().min(benchmarkDate);\nconst maxCheck = z.date().max(benchmarkDate);\n\ntest(\"passing validations\", () => {\n  minCheck.parse(benchmarkDate);\n  minCheck.parse(afterBenchmarkDate);\n\n  maxCheck.parse(benchmarkDate);\n  maxCheck.parse(beforeBenchmarkDate);\n});\n\ntest(\"failing validations\", () => {\n  expect(() => minCheck.parse(beforeBenchmarkDate)).toThrow();\n  expect(() => maxCheck.parse(afterBenchmarkDate)).toThrow();\n});\n\ntest(\"min max getters\", () => {\n  expect(minCheck.minDate).toEqual(benchmarkDate);\n  expect(minCheck.min(afterBenchmarkDate).minDate).toEqual(afterBenchmarkDate);\n\n  expect(maxCheck.maxDate).toEqual(benchmarkDate);\n  expect(maxCheck.max(beforeBenchmarkDate).maxDate).toEqual(beforeBenchmarkDate);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/date.test.ts",
        "start": 1,
        "end": 31,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 31,
          "column": 2,
          "position": 323
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/date.test.ts",
        "start": 1,
        "end": 31,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 31,
          "column": 2,
          "position": 323
        }
      }
    },
    {
      "format": "typescript",
      "lines": 40,
      "fragment": "import { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\ntest(\"passing validations\", () => {\n  const example1 = z.custom<number>((x) => typeof x === \"number\");\n  example1.parse(1234);\n  expect(() => example1.parse({})).toThrow();\n});\n\ntest(\"string params\", () => {\n  const example1 = z.custom<number>((x) => typeof x !== \"number\", \"customerr\");\n  const result = example1.safeParse(1234);\n  expect(result.success).toEqual(false);\n  expect(JSON.stringify(result.error).includes(\"customerr\")).toEqual(true);\n});\n\ntest(\"instanceof\", () => {\n  const fn = (value: string) => Uint8Array.from(Buffer.from(value, \"base64\"));\n\n  // Argument of type 'ZodCustom<Uint8Array<ArrayBuffer>, unknown>' is not assignable to parameter of type '$ZodType<any, Uint8Array<ArrayBuffer>>'.\n  z.string().transform(fn).pipe(z.instanceof(Uint8Array));\n});\n\ntest(\"non-continuable by default\", () => {\n  const A = z\n    .custom<string>((val) => typeof val === \"string\")\n    .transform((_) => {\n      throw new Error(\"Invalid input\");\n    });\n  expect(A.safeParse(123).error!).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"Invalid input\"\n      }\n    ]]\n  `);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/custom.test.ts",
        "start": 1,
        "end": 40,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 40,
          "column": 2,
          "position": 381
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/custom.test.ts",
        "start": 1,
        "end": 40,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 40,
          "column": 2,
          "position": 381
        }
      }
    },
    {
      "format": "typescript",
      "lines": 352,
      "fragment": "import { expect, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ntest(\"continuability\", () => {\n  /** \n   *  | $ZodGUID\n  | $ZodUUID\n  | $ZodEmail\n  | $ZodURL\n  | $ZodEmoji\n  | $ZodNanoID\n  | $ZodCUID\n  | $ZodCUID2\n  | $ZodULID\n  | $ZodXID\n  | $ZodKSUID\n  | $ZodISODateTime\n  | $ZodISODate\n  | $ZodISOTime\n  | $ZodISODuration\n  | $ZodIPv4\n  | $ZodIPv6\n  | $ZodCIDRv4\n  | $ZodCIDRv6\n  | $ZodBase64\n  | $ZodBase64URL\n  | $ZodE164\n  | $ZodJWT;\n   */\n  expect(\n    z\n      .email()\n      .refine(() => false)\n      .safeParse(\"invalid_value\").error!.issues\n  ).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"email\",\n        \"message\": \"Invalid email address\",\n        \"origin\": \"string\",\n        \"path\": [],\n        \"pattern\": \"/^(?!\\\\.)(?!.*\\\\.\\\\.)([A-Za-z0-9_'+\\\\-\\\\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\\\\-]*\\\\.)+[A-Za-z]{2,}$/\",\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [],\n      },\n    ]\n  `);\n  expect(\n    z\n      .uuid()\n      .refine(() => false)\n      .safeParse(\"invalid_value\").error!.issues\n  ).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"uuid\",\n        \"message\": \"Invalid UUID\",\n        \"origin\": \"string\",\n        \"path\": [],\n        \"pattern\": \"/^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/\",\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [],\n      },\n    ]\n  `);\n  expect(\n    z\n      .url()\n      .refine(() => false)\n      .safeParse(\"invalid_value\").error!.issues\n  ).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"url\",\n        \"message\": \"Invalid URL\",\n        \"path\": [],\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [],\n      },\n    ]\n  `);\n  expect(\n    z\n      .jwt()\n      .refine(() => false)\n      .safeParse(\"invalid_value\").error!.issues\n  ).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"jwt\",\n        \"message\": \"Invalid JWT\",\n        \"path\": [],\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [],\n      },\n    ]\n  `);\n  expect(\n    z\n      .cidrv4()\n      .refine(() => false)\n      .safeParse(\"invalid_value\").error!.issues\n  ).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"cidrv4\",\n        \"message\": \"Invalid IPv4 range\",\n        \"origin\": \"string\",\n        \"path\": [],\n        \"pattern\": \"/^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\\\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\\\/([0-9]|[1-2][0-9]|3[0-2])$/\",\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [],\n      },\n    ]\n  `);\n  expect(\n    z\n      .cidrv6()\n      .refine(() => false)\n      .safeParse(\"invalid_value\").error!.issues\n  ).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"cidrv6\",\n        \"message\": \"Invalid IPv6 range\",\n        \"path\": [],\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [],\n      },\n    ]\n  `);\n  expect(\n    z\n      .ipv4()\n      .refine(() => false)\n      .safeParse(\"invalid_value\").error!.issues\n  ).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"ipv4\",\n        \"message\": \"Invalid IPv4 address\",\n        \"origin\": \"string\",\n        \"path\": [],\n        \"pattern\": \"/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/\",\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [],\n      },\n    ]\n  `);\n  expect(\n    z\n      .ipv6()\n      .refine(() => false)\n      .safeParse(\"invalid_value\").error!.issues\n  ).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"ipv6\",\n        \"message\": \"Invalid IPv6 address\",\n        \"path\": [],\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [],\n      },\n    ]\n  `);\n  expect(\n    z\n      .emoji()\n      .refine(() => false)\n      .safeParse(\"invalid_value\").error!.issues\n  ).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"emoji\",\n        \"message\": \"Invalid emoji\",\n        \"origin\": \"string\",\n        \"path\": [],\n        \"pattern\": \"/^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$/u\",\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [],\n      },\n    ]\n  `);\n  expect(\n    z\n      .nanoid()\n      .refine(() => false)\n      .safeParse(\"invalid_value\").error!.issues\n  ).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"nanoid\",\n        \"message\": \"Invalid nanoid\",\n        \"origin\": \"string\",\n        \"path\": [],\n        \"pattern\": \"/^[a-zA-Z0-9_-]{21}$/\",\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [],\n      },\n    ]\n  `);\n  expect(\n    z\n      .cuid()\n      .refine(() => false)\n      .safeParse(\"invalid_value\").error!.issues\n  ).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"cuid\",\n        \"message\": \"Invalid cuid\",\n        \"origin\": \"string\",\n        \"path\": [],\n        \"pattern\": \"/^[cC][^\\\\s-]{8,}$/\",\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [],\n      },\n    ]\n  `);\n  expect(\n    z\n      .cuid2()\n      .refine(() => false)\n      .safeParse(\"invalid_value\").error!.issues\n  ).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"cuid2\",\n        \"message\": \"Invalid cuid2\",\n        \"origin\": \"string\",\n        \"path\": [],\n        \"pattern\": \"/^[0-9a-z]+$/\",\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [],\n      },\n    ]\n  `);\n  expect(\n    z\n      .ulid()\n      .refine(() => false)\n      .safeParse(\"invalid_value\").error!.issues\n  ).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"ulid\",\n        \"message\": \"Invalid ULID\",\n        \"origin\": \"string\",\n        \"path\": [],\n        \"pattern\": \"/^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/\",\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [],\n      },\n    ]\n  `);\n  expect(\n    z\n      .xid()\n      .refine(() => false)\n      .safeParse(\"invalid_value\").error!.issues\n  ).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"xid\",\n        \"message\": \"Invalid XID\",\n        \"origin\": \"string\",\n        \"path\": [],\n        \"pattern\": \"/^[0-9a-vA-V]{20}$/\",\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [],\n      },\n    ]\n  `);\n  expect(\n    z\n      .ksuid()\n      .refine(() => false)\n      .safeParse(\"invalid_value\").error!.issues\n  ).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"ksuid\",\n        \"message\": \"Invalid KSUID\",\n        \"origin\": \"string\",\n        \"path\": [],\n        \"pattern\": \"/^[A-Za-z0-9]{27}$/\",\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [],\n      },\n    ]\n  `);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/continuability.test.ts",
        "start": 1,
        "end": 352,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 352,
          "column": 2,
          "position": 737
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/continuability.test.ts",
        "start": 1,
        "end": 352,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 352,
          "column": 2,
          "position": 737
        }
      }
    },
    {
      "format": "typescript",
      "lines": 160,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\ntest(\"string coercion\", () => {\n  const schema = z.coerce.string();\n  expect(schema.parse(\"sup\")).toEqual(\"sup\");\n  expect(schema.parse(\"\")).toEqual(\"\");\n  expect(schema.parse(12)).toEqual(\"12\");\n  expect(schema.parse(0)).toEqual(\"0\");\n  expect(schema.parse(-12)).toEqual(\"-12\");\n  expect(schema.parse(3.14)).toEqual(\"3.14\");\n  expect(schema.parse(BigInt(15))).toEqual(\"15\");\n  expect(schema.parse(Number.NaN)).toEqual(\"NaN\");\n  expect(schema.parse(Number.POSITIVE_INFINITY)).toEqual(\"Infinity\");\n  expect(schema.parse(Number.NEGATIVE_INFINITY)).toEqual(\"-Infinity\");\n  expect(schema.parse(true)).toEqual(\"true\");\n  expect(schema.parse(false)).toEqual(\"false\");\n  expect(schema.parse(null)).toEqual(\"null\");\n  expect(schema.parse(undefined)).toEqual(\"undefined\");\n  expect(schema.parse({ hello: \"world!\" })).toEqual(\"[object Object]\");\n  expect(schema.parse([\"item\", \"another_item\"])).toEqual(\"item,another_item\");\n  expect(schema.parse([])).toEqual(\"\");\n  expect(schema.parse(new Date(\"2022-01-01T00:00:00.000Z\"))).toEqual(new Date(\"2022-01-01T00:00:00.000Z\").toString());\n});\n\ntest(\"number coercion\", () => {\n  const schema = z.coerce.number();\n  expect(schema.parse(\"12\")).toEqual(12);\n  expect(schema.parse(\"0\")).toEqual(0);\n  expect(schema.parse(\"-12\")).toEqual(-12);\n  expect(schema.parse(\"3.14\")).toEqual(3.14);\n  expect(schema.parse(\"\")).toEqual(0);\n  expect(() => schema.parse(\"NOT_A_NUMBER\")).toThrow(); // z.ZodError\n  expect(schema.parse(12)).toEqual(12);\n  expect(schema.parse(0)).toEqual(0);\n  expect(schema.parse(-12)).toEqual(-12);\n  expect(schema.parse(3.14)).toEqual(3.14);\n  expect(schema.parse(BigInt(15))).toEqual(15);\n  expect(() => schema.parse(Number.NaN)).toThrow(); // z.ZodError\n  // expect(schema.parse(Number.POSITIVE_INFINITY)).toEqual(Number.POSITIVE_INFINITY);\n  // expect(schema.parse(Number.NEGATIVE_INFINITY)).toEqual(Number.NEGATIVE_INFINITY);\n  expect(schema.parse(true)).toEqual(1);\n  expect(schema.parse(false)).toEqual(0);\n  expect(schema.parse(null)).toEqual(0);\n  expect(() => schema.parse(undefined)).toThrow(); // z.ZodError\n  expect(() => schema.parse({ hello: \"world!\" })).toThrow(); // z.ZodError\n  expect(() => schema.parse([\"item\", \"another_item\"])).toThrow(); // z.ZodError\n  expect(schema.parse([])).toEqual(0);\n  expect(schema.parse(new Date(1670139203496))).toEqual(1670139203496);\n});\n\ntest(\"boolean coercion\", () => {\n  const schema = z.coerce.boolean();\n  expect(schema.parse(\"true\")).toEqual(true);\n  expect(schema.parse(\"false\")).toEqual(true);\n  expect(schema.parse(\"0\")).toEqual(true);\n  expect(schema.parse(\"1\")).toEqual(true);\n  expect(schema.parse(\"\")).toEqual(false);\n  expect(schema.parse(1)).toEqual(true);\n  expect(schema.parse(0)).toEqual(false);\n  expect(schema.parse(-1)).toEqual(true);\n  expect(schema.parse(3.14)).toEqual(true);\n  expect(schema.parse(BigInt(15))).toEqual(true);\n  expect(schema.parse(Number.NaN)).toEqual(false);\n  expect(schema.parse(Number.POSITIVE_INFINITY)).toEqual(true);\n  expect(schema.parse(Number.NEGATIVE_INFINITY)).toEqual(true);\n  expect(schema.parse(true)).toEqual(true);\n  expect(schema.parse(false)).toEqual(false);\n  expect(schema.parse(null)).toEqual(false);\n  expect(schema.parse(undefined)).toEqual(false);\n  expect(schema.parse({ hello: \"world!\" })).toEqual(true);\n  expect(schema.parse([\"item\", \"another_item\"])).toEqual(true);\n  expect(schema.parse([])).toEqual(true);\n  expect(schema.parse(new Date(1670139203496))).toEqual(true);\n});\n\ntest(\"bigint coercion\", () => {\n  const schema = z.coerce.bigint();\n  expect(schema.parse(\"5\")).toEqual(BigInt(5));\n  expect(schema.parse(\"0\")).toEqual(BigInt(0));\n  expect(schema.parse(\"-5\")).toEqual(BigInt(-5));\n  expect(() => schema.parse(\"3.14\")).toThrow(); // not a z.ZodError!\n  expect(schema.parse(\"\")).toEqual(BigInt(0));\n  expect(() => schema.parse(\"NOT_A_NUMBER\")).toThrow(); // not a z.ZodError!\n  expect(schema.parse(5)).toEqual(BigInt(5));\n  expect(schema.parse(0)).toEqual(BigInt(0));\n  expect(schema.parse(-5)).toEqual(BigInt(-5));\n  expect(() => schema.parse(3.14)).toThrow(); // not a z.ZodError!\n  expect(schema.parse(BigInt(5))).toEqual(BigInt(5));\n  expect(() => schema.parse(Number.NaN)).toThrow(); // not a z.ZodError!\n  expect(() => schema.parse(Number.POSITIVE_INFINITY)).toThrow(); // not a z.ZodError!\n  expect(() => schema.parse(Number.NEGATIVE_INFINITY)).toThrow(); // not a z.ZodError!\n  expect(schema.parse(true)).toEqual(BigInt(1));\n  expect(schema.parse(false)).toEqual(BigInt(0));\n  expect(() => schema.parse(null)).toThrow(); // not a z.ZodError!\n  expect(() => schema.parse(undefined)).toThrow(); // not a z.ZodError!\n  expect(() => schema.parse({ hello: \"world!\" })).toThrow(); // not a z.ZodError!\n  expect(() => schema.parse([\"item\", \"another_item\"])).toThrow(); // not a z.ZodError!\n  expect(schema.parse([])).toEqual(BigInt(0));\n  expect(schema.parse(new Date(1670139203496))).toEqual(BigInt(1670139203496));\n});\n\ntest(\"date coercion\", () => {\n  const schema = z.coerce.date();\n  expect(schema.parse(new Date().toDateString())).toBeInstanceOf(Date);\n  expect(schema.parse(new Date().toISOString())).toBeInstanceOf(Date);\n  expect(schema.parse(new Date().toUTCString())).toBeInstanceOf(Date);\n  expect(schema.parse(\"5\")).toBeInstanceOf(Date);\n  expect(schema.parse(\"2000-01-01\")).toBeInstanceOf(Date);\n  // expect(schema.parse(\"0\")).toBeInstanceOf(Date);\n  // expect(schema.parse(\"-5\")).toBeInstanceOf(Date);\n  // expect(schema.parse(\"3.14\")).toBeInstanceOf(Date);\n  expect(() => schema.parse(\"\")).toThrow(); // z.ZodError\n  expect(() => schema.parse(\"NOT_A_DATE\")).toThrow(); // z.ZodError\n  expect(schema.parse(5)).toBeInstanceOf(Date);\n  expect(schema.parse(0)).toBeInstanceOf(Date);\n  expect(schema.parse(-5)).toBeInstanceOf(Date);\n  expect(schema.parse(3.14)).toBeInstanceOf(Date);\n  expect(() => schema.parse(BigInt(5))).toThrow(); // not a z.ZodError!\n  expect(() => schema.parse(Number.NaN)).toThrow(); // z.ZodError\n  expect(() => schema.parse(Number.POSITIVE_INFINITY)).toThrow(); // z.ZodError\n  expect(() => schema.parse(Number.NEGATIVE_INFINITY)).toThrow(); // z.ZodError\n  expect(schema.parse(true)).toBeInstanceOf(Date);\n  expect(schema.parse(false)).toBeInstanceOf(Date);\n  expect(schema.parse(null)).toBeInstanceOf(Date);\n  expect(() => schema.parse(undefined)).toThrow(); // z.ZodError\n  expect(() => schema.parse({ hello: \"world!\" })).toThrow(); // z.ZodError\n  expect(() => schema.parse([\"item\", \"another_item\"])).toThrow(); // z.ZodError\n  expect(() => schema.parse([])).toThrow(); // z.ZodError\n  expect(schema.parse(new Date())).toBeInstanceOf(Date);\n});\n\n// test(\"template literal coercion\", () => {\n//   const schema = z.coerce\n//     .templateLiteral()\n//     .interpolated(z.number().finite())\n//     .interpolated(\n//       z.enum([\"px\", \"em\", \"rem\", \"vh\", \"vw\", \"vmin\", \"vmax\"]).optional()\n//     );\n//   expect(schema.parse(300)).toEqual(\"300\");\n//   expect(schema.parse(BigInt(300))).toEqual(\"300\");\n//   expect(schema.parse(\"300\")).toEqual(\"300\");\n//   expect(schema.parse(\"300px\")).toEqual(\"300px\");\n//   expect(schema.parse(\"300em\")).toEqual(\"300em\");\n//   expect(schema.parse(\"300rem\")).toEqual(\"300rem\");\n//   expect(schema.parse(\"300vh\")).toEqual(\"300vh\");\n//   expect(schema.parse(\"300vw\")).toEqual(\"300vw\");\n//   expect(schema.parse(\"300vmin\")).toEqual(\"300vmin\");\n//   expect(schema.parse(\"300vmax\")).toEqual(\"300vmax\");\n//   expect(schema.parse([\"300px\"])).toEqual(\"300px\");\n// });\n\ntest(\"override input type\", () => {\n  const a = z.coerce.string<any>();\n  type input = z.input<typeof a>;\n  expectTypeOf<input>().toEqualTypeOf<any>();\n  type output = z.infer<typeof a>;\n  expectTypeOf<output>().toEqualTypeOf<string>();\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/coerce.test.ts",
        "start": 1,
        "end": 160,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 160,
          "column": 2,
          "position": 2478
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/coerce.test.ts",
        "start": 1,
        "end": 160,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 160,
          "column": 2,
          "position": 2478
        }
      }
    },
    {
      "format": "typescript",
      "lines": 252,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport { z } from \"zod/v4\";\nimport type { util } from \"zod/v4/core\";\n\ntest(\"basic catch\", () => {\n  expect(z.string().catch(\"default\").parse(undefined)).toBe(\"default\");\n});\n\ntest(\"catch fn does not run when parsing succeeds\", () => {\n  let isCalled = false;\n  const cb = () => {\n    isCalled = true;\n    return \"asdf\";\n  };\n  expect(z.string().catch(cb).parse(\"test\")).toBe(\"test\");\n  expect(isCalled).toEqual(false);\n});\n\ntest(\"basic catch async\", async () => {\n  const result = await z.string().catch(\"default\").parseAsync(1243);\n  expect(result).toBe(\"default\");\n});\n\ntest(\"catch replace wrong types\", () => {\n  expect(z.string().catch(\"default\").parse(true)).toBe(\"default\");\n  expect(z.string().catch(\"default\").parse(true)).toBe(\"default\");\n  expect(z.string().catch(\"default\").parse(15)).toBe(\"default\");\n  expect(z.string().catch(\"default\").parse([])).toBe(\"default\");\n  expect(z.string().catch(\"default\").parse(new Map())).toBe(\"default\");\n  expect(z.string().catch(\"default\").parse(new Set())).toBe(\"default\");\n  expect(z.string().catch(\"default\").parse({})).toBe(\"default\");\n});\n\ntest(\"catch with transform\", () => {\n  const stringWithDefault = z\n    .string()\n    .transform((val) => val.toUpperCase())\n    .catch(\"default\");\n\n  expect(stringWithDefault.parse(undefined)).toBe(\"default\");\n  expect(stringWithDefault.parse(15)).toBe(\"default\");\n  expect(stringWithDefault).toBeInstanceOf(z.ZodCatch);\n  expect(stringWithDefault.unwrap()).toBeInstanceOf(z.ZodPipe);\n  expect(stringWithDefault.unwrap().in).toBeInstanceOf(z.ZodString);\n  expect(stringWithDefault.unwrap().out).toBeInstanceOf(z.ZodTransform);\n\n  type inp = z.input<typeof stringWithDefault>;\n  expectTypeOf<inp>().toEqualTypeOf<string | util.Whatever>();\n  type out = z.output<typeof stringWithDefault>;\n  expectTypeOf<out>().toEqualTypeOf<string>();\n});\n\ntest(\"catch on existing optional\", () => {\n  const stringWithDefault = z.string().optional().catch(\"asdf\");\n  expect(stringWithDefault.parse(undefined)).toBe(undefined);\n  expect(stringWithDefault.parse(15)).toBe(\"asdf\");\n  expect(stringWithDefault).toBeInstanceOf(z.ZodCatch);\n  expect(stringWithDefault.unwrap()).toBeInstanceOf(z.ZodOptional);\n  expect(stringWithDefault.unwrap().unwrap()).toBeInstanceOf(z.ZodString);\n\n  type inp = z.input<typeof stringWithDefault>;\n  expectTypeOf<inp>().toEqualTypeOf<string | undefined | util.Whatever>();\n  type out = z.output<typeof stringWithDefault>;\n  expectTypeOf<out>().toEqualTypeOf<string | undefined>();\n});\n\ntest(\"optional on catch\", () => {\n  const stringWithDefault = z.string().catch(\"asdf\").optional();\n\n  type inp = z.input<typeof stringWithDefault>;\n  expectTypeOf<inp>().toEqualTypeOf<string | util.Whatever>();\n  type out = z.output<typeof stringWithDefault>;\n  expectTypeOf<out>().toEqualTypeOf<string | undefined>();\n});\n\ntest(\"complex chain example\", () => {\n  const complex = z\n    .string()\n    .catch(\"asdf\")\n    .transform((val) => `${val}!`)\n    .transform((val) => val.toUpperCase())\n    .catch(\"qwer\")\n    .unwrap()\n    .optional()\n    .catch(\"asdfasdf\");\n\n  expect(complex.parse(\"qwer\")).toBe(\"QWER!\");\n  expect(complex.parse(15)).toBe(\"ASDF!\");\n  expect(complex.parse(true)).toBe(\"ASDF!\");\n});\n\ntest(\"removeCatch\", () => {\n  const stringWithRemovedDefault = z.string().catch(\"asdf\").unwrap();\n\n  type out = z.output<typeof stringWithRemovedDefault>;\n  expectTypeOf<out>().toEqualTypeOf<string>();\n});\n\ntest(\"nested\", () => {\n  const inner = z.string().catch(\"asdf\");\n  const outer = z.object({ inner }).catch({\n    inner: \"asdf\",\n  });\n  type input = z.input<typeof outer>;\n  expectTypeOf<input>().toEqualTypeOf<{ inner: string | util.Whatever } | util.Whatever>();\n  type out = z.output<typeof outer>;\n\n  expectTypeOf<out>().toEqualTypeOf<{ inner: string }>();\n  expect(outer.parse(undefined)).toEqual({ inner: \"asdf\" });\n  expect(outer.parse({})).toEqual({ inner: \"asdf\" });\n  expect(outer.parse({ inner: undefined })).toEqual({ inner: \"asdf\" });\n});\n\ntest(\"chained catch\", () => {\n  const stringWithDefault = z.string().catch(\"inner\").catch(\"outer\");\n  const result = stringWithDefault.parse(undefined);\n  expect(result).toEqual(\"inner\");\n  const resultDiff = stringWithDefault.parse(5);\n  expect(resultDiff).toEqual(\"inner\");\n});\n\ntest(\"native enum\", () => {\n  enum Fruits {\n    apple = \"apple\",\n    orange = \"orange\",\n  }\n\n  const schema = z.object({\n    fruit: z.nativeEnum(Fruits).catch(Fruits.apple),\n  });\n\n  expect(schema.parse({})).toEqual({ fruit: Fruits.apple });\n  expect(schema.parse({ fruit: 15 })).toEqual({ fruit: Fruits.apple });\n});\n\ntest(\"enum\", () => {\n  const schema = z.object({\n    fruit: z.enum([\"apple\", \"orange\"]).catch(\"apple\"),\n  });\n\n  expect(schema.parse({})).toEqual({ fruit: \"apple\" });\n  expect(schema.parse({ fruit: true })).toEqual({ fruit: \"apple\" });\n  expect(schema.parse({ fruit: 15 })).toEqual({ fruit: \"apple\" });\n});\n\ntest(\"reported issues with nested usage\", () => {\n  const schema = z.object({\n    string: z.string(),\n    obj: z.object({\n      sub: z.object({\n        lit: z.literal(\"a\"),\n        subCatch: z.number().catch(23),\n      }),\n      midCatch: z.number().catch(42),\n    }),\n    number: z.number().catch(0),\n    bool: z.boolean(),\n  });\n\n  try {\n    schema.parse({\n      string: {},\n      obj: {\n        sub: {\n          lit: \"b\",\n          subCatch: \"24\",\n        },\n        midCatch: 444,\n      },\n      number: \"\",\n      bool: \"yes\",\n    });\n  } catch (error) {\n    const issues = (error as z.ZodError).issues;\n\n    expect(issues.length).toEqual(3);\n    expect(issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"invalid_type\",\n          \"expected\": \"string\",\n          \"message\": \"Invalid input: expected string, received object\",\n          \"path\": [\n            \"string\",\n          ],\n        },\n        {\n          \"code\": \"invalid_value\",\n          \"message\": \"Invalid input: expected \"a\"\",\n          \"path\": [\n            \"obj\",\n            \"sub\",\n            \"lit\",\n          ],\n          \"values\": [\n            \"a\",\n          ],\n        },\n        {\n          \"code\": \"invalid_type\",\n          \"expected\": \"boolean\",\n          \"message\": \"Invalid input: expected boolean, received string\",\n          \"path\": [\n            \"bool\",\n          ],\n        },\n      ]\n    `);\n    // expect(issues[0].message).toMatch(\"string\");\n    // expect(issues[1].message).toMatch(\"literal\");\n    // expect(issues[2].message).toMatch(\"boolean\");\n  }\n});\n\ntest(\"catch error\", () => {\n  const schema = z.object({\n    age: z.number(),\n    name: z.string().catch((ctx) => {\n      ctx.issues;\n      // issues = ctx.issues;\n\n      return \"John Doe\";\n    }),\n  });\n\n  const result = schema.safeParse({\n    age: null,\n    name: null,\n  });\n\n  expect(result.success).toEqual(false);\n  expect(result.error!).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"expected\": \"number\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"age\"\n        ],\n        \"message\": \"Invalid input: expected number, received null\"\n      }\n    ]]\n  `);\n});\n\ntest(\"ctx.input\", () => {\n  const schema = z.string().catch((ctx) => {\n    return String(ctx.input);\n  });\n\n  expect(schema.parse(123)).toEqual(\"123\");\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/catch.test.ts",
        "start": 1,
        "end": 252,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 252,
          "column": 2,
          "position": 2387
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/catch.test.ts",
        "start": 1,
        "end": 252,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 252,
          "column": 2,
          "position": 2387
        }
      }
    },
    {
      "format": "typescript",
      "lines": 63,
      "fragment": "import { expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ntest(\"branded types\", () => {\n  const mySchema = z\n    .object({\n      name: z.string(),\n    })\n    .brand<\"superschema\">();\n\n  // simple branding\n  type MySchema = z.infer<typeof mySchema>;\n\n  expectTypeOf<MySchema>().toEqualTypeOf<{ name: string } & z.$brand<\"superschema\">>();\n\n  const doStuff = (arg: MySchema) => arg;\n  doStuff(mySchema.parse({ name: \"hello there\" }));\n\n  // inheritance\n  const extendedSchema = mySchema.brand<\"subschema\">();\n  type ExtendedSchema = z.infer<typeof extendedSchema>;\n  expectTypeOf<ExtendedSchema>().toEqualTypeOf<{ name: string } & z.BRAND<\"superschema\"> & z.BRAND<\"subschema\">>();\n\n  doStuff(extendedSchema.parse({ name: \"hello again\" }));\n\n  // number branding\n  const numberSchema = z.number().brand<42>();\n  type NumberSchema = z.infer<typeof numberSchema>;\n  expectTypeOf<NumberSchema>().toEqualTypeOf<number & { [z.$brand]: { 42: true } }>();\n\n  // symbol branding\n  const MyBrand: unique symbol = Symbol(\"hello\");\n  type MyBrand = typeof MyBrand;\n  const symbolBrand = z.number().brand<\"sup\">().brand<typeof MyBrand>();\n  type SymbolBrand = z.infer<typeof symbolBrand>;\n  // number & { [z.BRAND]: { sup: true, [MyBrand]: true } }\n  expectTypeOf<SymbolBrand>().toEqualTypeOf<number & z.BRAND<\"sup\"> & z.BRAND<MyBrand>>();\n\n  // keeping brands out of input types\n  const age = z.number().brand<\"age\">();\n\n  type Age = z.infer<typeof age>;\n  type AgeInput = z.input<typeof age>;\n\n  expectTypeOf<AgeInput>().not.toEqualTypeOf<Age>();\n  expectTypeOf<number>().toEqualTypeOf<AgeInput>();\n  expectTypeOf<number & z.BRAND<\"age\">>().toEqualTypeOf<Age>();\n\n  // @ts-expect-error\n  doStuff({ name: \"hello there!\" });\n});\n\ntest(\"$branded\", () => {\n  const a = z.string().brand<\"a\">();\n\n  expectTypeOf<typeof a>().toEqualTypeOf<z.core.$ZodBranded<z.ZodString, \"a\">>();\n});\n\ntest(\"branded record\", () => {\n  const recordWithBrandedNumberKeys = z.record(z.string().brand(\"SomeBrand\"), z.number());\n  type recordWithBrandedNumberKeys = z.infer<typeof recordWithBrandedNumberKeys>;\n  expectTypeOf<recordWithBrandedNumberKeys>().toEqualTypeOf<Record<string & z.core.$brand<\"SomeBrand\">, number>>();\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/brand.test.ts",
        "start": 1,
        "end": 63,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 63,
          "column": 2,
          "position": 773
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/brand.test.ts",
        "start": 1,
        "end": 63,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 63,
          "column": 2,
          "position": 773
        }
      }
    },
    {
      "format": "typescript",
      "lines": 54,
      "fragment": "import { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\nconst gtFive = z.bigint().gt(BigInt(5));\nconst gteFive = z.bigint().gte(BigInt(5));\nconst ltFive = z.bigint().lt(BigInt(5));\nconst lteFive = z.bigint().lte(BigInt(5));\nconst positive = z.bigint().positive();\nconst negative = z.bigint().negative();\nconst nonnegative = z.bigint().nonnegative();\nconst nonpositive = z.bigint().nonpositive();\nconst multipleOfFive = z.bigint().multipleOf(BigInt(5));\n\ntest(\"passing validations\", () => {\n  z.bigint().parse(BigInt(1));\n  z.bigint().parse(BigInt(0));\n  z.bigint().parse(BigInt(-1));\n  gtFive.parse(BigInt(6));\n  gteFive.parse(BigInt(5));\n  gteFive.parse(BigInt(6));\n  ltFive.parse(BigInt(4));\n  lteFive.parse(BigInt(5));\n  lteFive.parse(BigInt(4));\n  positive.parse(BigInt(3));\n  negative.parse(BigInt(-2));\n  nonnegative.parse(BigInt(0));\n  nonnegative.parse(BigInt(7));\n  nonpositive.parse(BigInt(0));\n  nonpositive.parse(BigInt(-12));\n  multipleOfFive.parse(BigInt(15));\n});\n\ntest(\"failing validations\", () => {\n  expect(() => gtFive.parse(BigInt(5))).toThrow();\n  expect(() => gteFive.parse(BigInt(4))).toThrow();\n  expect(() => ltFive.parse(BigInt(5))).toThrow();\n  expect(() => lteFive.parse(BigInt(6))).toThrow();\n  expect(() => positive.parse(BigInt(0))).toThrow();\n  expect(() => positive.parse(BigInt(-2))).toThrow();\n  expect(() => negative.parse(BigInt(0))).toThrow();\n  expect(() => negative.parse(BigInt(3))).toThrow();\n  expect(() => nonnegative.parse(BigInt(-1))).toThrow();\n  expect(() => nonpositive.parse(BigInt(1))).toThrow();\n  expect(() => multipleOfFive.parse(BigInt(13))).toThrow();\n});\n\ntest(\"min max getters\", () => {\n  expect(z.bigint().min(BigInt(5)).minValue).toEqual(BigInt(5));\n  expect(z.bigint().min(BigInt(5)).min(BigInt(10)).minValue).toEqual(BigInt(10));\n\n  expect(z.bigint().max(BigInt(5)).maxValue).toEqual(BigInt(5));\n  expect(z.bigint().max(BigInt(5)).max(BigInt(1)).maxValue).toEqual(BigInt(1));\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/bigint.test.ts",
        "start": 1,
        "end": 54,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 54,
          "column": 2,
          "position": 859
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/bigint.test.ts",
        "start": 1,
        "end": 54,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 54,
          "column": 2,
          "position": 859
        }
      }
    },
    {
      "format": "typescript",
      "lines": 68,
      "fragment": "import { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\ntest(\"async refine .parse()\", async () => {\n  // throws ZodAsyncError\n  const s1 = z.string().refine(async (_val) => true);\n  expect(() => s1.safeParse(\"asdf\")).toThrow();\n});\n\ntest(\"async refine\", async () => {\n  const s1 = z.string().refine(async (_val) => true);\n  const r1 = await s1.parseAsync(\"asdf\");\n  expect(r1).toEqual(\"asdf\");\n\n  const s2 = z.string().refine(async (_val) => false);\n  const r2 = await s2.safeParseAsync(\"asdf\");\n  expect(r2.success).toBe(false);\n  expect(r2).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"Invalid input\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"async refine with Promises\", async () => {\n  // expect.assertions(2);\n\n  const schema1 = z.string().refine((_val) => Promise.resolve(true));\n  const v1 = await schema1.parseAsync(\"asdf\");\n  expect(v1).toEqual(\"asdf\");\n\n  const schema2 = z.string().refine((_val) => Promise.resolve(false));\n  await expect(schema2.parseAsync(\"asdf\")).rejects.toBeDefined();\n\n  const schema3 = z.string().refine((_val) => Promise.resolve(true));\n  await expect(schema3.parseAsync(\"asdf\")).resolves.toEqual(\"asdf\");\n  return await expect(schema3.parseAsync(\"qwer\")).resolves.toEqual(\"qwer\");\n});\n\ntest(\"async refine that uses value\", async () => {\n  const schema1 = z.string().refine(async (val) => {\n    return val.length > 5;\n  });\n\n  const r1 = await schema1.safeParseAsync(\"asdf\");\n  expect(r1.success).toBe(false);\n  expect(r1.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"Invalid input\"\n      }\n    ]]\n  `);\n\n  const r2 = await schema1.safeParseAsync(\"asdf123\");\n  expect(r2.success).toBe(true);\n  expect(r2.data).toEqual(\"asdf123\");\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/async-refinements.test.ts",
        "start": 1,
        "end": 68,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 68,
          "column": 2,
          "position": 605
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/async-refinements.test.ts",
        "start": 1,
        "end": 68,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 68,
          "column": 2,
          "position": 605
        }
      }
    },
    {
      "format": "typescript",
      "lines": 381,
      "fragment": "import { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\n/// string\nconst stringSchema = z.string();\n\ntest(\"string async parse\", async () => {\n  const goodData = \"XXX\";\n  const badData = 12;\n\n  const goodResult = await stringSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await stringSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// number\nconst numberSchema = z.number();\ntest(\"number async parse\", async () => {\n  const goodData = 1234.2353;\n  const badData = \"1234\";\n\n  const goodResult = await numberSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await numberSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// bigInt\nconst bigIntSchema = z.bigint();\ntest(\"bigInt async parse\", async () => {\n  const goodData = BigInt(145);\n  const badData = 134;\n\n  const goodResult = await bigIntSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await bigIntSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// boolean\nconst booleanSchema = z.boolean();\ntest(\"boolean async parse\", async () => {\n  const goodData = true;\n  const badData = 1;\n\n  const goodResult = await booleanSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await booleanSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// date\nconst dateSchema = z.date();\ntest(\"date async parse\", async () => {\n  const goodData = new Date();\n  const badData = new Date().toISOString();\n\n  const goodResult = await dateSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await dateSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// undefined\nconst undefinedSchema = z.undefined();\ntest(\"undefined async parse\", async () => {\n  const goodData = undefined;\n  const badData = \"XXX\";\n\n  const goodResult = await undefinedSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(undefined);\n\n  const badResult = await undefinedSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// null\nconst nullSchema = z.null();\ntest(\"null async parse\", async () => {\n  const goodData = null;\n  const badData = undefined;\n\n  const goodResult = await nullSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await nullSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// any\nconst anySchema = z.any();\ntest(\"any async parse\", async () => {\n  const goodData = [{}];\n  // const badData = 'XXX';\n\n  const goodResult = await anySchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  // const badResult = await anySchema.safeParseAsync(badData);\n  // expect(badResult.success).toBe(false);\n  // if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// unknown\nconst unknownSchema = z.unknown();\ntest(\"unknown async parse\", async () => {\n  const goodData = [\"asdf\", 124, () => {}];\n  // const badData = 'XXX';\n\n  const goodResult = await unknownSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  // const badResult = await unknownSchema.safeParseAsync(badData);\n  // expect(badResult.success).toBe(false);\n  // if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// void\nconst voidSchema = z.void();\ntest(\"void async parse\", async () => {\n  const goodData = undefined;\n  const badData = 0;\n\n  const goodResult = await voidSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await voidSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// array\nconst arraySchema = z.array(z.string());\ntest(\"array async parse\", async () => {\n  const goodData = [\"XXX\"];\n  const badData = \"XXX\";\n\n  const goodResult = await arraySchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await arraySchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// object\nconst objectSchema = z.object({ string: z.string() });\ntest(\"object async parse\", async () => {\n  const goodData = { string: \"XXX\" };\n  const badData = { string: 12 };\n\n  const goodResult = await objectSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await objectSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// union\nconst unionSchema = z.union([z.string(), z.undefined()]);\ntest(\"union async parse\", async () => {\n  const goodData = undefined;\n  const badData = null;\n\n  const goodResult = await unionSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await unionSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// record\nconst recordSchema = z.record(z.string(), z.object({}));\ntest(\"record async parse\", async () => {\n  const goodData = { adsf: {}, asdf: {} };\n  const badData = [{}];\n\n  const goodResult = await recordSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await recordSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// function\n// const functionSchema = z.function();\n// test(\"function async parse\", async () => {\n//   const goodData = () => {};\n//   const badData = \"XXX\";\n\n//   const goodResult = await functionSchema.safeParseAsync(goodData);\n//   expect(goodResult.success).toBe(true);\n//   if (goodResult.success) expect(typeof goodResult.data).toEqual(\"function\");\n\n//   const badResult = await functionSchema.safeParseAsync(badData);\n//   expect(badResult.success).toBe(false);\n//   if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n// });\n\n/// literal\nconst literalSchema = z.literal(\"asdf\");\ntest(\"literal async parse\", async () => {\n  const goodData = \"asdf\";\n  const badData = \"asdff\";\n\n  const goodResult = await literalSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await literalSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// enum\nconst enumSchema = z.enum([\"fish\", \"whale\"]);\ntest(\"enum async parse\", async () => {\n  const goodData = \"whale\";\n  const badData = \"leopard\";\n\n  const goodResult = await enumSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await enumSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// nativeEnum\nenum nativeEnumTest {\n  asdf = \"qwer\",\n}\n// @ts-ignore\nconst nativeEnumSchema = z.nativeEnum(nativeEnumTest);\ntest(\"nativeEnum async parse\", async () => {\n  const goodData = nativeEnumTest.asdf;\n  const badData = \"asdf\";\n\n  const goodResult = await nativeEnumSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await nativeEnumSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// promise\nconst promiseSchema = z.promise(z.number());\ntest(\"promise async parse good\", async () => {\n  const goodData = Promise.resolve(123);\n\n  const goodResult = await promiseSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  expect(typeof goodResult.data).toEqual(\"number\");\n  expect(goodResult.data).toEqual(123);\n});\n\ntest(\"promise async parse bad\", async () => {\n  const badData = Promise.resolve(\"XXX\");\n  const badResult = await promiseSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\ntest(\"async validation non-empty strings\", async () => {\n  const base = z.object({\n    hello: z.string().refine((x) => x && x.length > 0),\n    foo: z.string().refine((x) => x && x.length > 0),\n  });\n\n  const testval = { hello: \"\", foo: \"\" };\n  const result1 = base.safeParse(testval);\n  const result2 = base.safeParseAsync(testval);\n\n  const r1 = result1;\n  await result2.then((r2) => {\n    expect(r1.error!.issues.length).toBe(r2.error!.issues.length);\n  });\n});\n\ntest(\"async validation multiple errors 1\", async () => {\n  const base = z.object({\n    hello: z.string(),\n    foo: z.number(),\n  });\n\n  const testval = { hello: 3, foo: \"hello\" };\n  const result1 = base.safeParse(testval);\n  const result2 = base.safeParseAsync(testval);\n\n  await result2.then((result2) => {\n    expect(result2.error!.issues.length).toBe(result1.error!.issues.length);\n  });\n});\n\ntest(\"async validation multiple errors 2\", async () => {\n  const base = (is_async?: boolean) =>\n    z.object({\n      hello: z.string(),\n      foo: z.object({\n        bar: z.number().refine(\n          is_async\n            ? async () =>\n                new Promise((resolve) => {\n                  setTimeout(() => resolve(false), 500);\n                })\n            : () => false\n        ),\n      }),\n    });\n\n  const testval = { hello: 3, foo: { bar: 4 } };\n  const result1 = base().safeParse(testval);\n  const result2 = base(true).safeParseAsync(testval);\n\n  await result2.then((result2) => {\n    expect(result1.error!.issues.length).toBe(result2.error!.issues.length);\n  });\n});\n\ntest(\"ensure early async failure prevents follow-up refinement checks\", async () => {\n  let count = 0;\n  const base = z.object({\n    hello: z.string(),\n    foo: z\n      .number()\n      .refine(async () => {\n        count++;\n        return true;\n      })\n      .refine(async () => {\n        count++;\n        return true;\n      }, \"Good\"),\n  });\n\n  const testval = { hello: \"bye\", foo: 3 };\n  const result = await base.safeParseAsync(testval);\n  if (result.success === false) {\n    expect(result.error.issues.length).toBe(1);\n    expect(count).toBe(1);\n  }\n\n  // await result.then((r) => {\n  //   if (r.success === false) expect(r.error.issues.length).toBe(1);\n  //   expect(count).toBe(2);\n  // });\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/async-parsing.test.ts",
        "start": 1,
        "end": 381,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 381,
          "column": 2,
          "position": 3955
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/async-parsing.test.ts",
        "start": 1,
        "end": 381,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 381,
          "column": 2,
          "position": 3955
        }
      }
    },
    {
      "format": "typescript",
      "lines": 210,
      "fragment": "import { expectTypeOf, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\ntest(\"assignability\", () => {\n  // $ZodString\n  z.string() satisfies z.core.$ZodString;\n  z.string() satisfies z.ZodString;\n\n  // $ZodNumber\n  z.number() satisfies z.core.$ZodNumber;\n  z.number() satisfies z.ZodNumber;\n\n  // $ZodBigInt\n  z.bigint() satisfies z.core.$ZodBigInt;\n  z.bigint() satisfies z.ZodBigInt;\n\n  // $ZodBoolean\n  z.boolean() satisfies z.core.$ZodBoolean;\n  z.boolean() satisfies z.ZodBoolean;\n\n  // $ZodDate\n  z.date() satisfies z.core.$ZodDate;\n  z.date() satisfies z.ZodDate;\n\n  // $ZodSymbol\n  z.symbol() satisfies z.core.$ZodSymbol;\n  z.symbol() satisfies z.ZodSymbol;\n\n  // $ZodUndefined\n  z.undefined() satisfies z.core.$ZodUndefined;\n  z.undefined() satisfies z.ZodUndefined;\n\n  // $ZodNullable\n  z.string().nullable() satisfies z.core.$ZodNullable;\n  z.string().nullable() satisfies z.ZodNullable;\n\n  // $ZodNull\n  z.null() satisfies z.core.$ZodNull;\n  z.null() satisfies z.ZodNull;\n\n  // $ZodAny\n  z.any() satisfies z.core.$ZodAny;\n  z.any() satisfies z.ZodAny;\n\n  // $ZodUnknown\n  z.unknown() satisfies z.core.$ZodUnknown;\n  z.unknown() satisfies z.ZodUnknown;\n\n  // $ZodNever\n  z.never() satisfies z.core.$ZodNever;\n  z.never() satisfies z.ZodNever;\n\n  // $ZodVoid\n  z.void() satisfies z.core.$ZodVoid;\n  z.void() satisfies z.ZodVoid;\n\n  // $ZodArray\n  z.array(z.string()) satisfies z.core.$ZodArray;\n  z.array(z.string()) satisfies z.ZodArray;\n  z.array(z.string()) satisfies z.ZodType<Array<unknown>>;\n\n  // $ZodObject\n  z.object({ key: z.string() }) satisfies z.core.$ZodObject;\n  z.object({ key: z.string() }) satisfies z.ZodObject<{ key: z.ZodType }>;\n  z.object({ key: z.string() }) satisfies z.ZodType<{ key: string }>;\n\n  // $ZodUnion\n  z.union([z.string(), z.number()]) satisfies z.core.$ZodUnion;\n  z.union([z.string(), z.number()]) satisfies z.ZodUnion;\n  z.union([z.string(), z.number()]) satisfies z.ZodType<string | number>;\n\n  // $ZodIntersection\n  z.intersection(z.string(), z.number()) satisfies z.core.$ZodIntersection;\n  z.intersection(z.string(), z.number()) satisfies z.ZodIntersection;\n\n  // $ZodTuple\n  z.tuple([z.string(), z.number()]) satisfies z.core.$ZodTuple;\n  z.tuple([z.string(), z.number()]) satisfies z.ZodTuple;\n\n  // $ZodRecord\n  z.record(z.string(), z.number()) satisfies z.core.$ZodRecord;\n  z.record(z.string(), z.number()) satisfies z.ZodRecord;\n\n  // $ZodMap\n  z.map(z.string(), z.number()) satisfies z.core.$ZodMap;\n  z.map(z.string(), z.number()) satisfies z.ZodMap;\n\n  // $ZodSet\n  z.set(z.string()) satisfies z.core.$ZodSet;\n  z.set(z.string()) satisfies z.ZodSet;\n\n  // $ZodLiteral\n  z.literal(\"example\") satisfies z.core.$ZodLiteral;\n  z.literal(\"example\") satisfies z.ZodLiteral;\n\n  // $ZodEnum\n  z.enum([\"a\", \"b\", \"c\"]) satisfies z.core.$ZodEnum;\n  z.enum([\"a\", \"b\", \"c\"]) satisfies z.ZodEnum;\n\n  // $ZodPromise\n  z.promise(z.string()) satisfies z.core.$ZodPromise;\n  z.promise(z.string()) satisfies z.ZodPromise;\n\n  // $ZodLazy\n  const lazySchema = z.lazy(() => z.string());\n  lazySchema satisfies z.core.$ZodLazy;\n  lazySchema satisfies z.ZodLazy;\n\n  // $ZodOptional\n  z.string().optional() satisfies z.core.$ZodOptional;\n  z.string().optional() satisfies z.ZodOptional;\n\n  // $ZodDefault\n  z.string().default(\"default\") satisfies z.core.$ZodDefault;\n  z.string().default(\"default\") satisfies z.ZodDefault;\n\n  // $ZodTemplateLiteral\n  z.templateLiteral([z.literal(\"a\"), z.literal(\"b\")]) satisfies z.core.$ZodTemplateLiteral;\n  z.templateLiteral([z.literal(\"a\"), z.literal(\"b\")]) satisfies z.ZodTemplateLiteral;\n\n  // $ZodCustom\n  z.custom<string>((val) => typeof val === \"string\") satisfies z.core.$ZodCustom;\n  z.custom<string>((val) => typeof val === \"string\") satisfies z.ZodCustom;\n\n  // $ZodTransform\n  z.transform((val) => val as string) satisfies z.core.$ZodTransform;\n  z.transform((val) => val as string) satisfies z.ZodTransform;\n\n  // $ZodNonOptional\n  z.string().optional().nonoptional() satisfies z.core.$ZodNonOptional;\n  z.string().optional().nonoptional() satisfies z.ZodNonOptional;\n\n  // $ZodReadonly\n  z.object({ key: z.string() }).readonly() satisfies z.core.$ZodReadonly;\n  z.object({ key: z.string() }).readonly() satisfies z.ZodReadonly;\n\n  // $ZodNaN\n  z.nan() satisfies z.core.$ZodNaN;\n  z.nan() satisfies z.ZodNaN;\n\n  // $ZodPipe\n  z.unknown().pipe(z.number()) satisfies z.core.$ZodPipe;\n  z.unknown().pipe(z.number()) satisfies z.ZodPipe;\n\n  // $ZodSuccess\n  z.success(z.string()) satisfies z.core.$ZodSuccess;\n  z.success(z.string()) satisfies z.ZodSuccess;\n\n  // $ZodCatch\n  z.string().catch(\"fallback\") satisfies z.core.$ZodCatch;\n  z.string().catch(\"fallback\") satisfies z.ZodCatch;\n\n  // $ZodFile\n  z.file() satisfies z.core.$ZodFile;\n  z.file() satisfies z.ZodFile;\n});\n\ntest(\"checks\", () => {\n  const _a: z.core.$ZodCheck = {} as any as z.core.$ZodChecks;\n  const _b: z.core.$ZodCheck = {} as any as z.core.$ZodStringFormatChecks;\n  const _c: z.core.$ZodType = {} as any as z.core.$ZodTypes;\n  const _d: z.core.$ZodType = {} as any as z.core.$ZodStringFormatTypes;\n});\n\ntest(\"assignability to $ZodType\", () => {\n  z.string() satisfies z.ZodType;\n  z.number() satisfies z.ZodType;\n  z.boolean() satisfies z.ZodType;\n  z.object({ key: z.string() }) satisfies z.ZodType;\n  z.object({ key: z.string() }) satisfies z.ZodType<{ key: string }>;\n  z.array(z.string()) satisfies z.ZodType;\n  z.union([z.string(), z.number()]) satisfies z.ZodType;\n  z.intersection(z.string(), z.number()) satisfies z.ZodType;\n  z.tuple([z.string(), z.number()]) satisfies z.ZodType;\n  z.record(z.string(), z.number()) satisfies z.ZodType;\n  z.map(z.string(), z.number()) satisfies z.ZodType;\n  z.set(z.string()) satisfies z.ZodType;\n  z.literal(\"example\") satisfies z.ZodType;\n\n  expectTypeOf<z.ZodType extends z.core.$ZodType ? true : false>().toEqualTypeOf<true>();\n});\n\ntest(\"assignability with narrowing\", () => {\n  type _RefinedSchema<T extends z.ZodType<object> | z.ZodUnion> = T extends z.ZodUnion\n    ? RefinedUnionSchema<T> // <-- Type instantiation is excessively deep and possibly infinite.\n    : T extends z.ZodType<object>\n      ? RefinedTypeSchema<z.output<T>> // <-- Type instantiation is excessively deep and possibly infinite.\n      : never;\n\n  type RefinedTypeSchema<T extends object> = T;\n\n  type RefinedUnionSchema<T extends z.ZodUnion> = T;\n});\n\ntest(\"generic assignability in objects\", () => {\n  interface SortItem<T extends string> {\n    key: T;\n    order: string;\n  }\n\n  const createSortItemSchema = <T extends z.ZodType<string>>(sortKeySchema: T) =>\n    z.object({\n      key: sortKeySchema,\n      order: z.string(),\n    });\n\n  <T extends z.ZodType<string>>(sortKeySchema: T, defaultSortBy: SortItem<z.output<T>>[] = []) =>\n    createSortItemSchema(sortKeySchema).array().default(defaultSortBy);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/assignability.test.ts",
        "start": 1,
        "end": 210,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 210,
          "column": 2,
          "position": 2601
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/assignability.test.ts",
        "start": 1,
        "end": 210,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 210,
          "column": 2,
          "position": 2601
        }
      }
    },
    {
      "format": "typescript",
      "lines": 264,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ntest(\"type inference\", () => {\n  const schema = z.string().array();\n  expectTypeOf<z.infer<typeof schema>>().toEqualTypeOf<string[]>();\n});\n\ntest(\"array min/max\", async () => {\n  const schema = z.array(z.string()).min(2).max(2);\n  const r1 = await schema.safeParse([\"asdf\"]);\n  expect(r1.success).toEqual(false);\n  expect(r1.error!.issues).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"too_small\",\n        \"inclusive\": true,\n        \"message\": \"Too small: expected array to have >=2 items\",\n        \"minimum\": 2,\n        \"origin\": \"array\",\n        \"path\": [],\n      },\n    ]\n  `);\n\n  const r2 = await schema.safeParse([\"asdf\", \"asdf\", \"asdf\"]);\n  expect(r2.success).toEqual(false);\n  expect(r2.error!.issues).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"too_big\",\n        \"inclusive\": true,\n        \"maximum\": 2,\n        \"message\": \"Too big: expected array to have <=2 items\",\n        \"origin\": \"array\",\n        \"path\": [],\n      },\n    ]\n  `);\n});\n\ntest(\"array length\", async () => {\n  const schema = z.array(z.string()).length(2);\n  schema.parse([\"asdf\", \"asdf\"]);\n\n  const r1 = await schema.safeParse([\"asdf\"]);\n  expect(r1.success).toEqual(false);\n  expect(r1.error!.issues).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"too_small\",\n        \"exact\": true,\n        \"inclusive\": true,\n        \"message\": \"Too small: expected array to have >=2 items\",\n        \"minimum\": 2,\n        \"origin\": \"array\",\n        \"path\": [],\n      },\n    ]\n  `);\n\n  const r2 = await schema.safeParse([\"asdf\", \"asdf\", \"asdf\"]);\n  expect(r2.success).toEqual(false);\n  expect(r2.error!.issues).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"too_big\",\n        \"exact\": true,\n        \"inclusive\": true,\n        \"maximum\": 2,\n        \"message\": \"Too big: expected array to have <=2 items\",\n        \"origin\": \"array\",\n        \"path\": [],\n      },\n    ]\n  `);\n});\n\ntest(\"array.nonempty()\", () => {\n  const schema = z.string().array().nonempty();\n  schema.parse([\"a\"]);\n  expect(() => schema.parse([])).toThrow();\n});\n\ntest(\"array.nonempty().max()\", () => {\n  const schema = z.string().array().nonempty().max(2);\n  schema.parse([\"a\"]);\n  expect(() => schema.parse([])).toThrow();\n  expect(() => schema.parse([\"a\", \"a\", \"a\"])).toThrow();\n});\n\ntest(\"parse empty array in nonempty\", () => {\n  expect(() =>\n    z\n      .array(z.string())\n      .nonempty()\n      .parse([] as any)\n  ).toThrow();\n});\n\ntest(\"get element\", () => {\n  const schema = z.string().array();\n  schema.element.parse(\"asdf\");\n  expect(() => schema.element.parse(12)).toThrow();\n});\n\ntest(\"continue parsing despite array size error\", () => {\n  const schema = z.object({\n    people: z.string().array().min(2),\n  });\n\n  const result = schema.safeParse({\n    people: [123],\n  });\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"people\",\n          0\n        ],\n        \"message\": \"Invalid input: expected string, received number\"\n      },\n      {\n        \"origin\": \"array\",\n        \"code\": \"too_small\",\n        \"minimum\": 2,\n        \"inclusive\": true,\n        \"path\": [\n          \"people\"\n        ],\n        \"message\": \"Too small: expected array to have >=2 items\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"parse should fail given sparse array\", () => {\n  const schema = z.array(z.string()).nonempty().min(1).max(3);\n  const result = schema.safeParse(new Array(3));\n  expect(result.success).toEqual(false);\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          0\n        ],\n        \"message\": \"Invalid input: expected string, received undefined\"\n      },\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          1\n        ],\n        \"message\": \"Invalid input: expected string, received undefined\"\n      },\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          2\n        ],\n        \"message\": \"Invalid input: expected string, received undefined\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\n// const unique = z.string().array().unique();\n// const uniqueArrayOfObjects = z.array(z.object({ name: z.string() })).unique({ identifier: (item) => item.name });\n\n// test(\"passing unique validation\", () => {\n//   unique.parse([\"a\", \"b\", \"c\"]);\n//   uniqueArrayOfObjects.parse([{ name: \"Leo\" }, { name: \"Joe\" }]);\n// });\n\n// test(\"failing unique validation\", () => {\n//   expect(() => unique.parse([\"a\", \"a\", \"b\"])).toThrow();\n//   expect(() => uniqueArrayOfObjects.parse([{ name: \"Leo\" }, { name: \"Leo\" }])).toThrow();\n// });\n\n// test(\"continue parsing despite array of primitives uniqueness error\", () => {\n//   const schema = z.number().array().unique();\n\n//   const result = schema.safeParse([1, 1, 2, 2, 3]);\n\n//   expect(result.success).toEqual(false);\n//   if (!result.success) {\n//     const issue = result.error.issues.find(({ code }) => code === \"not_unique\");\n//     expect(issue?.message).toEqual(\"Values must be unique\");\n//   }\n// });\n\n// test(\"continue parsing despite array of objects not_unique error\", () => {\n//   const schema = z.array(z.object({ name: z.string() })).unique({\n//     identifier: (item) => item.name,\n//     showDuplicates: true,\n//   });\n\n//   const result = schema.safeParse([\n//     { name: \"Leo\" },\n//     { name: \"Joe\" },\n//     { name: \"Leo\" },\n//   ]);\n\n//   expect(result.success).toEqual(false);\n//   if (!result.success) {\n//     const issue = result.error.issues.find(({ code }) => code === \"not_unique\");\n//     expect(issue?.message).toEqual(\"Element(s): 'Leo' not unique\");\n//   }\n// });\n\n// test(\"returns custom error message without duplicate elements\", () => {\n//   const schema = z.number().array().unique({ message: \"Custom message\" });\n\n//   const result = schema.safeParse([1, 1, 2, 2, 3]);\n\n//   expect(result.success).toEqual(false);\n//   if (!result.success) {\n//     const issue = result.error.issues.find(({ code }) => code === \"not_unique\");\n//     expect(issue?.message).toEqual(\"Custom message\");\n//   }\n// });\n\n// test(\"returns error message with duplicate elements\", () => {\n//   const schema = z.number().array().unique({ showDuplicates: true });\n\n//   const result = schema.safeParse([1, 1, 2, 2, 3]);\n\n//   expect(result.success).toEqual(false);\n//   if (!result.success) {\n//     const issue = result.error.issues.find(({ code }) => code === \"not_unique\");\n//     expect(issue?.message).toEqual(\"Element(s): '1,2' not unique\");\n//   }\n// });\n\n// test(\"returns custom error message with duplicate elements\", () => {\n//   const schema = z\n//     .number()\n//     .array()\n//     .unique({\n//       message: (item) => `Custom message: '${item}' are not unique`,\n//       showDuplicates: true,\n//     });\n\n//   const result = schema.safeParse([1, 1, 2, 2, 3]);\n\n//   expect(result.success).toEqual(false);\n//   if (!result.success) {\n//     const issue = result.error.issues.find(({ code }) => code === \"not_unique\");\n//     expect(issue?.message).toEqual(\"Custom message: '1,2' are not unique\");\n//   }\n// });",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/array.test.ts",
        "start": 1,
        "end": 264,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 264,
          "column": 7,
          "position": 1066
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/array.test.ts",
        "start": 1,
        "end": 264,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 264,
          "column": 7,
          "position": 1066
        }
      }
    },
    {
      "format": "typescript",
      "lines": 26,
      "fragment": "import { expect, expectTypeOf, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\ntest(\"check any inference\", () => {\n  const t1 = z.any();\n  t1.optional();\n  t1.nullable();\n  type t1 = z.infer<typeof t1>;\n  expectTypeOf<t1>().toEqualTypeOf<any>();\n});\n\ntest(\"check unknown inference\", () => {\n  const t1 = z.unknown();\n  t1.optional();\n  t1.nullable();\n  type t1 = z.infer<typeof t1>;\n  expectTypeOf<t1>().toEqualTypeOf<unknown>();\n});\n\ntest(\"check never inference\", () => {\n  const t1 = z.never();\n  expect(() => t1.parse(undefined)).toThrow();\n  expect(() => t1.parse(\"asdf\")).toThrow();\n  expect(() => t1.parse(null)).toThrow();\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/tests/anyunknown.test.ts",
        "start": 1,
        "end": 26,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 26,
          "column": 2,
          "position": 285
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/tests/anyunknown.test.ts",
        "start": 1,
        "end": 26,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 26,
          "column": 2,
          "position": 285
        }
      }
    },
    {
      "format": "typescript",
      "lines": 23,
      "fragment": "import { ZodDiscriminatedUnionDef, ZodUnionDef } from \"zod\";\nimport { JsonSchema7Type } from \"../parseTypes.js\";\nimport { Refs } from \"../Refs.js\";\nexport declare const primitiveMappings: {\n    readonly ZodString: \"string\";\n    readonly ZodNumber: \"number\";\n    readonly ZodBigInt: \"integer\";\n    readonly ZodBoolean: \"boolean\";\n    readonly ZodNull: \"null\";\n};\ntype JsonSchema7Primitive = (typeof primitiveMappings)[keyof typeof primitiveMappings];\nexport type JsonSchema7UnionType = JsonSchema7PrimitiveUnionType | JsonSchema7AnyOfType;\ntype JsonSchema7PrimitiveUnionType = {\n    type: JsonSchema7Primitive | JsonSchema7Primitive[];\n} | {\n    type: JsonSchema7Primitive | JsonSchema7Primitive[];\n    enum: (string | number | bigint | boolean | null)[];\n};\ntype JsonSchema7AnyOfType = {\n    anyOf: JsonSchema7Type[];\n};\nexport declare function parseUnionDef(def: ZodUnionDef | ZodDiscriminatedUnionDef<any, any>, refs: Refs): JsonSchema7PrimitiveUnionType | JsonSchema7AnyOfType | undefined;\nexport {};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod-to-json-schema/dist/types/parsers/union.d.ts",
        "start": 1,
        "end": 23,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 23,
          "column": 2,
          "position": 272
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod-to-json-schema/dist/types/parsers/union.d.ts",
        "start": 1,
        "end": 23,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 23,
          "column": 2,
          "position": 272
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "import { ZodTupleDef, ZodTupleItems, ZodTypeAny } from \"zod\";\nimport { JsonSchema7Type } from \"../parseTypes.js\";\nimport { Refs } from \"../Refs.js\";\nexport type JsonSchema7TupleType = {\n    type: \"array\";\n    minItems: number;\n    items: JsonSchema7Type[];\n} & ({\n    maxItems: number;\n} | {\n    additionalItems?: JsonSchema7Type;\n});\nexport declare function parseTupleDef(def: ZodTupleDef<ZodTupleItems | [], ZodTypeAny | null>, refs: Refs): JsonSchema7TupleType;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod-to-json-schema/dist/types/parsers/tuple.d.ts",
        "start": 1,
        "end": 13,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 13,
          "column": 2,
          "position": 147
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod-to-json-schema/dist/types/parsers/tuple.d.ts",
        "start": 1,
        "end": 13,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 13,
          "column": 2,
          "position": 147
        }
      }
    },
    {
      "format": "typescript",
      "lines": 73,
      "fragment": "import { ZodStringDef } from \"zod\";\nimport { ErrorMessages } from \"../errorMessages.js\";\nimport { Refs } from \"../Refs.js\";\n/**\n * Generated from the regular expressions found here as of 2024-05-22:\n * https://github.com/colinhacks/zod/blob/master/src/types.ts.\n *\n * Expressions with /i flag have been changed accordingly.\n */\nexport declare const zodPatterns: {\n    /**\n     * `c` was changed to `[cC]` to replicate /i flag\n     */\n    readonly cuid: RegExp;\n    readonly cuid2: RegExp;\n    readonly ulid: RegExp;\n    /**\n     * `a-z` was added to replicate /i flag\n     */\n    readonly email: RegExp;\n    /**\n     * Constructed a valid Unicode RegExp\n     *\n     * Lazily instantiate since this type of regex isn't supported\n     * in all envs (e.g. React Native).\n     *\n     * See:\n     * https://github.com/colinhacks/zod/issues/2433\n     * Fix in Zod:\n     * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b\n     */\n    readonly emoji: () => RegExp;\n    /**\n     * Unused\n     */\n    readonly uuid: RegExp;\n    /**\n     * Unused\n     */\n    readonly ipv4: RegExp;\n    readonly ipv4Cidr: RegExp;\n    /**\n     * Unused\n     */\n    readonly ipv6: RegExp;\n    readonly ipv6Cidr: RegExp;\n    readonly base64: RegExp;\n    readonly base64url: RegExp;\n    readonly nanoid: RegExp;\n    readonly jwt: RegExp;\n};\nexport type JsonSchema7StringType = {\n    type: \"string\";\n    minLength?: number;\n    maxLength?: number;\n    format?: \"email\" | \"idn-email\" | \"uri\" | \"uuid\" | \"date-time\" | \"ipv4\" | \"ipv6\" | \"date\" | \"time\" | \"duration\";\n    pattern?: string;\n    allOf?: {\n        pattern: string;\n        errorMessage?: ErrorMessages<{\n            pattern: string;\n        }>;\n    }[];\n    anyOf?: {\n        format: string;\n        errorMessage?: ErrorMessages<{\n            format: string;\n        }>;\n    }[];\n    errorMessage?: ErrorMessages<JsonSchema7StringType>;\n    contentEncoding?: string;\n};\nexport declare function parseStringDef(def: ZodStringDef, refs: Refs): JsonSchema7StringType;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod-to-json-schema/dist/types/parsers/string.d.ts",
        "start": 1,
        "end": 73,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 73,
          "column": 2,
          "position": 415
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod-to-json-schema/dist/types/parsers/string.d.ts",
        "start": 1,
        "end": 73,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 73,
          "column": 2,
          "position": 415
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "import { ZodSetDef } from \"zod\";\nimport { ErrorMessages } from \"../errorMessages.js\";\nimport { JsonSchema7Type } from \"../parseTypes.js\";\nimport { Refs } from \"../Refs.js\";\nexport type JsonSchema7SetType = {\n    type: \"array\";\n    uniqueItems: true;\n    items?: JsonSchema7Type;\n    minItems?: number;\n    maxItems?: number;\n    errorMessage?: ErrorMessages<JsonSchema7SetType>;\n};\nexport declare function parseSetDef(def: ZodSetDef, refs: Refs): JsonSchema7SetType;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod-to-json-schema/dist/types/parsers/set.d.ts",
        "start": 1,
        "end": 13,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 13,
          "column": 2,
          "position": 136
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod-to-json-schema/dist/types/parsers/set.d.ts",
        "start": 1,
        "end": 13,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 13,
          "column": 2,
          "position": 136
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "import { ZodMapDef, ZodRecordDef, ZodTypeAny } from \"zod\";\nimport { JsonSchema7Type } from \"../parseTypes.js\";\nimport { Refs } from \"../Refs.js\";\nimport { JsonSchema7EnumType } from \"./enum.js\";\nimport { JsonSchema7StringType } from \"./string.js\";\ntype JsonSchema7RecordPropertyNamesType = Omit<JsonSchema7StringType, \"type\"> | Omit<JsonSchema7EnumType, \"type\">;\nexport type JsonSchema7RecordType = {\n    type: \"object\";\n    additionalProperties?: JsonSchema7Type | true;\n    propertyNames?: JsonSchema7RecordPropertyNamesType;\n};\nexport declare function parseRecordDef(def: ZodRecordDef<ZodTypeAny, ZodTypeAny> | ZodMapDef, refs: Refs): JsonSchema7RecordType;\nexport {};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod-to-json-schema/dist/types/parsers/record.d.ts",
        "start": 1,
        "end": 13,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 13,
          "column": 2,
          "position": 174
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod-to-json-schema/dist/types/parsers/record.d.ts",
        "start": 1,
        "end": 13,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 13,
          "column": 2,
          "position": 174
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "import { ZodNumberDef } from \"zod\";\nimport { ErrorMessages } from \"../errorMessages.js\";\nimport { Refs } from \"../Refs.js\";\nexport type JsonSchema7NumberType = {\n    type: \"number\" | \"integer\";\n    minimum?: number;\n    exclusiveMinimum?: number;\n    maximum?: number;\n    exclusiveMaximum?: number;\n    multipleOf?: number;\n    errorMessage?: ErrorMessages<JsonSchema7NumberType>;\n};\nexport declare function parseNumberDef(def: ZodNumberDef, refs: Refs): JsonSchema7NumberType;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod-to-json-schema/dist/types/parsers/number.d.ts",
        "start": 1,
        "end": 13,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 13,
          "column": 2,
          "position": 136
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod-to-json-schema/dist/types/parsers/number.d.ts",
        "start": 1,
        "end": 13,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 13,
          "column": 2,
          "position": 136
        }
      }
    },
    {
      "format": "typescript",
      "lines": 15,
      "fragment": "import { ZodMapDef } from \"zod\";\nimport { JsonSchema7Type } from \"../parseTypes.js\";\nimport { Refs } from \"../Refs.js\";\nimport { JsonSchema7RecordType } from \"./record.js\";\nexport type JsonSchema7MapType = {\n    type: \"array\";\n    maxItems: 125;\n    items: {\n        type: \"array\";\n        items: [JsonSchema7Type, JsonSchema7Type];\n        minItems: 2;\n        maxItems: 2;\n    };\n};\nexport declare function parseMapDef(def: ZodMapDef, refs: Refs): JsonSchema7MapType | JsonSchema7RecordType;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod-to-json-schema/dist/types/parsers/map.d.ts",
        "start": 1,
        "end": 15,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 15,
          "column": 2,
          "position": 148
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod-to-json-schema/dist/types/parsers/map.d.ts",
        "start": 1,
        "end": 15,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 15,
          "column": 2,
          "position": 148
        }
      }
    },
    {
      "format": "typescript",
      "lines": 15,
      "fragment": "import { ZodDateDef } from \"zod\";\nimport { Refs } from \"../Refs.js\";\nimport { ErrorMessages } from \"../errorMessages.js\";\nimport { JsonSchema7NumberType } from \"./number.js\";\nimport { DateStrategy } from \"../Options.js\";\nexport type JsonSchema7DateType = {\n    type: \"integer\" | \"string\";\n    format: \"unix-time\" | \"date-time\" | \"date\";\n    minimum?: number;\n    maximum?: number;\n    errorMessage?: ErrorMessages<JsonSchema7NumberType>;\n} | {\n    anyOf: JsonSchema7DateType[];\n};\nexport declare function parseDateDef(def: ZodDateDef, refs: Refs, overrideDateStrategy?: DateStrategy): JsonSchema7DateType;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod-to-json-schema/dist/types/parsers/date.d.ts",
        "start": 1,
        "end": 15,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 15,
          "column": 2,
          "position": 175
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod-to-json-schema/dist/types/parsers/date.d.ts",
        "start": 1,
        "end": 15,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 15,
          "column": 2,
          "position": 175
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": "import { ZodBigIntDef } from \"zod\";\nimport { Refs } from \"../Refs.js\";\nimport { ErrorMessages } from \"../errorMessages.js\";\nexport type JsonSchema7BigintType = {\n    type: \"integer\";\n    format: \"int64\";\n    minimum?: BigInt;\n    exclusiveMinimum?: BigInt;\n    maximum?: BigInt;\n    exclusiveMaximum?: BigInt;\n    multipleOf?: BigInt;\n    errorMessage?: ErrorMessages<JsonSchema7BigintType>;\n};\nexport declare function parseBigintDef(def: ZodBigIntDef, refs: Refs): JsonSchema7BigintType;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod-to-json-schema/dist/types/parsers/bigint.d.ts",
        "start": 1,
        "end": 14,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 14,
          "column": 2,
          "position": 139
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod-to-json-schema/dist/types/parsers/bigint.d.ts",
        "start": 1,
        "end": 14,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 14,
          "column": 2,
          "position": 139
        }
      }
    },
    {
      "format": "typescript",
      "lines": 12,
      "fragment": "import { ZodArrayDef } from \"zod\";\nimport { ErrorMessages } from \"../errorMessages.js\";\nimport { JsonSchema7Type } from \"../parseTypes.js\";\nimport { Refs } from \"../Refs.js\";\nexport type JsonSchema7ArrayType = {\n    type: \"array\";\n    items?: JsonSchema7Type;\n    minItems?: number;\n    maxItems?: number;\n    errorMessages?: ErrorMessages<JsonSchema7ArrayType, \"items\">;\n};\nexport declare function parseArrayDef(def: ZodArrayDef, refs: Refs): JsonSchema7ArrayType;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod-to-json-schema/dist/types/parsers/array.d.ts",
        "start": 1,
        "end": 12,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 12,
          "column": 2,
          "position": 132
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod-to-json-schema/dist/types/parsers/array.d.ts",
        "start": 1,
        "end": 12,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 12,
          "column": 2,
          "position": 132
        }
      }
    },
    {
      "format": "typescript",
      "lines": 62,
      "fragment": "import * as core from \"../core/index.js\";\nimport * as schemas from \"./schemas.js\";\n\n// iso time\nexport interface ZodMiniISODateTime extends schemas.ZodMiniStringFormat<\"datetime\"> {\n  _zod: core.$ZodISODateTimeInternals;\n}\nexport const ZodMiniISODateTime: core.$constructor<ZodMiniISODateTime> = /*@__PURE__*/ core.$constructor(\n  \"$ZodISODateTime\",\n  (inst, def) => {\n    core.$ZodISODateTime.init(inst, def);\n    schemas.ZodMiniStringFormat.init(inst, def);\n  }\n);\nexport function datetime(params?: string | core.$ZodISODateTimeParams): ZodMiniISODateTime {\n  return core._isoDateTime(ZodMiniISODateTime, params);\n}\n\n// iso date\nexport interface ZodMiniISODate extends schemas.ZodMiniStringFormat<\"date\"> {\n  _zod: core.$ZodISODateInternals;\n}\nexport const ZodMiniISODate: core.$constructor<ZodMiniISODate> = /*@__PURE__*/ core.$constructor(\n  \"$ZodISODate\",\n  (inst, def) => {\n    core.$ZodISODate.init(inst, def);\n    schemas.ZodMiniStringFormat.init(inst, def);\n  }\n);\nexport function date(params?: string | core.$ZodISODateParams): ZodMiniISODate {\n  return core._isoDate(ZodMiniISODate, params);\n}\n\n// iso time\nexport interface ZodMiniISOTime extends schemas.ZodMiniStringFormat<\"time\"> {\n  _zod: core.$ZodISOTimeInternals;\n}\nexport const ZodMiniISOTime: core.$constructor<ZodMiniISOTime> = /*@__PURE__*/ core.$constructor(\n  \"$ZodISOTime\",\n  (inst, def) => {\n    core.$ZodISOTime.init(inst, def);\n    schemas.ZodMiniStringFormat.init(inst, def);\n  }\n);\nexport function time(params?: string | core.$ZodISOTimeParams): ZodMiniISOTime {\n  return core._isoTime(ZodMiniISOTime, params);\n}\n\n// iso duration\nexport interface ZodMiniISODuration extends schemas.ZodMiniStringFormat<\"duration\"> {\n  _zod: core.$ZodISODurationInternals;\n}\nexport const ZodMiniISODuration: core.$constructor<ZodMiniISODuration> = /*@__PURE__*/ core.$constructor(\n  \"$ZodISODuration\",\n  (inst, def) => {\n    core.$ZodISODuration.init(inst, def);\n    schemas.ZodMiniStringFormat.init(inst, def);\n  }\n);\nexport function duration(params?: string | core.$ZodISODurationParams): ZodMiniISODuration {\n  return core._isoDuration(ZodMiniISODuration, params);\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/mini/iso.ts",
        "start": 1,
        "end": 62,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 62,
          "column": 2,
          "position": 608
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/iso.ts",
        "start": 1,
        "end": 62,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 62,
          "column": 2,
          "position": 608
        }
      }
    },
    {
      "format": "typescript",
      "lines": 40,
      "fragment": "export * as core from \"../core/index.js\";\nexport * from \"./parse.js\";\nexport * from \"./schemas.js\";\nexport * from \"./checks.js\";\n\nexport type { infer, output, input } from \"../core/index.js\";\nexport {\n  globalRegistry,\n  registry,\n  config,\n  $output,\n  $input,\n  $brand,\n  function,\n  clone,\n  regexes,\n  treeifyError,\n  prettifyError,\n  formatError,\n  flattenError,\n  toJSONSchema,\n  TimePrecision,\n  NEVER,\n} from \"../core/index.js\";\n\nexport * as locales from \"../locales/index.js\";\n/** A special constant with type `never` */\n// export const NEVER = {} as never;\n\n// iso\nexport * as iso from \"./iso.js\";\nexport {\n  ZodMiniISODateTime,\n  ZodMiniISODate,\n  ZodMiniISOTime,\n  ZodMiniISODuration,\n} from \"./iso.js\";\n\n// coerce\nexport * as coerce from \"./coerce.js\";",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/mini/external.ts",
        "start": 1,
        "end": 40,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 40,
          "column": 2,
          "position": 212
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/external.ts",
        "start": 1,
        "end": 40,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 40,
          "column": 2,
          "position": 212
        }
      }
    },
    {
      "format": "typescript",
      "lines": 22,
      "fragment": "import * as core from \"../core/index.js\";\nimport * as schemas from \"./schemas.js\";\n\nexport function string<T = unknown>(params?: string | core.$ZodStringParams): schemas.ZodMiniString<T> {\n  return core._coercedString(schemas.ZodMiniString, params) as schemas.ZodMiniString<T>;\n}\n\nexport function number<T = unknown>(params?: string | core.$ZodNumberParams): schemas.ZodMiniNumber<T> {\n  return core._coercedNumber(schemas.ZodMiniNumber, params) as schemas.ZodMiniNumber<T>;\n}\n\nexport function boolean<T = unknown>(params?: string | core.$ZodBooleanParams): schemas.ZodMiniBoolean<T> {\n  return core._coercedBoolean(schemas.ZodMiniBoolean, params) as schemas.ZodMiniBoolean<T>;\n}\n\nexport function bigint<T = unknown>(params?: string | core.$ZodBigIntParams): schemas.ZodMiniBigInt<T> {\n  return core._coercedBigint(schemas.ZodMiniBigInt, params) as schemas.ZodMiniBigInt<T>;\n}\n\nexport function date<T = unknown>(params?: string | core.$ZodDateParams): schemas.ZodMiniDate<T> {\n  return core._coercedDate(schemas.ZodMiniDate, params) as schemas.ZodMiniDate<T>;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/mini/coerce.ts",
        "start": 1,
        "end": 22,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 22,
          "column": 2,
          "position": 344
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/coerce.ts",
        "start": 1,
        "end": 22,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 22,
          "column": 2,
          "position": 344
        }
      }
    },
    {
      "format": "typescript",
      "lines": 32,
      "fragment": "export {\n  _lt as lt,\n  _lte as lte,\n  _lte as maximum,\n  _gt as gt,\n  _gte as gte,\n  _gte as minimum,\n  _positive as positive,\n  _negative as negative,\n  _nonpositive as nonpositive,\n  _nonnegative as nonnegative,\n  _multipleOf as multipleOf,\n  _maxSize as maxSize,\n  _minSize as minSize,\n  _size as size,\n  _maxLength as maxLength,\n  _minLength as minLength,\n  _length as length,\n  _regex as regex,\n  _lowercase as lowercase,\n  _uppercase as uppercase,\n  _includes as includes,\n  _startsWith as startsWith,\n  _endsWith as endsWith,\n  _property as property,\n  _mime as mime,\n  _overwrite as overwrite,\n  _normalize as normalize,\n  _trim as trim,\n  _toLowerCase as toLowerCase,\n  _toUpperCase as toUpperCase,\n} from \"../core/index.js\";",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/mini/checks.ts",
        "start": 1,
        "end": 32,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 32,
          "column": 2,
          "position": 249
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/checks.ts",
        "start": 1,
        "end": 32,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 32,
          "column": 2,
          "position": 249
        }
      }
    },
    {
      "format": "typescript",
      "lines": 125,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"\", verb: \"\" },\n    file: { unit: \"\", verb: \"\" },\n    array: { unit: \"\", verb: \"\" },\n    set: { unit: \"\", verb: \"\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"number\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"\",\n    email: \"\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO \",\n    date: \"ISO \",\n    time: \"ISO \",\n    duration: \"ISO \",\n    ipv4: \"IPv4 \",\n    ipv6: \"IPv6 \",\n    cidrv4: \"IPv4 \",\n    cidrv6: \"IPv6 \",\n    base64: \"base64 \",\n    base64url: \"base64url \",\n    json_string: \"JSON \",\n    e164: \"E.164 \",\n    jwt: \"JWT\",\n    template_literal: \"\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return ` ${issue.expected} ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return ` ${util.stringifyPrimitive(issue.values[0])}`;\n        return ` ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return ` ${issue.origin ?? \"\"}  ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"\"}`;\n        return ` ${issue.origin ?? \"\"}  ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return ` ${issue.origin}  ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n        return ` ${issue.origin}  ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") {\n          return ` \"${_issue.prefix}\" `;\n        }\n        if (_issue.format === \"ends_with\") return ` \"${_issue.suffix}\" `;\n        if (_issue.format === \"includes\") return ` \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return ` ${_issue.pattern}`;\n        return ` ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return ` ${issue.divisor} `;\n      case \"unrecognized_keys\":\n        return `${issue.keys.length > 1 ? \"\" : \"\"}${util.joinValues(issue.keys, \"\")}`;\n      case \"invalid_key\":\n        return `${issue.origin} `;\n      case \"invalid_union\":\n        return \"\";\n      case \"invalid_element\":\n        return `${issue.origin} `;\n      default:\n        return ``;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 125,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 125,
          "column": 2,
          "position": 1325
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 125,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 125,
          "column": 2,
          "position": 1325
        }
      }
    },
    {
      "format": "typescript",
      "lines": 123,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"\", verb: \"\" },\n    file: { unit: \"\", verb: \"\" },\n    array: { unit: \"\", verb: \"\" },\n    set: { unit: \"\", verb: \"\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"(NaN)\" : \"\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"\";\n        }\n        if (data === null) {\n          return \"(null)\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"\",\n    email: \"\",\n    url: \"URL\",\n    emoji: \"\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO\",\n    date: \"ISO\",\n    time: \"ISO\",\n    duration: \"ISO\",\n    ipv4: \"IPv4\",\n    ipv6: \"IPv6\",\n    cidrv4: \"IPv4\",\n    cidrv6: \"IPv6\",\n    base64: \"base64\",\n    base64url: \"base64url\",\n    json_string: \"JSON\",\n    e164: \"E.164\",\n    jwt: \"JWT\",\n    template_literal: \"\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return ` ${issue.expected} ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return ` ${util.stringifyPrimitive(issue.values[0])}`;\n        return ` ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return ` ${issue.origin ?? \"\"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"\"}`;\n        return ` ${issue.origin ?? \"\"} ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return ` ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n        return ` ${issue.origin} ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return ` \"${_issue.prefix}\" `;\n        if (_issue.format === \"ends_with\") return ` \"${_issue.suffix}\" `;\n        if (_issue.format === \"includes\") return ` \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return ` ${_issue.pattern}`;\n        return `${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return ` ${issue.divisor} `;\n      case \"unrecognized_keys\":\n        return `(key): ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `${issue.origin} (key)`;\n      case \"invalid_union\":\n        return \"\";\n      case \"invalid_element\":\n        return `${issue.origin} (value)`;\n      default:\n        return ``;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/zh-CN.ts",
        "start": 1,
        "end": 123,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 123,
          "column": 2,
          "position": 1300
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 123,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 123,
          "column": 2,
          "position": 1300
        }
      }
    },
    {
      "format": "typescript",
      "lines": 125,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"k t\", verb: \"c\" },\n    file: { unit: \"byte\", verb: \"c\" },\n    array: { unit: \"phn t\", verb: \"c\" },\n    set: { unit: \"phn t\", verb: \"c\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"s\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"mng\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"u vo\",\n    email: \"a ch email\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ngy gi ISO\",\n    date: \"ngy ISO\",\n    time: \"gi ISO\",\n    duration: \"khong thi gian ISO\",\n    ipv4: \"a ch IPv4\",\n    ipv6: \"a ch IPv6\",\n    cidrv4: \"di IPv4\",\n    cidrv6: \"di IPv6\",\n    base64: \"chui m ha base64\",\n    base64url: \"chui m ha base64url\",\n    json_string: \"chui JSON\",\n    e164: \"s E.164\",\n    jwt: \"JWT\",\n    template_literal: \"u vo\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `u vo khng hp l: mong i ${issue.expected}, nhn c ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1)\n          return `u vo khng hp l: mong i ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Ty chn khng hp l: mong i mt trong cc gi tr ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Qu ln: mong i ${issue.origin ?? \"gi tr\"} ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"phn t\"}`;\n        return `Qu ln: mong i ${issue.origin ?? \"gi tr\"} ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Qu nh: mong i ${issue.origin} ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `Qu nh: mong i ${issue.origin} ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `Chui khng hp l: phi bt u bng \"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return `Chui khng hp l: phi kt thc bng \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Chui khng hp l: phi bao gm \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `Chui khng hp l: phi khp vi mu ${_issue.pattern}`;\n        return `${Nouns[_issue.format] ?? issue.format} khng hp l`;\n      }\n      case \"not_multiple_of\":\n        return `S khng hp l: phi l bi s ca ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `Kha khng c nhn dng: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Kha khng hp l trong ${issue.origin}`;\n      case \"invalid_union\":\n        return \"u vo khng hp l\";\n      case \"invalid_element\":\n        return `Gi tr khng hp l trong ${issue.origin}`;\n      default:\n        return `u vo khng hp l`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/vi.ts",
        "start": 1,
        "end": 125,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 125,
          "column": 2,
          "position": 1314
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 125,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 125,
          "column": 2,
          "position": 1314
        }
      }
    },
    {
      "format": "typescript",
      "lines": 126,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"\", verb: \"\" },\n    file: { unit: \"\", verb: \"\" },\n    array: { unit: \"\", verb: \"\" },\n    set: { unit: \"\", verb: \"\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"\";\n        }\n        if (data === null) {\n          return \"\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \" \",\n    email: \"  \",\n    url: \"  \",\n    emoji: \"\",\n    uuid: \"   \",\n    uuidv4: \"     4\",\n    uuidv6: \"     6\",\n    nanoid: \"  \",\n    guid: \"   \",\n    cuid: \"   \",\n    cuid2: \"    2\",\n    ulid: \"   \",\n    xid: \"  \",\n    ksuid: \"    \",\n    datetime: \"    \",\n    date: \"   \",\n    time: \"   \",\n    duration: \"   \",\n    ipv4: \"   4 \",\n    ipv6: \"   6 \",\n    cidrv4: \"   4 \",\n    cidrv6: \"   6 \",\n    base64: \" 64   \",\n    base64url: \" 64      \",\n    json_string: \"    \",\n    e164: \" 164 \",\n    jwt: \"  \",\n    template_literal: \" \",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `  : ${issue.expected}   ${parsedType(issue.input)}  `;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `  : ${util.stringifyPrimitive(issue.values[0])}  `;\n        return ` : ${util.joinValues(issue.values, \"|\")}     `;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return ` : ${issue.origin ?? \"\"}  ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"\"}   `;\n        return ` : ${issue.origin ?? \"\"}  ${adj}${issue.maximum.toString()}   `;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return ` : ${issue.origin}  ${adj}${issue.minimum.toString()} ${sizing.unit}   `;\n        }\n\n        return ` : ${issue.origin}  ${adj}${issue.minimum.toString()}   `;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") {\n          return ` : \"${_issue.prefix}\"    `;\n        }\n        if (_issue.format === \"ends_with\") return ` : \"${_issue.suffix}\"    `;\n        if (_issue.format === \"includes\") return ` : \"${_issue.includes}\"   `;\n        if (_issue.format === \"regex\") return ` :  ${_issue.pattern}    `;\n        return ` ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return ` : ${issue.divisor}    `;\n      case \"unrecognized_keys\":\n        return `   ${issue.keys.length > 1 ? \"\" : \"\"}: ${util.joinValues(issue.keys, \" \")}`;\n      case \"invalid_key\":\n        return `${issue.origin}   `;\n      case \"invalid_union\":\n        return \"  \";\n      case \"invalid_element\":\n        return `${issue.origin}   `;\n      default:\n        return `  `;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/ur.ts",
        "start": 1,
        "end": 126,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 126,
          "column": 2,
          "position": 1326
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 126,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 126,
          "column": 2,
          "position": 1326
        }
      }
    },
    {
      "format": "typescript",
      "lines": 126,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"\", verb: \"\" },\n    file: { unit: \"\", verb: \"\" },\n    array: { unit: \"\", verb: \"\" },\n    set: { unit: \"\", verb: \"\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \" \",\n    email: \"  \",\n    url: \"URL\",\n    emoji: \"\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"   ISO\",\n    date: \" ISO\",\n    time: \" ISO\",\n    duration: \" ISO\",\n    ipv4: \" IPv4\",\n    ipv6: \" IPv6\",\n    cidrv4: \" IPv4\",\n    cidrv6: \" IPv6\",\n    base64: \"   base64\",\n    base64url: \"   base64url\",\n    json_string: \" JSON\",\n    e164: \" E.164\",\n    jwt: \"JWT\",\n    template_literal: \" \",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `  :  ${issue.expected},  ${parsedType(issue.input)}`;\n      // return `  :  ${issue.expected},  ${util.getParsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1)\n          return `  :  ${util.stringifyPrimitive(issue.values[0])}`;\n        return ` :    ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return ` : ,  ${issue.origin ?? \"\"} ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"\"}`;\n        return ` : ,  ${issue.origin ?? \"\"}  ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return ` : ,  ${issue.origin} ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return ` : ,  ${issue.origin}  ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return ` :    \"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return ` :    \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return ` :   \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return ` :    ${_issue.pattern}`;\n        return ` ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return ` :    ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return ` ${issue.keys.length > 1 ? \"\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `   ${issue.origin}`;\n      case \"invalid_union\":\n        return \"  \";\n      case \"invalid_element\":\n        return `   ${issue.origin}`;\n      default:\n        return `  `;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/ua.ts",
        "start": 1,
        "end": 126,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 126,
          "column": 2,
          "position": 1336
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 126,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 126,
          "column": 2,
          "position": 1336
        }
      }
    },
    {
      "format": "typescript",
      "lines": 121,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nexport const parsedType = (data: any): string => {\n  const t = typeof data;\n\n  switch (t) {\n    case \"number\": {\n      return Number.isNaN(data) ? \"NaN\" : \"number\";\n    }\n    case \"object\": {\n      if (Array.isArray(data)) {\n        return \"array\";\n      }\n      if (data === null) {\n        return \"null\";\n      }\n\n      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n        return data.constructor.name;\n      }\n    }\n  }\n  return t;\n};\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"karakter\", verb: \"olmal\" },\n    file: { unit: \"bayt\", verb: \"olmal\" },\n    array: { unit: \"e\", verb: \"olmal\" },\n    set: { unit: \"e\", verb: \"olmal\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"girdi\",\n    email: \"e-posta adresi\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO tarih ve saat\",\n    date: \"ISO tarih\",\n    time: \"ISO saat\",\n    duration: \"ISO sre\",\n    ipv4: \"IPv4 adresi\",\n    ipv6: \"IPv6 adresi\",\n    cidrv4: \"IPv4 aral\",\n    cidrv6: \"IPv6 aral\",\n    base64: \"base64 ile ifrelenmi metin\",\n    base64url: \"base64url ile ifrelenmi metin\",\n    json_string: \"JSON dizesi\",\n    e164: \"E.164 says\",\n    jwt: \"JWT\",\n    template_literal: \"ablon dizesi\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Geersiz deer: beklenen ${issue.expected}, alnan ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Geersiz deer: beklenen ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Geersiz seenek: aadakilerden biri olmal: ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `ok byk: beklenen ${issue.origin ?? \"deer\"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"e\"}`;\n        return `ok byk: beklenen ${issue.origin ?? \"deer\"} ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) return `ok kk: beklenen ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        return `ok kk: beklenen ${issue.origin} ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `Geersiz metin: \"${_issue.prefix}\" ile balamal`;\n        if (_issue.format === \"ends_with\") return `Geersiz metin: \"${_issue.suffix}\" ile bitmeli`;\n        if (_issue.format === \"includes\") return `Geersiz metin: \"${_issue.includes}\" iermeli`;\n        if (_issue.format === \"regex\") return `Geersiz metin: ${_issue.pattern} desenine uymal`;\n        return `Geersiz ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Geersiz say: ${issue.divisor} ile tam blnebilmeli`;\n      case \"unrecognized_keys\":\n        return `Tannmayan anahtar${issue.keys.length > 1 ? \"lar\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `${issue.origin} iinde geersiz anahtar`;\n      case \"invalid_union\":\n        return \"Geersiz deer\";\n      case \"invalid_element\":\n        return `${issue.origin} iinde geersiz deer`;\n      default:\n        return `Geersiz deer`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/tr.ts",
        "start": 1,
        "end": 121,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 121,
          "column": 2,
          "position": 1313
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/tr.ts",
        "start": 1,
        "end": 121,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 121,
          "column": 2,
          "position": 1313
        }
      }
    },
    {
      "format": "typescript",
      "lines": 126,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"\", verb: \"\" },\n    file: { unit: \"\", verb: \"\" },\n    array: { unit: \"\", verb: \"\" },\n    set: { unit: \"\", verb: \"\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \" (NaN)\" : \"\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \" (Array)\";\n        }\n        if (data === null) {\n          return \" (null)\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"\",\n    email: \"\",\n    url: \"URL\",\n    emoji: \"\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \" ISO\",\n    date: \" ISO\",\n    time: \" ISO\",\n    duration: \" ISO\",\n    ipv4: \" IPv4\",\n    ipv6: \" IPv6\",\n    cidrv4: \" IP  IPv4\",\n    cidrv6: \" IP  IPv6\",\n    base64: \" Base64\",\n    base64url: \" Base64  URL\",\n    json_string: \" JSON\",\n    e164: \" (E.164)\",\n    jwt: \" JWT\",\n    template_literal: \"\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `:  ${issue.expected}  ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `:  ${util.stringifyPrimitive(issue.values[0])}`;\n        return `:  ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"\" : \"\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `: ${issue.origin ?? \"\"} ${adj} ${issue.maximum.toString()} ${sizing.unit ?? \"\"}`;\n        return `: ${issue.origin ?? \"\"} ${adj} ${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \"\" : \"\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `: ${issue.origin} ${adj} ${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `: ${issue.origin} ${adj} ${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") {\n          return `:  \"${_issue.prefix}\"`;\n        }\n        if (_issue.format === \"ends_with\") return `:  \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `:  \"${_issue.includes}\" `;\n        if (_issue.format === \"regex\") return `:  ${_issue.pattern}`;\n        return `: ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `:  ${issue.divisor} `;\n      case \"unrecognized_keys\":\n        return `: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return ` ${issue.origin}`;\n      case \"invalid_union\":\n        return \": \";\n      case \"invalid_element\":\n        return ` ${issue.origin}`;\n      default:\n        return ``;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/th.ts",
        "start": 1,
        "end": 126,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 126,
          "column": 2,
          "position": 1311
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 126,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 126,
          "column": 2,
          "position": 1311
        }
      }
    },
    {
      "format": "typescript",
      "lines": 125,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"\", verb: \" \" },\n    file: { unit: \"\", verb: \" \" },\n    array: { unit: \"\", verb: \" \" },\n    set: { unit: \"\", verb: \" \" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \" \" : \"\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"\";\n        }\n        if (data === null) {\n          return \"\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"\",\n    email: \" \",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO  \",\n    date: \"ISO \",\n    time: \"ISO \",\n    duration: \"ISO  \",\n    ipv4: \"IPv4 \",\n    ipv6: \"IPv6 \",\n    cidrv4: \"IPv4 \",\n    cidrv6: \"IPv6 \",\n    base64: \"base64-encoded \",\n    base64url: \"base64url-encoded \",\n    json_string: \"JSON \",\n    e164: \"E.164 \",\n    jwt: \"JWT\",\n    template_literal: \"input\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return ` :  ${issue.expected},  ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return ` :  ${util.stringifyPrimitive(issue.values[0])}`;\n        return ` :  ${util.joinValues(issue.values, \"|\")}  `;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return ` :  ${issue.origin ?? \"\"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"\"}   `;\n        }\n        return ` :  ${issue.origin ?? \"\"} ${adj}${issue.maximum.toString()}   `;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return ` :  ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit}   `; //\n        }\n\n        return ` :  ${issue.origin} ${adj}${issue.minimum.toString()}   `;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return ` : \"${_issue.prefix}\"   `;\n        if (_issue.format === \"ends_with\") return ` : \"${_issue.suffix}\"   `;\n        if (_issue.format === \"includes\") return ` : \"${_issue.includes}\"   `;\n        if (_issue.format === \"regex\") return ` : ${_issue.pattern}   `;\n        return ` ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return ` : ${issue.divisor}    `;\n      case \"unrecognized_keys\":\n        return `  ${issue.keys.length > 1 ? \"\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `${issue.origin}   `;\n      case \"invalid_union\":\n        return \" \";\n      case \"invalid_element\":\n        return `${issue.origin}   `;\n      default:\n        return ` `;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/ta.ts",
        "start": 1,
        "end": 125,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 125,
          "column": 2,
          "position": 1327
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 125,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 125,
          "column": 2,
          "position": 1327
        }
      }
    },
    {
      "format": "typescript",
      "lines": 127,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"tecken\", verb: \"att ha\" },\n    file: { unit: \"bytes\", verb: \"att ha\" },\n    array: { unit: \"objekt\", verb: \"att innehlla\" },\n    set: { unit: \"objekt\", verb: \"att innehlla\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"antal\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"lista\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"reguljrt uttryck\",\n    email: \"e-postadress\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO-datum och tid\",\n    date: \"ISO-datum\",\n    time: \"ISO-tid\",\n    duration: \"ISO-varaktighet\",\n    ipv4: \"IPv4-intervall\",\n    ipv6: \"IPv6-intervall\",\n    cidrv4: \"IPv4-spektrum\",\n    cidrv6: \"IPv6-spektrum\",\n    base64: \"base64-kodad strng\",\n    base64url: \"base64url-kodad strng\",\n    json_string: \"JSON-strng\",\n    e164: \"E.164-nummer\",\n    jwt: \"JWT\",\n    template_literal: \"mall-literal\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Ogiltig inmatning: frvntat ${issue.expected}, fick ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1)\n          return `Ogiltig inmatning: frvntat ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Ogiltigt val: frvntade en av ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Fr stor(t): frvntade ${issue.origin ?? \"vrdet\"} att ha ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"element\"}`;\n        }\n        return `Fr stor(t): frvntat ${issue.origin ?? \"vrdet\"} att ha ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Fr lite(t): frvntade ${issue.origin ?? \"vrdet\"} att ha ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n        return `Fr lite(t): frvntade ${issue.origin ?? \"vrdet\"} att ha ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") {\n          return `Ogiltig strng: mste brja med \"${_issue.prefix}\"`;\n        }\n        if (_issue.format === \"ends_with\") return `Ogiltig strng: mste sluta med \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Ogiltig strng: mste innehlla \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `Ogiltig strng: mste matcha mnstret \"${_issue.pattern}\"`;\n        return `Ogiltig(t) ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Ogiltigt tal: mste vara en multipel av ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `${issue.keys.length > 1 ? \"Oknda nycklar\" : \"Oknd nyckel\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Ogiltig nyckel i ${issue.origin ?? \"vrdet\"}`;\n      case \"invalid_union\":\n        return \"Ogiltig input\";\n      case \"invalid_element\":\n        return `Ogiltigt vrde i ${issue.origin ?? \"vrdet\"}`;\n      default:\n        return `Ogiltig input`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/sv.ts",
        "start": 1,
        "end": 127,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 127,
          "column": 2,
          "position": 1347
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 127,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 127,
          "column": 2,
          "position": 1347
        }
      }
    },
    {
      "format": "typescript",
      "lines": 126,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"znakov\", verb: \"imeti\" },\n    file: { unit: \"bajtov\", verb: \"imeti\" },\n    array: { unit: \"elementov\", verb: \"imeti\" },\n    set: { unit: \"elementov\", verb: \"imeti\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"tevilo\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"tabela\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"vnos\",\n    email: \"e-potni naslov\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO datum in as\",\n    date: \"ISO datum\",\n    time: \"ISO as\",\n    duration: \"ISO trajanje\",\n    ipv4: \"IPv4 naslov\",\n    ipv6: \"IPv6 naslov\",\n    cidrv4: \"obseg IPv4\",\n    cidrv6: \"obseg IPv6\",\n    base64: \"base64 kodiran niz\",\n    base64url: \"base64url kodiran niz\",\n    json_string: \"JSON niz\",\n    e164: \"E.164 tevilka\",\n    jwt: \"JWT\",\n    template_literal: \"vnos\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Neveljaven vnos: priakovano ${issue.expected}, prejeto ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1)\n          return `Neveljaven vnos: priakovano ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Neveljavna monost: priakovano eno izmed ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Preveliko: priakovano, da bo ${issue.origin ?? \"vrednost\"} imelo ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elementov\"}`;\n        return `Preveliko: priakovano, da bo ${issue.origin ?? \"vrednost\"} ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Premajhno: priakovano, da bo ${issue.origin} imelo ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n        return `Premajhno: priakovano, da bo ${issue.origin} ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") {\n          return `Neveljaven niz: mora se zaeti z \"${_issue.prefix}\"`;\n        }\n        if (_issue.format === \"ends_with\") return `Neveljaven niz: mora se konati z \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Neveljaven niz: mora vsebovati \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;\n        return `Neveljaven ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Neveljavno tevilo: mora biti vekratnik ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `Neprepoznan${issue.keys.length > 1 ? \"i kljui\" : \" klju\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Neveljaven klju v ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Neveljaven vnos\";\n      case \"invalid_element\":\n        return `Neveljavna vrednost v ${issue.origin}`;\n      default:\n        return \"Neveljaven vnos\";\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/sl.ts",
        "start": 1,
        "end": 126,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 126,
          "column": 2,
          "position": 1326
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 126,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 126,
          "column": 2,
          "position": 1326
        }
      }
    },
    {
      "format": "typescript",
      "lines": 184,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nfunction getRussianPlural(count: number, one: string, few: string, many: string): string {\n  const absCount = Math.abs(count);\n  const lastDigit = absCount % 10;\n  const lastTwoDigits = absCount % 100;\n\n  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {\n    return many;\n  }\n\n  if (lastDigit === 1) {\n    return one;\n  }\n\n  if (lastDigit >= 2 && lastDigit <= 4) {\n    return few;\n  }\n\n  return many;\n}\n\ninterface RussianSizable {\n  unit: {\n    one: string;\n    few: string;\n    many: string;\n  };\n  verb: string;\n}\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, RussianSizable> = {\n    string: {\n      unit: {\n        one: \"\",\n        few: \"\",\n        many: \"\",\n      },\n      verb: \"\",\n    },\n    file: {\n      unit: {\n        one: \"\",\n        few: \"\",\n        many: \"\",\n      },\n      verb: \"\",\n    },\n    array: {\n      unit: {\n        one: \"\",\n        few: \"\",\n        many: \"\",\n      },\n      verb: \"\",\n    },\n    set: {\n      unit: {\n        one: \"\",\n        few: \"\",\n        many: \"\",\n      },\n      verb: \"\",\n    },\n  };\n\n  function getSizing(origin: string): RussianSizable | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"\",\n    email: \"email \",\n    url: \"URL\",\n    emoji: \"\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO   \",\n    date: \"ISO \",\n    time: \"ISO \",\n    duration: \"ISO \",\n    ipv4: \"IPv4 \",\n    ipv6: \"IPv6 \",\n    cidrv4: \"IPv4 \",\n    cidrv6: \"IPv6 \",\n    base64: \"   base64\",\n    base64url: \"   base64url\",\n    json_string: \"JSON \",\n    e164: \" E.164\",\n    jwt: \"JWT\",\n    template_literal: \"\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return ` :  ${issue.expected},  ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return ` :  ${util.stringifyPrimitive(issue.values[0])}`;\n        return ` :    ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          const maxValue = Number(issue.maximum);\n          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);\n          return `  : ,  ${issue.origin ?? \"\"}   ${adj}${issue.maximum.toString()} ${unit}`;\n        }\n        return `  : ,  ${issue.origin ?? \"\"}  ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          const minValue = Number(issue.minimum);\n          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);\n          return `  : ,  ${issue.origin}   ${adj}${issue.minimum.toString()} ${unit}`;\n        }\n        return `  : ,  ${issue.origin}  ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return ` :    \"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return ` :    \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return ` :   \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return ` :    ${_issue.pattern}`;\n        return ` ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return ` :    ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `${issue.keys.length > 1 ? \"\" : \"\"} ${issue.keys.length > 1 ? \"\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `   ${issue.origin}`;\n      case \"invalid_union\":\n        return \"  \";\n      case \"invalid_element\":\n        return `   ${issue.origin}`;\n      default:\n        return `  `;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/ru.ts",
        "start": 1,
        "end": 184,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 184,
          "column": 2,
          "position": 1736
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/ru.ts",
        "start": 1,
        "end": 184,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 184,
          "column": 2,
          "position": 1736
        }
      }
    },
    {
      "format": "typescript",
      "lines": 123,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"caracteres\", verb: \"ter\" },\n    file: { unit: \"bytes\", verb: \"ter\" },\n    array: { unit: \"itens\", verb: \"ter\" },\n    set: { unit: \"itens\", verb: \"ter\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"nmero\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"nulo\";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"padro\",\n    email: \"endereo de e-mail\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"data e hora ISO\",\n    date: \"data ISO\",\n    time: \"hora ISO\",\n    duration: \"durao ISO\",\n    ipv4: \"endereo IPv4\",\n    ipv6: \"endereo IPv6\",\n    cidrv4: \"faixa de IPv4\",\n    cidrv6: \"faixa de IPv6\",\n    base64: \"texto codificado em base64\",\n    base64url: \"URL codificada em base64\",\n    json_string: \"texto JSON\",\n    e164: \"nmero E.164\",\n    jwt: \"JWT\",\n    template_literal: \"entrada\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Tipo invlido: esperado ${issue.expected}, recebido ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Entrada invlida: esperado ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Opo invlida: esperada uma das ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Muito grande: esperado que ${issue.origin ?? \"valor\"} tivesse ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elementos\"}`;\n        return `Muito grande: esperado que ${issue.origin ?? \"valor\"} fosse ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Muito pequeno: esperado que ${issue.origin} tivesse ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `Muito pequeno: esperado que ${issue.origin} fosse ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `Texto invlido: deve comear com \"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return `Texto invlido: deve terminar com \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Texto invlido: deve incluir \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `Texto invlido: deve corresponder ao padro ${_issue.pattern}`;\n        return `${Nouns[_issue.format] ?? issue.format} invlido`;\n      }\n      case \"not_multiple_of\":\n        return `Nmero invlido: deve ser mltiplo de ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `Chave${issue.keys.length > 1 ? \"s\" : \"\"} desconhecida${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Chave invlida em ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Entrada invlida\";\n      case \"invalid_element\":\n        return `Valor invlido em ${issue.origin}`;\n      default:\n        return `Campo invlido`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/pt.ts",
        "start": 1,
        "end": 123,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 123,
          "column": 2,
          "position": 1338
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 123,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 123,
          "column": 2,
          "position": 1338
        }
      }
    },
    {
      "format": "typescript",
      "lines": 133,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"\", verb: \"\" },\n    file: { unit: \"\", verb: \"\" },\n    array: { unit: \"\", verb: \"\" },\n    set: { unit: \"\", verb: \"\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"\",\n    email: \"\",\n    url: \"  \",\n    emoji: \"\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"  \",\n    date: \"\",\n    time: \"\",\n    duration: \"\",\n    ipv4: \" IPv4 \",\n    ipv6: \" IPv6 \",\n    cidrv4: \" IPv4 \",\n    cidrv6: \" IPv6 \",\n    base64: \"base64-encoded \",\n    base64url: \"base64url-encoded \",\n    json_string: \"JSON \",\n    e164: \" E.164 \",\n    jwt: \"JWT\",\n    template_literal: \"\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return ` :  ${issue.expected} ,  ${parsedType(issue.input)}  `;\n      case \"invalid_value\":\n        if (issue.values.length === 1) {\n          return ` :  ${util.stringifyPrimitive(issue.values[0])} `;\n        }\n        return ` :    ${util.joinValues(issue.values, \"|\")}  `;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return ` : ${issue.origin ?? \"\"}  ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"\"} `;\n        }\n        return ` : ${issue.origin ?? \"\"}  ${adj}${issue.maximum.toString()} `;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return ` : ${issue.origin}  ${adj}${issue.minimum.toString()} ${sizing.unit} `;\n        }\n        return ` : ${issue.origin}  ${adj}${issue.minimum.toString()} `;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") {\n          return ` :   \"${_issue.prefix}\"   `;\n        }\n        if (_issue.format === \"ends_with\") {\n          return ` :   \"${_issue.suffix}\"    `;\n        }\n        if (_issue.format === \"includes\") {\n          return ` :  \"${_issue.includes}\" `;\n        }\n        if (_issue.format === \"regex\") {\n          return ` :   ${_issue.pattern}   `;\n        }\n        return `${Nouns[_issue.format] ?? issue.format}  `;\n      }\n      case \"not_multiple_of\":\n        return ` :   ${issue.divisor}  `;\n      case \"unrecognized_keys\":\n        return ` ${issue.keys.length > 1 ? \"\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `   ${issue.origin} `;\n      case \"invalid_union\":\n        return ` `;\n      case \"invalid_element\":\n        return `   ${issue.origin} `;\n      default:\n        return ` `;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/ps.ts",
        "start": 1,
        "end": 133,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 133,
          "column": 2,
          "position": 1353
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 133,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 133,
          "column": 2,
          "position": 1353
        }
      }
    },
    {
      "format": "typescript",
      "lines": 126,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"znakw\", verb: \"mie\" },\n    file: { unit: \"bajtw\", verb: \"mie\" },\n    array: { unit: \"elementw\", verb: \"mie\" },\n    set: { unit: \"elementw\", verb: \"mie\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"liczba\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"tablica\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"wyraenie\",\n    email: \"adres email\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"data i godzina w formacie ISO\",\n    date: \"data w formacie ISO\",\n    time: \"godzina w formacie ISO\",\n    duration: \"czas trwania ISO\",\n    ipv4: \"adres IPv4\",\n    ipv6: \"adres IPv6\",\n    cidrv4: \"zakres IPv4\",\n    cidrv6: \"zakres IPv6\",\n    base64: \"cig znakw zakodowany w formacie base64\",\n    base64url: \"cig znakw zakodowany w formacie base64url\",\n    json_string: \"cig znakw w formacie JSON\",\n    e164: \"liczba E.164\",\n    jwt: \"JWT\",\n    template_literal: \"wejcie\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Nieprawidowe dane wejciowe: oczekiwano ${issue.expected}, otrzymano ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1)\n          return `Nieprawidowe dane wejciowe: oczekiwano ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Nieprawidowa opcja: oczekiwano jednej z wartoci ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Za dua warto: oczekiwano, e ${issue.origin ?? \"warto\"} bdzie mie ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elementw\"}`;\n        }\n        return `Zbyt du(y/a/e): oczekiwano, e ${issue.origin ?? \"warto\"} bdzie wynosi ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Za maa warto: oczekiwano, e ${issue.origin ?? \"warto\"} bdzie mie ${adj}${issue.minimum.toString()} ${sizing.unit ?? \"elementw\"}`;\n        }\n        return `Zbyt ma(y/a/e): oczekiwano, e ${issue.origin ?? \"warto\"} bdzie wynosi ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\")\n          return `Nieprawidowy cig znakw: musi zaczyna si od \"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return `Nieprawidowy cig znakw: musi koczy si na \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Nieprawidowy cig znakw: musi zawiera \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `Nieprawidowy cig znakw: musi odpowiada wzorcowi ${_issue.pattern}`;\n        return `Nieprawidow(y/a/e) ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Nieprawidowa liczba: musi by wielokrotnoci ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `Nierozpoznane klucze${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Nieprawidowy klucz w ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Nieprawidowe dane wejciowe\";\n      case \"invalid_element\":\n        return `Nieprawidowa warto w ${issue.origin}`;\n      default:\n        return `Nieprawidowe dane wejciowe`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/pl.ts",
        "start": 1,
        "end": 126,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 126,
          "column": 2,
          "position": 1338
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 126,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 126,
          "column": 2,
          "position": 1338
        }
      }
    },
    {
      "format": "typescript",
      "lines": 125,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"harf\", verb: \"olmaldr\" },\n    file: { unit: \"bayt\", verb: \"olmaldr\" },\n    array: { unit: \"unsur\", verb: \"olmaldr\" },\n    set: { unit: \"unsur\", verb: \"olmaldr\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"numara\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"saf\";\n        }\n        if (data === null) {\n          return \"gayb\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"giren\",\n    email: \"epostagh\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO hengm\",\n    date: \"ISO tarihi\",\n    time: \"ISO zaman\",\n    duration: \"ISO mddeti\",\n    ipv4: \"IPv4 nin\",\n    ipv6: \"IPv6 nin\",\n    cidrv4: \"IPv4 menzili\",\n    cidrv6: \"IPv6 menzili\",\n    base64: \"base64-ifreli metin\",\n    base64url: \"base64url-ifreli metin\",\n    json_string: \"JSON metin\",\n    e164: \"E.164 says\",\n    jwt: \"JWT\",\n    template_literal: \"giren\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Fsit giren: umulan ${issue.expected}, alnan ${parsedType(issue.input)}`;\n      // return `Fsit giren: umulan ${issue.expected}, alnan ${util.getParsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Fsit giren: umulan ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Fsit tercih: mteberler ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Fazla byk: ${issue.origin ?? \"value\"}, ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elements\"} sahip olmalyd.`;\n        return `Fazla byk: ${issue.origin ?? \"value\"}, ${adj}${issue.maximum.toString()} olmalyd.`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Fazla kk: ${issue.origin}, ${adj}${issue.minimum.toString()} ${sizing.unit} sahip olmalyd.`;\n        }\n\n        return `Fazla kk: ${issue.origin}, ${adj}${issue.minimum.toString()} olmalyd.`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `Fsit metin: \"${_issue.prefix}\" ile balamal.`;\n        if (_issue.format === \"ends_with\") return `Fsit metin: \"${_issue.suffix}\" ile bitmeli.`;\n        if (_issue.format === \"includes\") return `Fsit metin: \"${_issue.includes}\" ihtiv etmeli.`;\n        if (_issue.format === \"regex\") return `Fsit metin: ${_issue.pattern} nakna uymal.`;\n        return `Fsit ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Fsit say: ${issue.divisor} kat olmalyd.`;\n      case \"unrecognized_keys\":\n        return `Tannmayan anahtar ${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `${issue.origin} iin tannmayan anahtar var.`;\n      case \"invalid_union\":\n        return \"Giren tannamad.\";\n      case \"invalid_element\":\n        return `${issue.origin} iin tannmayan kymet var.`;\n      default:\n        return `Kymet tannamad.`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/ota.ts",
        "start": 1,
        "end": 125,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 125,
          "column": 2,
          "position": 1323
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 125,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 125,
          "column": 2,
          "position": 1323
        }
      }
    },
    {
      "format": "typescript",
      "lines": 124,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"tegn\", verb: \" ha\" },\n    file: { unit: \"bytes\", verb: \" ha\" },\n    array: { unit: \"elementer\", verb: \" inneholde\" },\n    set: { unit: \"elementer\", verb: \" inneholde\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"tall\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"liste\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"input\",\n    email: \"e-postadresse\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO dato- og klokkeslett\",\n    date: \"ISO-dato\",\n    time: \"ISO-klokkeslett\",\n    duration: \"ISO-varighet\",\n    ipv4: \"IPv4-omrde\",\n    ipv6: \"IPv6-omrde\",\n    cidrv4: \"IPv4-spekter\",\n    cidrv6: \"IPv6-spekter\",\n    base64: \"base64-enkodet streng\",\n    base64url: \"base64url-enkodet streng\",\n    json_string: \"JSON-streng\",\n    e164: \"E.164-nummer\",\n    jwt: \"JWT\",\n    template_literal: \"input\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Ugyldig input: forventet ${issue.expected}, fikk ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Ugyldig verdi: forventet ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Ugyldig valg: forventet en av ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `For stor(t): forventet ${issue.origin ?? \"value\"} til  ha ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elementer\"}`;\n        return `For stor(t): forventet ${issue.origin ?? \"value\"} til  ha ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `For lite(n): forventet ${issue.origin} til  ha ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `For lite(n): forventet ${issue.origin} til  ha ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `Ugyldig streng: m starte med \"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return `Ugyldig streng: m ende med \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Ugyldig streng: m inneholde \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `Ugyldig streng: m matche mnsteret ${_issue.pattern}`;\n        return `Ugyldig ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Ugyldig tall: m vre et multiplum av ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `${issue.keys.length > 1 ? \"Ukjente nkler\" : \"Ukjent nkkel\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Ugyldig nkkel i ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Ugyldig input\";\n      case \"invalid_element\":\n        return `Ugyldig verdi i ${issue.origin}`;\n      default:\n        return `Ugyldig input`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/no.ts",
        "start": 1,
        "end": 124,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 124,
          "column": 2,
          "position": 1320
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 124,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 124,
          "column": 2,
          "position": 1320
        }
      }
    },
    {
      "format": "typescript",
      "lines": 126,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string }> = {\n    string: { unit: \"tekens\" },\n    file: { unit: \"bytes\" },\n    array: { unit: \"elementen\" },\n    set: { unit: \"elementen\" },\n  };\n\n  function getSizing(origin: string): { unit: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"getal\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"invoer\",\n    email: \"emailadres\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO datum en tijd\",\n    date: \"ISO datum\",\n    time: \"ISO tijd\",\n    duration: \"ISO duur\",\n    ipv4: \"IPv4-adres\",\n    ipv6: \"IPv6-adres\",\n    cidrv4: \"IPv4-bereik\",\n    cidrv6: \"IPv6-bereik\",\n    base64: \"base64-gecodeerde tekst\",\n    base64url: \"base64 URL-gecodeerde tekst\",\n    json_string: \"JSON string\",\n    e164: \"E.164-nummer\",\n    jwt: \"JWT\",\n    template_literal: \"invoer\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Ongeldige invoer: verwacht ${issue.expected}, ontving ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Ongeldige invoer: verwacht ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Ongeldige optie: verwacht n van ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Te lang: verwacht dat ${issue.origin ?? \"waarde\"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elementen\"} bevat`;\n        return `Te lang: verwacht dat ${issue.origin ?? \"waarde\"} ${adj}${issue.maximum.toString()} is`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Te kort: verwacht dat ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit} bevat`;\n        }\n\n        return `Te kort: verwacht dat ${issue.origin} ${adj}${issue.minimum.toString()} is`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") {\n          return `Ongeldige tekst: moet met \"${_issue.prefix}\" beginnen`;\n        }\n        if (_issue.format === \"ends_with\") return `Ongeldige tekst: moet op \"${_issue.suffix}\" eindigen`;\n        if (_issue.format === \"includes\") return `Ongeldige tekst: moet \"${_issue.includes}\" bevatten`;\n        if (_issue.format === \"regex\") return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;\n        return `Ongeldig: ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Ongeldig getal: moet een veelvoud van ${issue.divisor} zijn`;\n      case \"unrecognized_keys\":\n        return `Onbekende key${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Ongeldige key in ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Ongeldige invoer\";\n      case \"invalid_element\":\n        return `Ongeldige waarde in ${issue.origin}`;\n      default:\n        return `Ongeldige invoer`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/nl.ts",
        "start": 1,
        "end": 126,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 126,
          "column": 2,
          "position": 1290
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/nl.ts",
        "start": 1,
        "end": 126,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 126,
          "column": 2,
          "position": 1290
        }
      }
    },
    {
      "format": "typescript",
      "lines": 124,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"aksara\", verb: \"mempunyai\" },\n    file: { unit: \"bait\", verb: \"mempunyai\" },\n    array: { unit: \"elemen\", verb: \"mempunyai\" },\n    set: { unit: \"elemen\", verb: \"mempunyai\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"nombor\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"input\",\n    email: \"alamat e-mel\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"tarikh masa ISO\",\n    date: \"tarikh ISO\",\n    time: \"masa ISO\",\n    duration: \"tempoh ISO\",\n    ipv4: \"alamat IPv4\",\n    ipv6: \"alamat IPv6\",\n    cidrv4: \"julat IPv4\",\n    cidrv6: \"julat IPv6\",\n    base64: \"string dikodkan base64\",\n    base64url: \"string dikodkan base64url\",\n    json_string: \"string JSON\",\n    e164: \"nombor E.164\",\n    jwt: \"JWT\",\n    template_literal: \"input\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Input tidak sah: dijangka ${issue.expected}, diterima ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Input tidak sah: dijangka ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Pilihan tidak sah: dijangka salah satu daripada ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Terlalu besar: dijangka ${issue.origin ?? \"nilai\"} ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elemen\"}`;\n        return `Terlalu besar: dijangka ${issue.origin ?? \"nilai\"} adalah ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Terlalu kecil: dijangka ${issue.origin} ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `Terlalu kecil: dijangka ${issue.origin} adalah ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `String tidak sah: mesti bermula dengan \"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return `String tidak sah: mesti berakhir dengan \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `String tidak sah: mesti mengandungi \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;\n        return `${Nouns[_issue.format] ?? issue.format} tidak sah`;\n      }\n      case \"not_multiple_of\":\n        return `Nombor tidak sah: perlu gandaan ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `Kunci tidak dikenali: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Kunci tidak sah dalam ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Input tidak sah\";\n      case \"invalid_element\":\n        return `Nilai tidak sah dalam ${issue.origin}`;\n      default:\n        return `Input tidak sah`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/ms.ts",
        "start": 1,
        "end": 124,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 124,
          "column": 2,
          "position": 1313
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 124,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 124,
          "column": 2,
          "position": 1313
        }
      }
    },
    {
      "format": "typescript",
      "lines": 127,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"\", verb: \" \" },\n    file: { unit: \"\", verb: \" \" },\n    array: { unit: \"\", verb: \" \" },\n    set: { unit: \"\", verb: \" \" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"\",\n    email: \"  -\",\n    url: \"URL\",\n    emoji: \"\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO   \",\n    date: \"ISO \",\n    time: \"ISO \",\n    duration: \"ISO \",\n    ipv4: \"IPv4 \",\n    ipv6: \"IPv6 \",\n    cidrv4: \"IPv4 \",\n    cidrv6: \"IPv6 \",\n    base64: \"base64- \",\n    base64url: \"base64url- \",\n    json_string: \"JSON \",\n    e164: \"E.164 \",\n    jwt: \"JWT\",\n    template_literal: \"\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return ` :   ${issue.expected},  ${parsedType(issue.input)}`;\n      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Invalid input: expected ${util.stringifyPrimitive(issue.values[0])}`;\n        return ` :    ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return ` :   ${issue.origin ?? \"\"}   ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"\"}`;\n        return ` :   ${issue.origin ?? \"\"}   ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return ` :   ${issue.origin}   ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return ` :   ${issue.origin}   ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") {\n          return ` :     \"${_issue.prefix}\"`;\n        }\n        if (_issue.format === \"ends_with\") return ` :     \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return ` :    \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return ` :      ${_issue.pattern}`;\n        return `Invalid ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return ` :      ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `${issue.keys.length > 1 ? \" \" : \" \"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `   ${issue.origin}`;\n      case \"invalid_union\":\n        return \" \";\n      case \"invalid_element\":\n        return `   ${issue.origin}`;\n      default:\n        return ` `;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/mk.ts",
        "start": 1,
        "end": 127,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 127,
          "column": 2,
          "position": 1329
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 127,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 127,
          "column": 2,
          "position": 1329
        }
      }
    },
    {
      "format": "typescript",
      "lines": 131,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"\", verb: \"to have\" },\n    file: { unit: \"\", verb: \"to have\" },\n    array: { unit: \"\", verb: \"to have\" },\n    set: { unit: \"\", verb: \"to have\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"number\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"\",\n    email: \" \",\n    url: \"URL\",\n    emoji: \"\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO \",\n    date: \"ISO \",\n    time: \"ISO \",\n    duration: \"ISO \",\n    ipv4: \"IPv4 \",\n    ipv6: \"IPv6 \",\n    cidrv4: \"IPv4 \",\n    cidrv6: \"IPv6 \",\n    base64: \"base64  \",\n    base64url: \"base64url  \",\n    json_string: \"JSON \",\n    e164: \"E.164 \",\n    jwt: \"JWT\",\n    template_literal: \"\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return ` :   ${issue.expected},   ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1)\n          return ` :  ${util.stringifyPrimitive(issue.values[0])}  `;\n        return ` : ${util.joinValues(issue.values, \" \")}   `;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"\" : \"\";\n        const suffix = adj === \"\" ? \" \" : \" \";\n        const sizing = getSizing(issue.origin);\n        const unit = sizing?.unit ?? \"\";\n        if (sizing) return `${issue.origin ?? \"\"}  : ${issue.maximum.toString()}${unit} ${adj}${suffix}`;\n\n        return `${issue.origin ?? \"\"}  : ${issue.maximum.toString()} ${adj}${suffix}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \"\" : \"\";\n        const suffix = adj === \"\" ? \" \" : \" \";\n        const sizing = getSizing(issue.origin);\n        const unit = sizing?.unit ?? \"\";\n        if (sizing) {\n          return `${issue.origin ?? \"\"}  : ${issue.minimum.toString()}${unit} ${adj}${suffix}`;\n        }\n\n        return `${issue.origin ?? \"\"}  : ${issue.minimum.toString()} ${adj}${suffix}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") {\n          return ` : \"${_issue.prefix}\"()  `;\n        }\n        if (_issue.format === \"ends_with\") return ` : \"${_issue.suffix}\"()  `;\n        if (_issue.format === \"includes\") return ` : \"${_issue.includes}\"()  `;\n        if (_issue.format === \"regex\") return ` :  ${_issue.pattern}   `;\n        return ` ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return ` : ${issue.divisor}  `;\n      case \"unrecognized_keys\":\n        return `   : ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return ` : ${issue.origin}`;\n      case \"invalid_union\":\n        return ` `;\n      case \"invalid_element\":\n        return ` : ${issue.origin}`;\n      default:\n        return ` `;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/ko.ts",
        "start": 1,
        "end": 131,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 131,
          "column": 2,
          "position": 1402
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 131,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 131,
          "column": 2,
          "position": 1402
        }
      }
    },
    {
      "format": "typescript",
      "lines": 126,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"\", verb: \"\" },\n    file: { unit: \"\", verb: \"\" },\n    array: { unit: \"\", verb: \"\" },\n    set: { unit: \"\", verb: \"\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \" (NaN)\" : \"\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \" (Array)\";\n        }\n        if (data === null) {\n          return \" (null)\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"\",\n    email: \"\",\n    url: \"URL\",\n    emoji: \"\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"  ISO\",\n    date: \" ISO\",\n    time: \" ISO\",\n    duration: \" ISO\",\n    ipv4: \" IPv4\",\n    ipv6: \" IPv6\",\n    cidrv4: \" IPv4\",\n    cidrv6: \" IPv6\",\n    base64: \" base64\",\n    base64url: \" base64url\",\n    json_string: \" JSON\",\n    e164: \" E.164\",\n    jwt: \"JWT\",\n    template_literal: \"\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `  ${issue.expected}  ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `  ${util.stringifyPrimitive(issue.values[0])}`;\n        return `  ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `  ${issue.origin ?? \"\"} ${adj} ${issue.maximum.toString()} ${sizing.unit ?? \"\"}`;\n        return `  ${issue.origin ?? \"\"} ${adj} ${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `  ${issue.origin} ${adj} ${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `  ${issue.origin} ${adj} ${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") {\n          return `  \"${_issue.prefix}\"`;\n        }\n        if (_issue.format === \"ends_with\") return `  \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `  \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `  ${_issue.pattern}`;\n        return ` ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `  ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return ` ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return ` ${issue.origin}`;\n      case \"invalid_union\":\n        return ``;\n      case \"invalid_element\":\n        return ` ${issue.origin}`;\n      default:\n        return ``;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/kh.ts",
        "start": 1,
        "end": 126,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 126,
          "column": 2,
          "position": 1311
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 126,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 126,
          "column": 2,
          "position": 1311
        }
      }
    },
    {
      "format": "typescript",
      "lines": 122,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"\", verb: \"\" },\n    file: { unit: \"\", verb: \"\" },\n    array: { unit: \"\", verb: \"\" },\n    set: { unit: \"\", verb: \"\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"\",\n    email: \"\",\n    url: \"URL\",\n    emoji: \"\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO\",\n    date: \"ISO\",\n    time: \"ISO\",\n    duration: \"ISO\",\n    ipv4: \"IPv4\",\n    ipv6: \"IPv6\",\n    cidrv4: \"IPv4\",\n    cidrv6: \"IPv6\",\n    base64: \"base64\",\n    base64url: \"base64url\",\n    json_string: \"JSON\",\n    e164: \"E.164\",\n    jwt: \"JWT\",\n    template_literal: \"\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `: ${issue.expected}${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `: ${util.stringifyPrimitive(issue.values[0])}`;\n        return `: ${util.joinValues(issue.values, \"\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"\" : \"\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `: ${issue.origin ?? \"\"}${issue.maximum.toString()}${sizing.unit ?? \"\"}${adj}`;\n        return `: ${issue.origin ?? \"\"}${issue.maximum.toString()}${adj}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \"\" : \"\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `: ${issue.origin}${issue.minimum.toString()}${sizing.unit}${adj}`;\n        return `: ${issue.origin}${issue.minimum.toString()}${adj}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `: \"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return `: \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `: \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `: ${_issue.pattern}`;\n        return `${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `: ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `${issue.keys.length > 1 ? \"\" : \"\"}: ${util.joinValues(issue.keys, \"\")}`;\n      case \"invalid_key\":\n        return `${issue.origin}`;\n      case \"invalid_union\":\n        return \"\";\n      case \"invalid_element\":\n        return `${issue.origin}`;\n      default:\n        return ``;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/ja.ts",
        "start": 1,
        "end": 122,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 122,
          "column": 2,
          "position": 1312
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 122,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 122,
          "column": 2,
          "position": 1312
        }
      }
    },
    {
      "format": "typescript",
      "lines": 125,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"caratteri\", verb: \"avere\" },\n    file: { unit: \"byte\", verb: \"avere\" },\n    array: { unit: \"elementi\", verb: \"avere\" },\n    set: { unit: \"elementi\", verb: \"avere\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"numero\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"vettore\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"input\",\n    email: \"indirizzo email\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"data e ora ISO\",\n    date: \"data ISO\",\n    time: \"ora ISO\",\n    duration: \"durata ISO\",\n    ipv4: \"indirizzo IPv4\",\n    ipv6: \"indirizzo IPv6\",\n    cidrv4: \"intervallo IPv4\",\n    cidrv6: \"intervallo IPv6\",\n    base64: \"stringa codificata in base64\",\n    base64url: \"URL codificata in base64\",\n    json_string: \"stringa JSON\",\n    e164: \"numero E.164\",\n    jwt: \"JWT\",\n    template_literal: \"input\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Input non valido: atteso ${issue.expected}, ricevuto ${parsedType(issue.input)}`;\n      // return `Input non valido: atteso ${issue.expected}, ricevuto ${util.getParsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Input non valido: atteso ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Opzione non valida: atteso uno tra ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Troppo grande: ${issue.origin ?? \"valore\"} deve avere ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elementi\"}`;\n        return `Troppo grande: ${issue.origin ?? \"valore\"} deve essere ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Troppo piccolo: ${issue.origin} deve avere ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `Troppo piccolo: ${issue.origin} deve essere ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `Stringa non valida: deve iniziare con \"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return `Stringa non valida: deve terminare con \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Stringa non valida: deve includere \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;\n        return `Invalid ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Numero non valido: deve essere un multiplo di ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `Chiav${issue.keys.length > 1 ? \"i\" : \"e\"} non riconosciut${issue.keys.length > 1 ? \"e\" : \"a\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Chiave non valida in ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Input non valido\";\n      case \"invalid_element\":\n        return `Valore non valido in ${issue.origin}`;\n      default:\n        return `Input non valido`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/it.ts",
        "start": 1,
        "end": 125,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 125,
          "column": 2,
          "position": 1342
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 125,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 125,
          "column": 2,
          "position": 1342
        }
      }
    },
    {
      "format": "typescript",
      "lines": 39,
      "fragment": "export { default as ar } from \"./ar.js\";\nexport { default as az } from \"./az.js\";\nexport { default as be } from \"./be.js\";\nexport { default as ca } from \"./ca.js\";\nexport { default as cs } from \"./cs.js\";\nexport { default as de } from \"./de.js\";\nexport { default as en } from \"./en.js\";\nexport { default as eo } from \"./eo.js\";\nexport { default as es } from \"./es.js\";\nexport { default as fa } from \"./fa.js\";\nexport { default as fi } from \"./fi.js\";\nexport { default as fr } from \"./fr.js\";\nexport { default as frCA } from \"./fr-CA.js\";\nexport { default as he } from \"./he.js\";\nexport { default as hu } from \"./hu.js\";\nexport { default as id } from \"./id.js\";\nexport { default as it } from \"./it.js\";\nexport { default as ja } from \"./ja.js\";\nexport { default as kh } from \"./kh.js\";\nexport { default as ko } from \"./ko.js\";\nexport { default as mk } from \"./mk.js\";\nexport { default as ms } from \"./ms.js\";\nexport { default as nl } from \"./nl.js\";\nexport { default as no } from \"./no.js\";\nexport { default as ota } from \"./ota.js\";\nexport { default as ps } from \"./ps.js\";\nexport { default as pl } from \"./pl.js\";\nexport { default as pt } from \"./pt.js\";\nexport { default as ru } from \"./ru.js\";\nexport { default as sl } from \"./sl.js\";\nexport { default as sv } from \"./sv.js\";\nexport { default as ta } from \"./ta.js\";\nexport { default as th } from \"./th.js\";\nexport { default as tr } from \"./tr.js\";\nexport { default as ua } from \"./ua.js\";\nexport { default as ur } from \"./ur.js\";\nexport { default as vi } from \"./vi.js\";\nexport { default as zhCN } from \"./zh-CN.js\";\nexport { default as zhTW } from \"./zh-TW.js\";",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/index.ts",
        "start": 1,
        "end": 39,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 39,
          "column": 2,
          "position": 661
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/index.ts",
        "start": 1,
        "end": 39,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 39,
          "column": 2,
          "position": 661
        }
      }
    },
    {
      "format": "typescript",
      "lines": 125,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"karakter\", verb: \"memiliki\" },\n    file: { unit: \"byte\", verb: \"memiliki\" },\n    array: { unit: \"item\", verb: \"memiliki\" },\n    set: { unit: \"item\", verb: \"memiliki\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"number\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"input\",\n    email: \"alamat email\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"tanggal dan waktu format ISO\",\n    date: \"tanggal format ISO\",\n    time: \"jam format ISO\",\n    duration: \"durasi format ISO\",\n    ipv4: \"alamat IPv4\",\n    ipv6: \"alamat IPv6\",\n    cidrv4: \"rentang alamat IPv4\",\n    cidrv6: \"rentang alamat IPv6\",\n    base64: \"string dengan enkode base64\",\n    base64url: \"string dengan enkode base64url\",\n    json_string: \"string JSON\",\n    e164: \"angka E.164\",\n    jwt: \"JWT\",\n    template_literal: \"input\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Input tidak valid: diharapkan ${issue.expected}, diterima ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1)\n          return `Input tidak valid: diharapkan ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Pilihan tidak valid: diharapkan salah satu dari ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Terlalu besar: diharapkan ${issue.origin ?? \"value\"} memiliki ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elemen\"}`;\n        return `Terlalu besar: diharapkan ${issue.origin ?? \"value\"} menjadi ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Terlalu kecil: diharapkan ${issue.origin} memiliki ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `Terlalu kecil: diharapkan ${issue.origin} menjadi ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `String tidak valid: harus dimulai dengan \"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return `String tidak valid: harus berakhir dengan \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `String tidak valid: harus menyertakan \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `String tidak valid: harus sesuai pola ${_issue.pattern}`;\n        return `${Nouns[_issue.format] ?? issue.format} tidak valid`;\n      }\n      case \"not_multiple_of\":\n        return `Angka tidak valid: harus kelipatan dari ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `Kunci tidak dikenali ${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Kunci tidak valid di ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Input tidak valid\";\n      case \"invalid_element\":\n        return `Nilai tidak valid di ${issue.origin}`;\n      default:\n        return `Input tidak valid`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/id.ts",
        "start": 1,
        "end": 125,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 125,
          "column": 2,
          "position": 1321
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 125,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 125,
          "column": 2,
          "position": 1321
        }
      }
    },
    {
      "format": "typescript",
      "lines": 126,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"karakter\", verb: \"legyen\" },\n    file: { unit: \"byte\", verb: \"legyen\" },\n    array: { unit: \"elem\", verb: \"legyen\" },\n    set: { unit: \"elem\", verb: \"legyen\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"szm\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"tmb\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"bemenet\",\n    email: \"email cm\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO idblyeg\",\n    date: \"ISO dtum\",\n    time: \"ISO id\",\n    duration: \"ISO idintervallum\",\n    ipv4: \"IPv4 cm\",\n    ipv6: \"IPv6 cm\",\n    cidrv4: \"IPv4 tartomny\",\n    cidrv6: \"IPv6 tartomny\",\n    base64: \"base64-kdolt string\",\n    base64url: \"base64url-kdolt string\",\n    json_string: \"JSON string\",\n    e164: \"E.164 szm\",\n    jwt: \"JWT\",\n    template_literal: \"bemenet\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `rvnytelen bemenet: a vrt rtk ${issue.expected}, a kapott rtk ${parsedType(issue.input)}`;\n      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1)\n          return `rvnytelen bemenet: a vrt rtk ${util.stringifyPrimitive(issue.values[0])}`;\n        return `rvnytelen opci: valamelyik rtk vrt ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Tl nagy: ${issue.origin ?? \"rtk\"} mrete tl nagy ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elem\"}`;\n        return `Tl nagy: a bemeneti rtk ${issue.origin ?? \"rtk\"} tl nagy: ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Tl kicsi: a bemeneti rtk ${issue.origin} mrete tl kicsi ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `Tl kicsi: a bemeneti rtk ${issue.origin} tl kicsi ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `rvnytelen string: \"${_issue.prefix}\" rtkkel kell kezddnie`;\n        if (_issue.format === \"ends_with\") return `rvnytelen string: \"${_issue.suffix}\" rtkkel kell vgzdnie`;\n        if (_issue.format === \"includes\") return `rvnytelen string: \"${_issue.includes}\" rtket kell tartalmaznia`;\n        if (_issue.format === \"regex\") return `rvnytelen string: ${_issue.pattern} mintnak kell megfelelnie`;\n        return `rvnytelen ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `rvnytelen szm: ${issue.divisor} tbbszrsnek kell lennie`;\n      case \"unrecognized_keys\":\n        return `Ismeretlen kulcs${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `rvnytelen kulcs ${issue.origin}`;\n      case \"invalid_union\":\n        return \"rvnytelen bemenet\";\n      case \"invalid_element\":\n        return `rvnytelen rtk: ${issue.origin}`;\n      default:\n        return `rvnytelen bemenet`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/hu.ts",
        "start": 1,
        "end": 126,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 126,
          "column": 2,
          "position": 1324
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 126,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 126,
          "column": 2,
          "position": 1324
        }
      }
    },
    {
      "format": "typescript",
      "lines": 125,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"\", verb: \"\" },\n    file: { unit: \"\", verb: \"\" },\n    array: { unit: \"\", verb: \"\" },\n    set: { unit: \"\", verb: \"\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"number\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"\",\n    email: \" \",\n    url: \" \",\n    emoji: \"'\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"  ISO\",\n    date: \" ISO\",\n    time: \" ISO\",\n    duration: \"  ISO\",\n    ipv4: \" IPv4\",\n    ipv6: \" IPv6\",\n    cidrv4: \" IPv4\",\n    cidrv6: \" IPv6\",\n    base64: \"  64\",\n    base64url: \"  64  \",\n    json_string: \" JSON\",\n    e164: \" E.164\",\n    jwt: \"JWT\",\n    template_literal: \"\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `  :  ${issue.expected},  ${parsedType(issue.input)}`;\n      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `  :  ${util.stringifyPrimitive(issue.values[0])}`;\n        return `  :     ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return ` : ${issue.origin ?? \"value\"}   ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elements\"}`;\n        return ` : ${issue.origin ?? \"value\"}   ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return ` : ${issue.origin}   ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return ` : ${issue.origin}   ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `  :   \"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return `  :    \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `  :   \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `  :    ${_issue.pattern}`;\n        return `${Nouns[_issue.format] ?? issue.format}  `;\n      }\n      case \"not_multiple_of\":\n        return `  :     ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `${issue.keys.length > 1 ? \"\" : \"\"}  ${issue.keys.length > 1 ? \"\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `   ${issue.origin}`;\n      case \"invalid_union\":\n        return \"  \";\n      case \"invalid_element\":\n        return `   ${issue.origin}`;\n      default:\n        return `  `;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/he.ts",
        "start": 1,
        "end": 125,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 125,
          "column": 2,
          "position": 1342
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 125,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 125,
          "column": 2,
          "position": 1342
        }
      }
    },
    {
      "format": "typescript",
      "lines": 124,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"caractres\", verb: \"avoir\" },\n    file: { unit: \"octets\", verb: \"avoir\" },\n    array: { unit: \"lments\", verb: \"avoir\" },\n    set: { unit: \"lments\", verb: \"avoir\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"nombre\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"tableau\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"entre\",\n    email: \"adresse e-mail\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"date et heure ISO\",\n    date: \"date ISO\",\n    time: \"heure ISO\",\n    duration: \"dure ISO\",\n    ipv4: \"adresse IPv4\",\n    ipv6: \"adresse IPv6\",\n    cidrv4: \"plage IPv4\",\n    cidrv6: \"plage IPv6\",\n    base64: \"chane encode en base64\",\n    base64url: \"chane encode en base64url\",\n    json_string: \"chane JSON\",\n    e164: \"numro E.164\",\n    jwt: \"JWT\",\n    template_literal: \"entre\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Entre invalide : ${issue.expected} attendu, ${parsedType(issue.input)} reu`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Entre invalide : ${util.stringifyPrimitive(issue.values[0])} attendu`;\n        return `Option invalide : une valeur parmi ${util.joinValues(issue.values, \"|\")} attendue`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Trop grand : ${issue.origin ?? \"valeur\"} doit ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"lment(s)\"}`;\n        return `Trop grand : ${issue.origin ?? \"valeur\"} doit tre ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Trop petit : ${issue.origin} doit ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `Trop petit : ${issue.origin} doit tre ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `Chane invalide : doit commencer par \"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return `Chane invalide : doit se terminer par \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Chane invalide : doit inclure \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `Chane invalide : doit correspondre au modle ${_issue.pattern}`;\n        return `${Nouns[_issue.format] ?? issue.format} invalide`;\n      }\n      case \"not_multiple_of\":\n        return `Nombre invalide : doit tre un multiple de ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `Cl${issue.keys.length > 1 ? \"s\" : \"\"} non reconnue${issue.keys.length > 1 ? \"s\" : \"\"} : ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Cl invalide dans ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Entre invalide\";\n      case \"invalid_element\":\n        return `Valeur invalide dans ${issue.origin}`;\n      default:\n        return `Entre invalide`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/fr.ts",
        "start": 1,
        "end": 124,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 124,
          "column": 2,
          "position": 1351
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 124,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 124,
          "column": 2,
          "position": 1351
        }
      }
    },
    {
      "format": "typescript",
      "lines": 126,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"caractres\", verb: \"avoir\" },\n    file: { unit: \"octets\", verb: \"avoir\" },\n    array: { unit: \"lments\", verb: \"avoir\" },\n    set: { unit: \"lments\", verb: \"avoir\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"number\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"entre\",\n    email: \"adresse courriel\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"date-heure ISO\",\n    date: \"date ISO\",\n    time: \"heure ISO\",\n    duration: \"dure ISO\",\n    ipv4: \"adresse IPv4\",\n    ipv6: \"adresse IPv6\",\n    cidrv4: \"plage IPv4\",\n    cidrv6: \"plage IPv6\",\n    base64: \"chane encode en base64\",\n    base64url: \"chane encode en base64url\",\n    json_string: \"chane JSON\",\n    e164: \"numro E.164\",\n    jwt: \"JWT\",\n    template_literal: \"entre\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Entre invalide : attendu ${issue.expected}, reu ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Entre invalide : attendu ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Option invalide : attendu l'une des valeurs suivantes ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Trop grand : attendu que ${issue.origin ?? \"la valeur\"} ait ${adj}${issue.maximum.toString()} ${sizing.unit}`;\n        return `Trop grand : attendu que ${issue.origin ?? \"la valeur\"} soit ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \"\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Trop petit : attendu que ${issue.origin} ait ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `Trop petit : attendu que ${issue.origin} soit ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") {\n          return `Chane invalide : doit commencer par \"${_issue.prefix}\"`;\n        }\n        if (_issue.format === \"ends_with\") return `Chane invalide : doit se terminer par \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Chane invalide : doit inclure \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `Chane invalide : doit correspondre au motif ${_issue.pattern}`;\n        return `${Nouns[_issue.format] ?? issue.format} invalide`;\n      }\n      case \"not_multiple_of\":\n        return `Nombre invalide : doit tre un multiple de ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `Cl${issue.keys.length > 1 ? \"s\" : \"\"} non reconnue${issue.keys.length > 1 ? \"s\" : \"\"} : ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Cl invalide dans ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Entre invalide\";\n      case \"invalid_element\":\n        return `Valeur invalide dans ${issue.origin}`;\n      default:\n        return `Entre invalide`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/fr-CA.ts",
        "start": 1,
        "end": 126,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 126,
          "column": 2,
          "position": 1341
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 124,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 124,
          "column": 2,
          "position": 1351
        }
      }
    },
    {
      "format": "typescript",
      "lines": 131,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; subject: string }> = {\n    string: { unit: \"merkki\", subject: \"merkkijonon\" },\n    file: { unit: \"tavua\", subject: \"tiedoston\" },\n    array: { unit: \"alkiota\", subject: \"listan\" },\n    set: { unit: \"alkiota\", subject: \"joukon\" },\n    number: { unit: \"\", subject: \"luvun\" },\n    bigint: { unit: \"\", subject: \"suuren kokonaisluvun\" },\n    int: { unit: \"\", subject: \"kokonaisluvun\" },\n    date: { unit: \"\", subject: \"pivmrn\" },\n  };\n\n  function getSizing(origin: string): { unit: string; subject: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"number\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"snnllinen lauseke\",\n    email: \"shkpostiosoite\",\n    url: \"URL-osoite\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO-aikaleima\",\n    date: \"ISO-pivmr\",\n    time: \"ISO-aika\",\n    duration: \"ISO-kesto\",\n    ipv4: \"IPv4-osoite\",\n    ipv6: \"IPv6-osoite\",\n    cidrv4: \"IPv4-alue\",\n    cidrv6: \"IPv6-alue\",\n    base64: \"base64-koodattu merkkijono\",\n    base64url: \"base64url-koodattu merkkijono\",\n    json_string: \"JSON-merkkijono\",\n    e164: \"E.164-luku\",\n    jwt: \"JWT\",\n    template_literal: \"templaattimerkkijono\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Virheellinen tyyppi: odotettiin ${issue.expected}, oli ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1)\n          return `Virheellinen syte: tytyy olla ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Virheellinen valinta: tytyy olla yksi seuraavista: ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Liian suuri: ${sizing.subject} tytyy olla ${adj}${issue.maximum.toString()} ${sizing.unit}`.trim();\n        }\n        return `Liian suuri: arvon tytyy olla ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Liian pieni: ${sizing.subject} tytyy olla ${adj}${issue.minimum.toString()} ${sizing.unit}`.trim();\n        }\n        return `Liian pieni: arvon tytyy olla ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `Virheellinen syte: tytyy alkaa \"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return `Virheellinen syte: tytyy loppua \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Virheellinen syte: tytyy sislt \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") {\n          return `Virheellinen syte: tytyy vastata snnllist lauseketta ${_issue.pattern}`;\n        }\n        return `Virheellinen ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Virheellinen luku: tytyy olla luvun ${issue.divisor} monikerta`;\n      case \"unrecognized_keys\":\n        return `${issue.keys.length > 1 ? \"Tuntemattomat avaimet\" : \"Tuntematon avain\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return \"Virheellinen avain tietueessa\";\n      case \"invalid_union\":\n        return \"Virheellinen unioni\";\n      case \"invalid_element\":\n        return \"Virheellinen arvo joukossa\";\n      default:\n        return `Virheellinen syte`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/fi.ts",
        "start": 1,
        "end": 131,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 131,
          "column": 2,
          "position": 1383
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/fi.ts",
        "start": 1,
        "end": 131,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 131,
          "column": 2,
          "position": 1383
        }
      }
    },
    {
      "format": "typescript",
      "lines": 134,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"\", verb: \" \" },\n    file: { unit: \"\", verb: \" \" },\n    array: { unit: \"\", verb: \" \" },\n    set: { unit: \"\", verb: \" \" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"\",\n    email: \" \",\n    url: \"URL\",\n    emoji: \"\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"   \",\n    date: \" \",\n    time: \" \",\n    duration: \"  \",\n    ipv4: \"IPv4 \",\n    ipv6: \"IPv6 \",\n    cidrv4: \"IPv4 \",\n    cidrv6: \"IPv6 \",\n    base64: \"base64-encoded \",\n    base64url: \"base64url-encoded \",\n    json_string: \"JSON \",\n    e164: \"E.164 \",\n    jwt: \"JWT\",\n    template_literal: \"\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return ` :  ${issue.expected}  ${parsedType(issue.input)}  `;\n      case \"invalid_value\":\n        if (issue.values.length === 1) {\n          return ` :  ${util.stringifyPrimitive(issue.values[0])} `;\n        }\n        return ` :    ${util.joinValues(issue.values, \"|\")} `;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return ` : ${issue.origin ?? \"\"}  ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"\"} `;\n        }\n        return ` : ${issue.origin ?? \"\"}  ${adj}${issue.maximum.toString()} `;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return ` : ${issue.origin}  ${adj}${issue.minimum.toString()} ${sizing.unit} `;\n        }\n        return ` : ${issue.origin}  ${adj}${issue.minimum.toString()} `;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") {\n          return ` :   \"${_issue.prefix}\"  `;\n        }\n        if (_issue.format === \"ends_with\") {\n          return ` :   \"${_issue.suffix}\"  `;\n        }\n        if (_issue.format === \"includes\") {\n          return ` :   \"${_issue.includes}\" `;\n        }\n        if (_issue.format === \"regex\") {\n          return ` :    ${_issue.pattern}   `;\n        }\n        return `${Nouns[_issue.format] ?? issue.format} `;\n      }\n      case \"not_multiple_of\":\n        return ` :   ${issue.divisor} `;\n      case \"unrecognized_keys\":\n        return `${issue.keys.length > 1 ? \"\" : \"\"} : ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `   ${issue.origin}`;\n      case \"invalid_union\":\n        return ` `;\n      case \"invalid_element\":\n        return `   ${issue.origin}`;\n      default:\n        return ` `;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/fa.ts",
        "start": 1,
        "end": 134,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 134,
          "column": 2,
          "position": 1354
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 134,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 134,
          "column": 2,
          "position": 1354
        }
      }
    },
    {
      "format": "typescript",
      "lines": 125,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"caracteres\", verb: \"tener\" },\n    file: { unit: \"bytes\", verb: \"tener\" },\n    array: { unit: \"elementos\", verb: \"tener\" },\n    set: { unit: \"elementos\", verb: \"tener\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"nmero\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"arreglo\";\n        }\n        if (data === null) {\n          return \"nulo\";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"entrada\",\n    email: \"direccin de correo electrnico\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"fecha y hora ISO\",\n    date: \"fecha ISO\",\n    time: \"hora ISO\",\n    duration: \"duracin ISO\",\n    ipv4: \"direccin IPv4\",\n    ipv6: \"direccin IPv6\",\n    cidrv4: \"rango IPv4\",\n    cidrv6: \"rango IPv6\",\n    base64: \"cadena codificada en base64\",\n    base64url: \"URL codificada en base64\",\n    json_string: \"cadena JSON\",\n    e164: \"nmero E.164\",\n    jwt: \"JWT\",\n    template_literal: \"entrada\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Entrada invlida: se esperaba ${issue.expected}, recibido ${parsedType(issue.input)}`;\n      // return `Entrada invlida: se esperaba ${issue.expected}, recibido ${util.getParsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1)\n          return `Entrada invlida: se esperaba ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Opcin invlida: se esperaba una de ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Demasiado grande: se esperaba que ${issue.origin ?? \"valor\"} tuviera ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elementos\"}`;\n        return `Demasiado grande: se esperaba que ${issue.origin ?? \"valor\"} fuera ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Demasiado pequeo: se esperaba que ${issue.origin} tuviera ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `Demasiado pequeo: se esperaba que ${issue.origin} fuera ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `Cadena invlida: debe comenzar con \"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return `Cadena invlida: debe terminar en \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Cadena invlida: debe incluir \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `Cadena invlida: debe coincidir con el patrn ${_issue.pattern}`;\n        return `Invlido ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Nmero invlido: debe ser mltiplo de ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `Llave${issue.keys.length > 1 ? \"s\" : \"\"} desconocida${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Llave invlida en ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Entrada invlida\";\n      case \"invalid_element\":\n        return `Valor invlido en ${issue.origin}`;\n      default:\n        return `Entrada invlida`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/es.ts",
        "start": 1,
        "end": 125,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 125,
          "column": 2,
          "position": 1336
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 125,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 125,
          "column": 2,
          "position": 1336
        }
      }
    },
    {
      "format": "typescript",
      "lines": 125,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nexport const parsedType = (data: any): string => {\n  const t = typeof data;\n\n  switch (t) {\n    case \"number\": {\n      return Number.isNaN(data) ? \"NaN\" : \"nombro\";\n    }\n    case \"object\": {\n      if (Array.isArray(data)) {\n        return \"tabelo\";\n      }\n      if (data === null) {\n        return \"senvalora\";\n      }\n\n      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n        return data.constructor.name;\n      }\n    }\n  }\n  return t;\n};\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"karaktrojn\", verb: \"havi\" },\n    file: { unit: \"bajtojn\", verb: \"havi\" },\n    array: { unit: \"elementojn\", verb: \"havi\" },\n    set: { unit: \"elementojn\", verb: \"havi\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"enigo\",\n    email: \"retadreso\",\n    url: \"URL\",\n    emoji: \"emoio\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO-datotempo\",\n    date: \"ISO-dato\",\n    time: \"ISO-tempo\",\n    duration: \"ISO-daro\",\n    ipv4: \"IPv4-adreso\",\n    ipv6: \"IPv6-adreso\",\n    cidrv4: \"IPv4-rango\",\n    cidrv6: \"IPv6-rango\",\n    base64: \"64-ume kodita karaktraro\",\n    base64url: \"URL-64-ume kodita karaktraro\",\n    json_string: \"JSON-karaktraro\",\n    e164: \"E.164-nombro\",\n    jwt: \"JWT\",\n    template_literal: \"enigo\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Nevalida enigo: atendiis ${issue.expected}, riceviis ${parsedType(issue.input)}`;\n\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Nevalida enigo: atendiis ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Nevalida opcio: atendiis unu el ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Tro granda: atendiis ke ${issue.origin ?? \"valoro\"} havu ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elementojn\"}`;\n        return `Tro granda: atendiis ke ${issue.origin ?? \"valoro\"} havu ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Tro malgranda: atendiis ke ${issue.origin} havu ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `Tro malgranda: atendiis ke ${issue.origin} estu ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `Nevalida karaktraro: devas komencii per \"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return `Nevalida karaktraro: devas finii per \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Nevalida karaktraro: devas inkluzivi \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;\n        return `Nevalida ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Nevalida nombro: devas esti oblo de ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `Nekonata${issue.keys.length > 1 ? \"j\" : \"\"} losilo${issue.keys.length > 1 ? \"j\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Nevalida losilo en ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Nevalida enigo\";\n      case \"invalid_element\":\n        return `Nevalida valoro en ${issue.origin}`;\n      default:\n        return `Nevalida enigo`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/eo.ts",
        "start": 1,
        "end": 125,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 125,
          "column": 2,
          "position": 1340
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/tr.ts",
        "start": 1,
        "end": 125,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 125,
          "column": 2,
          "position": 1340
        }
      }
    },
    {
      "format": "typescript",
      "lines": 127,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nexport const parsedType = (data: any): string => {\n  const t = typeof data;\n\n  switch (t) {\n    case \"number\": {\n      return Number.isNaN(data) ? \"NaN\" : \"number\";\n    }\n    case \"object\": {\n      if (Array.isArray(data)) {\n        return \"array\";\n      }\n      if (data === null) {\n        return \"null\";\n      }\n\n      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n        return data.constructor.name;\n      }\n    }\n  }\n  return t;\n};\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"characters\", verb: \"to have\" },\n    file: { unit: \"bytes\", verb: \"to have\" },\n    array: { unit: \"items\", verb: \"to have\" },\n    set: { unit: \"items\", verb: \"to have\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"input\",\n    email: \"email address\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO datetime\",\n    date: \"ISO date\",\n    time: \"ISO time\",\n    duration: \"ISO duration\",\n    ipv4: \"IPv4 address\",\n    ipv6: \"IPv6 address\",\n    cidrv4: \"IPv4 range\",\n    cidrv6: \"IPv6 range\",\n    base64: \"base64-encoded string\",\n    base64url: \"base64url-encoded string\",\n    json_string: \"JSON string\",\n    e164: \"E.164 number\",\n    jwt: \"JWT\",\n    template_literal: \"input\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Invalid input: expected ${issue.expected}, received ${parsedType(issue.input)}`;\n\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Invalid input: expected ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Invalid option: expected one of ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Too big: expected ${issue.origin ?? \"value\"} to have ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elements\"}`;\n        return `Too big: expected ${issue.origin ?? \"value\"} to be ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Too small: expected ${issue.origin} to have ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `Too small: expected ${issue.origin} to be ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") {\n          return `Invalid string: must start with \"${_issue.prefix}\"`;\n        }\n        if (_issue.format === \"ends_with\") return `Invalid string: must end with \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Invalid string: must include \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `Invalid string: must match pattern ${_issue.pattern}`;\n        return `Invalid ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Invalid number: must be a multiple of ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `Unrecognized key${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Invalid key in ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Invalid input\";\n      case \"invalid_element\":\n        return `Invalid value in ${issue.origin}`;\n      default:\n        return `Invalid input`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/en.ts",
        "start": 1,
        "end": 127,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 127,
          "column": 2,
          "position": 1327
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/tr.ts",
        "start": 1,
        "end": 127,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 127,
          "column": 2,
          "position": 1327
        }
      }
    },
    {
      "format": "typescript",
      "lines": 124,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"Zeichen\", verb: \"zu haben\" },\n    file: { unit: \"Bytes\", verb: \"zu haben\" },\n    array: { unit: \"Elemente\", verb: \"zu haben\" },\n    set: { unit: \"Elemente\", verb: \"zu haben\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"Zahl\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"Array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"Eingabe\",\n    email: \"E-Mail-Adresse\",\n    url: \"URL\",\n    emoji: \"Emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO-Datum und -Uhrzeit\",\n    date: \"ISO-Datum\",\n    time: \"ISO-Uhrzeit\",\n    duration: \"ISO-Dauer\",\n    ipv4: \"IPv4-Adresse\",\n    ipv6: \"IPv6-Adresse\",\n    cidrv4: \"IPv4-Bereich\",\n    cidrv6: \"IPv6-Bereich\",\n    base64: \"Base64-codierter String\",\n    base64url: \"Base64-URL-codierter String\",\n    json_string: \"JSON-String\",\n    e164: \"E.164-Nummer\",\n    jwt: \"JWT\",\n    template_literal: \"Eingabe\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Ungltige Eingabe: erwartet ${issue.expected}, erhalten ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Ungltige Eingabe: erwartet ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Ungltige Option: erwartet eine von ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Zu gro: erwartet, dass ${issue.origin ?? \"Wert\"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"Elemente\"} hat`;\n        return `Zu gro: erwartet, dass ${issue.origin ?? \"Wert\"} ${adj}${issue.maximum.toString()} ist`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Zu klein: erwartet, dass ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit} hat`;\n        }\n\n        return `Zu klein: erwartet, dass ${issue.origin} ${adj}${issue.minimum.toString()} ist`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `Ungltiger String: muss mit \"${_issue.prefix}\" beginnen`;\n        if (_issue.format === \"ends_with\") return `Ungltiger String: muss mit \"${_issue.suffix}\" enden`;\n        if (_issue.format === \"includes\") return `Ungltiger String: muss \"${_issue.includes}\" enthalten`;\n        if (_issue.format === \"regex\") return `Ungltiger String: muss dem Muster ${_issue.pattern} entsprechen`;\n        return `Ungltig: ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Ungltige Zahl: muss ein Vielfaches von ${issue.divisor} sein`;\n      case \"unrecognized_keys\":\n        return `${issue.keys.length > 1 ? \"Unbekannte Schlssel\" : \"Unbekannter Schlssel\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Ungltiger Schlssel in ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Ungltige Eingabe\";\n      case \"invalid_element\":\n        return `Ungltiger Wert in ${issue.origin}`;\n      default:\n        return `Ungltige Eingabe`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/de.ts",
        "start": 1,
        "end": 124,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 124,
          "column": 2,
          "position": 1320
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 124,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 124,
          "column": 2,
          "position": 1320
        }
      }
    },
    {
      "format": "typescript",
      "lines": 142,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"znak\", verb: \"mt\" },\n    file: { unit: \"bajt\", verb: \"mt\" },\n    array: { unit: \"prvk\", verb: \"mt\" },\n    set: { unit: \"prvk\", verb: \"mt\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"slo\";\n      }\n      case \"string\": {\n        return \"etzec\";\n      }\n      case \"boolean\": {\n        return \"boolean\";\n      }\n      case \"bigint\": {\n        return \"bigint\";\n      }\n      case \"function\": {\n        return \"funkce\";\n      }\n      case \"symbol\": {\n        return \"symbol\";\n      }\n      case \"undefined\": {\n        return \"undefined\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"pole\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"regulrn vraz\",\n    email: \"e-mailov adresa\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"datum a as ve formtu ISO\",\n    date: \"datum ve formtu ISO\",\n    time: \"as ve formtu ISO\",\n    duration: \"doba trvn ISO\",\n    ipv4: \"IPv4 adresa\",\n    ipv6: \"IPv6 adresa\",\n    cidrv4: \"rozsah IPv4\",\n    cidrv6: \"rozsah IPv6\",\n    base64: \"etzec zakdovan ve formtu base64\",\n    base64url: \"etzec zakdovan ve formtu base64url\",\n    json_string: \"etzec ve formtu JSON\",\n    e164: \"slo E.164\",\n    jwt: \"JWT\",\n    template_literal: \"vstup\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Neplatn vstup: oekvno ${issue.expected}, obdreno ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Neplatn vstup: oekvno ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Neplatn monost: oekvna jedna z hodnot ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Hodnota je pli velk: ${issue.origin ?? \"hodnota\"} mus mt ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"prvk\"}`;\n        }\n        return `Hodnota je pli velk: ${issue.origin ?? \"hodnota\"} mus bt ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Hodnota je pli mal: ${issue.origin ?? \"hodnota\"} mus mt ${adj}${issue.minimum.toString()} ${sizing.unit ?? \"prvk\"}`;\n        }\n        return `Hodnota je pli mal: ${issue.origin ?? \"hodnota\"} mus bt ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `Neplatn etzec: mus zanat na \"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return `Neplatn etzec: mus konit na \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Neplatn etzec: mus obsahovat \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `Neplatn etzec: mus odpovdat vzoru ${_issue.pattern}`;\n        return `Neplatn formt ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Neplatn slo: mus bt nsobkem ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `Neznm kle: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Neplatn kl v ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Neplatn vstup\";\n      case \"invalid_element\":\n        return `Neplatn hodnota v ${issue.origin}`;\n      default:\n        return `Neplatn vstup`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/cs.ts",
        "start": 1,
        "end": 142,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 142,
          "column": 2,
          "position": 1419
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 142,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 142,
          "column": 2,
          "position": 1419
        }
      }
    },
    {
      "format": "typescript",
      "lines": 127,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"carcters\", verb: \"contenir\" },\n    file: { unit: \"bytes\", verb: \"contenir\" },\n    array: { unit: \"elements\", verb: \"contenir\" },\n    set: { unit: \"elements\", verb: \"contenir\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"number\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"entrada\",\n    email: \"adrea electrnica\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"data i hora ISO\",\n    date: \"data ISO\",\n    time: \"hora ISO\",\n    duration: \"durada ISO\",\n    ipv4: \"adrea IPv4\",\n    ipv6: \"adrea IPv6\",\n    cidrv4: \"rang IPv4\",\n    cidrv6: \"rang IPv6\",\n    base64: \"cadena codificada en base64\",\n    base64url: \"cadena codificada en base64url\",\n    json_string: \"cadena JSON\",\n    e164: \"nmero E.164\",\n    jwt: \"JWT\",\n    template_literal: \"entrada\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Tipus invlid: s'esperava ${issue.expected}, s'ha rebut ${parsedType(issue.input)}`;\n      // return `Tipus invlid: s'esperava ${issue.expected}, s'ha rebut ${util.getParsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Valor invlid: s'esperava ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Opci invlida: s'esperava una de ${util.joinValues(issue.values, \" o \")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"com a mxim\" : \"menys de\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Massa gran: s'esperava que ${issue.origin ?? \"el valor\"} contingus ${adj} ${issue.maximum.toString()} ${sizing.unit ?? \"elements\"}`;\n        return `Massa gran: s'esperava que ${issue.origin ?? \"el valor\"} fos ${adj} ${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \"com a mnim\" : \"ms de\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Massa petit: s'esperava que ${issue.origin} contingus ${adj} ${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `Massa petit: s'esperava que ${issue.origin} fos ${adj} ${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") {\n          return `Format invlid: ha de comenar amb \"${_issue.prefix}\"`;\n        }\n        if (_issue.format === \"ends_with\") return `Format invlid: ha d'acabar amb \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Format invlid: ha d'incloure \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `Format invlid: ha de coincidir amb el patr ${_issue.pattern}`;\n        return `Format invlid per a ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Nmero invlid: ha de ser mltiple de ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `Clau${issue.keys.length > 1 ? \"s\" : \"\"} no reconeguda${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Clau invlida a ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Entrada invlida\"; // Could also be \"Tipus d'uni invlid\" but \"Entrada invlida\" is more general\n      case \"invalid_element\":\n        return `Element invlid a ${issue.origin}`;\n      default:\n        return `Entrada invlida`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/ca.ts",
        "start": 1,
        "end": 127,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 127,
          "column": 2,
          "position": 1354
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 127,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 127,
          "column": 2,
          "position": 1354
        }
      }
    },
    {
      "format": "typescript",
      "lines": 184,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nfunction getBelarusianPlural(count: number, one: string, few: string, many: string): string {\n  const absCount = Math.abs(count);\n  const lastDigit = absCount % 10;\n  const lastTwoDigits = absCount % 100;\n\n  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {\n    return many;\n  }\n\n  if (lastDigit === 1) {\n    return one;\n  }\n\n  if (lastDigit >= 2 && lastDigit <= 4) {\n    return few;\n  }\n\n  return many;\n}\n\ninterface BelarusianSizable {\n  unit: {\n    one: string;\n    few: string;\n    many: string;\n  };\n  verb: string;\n}\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, BelarusianSizable> = {\n    string: {\n      unit: {\n        one: \"\",\n        few: \"\",\n        many: \"\",\n      },\n      verb: \"\",\n    },\n    array: {\n      unit: {\n        one: \"\",\n        few: \"\",\n        many: \"\",\n      },\n      verb: \"\",\n    },\n    set: {\n      unit: {\n        one: \"\",\n        few: \"\",\n        many: \"\",\n      },\n      verb: \"\",\n    },\n    file: {\n      unit: {\n        one: \"\",\n        few: \"\",\n        many: \"\",\n      },\n      verb: \"\",\n    },\n  };\n\n  function getSizing(origin: string): BelarusianSizable | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"\",\n    email: \"email \",\n    url: \"URL\",\n    emoji: \"\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO   \",\n    date: \"ISO \",\n    time: \"ISO \",\n    duration: \"ISO \",\n    ipv4: \"IPv4 \",\n    ipv6: \"IPv6 \",\n    cidrv4: \"IPv4 \",\n    cidrv6: \"IPv6 \",\n    base64: \"   base64\",\n    base64url: \"   base64url\",\n    json_string: \"JSON \",\n    e164: \" E.164\",\n    jwt: \"JWT\",\n    template_literal: \"\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return ` :  ${issue.expected},  ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return ` :  ${util.stringifyPrimitive(issue.values[0])}`;\n        return ` :    ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          const maxValue = Number(issue.maximum);\n          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);\n          return ` : ,  ${issue.origin ?? \"\"}  ${sizing.verb} ${adj}${issue.maximum.toString()} ${unit}`;\n        }\n        return ` : ,  ${issue.origin ?? \"\"}   ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          const minValue = Number(issue.minimum);\n          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);\n          return ` : ,  ${issue.origin}  ${sizing.verb} ${adj}${issue.minimum.toString()} ${unit}`;\n        }\n        return ` : ,  ${issue.origin}   ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return ` :    \"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return ` :    \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return ` :   \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return ` :    ${_issue.pattern}`;\n        return ` ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return ` :    ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return ` ${issue.keys.length > 1 ? \"\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `   ${issue.origin}`;\n      case \"invalid_union\":\n        return \" \";\n      case \"invalid_element\":\n        return `   ${issue.origin}`;\n      default:\n        return ` `;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/be.ts",
        "start": 1,
        "end": 184,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 184,
          "column": 2,
          "position": 1729
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/be.ts",
        "start": 1,
        "end": 184,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 184,
          "column": 2,
          "position": 1729
        }
      }
    },
    {
      "format": "typescript",
      "lines": 121,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"simvol\", verb: \"olmaldr\" },\n    file: { unit: \"bayt\", verb: \"olmaldr\" },\n    array: { unit: \"element\", verb: \"olmaldr\" },\n    set: { unit: \"element\", verb: \"olmaldr\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"number\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"input\",\n    email: \"email address\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO datetime\",\n    date: \"ISO date\",\n    time: \"ISO time\",\n    duration: \"ISO duration\",\n    ipv4: \"IPv4 address\",\n    ipv6: \"IPv6 address\",\n    cidrv4: \"IPv4 range\",\n    cidrv6: \"IPv6 range\",\n    base64: \"base64-encoded string\",\n    base64url: \"base64url-encoded string\",\n    json_string: \"JSON string\",\n    e164: \"E.164 number\",\n    jwt: \"JWT\",\n    template_literal: \"input\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Yanl dyr: gzlniln ${issue.expected}, daxil olan ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Yanl dyr: gzlniln ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Yanl seim: aadaklardan biri olmaldr: ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `ox byk: gzlniln ${issue.origin ?? \"dyr\"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"element\"}`;\n        return `ox byk: gzlniln ${issue.origin ?? \"dyr\"} ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) return `ox kiik: gzlniln ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        return `ox kiik: gzlniln ${issue.origin} ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `Yanl mtn: \"${_issue.prefix}\" il balamaldr`;\n        if (_issue.format === \"ends_with\") return `Yanl mtn: \"${_issue.suffix}\" il bitmlidir`;\n        if (_issue.format === \"includes\") return `Yanl mtn: \"${_issue.includes}\" daxil olmaldr`;\n        if (_issue.format === \"regex\") return `Yanl mtn: ${_issue.pattern} ablonuna uyun olmaldr`;\n        return `Yanl ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Yanl dd: ${issue.divisor} il bln biln olmaldr`;\n      case \"unrecognized_keys\":\n        return `Tannmayan aar${issue.keys.length > 1 ? \"lar\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `${issue.origin} daxilind yanl aar`;\n      case \"invalid_union\":\n        return \"Yanl dyr\";\n      case \"invalid_element\":\n        return `${issue.origin} daxilind yanl dyr`;\n      default:\n        return `Yanl dyr`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/az.ts",
        "start": 1,
        "end": 121,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 121,
          "column": 2,
          "position": 1313
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 121,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 121,
          "column": 2,
          "position": 1313
        }
      }
    },
    {
      "format": "typescript",
      "lines": 125,
      "fragment": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"\", verb: \" \" },\n    file: { unit: \"\", verb: \" \" },\n    array: { unit: \"\", verb: \" \" },\n    set: { unit: \"\", verb: \" \" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"number\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"\",\n    email: \" \",\n    url: \"\",\n    emoji: \"\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"   ISO\",\n    date: \"  ISO\",\n    time: \"  ISO\",\n    duration: \"  ISO\",\n    ipv4: \" IPv4\",\n    ipv6: \" IPv6\",\n    cidrv4: \"   IPv4\",\n    cidrv6: \"   IPv6\",\n    base64: \"  base64-encoded\",\n    base64url: \"  base64url-encoded\",\n    json_string: \"   JSON\",\n    e164: \"   E.164\",\n    jwt: \"JWT\",\n    template_literal: \"\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `  :   ${issue.expected}    ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1)\n          return `  :   ${util.stringifyPrimitive(issue.values[0])}`;\n        return `  :     : ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `   :    ${issue.origin ?? \"\"} ${adj} ${issue.maximum.toString()} ${sizing.unit ?? \"\"}`;\n        return `  :    ${issue.origin ?? \"\"} ${adj} ${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `  :   ${issue.origin}   ${adj} ${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `  :   ${issue.origin}   ${adj} ${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `  :     \"${issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return `  :     \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `  :    \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `  :     ${_issue.pattern}`;\n        return `${Nouns[_issue.format] ?? issue.format}  `;\n      }\n      case \"not_multiple_of\":\n        return `  :      ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `${issue.keys.length > 1 ? \"\" : \"\"} ${issue.keys.length > 1 ? \"\" : \"\"}: ${util.joinValues(issue.keys, \" \")}`;\n      case \"invalid_key\":\n        return `    ${issue.origin}`;\n      case \"invalid_union\":\n        return \"  \";\n      case \"invalid_element\":\n        return `    ${issue.origin}`;\n      default:\n        return \"  \";\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/locales/ar.ts",
        "start": 1,
        "end": 125,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 125,
          "column": 2,
          "position": 1344
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/zh-TW.ts",
        "start": 1,
        "end": 125,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 125,
          "column": 2,
          "position": 1344
        }
      }
    },
    {
      "format": "typescript",
      "lines": 323,
      "fragment": "///////////////////////////////////////////////////\n////////////////      TYPES     ///////////////////\n///////////////////////////////////////////////////\n\nexport interface $ZSF {\n  $zsf: { version: number };\n  type: string;\n  // default value if not defined\n  default: unknown;\n  // fallback value if validation fails\n  fallback: unknown;\n}\n\nexport interface $ZSFString extends $ZSF {\n  type: \"string\";\n  min_length?: number;\n  max_length?: number;\n  pattern?: string;\n}\n\nexport type NumberTypes = \"float32\" | \"int32\" | \"uint32\" | \"float64\" | \"int64\" | \"uint64\" | \"bigint\" | \"bigdecimal\";\n\nexport interface $ZSFNumber extends $ZSF {\n  type: \"number\";\n  format?: NumberTypes;\n  minimum?: number;\n  maximum?: number;\n  multiple_of?: number;\n}\n\nexport interface $ZSFBoolean extends $ZSF {\n  type: \"boolean\";\n}\n\nexport interface $ZSFNull extends $ZSF {\n  type: \"null\";\n}\n\nexport interface $ZSFUndefined extends $ZSF {\n  type: \"undefined\";\n}\n\nexport interface $ZSFOptional<T extends $ZSF = $ZSF> extends $ZSF {\n  type: \"optional\";\n  inner: T;\n}\n\nexport interface $ZSFNever extends $ZSF {\n  type: \"never\";\n}\n\nexport interface $ZSFAny extends $ZSF {\n  type: \"any\";\n}\n\n/** Supports */\nexport interface $ZSFEnum<Elements extends { [k: string]: $ZSFLiteral } = { [k: string]: $ZSFLiteral }> extends $ZSF {\n  type: \"enum\";\n  elements: Elements;\n}\n\nexport interface $ZSFArray<PrefixItems extends $ZSF[] = $ZSF[], Items extends $ZSF = $ZSF> extends $ZSF {\n  type: \"array\";\n  prefixItems: PrefixItems;\n  items: Items;\n}\n\n// type $ZSFObjectProperties = { [k: string]: $ZSF };\ntype $ZSFObjectProperties = Array<{\n  key: string;\n  value: $ZSF;\n  format?: \"literal\" | \"pattern\";\n  ordering?: number;\n}>;\nexport interface $ZSFObject<Properties extends $ZSFObjectProperties = $ZSFObjectProperties> extends $ZSF {\n  type: \"object\";\n  properties: Properties;\n}\n\n// export interface $ZSFTuple<\n//   Items extends $ZSF[] = $ZSF[],\n//   Rest extends $ZSF = $ZSF,\n// > extends $ZSF {\n//   type: \"array\";\n//   items: Items;\n//   rest: Rest;\n// }\n\n/** Supports arbitrary literal values */\nexport interface $ZSFLiteral<T extends $ZSF = $ZSF> extends $ZSF {\n  type: \"literal\";\n  schema: T;\n  value: unknown;\n}\n\nexport interface $ZSFUnion<Elements extends $ZSF[] = $ZSF[]> extends $ZSF {\n  type: \"union\";\n  elements: Elements;\n}\n\nexport interface $ZSFIntersection extends $ZSF {\n  type: \"intersection\";\n  elements: $ZSF[];\n}\n\nexport interface $ZSFMap<K extends $ZSF = $ZSF, V extends $ZSF = $ZSF> extends $ZSF {\n  type: \"map\";\n  keys: K;\n  values: V;\n}\n\nexport interface $ZSFConditional<If extends $ZSF, Then extends $ZSF, Else extends $ZSF> extends $ZSF {\n  type: \"conditional\";\n  if: If;\n  then: Then;\n  else: Else;\n}\n\n/////////////////////////////////////////////////\n////////////////      CHECKS     ////////////////\n/////////////////////////////////////////////////\n\n// export interface $ZSFCheckRegex {\n//   check: \"regex\";\n//   pattern: string;\n// }\n\n// export interface $ZSFCheckEmail {\n//   check: \"email\";\n// }\n\n// export interface $ZSFCheckURL {\n//   check: \"url\";\n// }\n\n// export interface $ZSFCheckEmoji {\n//   check: \"emoji\";\n// }\n\n// export interface $ZSFCheckUUID {\n//   check: \"uuid\";\n// }\n\n// export interface $ZSFCheckUUIDv4 {\n//   check: \"uuidv4\";\n// }\n\n// export interface $ZSFCheckUUIDv6 {\n//   check: \"uuidv6\";\n// }\n\n// export interface $ZSFCheckNanoid {\n//   check: \"nanoid\";\n// }\n\n// export interface $ZSFCheckGUID {\n//   check: \"guid\";\n// }\n\n// export interface $ZSFCheckCUID {\n//   check: \"cuid\";\n// }\n\n// export interface $ZSFCheckCUID2 {\n//   check: \"cuid2\";\n// }\n\n// export interface $ZSFCheckULID {\n//   check: \"ulid\";\n// }\n\n// export interface $ZSFCheckXID {\n//   check: \"xid\";\n// }\n\n// export interface $ZSFCheckKSUID {\n//   check: \"ksuid\";\n// }\n\n// export interface $ZSFCheckISODateTime {\n//   check: \"datetime\";\n//   precision?: number;\n//   local?: boolean;\n// }\n\n// export interface $ZSFCheckISODate {\n//   check: \"date\";\n// }\n\n// export interface $ZSFCheckISOTime {\n//   check: \"time\";\n//   precision?: number;\n//   local?: boolean;\n// }\n\n// export interface $ZSFCheckDuration {\n//   check: \"duration\";\n// }\n\n// export interface $ZSFCheckIP {\n//   check: \"ip\";\n// }\n\n// export interface $ZSFCheckIPv4 {\n//   check: \"ipv4\";\n// }\n\n// export interface $ZSFCheckIPv6 {\n//   check: \"ipv6\";\n// }\n\n// export interface $ZSFCheckBase64 {\n//   check: \"base64\";\n// }\n\n// export interface $ZSFCheckJWT {\n//   check: \"jwt\";\n// }\n\n// export interface $ZSFCheckJSONString {\n//   check: \"json_string\";\n// }\n\n// export interface $ZSFCheckPrefix {\n//   check: \"prefix\";\n//   prefix: string;\n// }\n\n// export interface $ZSFCheckSuffix {\n//   check: \"suffix\";\n//   suffix: string;\n// }\n\n// export interface $ZSFCheckIncludes {\n//   check: \"includes\";\n//   includes: string;\n// }\n\n// export interface $ZSFCheckMinSize {\n//   check: \"min_size\";\n//   minimum: number;\n// }\n\n// export interface $ZSFCheckMaxSize {\n//   check: \"max_size\";\n//   maximum: number;\n// }\n\n// export interface $ZSFCheckSizeEquals {\n//   check: \"size_equals\";\n//   size: number;\n// }\n\n// export interface $ZSFCheckLessThan {\n//   check: \"less_than\";\n//   maximum: number | bigint | Date;\n// }\n\n// export interface $ZSFCheckLessThanOrEqual {\n//   check: \"less_than_or_equal\";\n//   maximum: number | bigint | Date;\n// }\n\n// export interface $ZSFCheckGreaterThan {\n//   check: \"greater_than\";\n//   minimum: number | bigint | Date;\n// }\n\n// export interface $ZSFCheckGreaterThanOrEqual {\n//   check: \"greater_than_or_equal\";\n//   minimum: number | bigint | Date;\n// }\n\n// export interface $ZSFCheckEquals {\n//   check: \"equals\";\n//   value: number | bigint | Date;\n// }\n\n// export interface $ZSFCheckMultipleOf {\n//   check: \"multiple_of\";\n//   multipleOf: number;\n// }\n\n// export type $ZSFStringFormatChecks =\n//   | $ZSFCheckRegex\n//   | $ZSFCheckEmail\n//   | $ZSFCheckURL\n//   | $ZSFCheckEmoji\n//   | $ZSFCheckUUID\n//   | $ZSFCheckUUIDv4\n//   | $ZSFCheckUUIDv6\n//   | $ZSFCheckNanoid\n//   | $ZSFCheckGUID\n//   | $ZSFCheckCUID\n//   | $ZSFCheckCUID2\n//   | $ZSFCheckULID\n//   | $ZSFCheckXID\n//   | $ZSFCheckKSUID\n//   | $ZSFCheckISODateTime\n//   | $ZSFCheckISODate\n//   | $ZSFCheckISOTime\n//   | $ZSFCheckDuration\n//   | $ZSFCheckIP\n//   | $ZSFCheckIPv4\n//   | $ZSFCheckIPv6\n//   | $ZSFCheckBase64\n//   | $ZSFCheckJWT\n//   | $ZSFCheckJSONString\n//   | $ZSFCheckPrefix\n//   | $ZSFCheckSuffix\n//   | $ZSFCheckIncludes;\n\n// export type $ZSFCheck =\n//   | $ZSFStringFormatChecks\n//   | $ZSFCheckMinSize\n//   | $ZSFCheckMaxSize\n//   | $ZSFCheckSizeEquals\n//   | $ZSFCheckLessThan\n//   | $ZSFCheckLessThanOrEqual\n//   | $ZSFCheckGreaterThan\n//   | $ZSFCheckGreaterThanOrEqual\n//   | $ZSFCheckEquals\n//   | $ZSFCheckMultipleOf;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/core/zsf.ts",
        "start": 1,
        "end": 323,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 323,
          "column": 28,
          "position": 1236
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/zsf.ts",
        "start": 1,
        "end": 323,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 323,
          "column": 28,
          "position": 1236
        }
      }
    },
    {
      "format": "typescript",
      "lines": 775,
      "fragment": "import type * as checks from \"./checks.js\";\nimport type { $ZodConfig } from \"./core.js\";\nimport type * as errors from \"./errors.js\";\nimport type * as schemas from \"./schemas.js\";\n\n// json\nexport type JSONType = string | number | boolean | null | JSONType[] | { [key: string]: JSONType };\nexport type JWTAlgorithm =\n  | \"HS256\"\n  | \"HS384\"\n  | \"HS512\"\n  | \"RS256\"\n  | \"RS384\"\n  | \"RS512\"\n  | \"ES256\"\n  | \"ES384\"\n  | \"ES512\"\n  | \"PS256\"\n  | \"PS384\"\n  | \"PS512\"\n  | \"EdDSA\"\n  | (string & {});\nexport type IPVersion = \"v4\" | \"v6\";\nexport type MimeTypes =\n  | \"application/json\"\n  | \"application/xml\"\n  | \"application/x-www-form-urlencoded\"\n  | \"application/javascript\"\n  | \"application/pdf\"\n  | \"application/zip\"\n  | \"application/vnd.ms-excel\"\n  | \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"\n  | \"application/msword\"\n  | \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\"\n  | \"application/vnd.ms-powerpoint\"\n  | \"application/vnd.openxmlformats-officedocument.presentationml.presentation\"\n  | \"application/octet-stream\"\n  | \"application/graphql\"\n  | \"text/html\"\n  | \"text/plain\"\n  | \"text/css\"\n  | \"text/javascript\"\n  | \"text/csv\"\n  | \"image/png\"\n  | \"image/jpeg\"\n  | \"image/gif\"\n  | \"image/svg+xml\"\n  | \"image/webp\"\n  | \"audio/mpeg\"\n  | \"audio/ogg\"\n  | \"audio/wav\"\n  | \"audio/webm\"\n  | \"video/mp4\"\n  | \"video/webm\"\n  | \"video/ogg\"\n  | \"font/woff\"\n  | \"font/woff2\"\n  | \"font/ttf\"\n  | \"font/otf\"\n  | \"multipart/form-data\"\n  | (string & {});\nexport type ParsedTypes =\n  | \"string\"\n  | \"number\"\n  | \"bigint\"\n  | \"boolean\"\n  | \"symbol\"\n  | \"undefined\"\n  | \"object\"\n  | \"function\"\n  | \"file\"\n  | \"date\"\n  | \"array\"\n  | \"map\"\n  | \"set\"\n  | \"nan\"\n  | \"null\"\n  | \"promise\";\n\n// utils\nexport type AssertEqual<T, U> = (<V>() => V extends T ? 1 : 2) extends <V>() => V extends U ? 1 : 2 ? true : false;\nexport type AssertNotEqual<T, U> = (<V>() => V extends T ? 1 : 2) extends <V>() => V extends U ? 1 : 2 ? false : true;\nexport type AssertExtends<T, U> = T extends U ? T : never;\nexport type IsAny<T> = 0 extends 1 & T ? true : false;\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\nexport type OmitKeys<T, K extends string> = Pick<T, Exclude<keyof T, K>>;\nexport type MakePartial<T, K extends keyof T> = Omit<T, K> & InexactPartial<Pick<T, K>>;\nexport type MakeRequired<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;\n\nexport type Exactly<T, X> = T & Record<Exclude<keyof X, keyof T>, never>;\nexport type NoUndefined<T> = T extends undefined ? never : T;\nexport type Whatever = {} | undefined | null;\nexport type LoosePartial<T extends object> = InexactPartial<T> & {\n  [k: string]: unknown;\n};\nexport type Mask<Keys extends PropertyKey> = { [K in Keys]?: true };\nexport type Writeable<T> = { -readonly [P in keyof T]: T[P] } & {};\nexport type InexactPartial<T> = {\n  [P in keyof T]?: T[P] | undefined;\n};\nexport type EmptyObject = Record<string, never>;\nexport type BuiltIn =\n  | (((...args: any[]) => any) | (new (...args: any[]) => any))\n  | { readonly [Symbol.toStringTag]: string }\n  | Date\n  | Error\n  | Generator\n  | Promise<unknown>\n  | RegExp;\nexport type MakeReadonly<T> = T extends Map<infer K, infer V>\n  ? ReadonlyMap<K, V>\n  : T extends Set<infer V>\n    ? ReadonlySet<V>\n    : T extends [infer Head, ...infer Tail]\n      ? readonly [Head, ...Tail]\n      : T extends Array<infer V>\n        ? ReadonlyArray<V>\n        : T extends BuiltIn\n          ? T\n          : Readonly<T>;\nexport type SomeObject = Record<PropertyKey, any>;\nexport type Identity<T> = T;\nexport type Flatten<T> = Identity<{ [k in keyof T]: T[k] }>;\nexport type Mapped<T> = { [k in keyof T]: T[k] };\nexport type Prettify<T> = {\n  [K in keyof T]: T[K];\n} & {};\n\nexport type NoNeverKeys<T> = {\n  [k in keyof T]: [T[k]] extends [never] ? never : k;\n}[keyof T];\nexport type NoNever<T> = Identity<{\n  [k in NoNeverKeys<T>]: k extends keyof T ? T[k] : never;\n}>;\nexport type Extend<A extends SomeObject, B extends SomeObject> = Flatten<\n  // fast path when there is no keys overlap\n  keyof A & keyof B extends never\n    ? A & B\n    : {\n        [K in keyof A as K extends keyof B ? never : K]: A[K];\n      } & {\n        [K in keyof B]: B[K];\n      }\n>;\n\nexport type TupleItems = ReadonlyArray<schemas.SomeType>;\nexport type AnyFunc = (...args: any[]) => any;\nexport type IsProp<T, K extends keyof T> = T[K] extends AnyFunc ? never : K;\nexport type MaybeAsync<T> = T | Promise<T>;\nexport type KeyOf<T> = keyof OmitIndexSignature<T>;\nexport type OmitIndexSignature<T> = {\n  [K in keyof T as string extends K ? never : K extends string ? K : never]: T[K];\n};\nexport type ExtractIndexSignature<T> = {\n  [K in keyof T as string extends K ? K : K extends string ? never : K]: T[K];\n};\nexport type Keys<T extends object> = keyof OmitIndexSignature<T>;\n\nexport type SchemaClass<T extends schemas.SomeType> = {\n  new (def: T[\"_zod\"][\"def\"]): T;\n};\nexport type EnumValue = string | number; // | bigint | boolean | symbol;\nexport type EnumLike = Readonly<Record<string, EnumValue>>;\nexport type ToEnum<T extends EnumValue> = Flatten<{ [k in T]: k }>;\nexport type KeysEnum<T extends object> = ToEnum<Exclude<keyof T, symbol>>;\nexport type KeysArray<T extends object> = Flatten<(keyof T & string)[]>;\nexport type Literal = string | number | bigint | boolean | null | undefined;\nexport type LiteralArray = Array<Literal>;\nexport type Primitive = string | number | symbol | bigint | boolean | null | undefined;\nexport type PrimitiveArray = Array<Primitive>;\nexport type HasSize = { size: number };\nexport type HasLength = { length: number }; // string | Array<unknown> | Set<unknown> | File;\nexport type Numeric = number | bigint | Date;\nexport type SafeParseResult<T> = SafeParseSuccess<T> | SafeParseError<T>;\nexport type SafeParseSuccess<T> = { success: true; data: T; error?: never };\nexport type SafeParseError<T> = {\n  success: false;\n  data?: never;\n  error: errors.$ZodError<T>;\n};\n\nexport type PropValues = Record<string, Set<Primitive>>;\nexport type PrimitiveSet = Set<Primitive>;\n\n// functions\nexport function assertEqual<A, B>(val: AssertEqual<A, B>): AssertEqual<A, B> {\n  return val;\n}\n\nexport function assertNotEqual<A, B>(val: AssertNotEqual<A, B>): AssertNotEqual<A, B> {\n  return val;\n}\n\nexport function assertIs<T>(_arg: T): void {}\n\nexport function assertNever(_x: never): never {\n  throw new Error();\n}\nexport function assert<T>(_: any): asserts _ is T {}\n\nexport function getEnumValues(entries: EnumLike): EnumValue[] {\n  const numericValues = Object.values(entries).filter((v) => typeof v === \"number\");\n  const values = Object.entries(entries)\n    .filter(([k, _]) => numericValues.indexOf(+k) === -1)\n    .map(([_, v]) => v);\n  return values;\n}\n\nexport function joinValues<T extends Primitive[]>(array: T, separator = \"|\"): string {\n  return array.map((val) => stringifyPrimitive(val)).join(separator);\n}\n\nexport function jsonStringifyReplacer(_: string, value: any): any {\n  if (typeof value === \"bigint\") return value.toString();\n  return value;\n}\n\nexport function cached<T>(getter: () => T): { value: T } {\n  const set = false;\n  return {\n    get value() {\n      if (!set) {\n        const value = getter();\n        Object.defineProperty(this, \"value\", { value });\n        return value;\n      }\n      throw new Error(\"cached value already set\");\n    },\n  };\n}\n\nexport function nullish(input: any): boolean {\n  return input === null || input === undefined;\n}\n\nexport function cleanRegex(source: string): string {\n  const start = source.startsWith(\"^\") ? 1 : 0;\n  const end = source.endsWith(\"$\") ? source.length - 1 : source.length;\n  return source.slice(start, end);\n}\n\nexport function floatSafeRemainder(val: number, step: number): number {\n  const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n  const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n  const valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n  const stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n  return (valInt % stepInt) / 10 ** decCount;\n}\n\nexport function defineLazy<T, K extends keyof T>(object: T, key: K, getter: () => T[K]): void {\n  const set = false;\n  Object.defineProperty(object, key, {\n    get() {\n      if (!set) {\n        const value = getter();\n        object[key] = value;\n        return value;\n      }\n      throw new Error(\"cached value already set\");\n    },\n    set(v) {\n      Object.defineProperty(object, key, {\n        value: v,\n        // configurable: true,\n      });\n      // object[key] = v;\n    },\n    configurable: true,\n  });\n}\n\nexport function assignProp<T extends object, K extends PropertyKey>(\n  target: T,\n  prop: K,\n  value: K extends keyof T ? T[K] : any\n): void {\n  Object.defineProperty(target, prop, {\n    value,\n    writable: true,\n    enumerable: true,\n    configurable: true,\n  });\n}\n\nexport function getElementAtPath(obj: any, path: (string | number)[] | null | undefined): any {\n  if (!path) return obj;\n  return path.reduce((acc, key) => acc?.[key], obj);\n}\n\nexport function promiseAllObject<T extends object>(promisesObj: T): Promise<{ [k in keyof T]: Awaited<T[k]> }> {\n  const keys = Object.keys(promisesObj);\n  const promises = keys.map((key) => (promisesObj as any)[key]);\n\n  return Promise.all(promises).then((results) => {\n    const resolvedObj: any = {};\n    for (let i = 0; i < keys.length; i++) {\n      resolvedObj[keys[i]!] = results[i];\n    }\n    return resolvedObj;\n  });\n}\n\nexport function randomString(length = 10): string {\n  const chars = \"abcdefghijklmnopqrstuvwxyz\";\n  let str = \"\";\n  for (let i = 0; i < length; i++) {\n    str += chars[Math.floor(Math.random() * chars.length)];\n  }\n  return str;\n}\n\nexport function esc(str: string): string {\n  return JSON.stringify(str);\n}\n\nexport const captureStackTrace: (targetObject: object, constructorOpt?: Function) => void = Error.captureStackTrace\n  ? Error.captureStackTrace\n  : (..._args) => {};\n\nexport function isObject(data: any): data is Record<PropertyKey, unknown> {\n  return typeof data === \"object\" && data !== null && !Array.isArray(data);\n}\n\nexport const allowsEval: { value: boolean } = cached(() => {\n  if (typeof navigator !== \"undefined\" && navigator?.userAgent?.includes(\"Cloudflare\")) {\n    return false;\n  }\n\n  try {\n    const F = Function;\n    new F(\"\");\n    return true;\n  } catch (_) {\n    return false;\n  }\n});\n\nexport function isPlainObject(o: any): o is Record<PropertyKey, unknown> {\n  if (isObject(o) === false) return false;\n\n  // modified constructor\n  const ctor = o.constructor;\n  if (ctor === undefined) return true;\n\n  // modified prototype\n  const prot = ctor.prototype;\n  if (isObject(prot) === false) return false;\n\n  // ctor doesn't have static `isPrototypeOf`\n  if (Object.prototype.hasOwnProperty.call(prot, \"isPrototypeOf\") === false) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function numKeys(data: any): number {\n  let keyCount = 0;\n  for (const key in data) {\n    if (Object.prototype.hasOwnProperty.call(data, key)) {\n      keyCount++;\n    }\n  }\n  return keyCount;\n}\n\nexport const getParsedType = (data: any): ParsedTypes => {\n  const t = typeof data;\n\n  switch (t) {\n    case \"undefined\":\n      return \"undefined\";\n\n    case \"string\":\n      return \"string\";\n\n    case \"number\":\n      return Number.isNaN(data) ? \"nan\" : \"number\";\n\n    case \"boolean\":\n      return \"boolean\";\n\n    case \"function\":\n      return \"function\";\n\n    case \"bigint\":\n      return \"bigint\";\n\n    case \"symbol\":\n      return \"symbol\";\n\n    case \"object\":\n      if (Array.isArray(data)) {\n        return \"array\";\n      }\n      if (data === null) {\n        return \"null\";\n      }\n      if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n        return \"promise\";\n      }\n      if (typeof Map !== \"undefined\" && data instanceof Map) {\n        return \"map\";\n      }\n      if (typeof Set !== \"undefined\" && data instanceof Set) {\n        return \"set\";\n      }\n      if (typeof Date !== \"undefined\" && data instanceof Date) {\n        return \"date\";\n      }\n      if (typeof File !== \"undefined\" && data instanceof File) {\n        return \"file\";\n      }\n      return \"object\";\n\n    default:\n      throw new Error(`Unknown data type: ${t}`);\n  }\n};\n\nexport const propertyKeyTypes: Set<string> = new Set([\"string\", \"number\", \"symbol\"]);\nexport const primitiveTypes: Set<string> = new Set([\"string\", \"number\", \"bigint\", \"boolean\", \"symbol\", \"undefined\"]);\nexport function escapeRegex(str: string): string {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n\n// zod-specific utils\nexport function clone<T extends schemas.$ZodType>(inst: T, def?: T[\"_zod\"][\"def\"], params?: { parent: boolean }): T {\n  const cl = new inst._zod.constr(def ?? inst._zod.def);\n  if (!def || params?.parent) cl._zod.parent = inst;\n  return cl as any;\n}\n\nexport type EmptyToNever<T> = keyof T extends never ? never : T;\n\nexport type Normalize<T> = T extends undefined\n  ? never\n  : T extends Record<any, any>\n    ? Flatten<\n        {\n          [k in keyof Omit<T, \"error\" | \"message\">]: T[k];\n        } & (\"error\" extends keyof T\n          ? {\n              error?: Exclude<T[\"error\"], string>;\n              // path?: PropertyKey[] | undefined;\n              // message?: string | undefined;\n            }\n          : unknown)\n      >\n    : never;\n\nexport function normalizeParams<T>(_params: T): Normalize<T> {\n  const params: any = _params;\n\n  if (!params) return {} as any;\n  if (typeof params === \"string\") return { error: () => params } as any;\n  if (params?.message !== undefined) {\n    if (params?.error !== undefined) throw new Error(\"Cannot specify both `message` and `error` params\");\n    params.error = params.message;\n  }\n  delete params.message;\n  if (typeof params.error === \"string\") return { ...params, error: () => params.error } as any;\n  return params;\n}\n\nexport function createTransparentProxy<T extends object>(getter: () => T): T {\n  let target: T;\n  return new Proxy(\n    {},\n    {\n      get(_, prop, receiver) {\n        target ??= getter();\n        return Reflect.get(target, prop, receiver);\n      },\n      set(_, prop, value, receiver) {\n        target ??= getter();\n        return Reflect.set(target, prop, value, receiver);\n      },\n      has(_, prop) {\n        target ??= getter();\n        return Reflect.has(target, prop);\n      },\n      deleteProperty(_, prop) {\n        target ??= getter();\n        return Reflect.deleteProperty(target, prop);\n      },\n      ownKeys(_) {\n        target ??= getter();\n        return Reflect.ownKeys(target);\n      },\n      getOwnPropertyDescriptor(_, prop) {\n        target ??= getter();\n        return Reflect.getOwnPropertyDescriptor(target, prop);\n      },\n      defineProperty(_, prop, descriptor) {\n        target ??= getter();\n        return Reflect.defineProperty(target, prop, descriptor);\n      },\n    }\n  ) as T;\n}\n\nexport function stringifyPrimitive(value: any): string {\n  if (typeof value === \"bigint\") return value.toString() + \"n\";\n  if (typeof value === \"string\") return `\"${value}\"`;\n  return `${value}`;\n}\n\nexport function optionalKeys(shape: schemas.$ZodShape): string[] {\n  return Object.keys(shape).filter((k) => {\n    return shape[k]!._zod.optin === \"optional\" && shape[k]!._zod.optout === \"optional\";\n  });\n}\n\nexport type CleanKey<T extends PropertyKey> = T extends `?${infer K}` ? K : T extends `${infer K}?` ? K : T;\nexport type ToCleanMap<T extends schemas.$ZodLooseShape> = {\n  [k in keyof T]: k extends `?${infer K}` ? K : k extends `${infer K}?` ? K : k;\n};\nexport type FromCleanMap<T extends schemas.$ZodLooseShape> = {\n  [k in keyof T as k extends `?${infer K}` ? K : k extends `${infer K}?` ? K : k]: k;\n};\n\nexport const NUMBER_FORMAT_RANGES: Record<checks.$ZodNumberFormats, [number, number]> = {\n  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],\n  int32: [-2147483648, 2147483647],\n  uint32: [0, 4294967295],\n  float32: [-3.4028234663852886e38, 3.4028234663852886e38],\n  float64: [-Number.MAX_VALUE, Number.MAX_VALUE],\n};\n\nexport const BIGINT_FORMAT_RANGES: Record<checks.$ZodBigIntFormats, [bigint, bigint]> = {\n  int64: [/* @__PURE__*/ BigInt(\"-9223372036854775808\"), /* @__PURE__*/ BigInt(\"9223372036854775807\")],\n  uint64: [/* @__PURE__*/ BigInt(0), /* @__PURE__*/ BigInt(\"18446744073709551615\")],\n};\n\nexport function pick(schema: schemas.$ZodObject, mask: Record<string, unknown>): any {\n  const newShape: Writeable<schemas.$ZodShape> = {};\n  const currDef = schema._zod.def; //.shape;\n\n  for (const key in mask) {\n    if (!(key in currDef.shape)) {\n      throw new Error(`Unrecognized key: \"${key}\"`);\n    }\n    if (!mask[key]) continue;\n\n    // pick key\n    newShape[key] = currDef.shape[key]!;\n  }\n\n  return clone(schema, {\n    ...schema._zod.def,\n    shape: newShape,\n    checks: [],\n  }) as any;\n}\n\nexport function omit(schema: schemas.$ZodObject, mask: object): any {\n  const newShape: Writeable<schemas.$ZodShape> = { ...schema._zod.def.shape };\n  const currDef = schema._zod.def; //.shape;\n  for (const key in mask) {\n    if (!(key in currDef.shape)) {\n      throw new Error(`Unrecognized key: \"${key}\"`);\n    }\n    if (!(mask as any)[key]) continue;\n\n    delete newShape[key];\n  }\n  return clone(schema, {\n    ...schema._zod.def,\n    shape: newShape,\n    checks: [],\n  });\n}\n\nexport function extend(schema: schemas.$ZodObject, shape: schemas.$ZodShape): any {\n  if (!isPlainObject(shape)) {\n    throw new Error(\"Invalid input to extend: expected a plain object\");\n  }\n  const def = {\n    ...schema._zod.def,\n    get shape() {\n      const _shape = { ...schema._zod.def.shape, ...shape };\n      assignProp(this, \"shape\", _shape); // self-caching\n      return _shape;\n    },\n    checks: [], // delete existing checks\n  } as any;\n  return clone(schema, def) as any;\n}\n\nexport function merge(a: schemas.$ZodObject, b: schemas.$ZodObject): any {\n  return clone(a, {\n    ...a._zod.def,\n    get shape() {\n      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };\n      assignProp(this, \"shape\", _shape); // self-caching\n      return _shape;\n    },\n    catchall: b._zod.def.catchall,\n    checks: [], // delete existing checks\n  }) as any;\n}\n\nexport function partial(\n  Class: SchemaClass<schemas.$ZodOptional> | null,\n  schema: schemas.$ZodObject,\n  mask: object | undefined\n): any {\n  const oldShape = schema._zod.def.shape;\n  const shape: Writeable<schemas.$ZodShape> = { ...oldShape };\n\n  if (mask) {\n    for (const key in mask) {\n      if (!(key in oldShape)) {\n        throw new Error(`Unrecognized key: \"${key}\"`);\n      }\n      if (!(mask as any)[key]) continue;\n      // if (oldShape[key]!._zod.optin === \"optional\") continue;\n      shape[key] = Class\n        ? new Class({\n            type: \"optional\",\n            innerType: oldShape[key]!,\n          })\n        : oldShape[key]!;\n    }\n  } else {\n    for (const key in oldShape) {\n      // if (oldShape[key]!._zod.optin === \"optional\") continue;\n      shape[key] = Class\n        ? new Class({\n            type: \"optional\",\n            innerType: oldShape[key]!,\n          })\n        : oldShape[key]!;\n    }\n  }\n\n  return clone(schema, {\n    ...schema._zod.def,\n    shape,\n    checks: [],\n  }) as any;\n}\n\nexport function required(\n  Class: SchemaClass<schemas.$ZodNonOptional>,\n  schema: schemas.$ZodObject,\n  mask: object | undefined\n): any {\n  const oldShape = schema._zod.def.shape;\n  const shape: Writeable<schemas.$ZodShape> = { ...oldShape };\n\n  if (mask) {\n    for (const key in mask) {\n      if (!(key in shape)) {\n        throw new Error(`Unrecognized key: \"${key}\"`);\n      }\n      if (!(mask as any)[key]) continue;\n      // overwrite with non-optional\n      shape[key] = new Class({\n        type: \"nonoptional\",\n        innerType: oldShape[key]!,\n      });\n    }\n  } else {\n    for (const key in oldShape) {\n      // overwrite with non-optional\n      shape[key] = new Class({\n        type: \"nonoptional\",\n        innerType: oldShape[key]!,\n      });\n    }\n  }\n\n  return clone(schema, {\n    ...schema._zod.def,\n    shape,\n    // optional: [],\n    checks: [],\n  }) as any;\n}\n\nexport type Constructor<T, Def extends any[] = any[]> = new (...args: Def) => T;\n\nexport function aborted(x: schemas.ParsePayload, startIndex = 0): boolean {\n  for (let i = startIndex; i < x.issues.length; i++) {\n    if (x.issues[i]?.continue !== true) return true;\n  }\n  return false;\n}\n\nexport function prefixIssues(path: PropertyKey, issues: errors.$ZodRawIssue[]): errors.$ZodRawIssue[] {\n  return issues.map((iss) => {\n    (iss as any).path ??= [];\n    (iss as any).path.unshift(path);\n    return iss;\n  });\n}\n\nexport function unwrapMessage(message: string | { message: string } | undefined | null): string | undefined {\n  return typeof message === \"string\" ? message : message?.message;\n}\n\nexport function finalizeIssue(\n  iss: errors.$ZodRawIssue,\n  ctx: schemas.ParseContextInternal | undefined,\n  config: $ZodConfig\n): errors.$ZodIssue {\n  const full = { ...iss, path: iss.path ?? [] } as errors.$ZodIssue;\n\n  // for backwards compatibility\n  if (!iss.message) {\n    const message =\n      unwrapMessage(iss.inst?._zod.def?.error?.(iss as never)) ??\n      unwrapMessage(ctx?.error?.(iss as never)) ??\n      unwrapMessage(config.customError?.(iss)) ??\n      unwrapMessage(config.localeError?.(iss)) ??\n      \"Invalid input\";\n    (full as any).message = message;\n  }\n\n  // delete (full as any).def;\n  delete (full as any).inst;\n  delete (full as any).continue;\n  if (!ctx?.reportInput) {\n    delete (full as any).input;\n  }\n\n  return full;\n}\n\nexport function getSizableOrigin(input: any): \"set\" | \"map\" | \"file\" | \"unknown\" {\n  if (input instanceof Set) return \"set\";\n  if (input instanceof Map) return \"map\";\n  if (input instanceof File) return \"file\";\n  return \"unknown\";\n}\n\nexport function getLengthableOrigin(input: any): \"array\" | \"string\" | \"unknown\" {\n  if (Array.isArray(input)) return \"array\";\n  if (typeof input === \"string\") return \"string\";\n  return \"unknown\";\n}\n\n//////////    REFINES     //////////\nexport function issue(_iss: string, input: any, inst: any): errors.$ZodRawIssue;\nexport function issue(_iss: errors.$ZodRawIssue): errors.$ZodRawIssue;\nexport function issue(...args: [string | errors.$ZodRawIssue, any?, any?]): errors.$ZodRawIssue {\n  const [iss, input, inst] = args;\n  if (typeof iss === \"string\") {\n    return {\n      message: iss,\n      code: \"custom\",\n      input,\n      inst,\n    };\n  }\n\n  return { ...iss };\n}\n\nexport function cleanEnum(obj: Record<string, EnumValue>): EnumValue[] {\n  return Object.entries(obj)\n    .filter(([k, _]) => {\n      // return true if NaN, meaning it's not a number, thus a string key\n      return Number.isNaN(Number.parseInt(k, 10));\n    })\n    .map((el) => el[1]);\n}\n\n// instanceof\nexport abstract class Class {\n  constructor(..._args: any[]) {}\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/core/util.ts",
        "start": 1,
        "end": 775,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 775,
          "column": 2,
          "position": 8783
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/util.ts",
        "start": 1,
        "end": 775,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 775,
          "column": 2,
          "position": 8783
        }
      }
    },
    {
      "format": "typescript",
      "lines": 977,
      "fragment": "import type * as checks from \"./checks.js\";\nimport type * as JSONSchema from \"./json-schema.js\";\nimport { $ZodRegistry, globalRegistry } from \"./registries.js\";\nimport type * as schemas from \"./schemas.js\";\nimport { getEnumValues } from \"./util.js\";\n\ninterface JSONSchemaGeneratorParams {\n  /** A registry used to look up metadata for each schema. Any schema with an `id` property will be extracted as a $def.\n   *  @default globalRegistry */\n  metadata?: $ZodRegistry<Record<string, any>>;\n  /** The JSON Schema version to target.\n   * - `\"draft-2020-12\"`  Default. JSON Schema Draft 2020-12\n   * - `\"draft-7\"`  JSON Schema Draft 7 */\n  target?: \"draft-7\" | \"draft-2020-12\";\n  /** How to handle unrepresentable types.\n   * - `\"throw\"`  Default. Unrepresentable types throw an error\n   * - `\"any\"`  Unrepresentable types become `{}` */\n  unrepresentable?: \"throw\" | \"any\";\n  /** Arbitrary custom logic that can be used to modify the generated JSON Schema. */\n  override?: (ctx: {\n    zodSchema: schemas.$ZodTypes;\n    jsonSchema: JSONSchema.BaseSchema;\n    path: (string | number)[];\n  }) => void;\n  /** Whether to extract the `\"input\"` or `\"output\"` type. Relevant to transforms, Error converting schema to JSONz, defaults, coerced primitives, etc.\n   * - `\"output\"`  Default. Convert the output schema.\n   * - `\"input\"`  Convert the input schema. */\n  io?: \"input\" | \"output\";\n}\n\ninterface ProcessParams {\n  schemaPath: schemas.$ZodType[];\n  path: (string | number)[];\n}\n\ninterface EmitParams {\n  /** How to handle cycles.\n   * - `\"ref\"`  Default. Cycles will be broken using $defs\n   * - `\"throw\"`  Cycles will throw an error if encountered */\n  cycles?: \"ref\" | \"throw\";\n  /* How to handle reused schemas.\n   * - `\"inline\"`  Default. Reused schemas will be inlined\n   * - `\"ref\"`  Reused schemas will be extracted as $defs */\n  reused?: \"ref\" | \"inline\";\n\n  external?:\n    | {\n        /**  */\n        registry: $ZodRegistry<{ id?: string | undefined }>;\n        uri?: ((id: string) => string) | undefined;\n        defs: Record<string, JSONSchema.BaseSchema>;\n      }\n    | undefined;\n}\n\ninterface Seen {\n  /** JSON Schema result for this Zod schema */\n  schema: JSONSchema.BaseSchema;\n  /** A cached version of the schema that doesn't get overwritten during ref resolution */\n  def?: JSONSchema.BaseSchema;\n  defId?: string | undefined;\n  /** Number of times this schema was encountered during traversal */\n  count: number;\n  /** Cycle path */\n  cycle?: (string | number)[] | undefined;\n  isParent?: boolean | undefined;\n  ref?: schemas.$ZodType | undefined | null;\n  /** JSON Schema property path for this schema */\n  path?: (string | number)[] | undefined;\n}\n\nexport class JSONSchemaGenerator {\n  metadataRegistry: $ZodRegistry<Record<string, any>>;\n  target: \"draft-7\" | \"draft-2020-12\";\n  unrepresentable: \"throw\" | \"any\";\n  override: (ctx: {\n    zodSchema: schemas.$ZodTypes;\n    jsonSchema: JSONSchema.BaseSchema;\n    path: (string | number)[];\n  }) => void;\n  io: \"input\" | \"output\";\n\n  counter = 0;\n  seen: Map<schemas.$ZodType, Seen>;\n\n  constructor(params?: JSONSchemaGeneratorParams) {\n    this.metadataRegistry = params?.metadata ?? globalRegistry;\n    this.target = params?.target ?? \"draft-2020-12\";\n    this.unrepresentable = params?.unrepresentable ?? \"throw\";\n    this.override = params?.override ?? (() => {});\n    this.io = params?.io ?? \"output\";\n\n    this.seen = new Map();\n  }\n\n  process(schema: schemas.$ZodType, _params: ProcessParams = { path: [], schemaPath: [] }): JSONSchema.BaseSchema {\n    const def = (schema as schemas.$ZodTypes)._zod.def;\n\n    const formatMap: Partial<Record<checks.$ZodStringFormats, string | undefined>> = {\n      guid: \"uuid\",\n      url: \"uri\",\n      datetime: \"date-time\",\n      json_string: \"json-string\",\n      regex: \"\", // do not set\n    };\n\n    // check for schema in seens\n    const seen = this.seen.get(schema);\n\n    if (seen) {\n      seen.count++;\n\n      // check if cycle\n      const isCycle = _params.schemaPath.includes(schema);\n      if (isCycle) {\n        seen.cycle = _params.path;\n      }\n\n      return seen.schema;\n    }\n\n    // initialize\n    const result: Seen = { schema: {}, count: 1, cycle: undefined, path: _params.path };\n    this.seen.set(schema, result);\n\n    // custom method overrides default behavior\n    const overrideSchema = schema._zod.toJSONSchema?.();\n    if (overrideSchema) {\n      result.schema = overrideSchema as any;\n    } else {\n      const params = {\n        ..._params,\n        schemaPath: [..._params.schemaPath, schema],\n        path: _params.path,\n      };\n\n      const parent = schema._zod.parent;\n\n      if (parent) {\n        // schema was cloned from another schema\n        result.ref = parent;\n        this.process(parent, params);\n        this.seen.get(parent)!.isParent = true;\n      } else {\n        const _json = result.schema;\n        switch (def.type) {\n          case \"string\": {\n            const json: JSONSchema.StringSchema = _json as any;\n            json.type = \"string\";\n            const { minimum, maximum, format, patterns, contentEncoding } = schema._zod\n              .bag as schemas.$ZodStringInternals<unknown>[\"bag\"];\n            if (typeof minimum === \"number\") json.minLength = minimum;\n            if (typeof maximum === \"number\") json.maxLength = maximum;\n            // custom pattern overrides format\n            if (format) {\n              json.format = formatMap[format as checks.$ZodStringFormats] ?? format;\n              if (json.format === \"\") delete json.format; // empty format is not valid\n            }\n            if (contentEncoding) json.contentEncoding = contentEncoding;\n            if (patterns && patterns.size > 0) {\n              const regexes = [...patterns];\n              if (regexes.length === 1) json.pattern = regexes[0]!.source;\n              else if (regexes.length > 1) {\n                result.schema.allOf = [\n                  ...regexes.map((regex) => ({\n                    ...(this.target === \"draft-7\" ? ({ type: \"string\" } as const) : {}),\n                    pattern: regex.source,\n                  })),\n                ];\n              }\n            }\n\n            break;\n          }\n          case \"number\": {\n            const json: JSONSchema.NumberSchema | JSONSchema.IntegerSchema = _json as any;\n            const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;\n            if (typeof format === \"string\" && format.includes(\"int\")) json.type = \"integer\";\n            else json.type = \"number\";\n\n            if (typeof exclusiveMinimum === \"number\") json.exclusiveMinimum = exclusiveMinimum;\n            if (typeof minimum === \"number\") {\n              json.minimum = minimum;\n              if (typeof exclusiveMinimum === \"number\") {\n                if (exclusiveMinimum >= minimum) delete json.minimum;\n                else delete json.exclusiveMinimum;\n              }\n            }\n\n            if (typeof exclusiveMaximum === \"number\") json.exclusiveMaximum = exclusiveMaximum;\n            if (typeof maximum === \"number\") {\n              json.maximum = maximum;\n              if (typeof exclusiveMaximum === \"number\") {\n                if (exclusiveMaximum <= maximum) delete json.maximum;\n                else delete json.exclusiveMaximum;\n              }\n            }\n\n            if (typeof multipleOf === \"number\") json.multipleOf = multipleOf;\n\n            break;\n          }\n          case \"boolean\": {\n            const json = _json as JSONSchema.BooleanSchema;\n            json.type = \"boolean\";\n            break;\n          }\n          case \"bigint\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"BigInt cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          case \"symbol\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"Symbols cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          case \"null\": {\n            _json.type = \"null\";\n            break;\n          }\n          case \"any\": {\n            break;\n          }\n          case \"unknown\": {\n            break;\n          }\n          case \"undefined\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"Undefined cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          case \"void\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"Void cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          case \"never\": {\n            _json.not = {};\n            break;\n          }\n          case \"date\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"Date cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          case \"array\": {\n            const json: JSONSchema.ArraySchema = _json as any;\n            const { minimum, maximum } = schema._zod.bag;\n            if (typeof minimum === \"number\") json.minItems = minimum;\n            if (typeof maximum === \"number\") json.maxItems = maximum;\n\n            json.type = \"array\";\n            json.items = this.process(def.element, { ...params, path: [...params.path, \"items\"] });\n            break;\n          }\n          case \"object\": {\n            const json: JSONSchema.ObjectSchema = _json as any;\n            json.type = \"object\";\n            json.properties = {};\n            const shape = def.shape; // params.shapeCache.get(schema)!;\n\n            for (const key in shape) {\n              json.properties[key] = this.process(shape[key]!, {\n                ...params,\n                path: [...params.path, \"properties\", key],\n              });\n            }\n\n            // required keys\n            const allKeys = new Set(Object.keys(shape));\n            // const optionalKeys = new Set(def.optional);\n            const requiredKeys = new Set(\n              [...allKeys].filter((key) => {\n                const v = def.shape[key]!._zod;\n                if (this.io === \"input\") {\n                  return v.optin === undefined;\n                } else {\n                  return v.optout === undefined;\n                }\n              })\n            );\n\n            if (requiredKeys.size > 0) {\n              json.required = Array.from(requiredKeys);\n            }\n\n            // catchall\n            if (def.catchall?._zod.def.type === \"never\") {\n              // strict\n              json.additionalProperties = false;\n            } else if (!def.catchall) {\n              // regular\n              if (this.io === \"output\") json.additionalProperties = false;\n            } else if (def.catchall) {\n              json.additionalProperties = this.process(def.catchall, {\n                ...params,\n                path: [...params.path, \"additionalProperties\"],\n              });\n            }\n\n            break;\n          }\n          case \"union\": {\n            const json: JSONSchema.BaseSchema = _json as any;\n            json.anyOf = def.options.map((x, i) =>\n              this.process(x, {\n                ...params,\n                path: [...params.path, \"anyOf\", i],\n              })\n            );\n            break;\n          }\n          case \"intersection\": {\n            const json: JSONSchema.BaseSchema = _json as any;\n            const a = this.process(def.left, {\n              ...params,\n              path: [...params.path, \"allOf\", 0],\n            });\n            const b = this.process(def.right, {\n              ...params,\n              path: [...params.path, \"allOf\", 1],\n            });\n\n            const isSimpleIntersection = (val: any) => \"allOf\" in val && Object.keys(val).length === 1;\n            const allOf = [\n              ...(isSimpleIntersection(a) ? (a.allOf as any[]) : [a]),\n              ...(isSimpleIntersection(b) ? (b.allOf as any[]) : [b]),\n            ];\n            json.allOf = allOf;\n            break;\n          }\n          case \"tuple\": {\n            const json: JSONSchema.ArraySchema = _json as any;\n            json.type = \"array\";\n            const prefixItems = def.items.map((x, i) =>\n              this.process(x, { ...params, path: [...params.path, \"prefixItems\", i] })\n            );\n            if (this.target === \"draft-2020-12\") {\n              json.prefixItems = prefixItems;\n            } else {\n              json.items = prefixItems;\n            }\n\n            if (def.rest) {\n              const rest = this.process(def.rest, {\n                ...params,\n                path: [...params.path, \"items\"],\n              });\n              if (this.target === \"draft-2020-12\") {\n                json.items = rest;\n              } else {\n                json.additionalItems = rest;\n              }\n            }\n\n            // additionalItems\n            if (def.rest) {\n              json.items = this.process(def.rest, {\n                ...params,\n                path: [...params.path, \"items\"],\n              });\n            }\n\n            // length\n            const { minimum, maximum } = schema._zod.bag as {\n              minimum?: number;\n              maximum?: number;\n            };\n            if (typeof minimum === \"number\") json.minItems = minimum;\n            if (typeof maximum === \"number\") json.maxItems = maximum;\n            break;\n          }\n          case \"record\": {\n            const json: JSONSchema.ObjectSchema = _json as any;\n            json.type = \"object\";\n            json.propertyNames = this.process(def.keyType, { ...params, path: [...params.path, \"propertyNames\"] });\n            json.additionalProperties = this.process(def.valueType, {\n              ...params,\n              path: [...params.path, \"additionalProperties\"],\n            });\n            break;\n          }\n          case \"map\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"Map cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          case \"set\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"Set cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          case \"enum\": {\n            const json: JSONSchema.BaseSchema = _json as any;\n            const values = getEnumValues(def.entries);\n            // Number enums can have both string and number values\n            if (values.every((v) => typeof v === \"number\")) json.type = \"number\";\n            if (values.every((v) => typeof v === \"string\")) json.type = \"string\";\n            json.enum = values;\n            break;\n          }\n          case \"literal\": {\n            const json: JSONSchema.BaseSchema = _json as any;\n            const vals: (string | number | boolean | null)[] = [];\n            for (const val of def.values) {\n              if (val === undefined) {\n                if (this.unrepresentable === \"throw\") {\n                  throw new Error(\"Literal `undefined` cannot be represented in JSON Schema\");\n                } else {\n                  // do not add to vals\n                }\n              } else if (typeof val === \"bigint\") {\n                if (this.unrepresentable === \"throw\") {\n                  throw new Error(\"BigInt literals cannot be represented in JSON Schema\");\n                } else {\n                  vals.push(Number(val));\n                }\n              } else {\n                vals.push(val);\n              }\n            }\n            if (vals.length === 0) {\n              // do nothing (an undefined literal was stripped)\n            } else if (vals.length === 1) {\n              const val = vals[0]!;\n              json.type = val === null ? (\"null\" as const) : (typeof val as any);\n              json.const = val;\n            } else {\n              if (vals.every((v) => typeof v === \"number\")) json.type = \"number\";\n              if (vals.every((v) => typeof v === \"string\")) json.type = \"string\";\n              if (vals.every((v) => typeof v === \"boolean\")) json.type = \"string\";\n              if (vals.every((v) => v === null)) json.type = \"null\";\n              json.enum = vals;\n            }\n            break;\n          }\n\n          case \"file\": {\n            const json: JSONSchema.StringSchema = _json as any;\n            const file: JSONSchema.StringSchema = {\n              type: \"string\",\n              format: \"binary\",\n              contentEncoding: \"binary\",\n            };\n\n            const { minimum, maximum, mime } = schema._zod.bag as schemas.$ZodFileInternals[\"bag\"];\n            if (minimum !== undefined) file.minLength = minimum;\n            if (maximum !== undefined) file.maxLength = maximum;\n            if (mime) {\n              if (mime.length === 1) {\n                file.contentMediaType = mime[0]!;\n                Object.assign(json, file);\n              } else {\n                json.anyOf = mime.map((m) => {\n                  const mFile: JSONSchema.StringSchema = { ...file, contentMediaType: m };\n                  return mFile;\n                });\n              }\n            } else {\n              Object.assign(json, file);\n            }\n\n            // if (this.unrepresentable === \"throw\") {\n            //   throw new Error(\"File cannot be represented in JSON Schema\");\n            // }\n            break;\n          }\n          case \"transform\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"Transforms cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n\n          case \"nullable\": {\n            const inner = this.process(def.innerType, params);\n            _json.anyOf = [inner, { type: \"null\" }];\n            break;\n          }\n          case \"nonoptional\": {\n            this.process(def.innerType, params);\n            result.ref = def.innerType;\n            break;\n          }\n          case \"success\": {\n            const json = _json as JSONSchema.BooleanSchema;\n            json.type = \"boolean\";\n            break;\n          }\n          case \"default\": {\n            this.process(def.innerType, params);\n            result.ref = def.innerType;\n            _json.default = JSON.parse(JSON.stringify(def.defaultValue));\n            break;\n          }\n          case \"prefault\": {\n            this.process(def.innerType, params);\n            result.ref = def.innerType;\n            if (this.io === \"input\") _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));\n\n            break;\n          }\n          case \"catch\": {\n            // use conditionals\n            this.process(def.innerType, params);\n            result.ref = def.innerType;\n            let catchValue: any;\n            try {\n              catchValue = def.catchValue(undefined as any);\n            } catch {\n              throw new Error(\"Dynamic catch values are not supported in JSON Schema\");\n            }\n            _json.default = catchValue;\n            break;\n          }\n          case \"nan\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"NaN cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          case \"template_literal\": {\n            const json = _json as JSONSchema.StringSchema;\n            const pattern = schema._zod.pattern;\n            if (!pattern) throw new Error(\"Pattern not found in template literal\");\n            json.type = \"string\";\n            json.pattern = pattern.source;\n            break;\n          }\n          case \"pipe\": {\n            const innerType = this.io === \"input\" ? (def.in._zod.def.type === \"transform\" ? def.out : def.in) : def.out;\n            this.process(innerType, params);\n            result.ref = innerType;\n            break;\n          }\n          case \"readonly\": {\n            this.process(def.innerType, params);\n            result.ref = def.innerType;\n            _json.readOnly = true;\n            break;\n          }\n          // passthrough types\n          case \"promise\": {\n            this.process(def.innerType, params);\n            result.ref = def.innerType;\n            break;\n          }\n          case \"optional\": {\n            this.process(def.innerType, params);\n            result.ref = def.innerType;\n            break;\n          }\n          case \"lazy\": {\n            const innerType = (schema as schemas.$ZodLazy)._zod.innerType;\n            this.process(innerType, params);\n            result.ref = innerType;\n            break;\n          }\n          case \"custom\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"Custom types cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          default: {\n            def satisfies never;\n          }\n        }\n      }\n    }\n\n    // metadata\n    const meta = this.metadataRegistry.get(schema);\n    if (meta) Object.assign(result.schema, meta);\n\n    if (this.io === \"input\" && isTransforming(schema)) {\n      // examples/defaults only apply to output type of pipe\n      delete result.schema.examples;\n      delete result.schema.default;\n    }\n\n    // set prefault as default\n    if (this.io === \"input\" && result.schema._prefault) result.schema.default ??= result.schema._prefault;\n    delete result.schema._prefault;\n\n    // pulling fresh from this.seen in case it was overwritten\n    const _result = this.seen.get(schema)!;\n\n    return _result.schema;\n  }\n\n  emit(schema: schemas.$ZodType, _params?: EmitParams): JSONSchema.BaseSchema {\n    const params = {\n      cycles: _params?.cycles ?? \"ref\",\n      reused: _params?.reused ?? \"inline\",\n      // unrepresentable: _params?.unrepresentable ?? \"throw\",\n      // uri: _params?.uri ?? ((id) => `${id}`),\n      external: _params?.external ?? undefined,\n    } satisfies EmitParams;\n\n    // iterate over seen map;\n    const root = this.seen.get(schema);\n\n    if (!root) throw new Error(\"Unprocessed schema. This is a bug in Zod.\");\n\n    // initialize result with root schema fields\n    // Object.assign(result, seen.cached);\n\n    // returns a ref to the schema\n    // defId will be empty if the ref points to an external schema (or #)\n    const makeURI = (entry: [schemas.$ZodType<unknown, unknown>, Seen]): { ref: string; defId?: string } => {\n      // comparing the seen objects because sometimes\n      // multiple schemas map to the same seen object.\n      // e.g. lazy\n\n      // external is configured\n      const defsSegment = this.target === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n      if (params.external) {\n        const externalId = params.external.registry.get(entry[0])?.id; // ?? \"__shared\";// `__schema${this.counter++}`;\n\n        // check if schema is in the external registry\n        const uriGenerator = params.external.uri ?? ((id) => id);\n        if (externalId) {\n          return { ref: uriGenerator(externalId) };\n        }\n\n        // otherwise, add to __shared\n        const id: string = entry[1].defId ?? (entry[1].schema.id as string) ?? `schema${this.counter++}`;\n        entry[1].defId = id; // set defId so it will be reused if needed\n        return { defId: id, ref: `${uriGenerator(\"__shared\")}#/${defsSegment}/${id}` };\n      }\n\n      if (entry[1] === root) {\n        return { ref: \"#\" };\n      }\n\n      // self-contained schema\n      const uriPrefix = `#`;\n      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;\n      const defId = entry[1].schema.id ?? `__schema${this.counter++}`;\n      return { defId, ref: defUriPrefix + defId };\n    };\n\n    // stored cached version in `def` property\n    // remove all properties, set $ref\n    const extractToDef = (entry: [schemas.$ZodType<unknown, unknown>, Seen]): void => {\n      // if the schema is already a reference, do not extract it\n      if (entry[1].schema.$ref) {\n        return;\n      }\n      const seen = entry[1];\n      const { ref, defId } = makeURI(entry);\n\n      seen.def = { ...seen.schema };\n      // defId won't be set if the schema is a reference to an external schema\n      if (defId) seen.defId = defId;\n      // wipe away all properties except $ref\n      const schema = seen.schema;\n      for (const key in schema) {\n        delete schema[key];\n      }\n      schema.$ref = ref;\n    };\n\n    // throw on cycles\n\n    // break cycles\n    if (params.cycles === \"throw\") {\n      for (const entry of this.seen.entries()) {\n        const seen = entry[1];\n        if (seen.cycle) {\n          throw new Error(\n            \"Cycle detected: \" +\n              `#/${seen.cycle?.join(\"/\")}/<root>` +\n              '\\n\\nSet the `cycles` parameter to `\"ref\"` to resolve cyclical schemas with defs.'\n          );\n        }\n      }\n    }\n\n    // extract schemas into $defs\n    for (const entry of this.seen.entries()) {\n      const seen = entry[1];\n\n      // convert root schema to # $ref\n      if (schema === entry[0]) {\n        extractToDef(entry); // this has special handling for the root schema\n        continue;\n      }\n\n      // extract schemas that are in the external registry\n      if (params.external) {\n        const ext = params.external.registry.get(entry[0])?.id;\n        if (schema !== entry[0] && ext) {\n          extractToDef(entry);\n          continue;\n        }\n      }\n\n      // extract schemas with `id` meta\n      const id = this.metadataRegistry.get(entry[0])?.id;\n      if (id) {\n        extractToDef(entry);\n        continue;\n      }\n\n      // break cycles\n      if (seen.cycle) {\n        // any\n        extractToDef(entry);\n        continue;\n      }\n\n      // extract reused schemas\n      if (seen.count > 1) {\n        if (params.reused === \"ref\") {\n          extractToDef(entry);\n          // biome-ignore lint:\n          continue;\n        }\n      }\n    }\n\n    // flatten _refs\n    const flattenRef = (zodSchema: schemas.$ZodType, params: Pick<ToJSONSchemaParams, \"target\">) => {\n      const seen = this.seen.get(zodSchema)!;\n      const schema = seen.def ?? seen.schema;\n\n      const _cached = { ...schema };\n\n      // already seen\n      if (seen.ref === null) {\n        return;\n      }\n\n      // flatten ref if defined\n      const ref = seen.ref;\n      seen.ref = null; // prevent recursion\n      if (ref) {\n        flattenRef(ref, params);\n\n        // merge referenced schema into current\n        const refSchema = this.seen.get(ref)!.schema;\n        if (refSchema.$ref && params.target === \"draft-7\") {\n          schema.allOf = schema.allOf ?? [];\n          schema.allOf.push(refSchema);\n        } else {\n          Object.assign(schema, refSchema);\n          Object.assign(schema, _cached); // prevent overwriting any fields in the original schema\n        }\n      }\n\n      // execute overrides\n      if (!seen.isParent)\n        this.override({\n          zodSchema: zodSchema as schemas.$ZodTypes,\n          jsonSchema: schema,\n          path: seen.path ?? [],\n        });\n    };\n\n    for (const entry of [...this.seen.entries()].reverse()) {\n      flattenRef(entry[0], { target: this.target });\n    }\n\n    const result: JSONSchema.BaseSchema = {};\n    if (this.target === \"draft-2020-12\") {\n      result.$schema = \"https://json-schema.org/draft/2020-12/schema\";\n    } else if (this.target === \"draft-7\") {\n      result.$schema = \"http://json-schema.org/draft-07/schema#\";\n    } else {\n      console.warn(`Invalid target: ${this.target}`);\n    }\n\n    if (params.external?.uri) {\n      const id = params.external.registry.get(schema)?.id;\n      if (!id) throw new Error(\"Schema is missing an `id` property\");\n      result.$id = params.external.uri(id);\n    }\n\n    Object.assign(result, root.def);\n\n    // build defs object\n    const defs: JSONSchema.BaseSchema[\"$defs\"] = params.external?.defs ?? {};\n    for (const entry of this.seen.entries()) {\n      const seen = entry[1];\n      if (seen.def && seen.defId) {\n        defs[seen.defId] = seen.def;\n      }\n    }\n\n    // set definitions in result\n    if (params.external) {\n    } else {\n      if (Object.keys(defs).length > 0) {\n        if (this.target === \"draft-2020-12\") {\n          result.$defs = defs;\n        } else {\n          result.definitions = defs;\n        }\n      }\n    }\n\n    try {\n      // this \"finalizes\" this schema and ensures all cycles are removed\n      // each call to .emit() is functionally independent\n      // though the seen map is shared\n      return JSON.parse(JSON.stringify(result));\n    } catch (_err) {\n      throw new Error(\"Error converting schema to JSON.\");\n    }\n  }\n}\n\ninterface ToJSONSchemaParams extends Omit<JSONSchemaGeneratorParams & EmitParams, \"external\"> {}\ninterface RegistryToJSONSchemaParams extends Omit<JSONSchemaGeneratorParams & EmitParams, \"external\"> {\n  uri?: (id: string) => string;\n}\n\nexport function toJSONSchema(schema: schemas.$ZodType, _params?: ToJSONSchemaParams): JSONSchema.BaseSchema;\nexport function toJSONSchema(\n  registry: $ZodRegistry<{ id?: string | undefined }>,\n  _params?: RegistryToJSONSchemaParams\n): { schemas: Record<string, JSONSchema.BaseSchema> };\nexport function toJSONSchema(\n  input: schemas.$ZodType | $ZodRegistry<{ id?: string | undefined }>,\n  _params?: ToJSONSchemaParams\n): any {\n  if (input instanceof $ZodRegistry) {\n    const gen = new JSONSchemaGenerator(_params);\n    const defs: any = {};\n    for (const entry of input._idmap.entries()) {\n      const [_, schema] = entry;\n      gen.process(schema);\n    }\n\n    const schemas: Record<string, JSONSchema.BaseSchema> = {};\n    const external = {\n      registry: input,\n      uri: (_params as RegistryToJSONSchemaParams)?.uri,\n      defs,\n    };\n    for (const entry of input._idmap.entries()) {\n      const [key, schema] = entry;\n      schemas[key] = gen.emit(schema, {\n        ..._params,\n        external,\n      });\n    }\n\n    if (Object.keys(defs).length > 0) {\n      const defsSegment = gen.target === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n      schemas.__shared = {\n        [defsSegment]: defs,\n      };\n    }\n\n    return { schemas };\n  }\n\n  const gen = new JSONSchemaGenerator(_params);\n  gen.process(input);\n\n  return gen.emit(input, _params);\n}\n\nfunction isTransforming(\n  _schema: schemas.$ZodType,\n  _ctx?: {\n    seen: Set<schemas.$ZodType>;\n  }\n): boolean {\n  const ctx = _ctx ?? { seen: new Set() };\n\n  if (ctx.seen.has(_schema)) return false;\n  ctx.seen.add(_schema);\n\n  const schema = _schema as schemas.$ZodTypes;\n  const def = schema._zod.def;\n  switch (def.type) {\n    case \"string\":\n    case \"number\":\n    case \"bigint\":\n    case \"boolean\":\n    case \"date\":\n    case \"symbol\":\n    case \"undefined\":\n    case \"null\":\n    case \"any\":\n    case \"unknown\":\n    case \"never\":\n    case \"void\":\n    case \"literal\":\n    case \"enum\":\n    case \"nan\":\n    case \"file\":\n    case \"template_literal\":\n      return false;\n    case \"array\": {\n      return isTransforming(def.element, ctx);\n    }\n    case \"object\": {\n      for (const key in def.shape) {\n        if (isTransforming(def.shape[key]!, ctx)) return true;\n      }\n      return false;\n    }\n    case \"union\": {\n      for (const option of def.options) {\n        if (isTransforming(option, ctx)) return true;\n      }\n      return false;\n    }\n    case \"intersection\": {\n      return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);\n    }\n    case \"tuple\": {\n      for (const item of def.items) {\n        if (isTransforming(item, ctx)) return true;\n      }\n      if (def.rest && isTransforming(def.rest, ctx)) return true;\n      return false;\n    }\n    case \"record\": {\n      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);\n    }\n    case \"map\": {\n      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);\n    }\n    case \"set\": {\n      return isTransforming(def.valueType, ctx);\n    }\n\n    // inner types\n    case \"promise\":\n    case \"optional\":\n    case \"nonoptional\":\n    case \"nullable\":\n    case \"readonly\":\n      return isTransforming(def.innerType, ctx);\n    case \"lazy\":\n      return isTransforming(def.getter(), ctx);\n    case \"default\": {\n      return isTransforming(def.innerType, ctx);\n    }\n    case \"prefault\": {\n      return isTransforming(def.innerType, ctx);\n    }\n    case \"custom\": {\n      return false;\n    }\n    case \"transform\": {\n      return true;\n    }\n    case \"pipe\": {\n      return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);\n    }\n    case \"success\": {\n      return false;\n    }\n    case \"catch\": {\n      return false;\n    }\n\n    default:\n      def satisfies never;\n  }\n  throw new Error(`Unknown schema type: ${(def as any).type}`);\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/core/to-json-schema.ts",
        "start": 1,
        "end": 977,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 977,
          "column": 2,
          "position": 9224
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/to-json-schema.ts",
        "start": 1,
        "end": 977,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 977,
          "column": 2,
          "position": 9224
        }
      }
    },
    {
      "format": "typescript",
      "lines": 64,
      "fragment": "/** The Standard Schema interface. */\nexport interface StandardSchemaV1<Input = unknown, Output = Input> {\n  /** The Standard Schema properties. */\n  readonly \"~standard\": StandardSchemaV1.Props<Input, Output>;\n}\n\nexport declare namespace StandardSchemaV1 {\n  /** The Standard Schema properties interface. */\n  export interface Props<Input = unknown, Output = Input> {\n    /** The version number of the standard. */\n    readonly version: 1;\n    /** The vendor name of the schema library. */\n    readonly vendor: string;\n    /** Validates unknown input values. */\n    readonly validate: (value: unknown) => Result<Output> | Promise<Result<Output>>;\n    /** Inferred types associated with the schema. */\n    readonly types?: Types<Input, Output> | undefined;\n  }\n\n  /** The result interface of the validate function. */\n  export type Result<Output> = SuccessResult<Output> | FailureResult;\n\n  /** The result interface if validation succeeds. */\n  export interface SuccessResult<Output> {\n    /** The typed output value. */\n    readonly value: Output;\n    /** The non-existent issues. */\n    readonly issues?: undefined;\n  }\n\n  /** The result interface if validation fails. */\n  export interface FailureResult {\n    /** The issues of failed validation. */\n    readonly issues: ReadonlyArray<Issue>;\n  }\n\n  /** The issue interface of the failure output. */\n  export interface Issue {\n    /** The error message of the issue. */\n    readonly message: string;\n    /** The path of the issue, if any. */\n    readonly path?: ReadonlyArray<PropertyKey | PathSegment> | undefined;\n  }\n\n  /** The path segment interface of the issue. */\n  export interface PathSegment {\n    /** The key representing a path segment. */\n    readonly key: PropertyKey;\n  }\n\n  /** The Standard Schema types interface. */\n  export interface Types<Input = unknown, Output = Input> {\n    /** The input type of the schema. */\n    readonly input: Input;\n    /** The output type of the schema. */\n    readonly output: Output;\n  }\n\n  /** Infers the input type of a Standard Schema. */\n  export type InferInput<Schema extends StandardSchemaV1> = NonNullable<Schema[\"~standard\"][\"types\"]>[\"input\"];\n\n  /** Infers the output type of a Standard Schema. */\n  export type InferOutput<Schema extends StandardSchemaV1> = NonNullable<Schema[\"~standard\"][\"types\"]>[\"output\"];\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/core/standard-schema.ts",
        "start": 1,
        "end": 64,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 64,
          "column": 2,
          "position": 471
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/standard-schema.ts",
        "start": 1,
        "end": 64,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 64,
          "column": 2,
          "position": 471
        }
      }
    },
    {
      "format": "typescript",
      "lines": 96,
      "fragment": "import type * as core from \"./core.js\";\nimport type { $ZodType } from \"./schemas.js\";\n\nexport const $output: unique symbol = Symbol(\"ZodOutput\");\nexport type $output = typeof $output;\nexport const $input: unique symbol = Symbol(\"ZodInput\");\nexport type $input = typeof $input;\n\nexport type $replace<Meta, S extends $ZodType> = Meta extends $output\n  ? core.output<S>\n  : Meta extends $input\n    ? core.input<S>\n    : Meta extends (infer M)[]\n      ? $replace<M, S>[]\n      : Meta extends (...args: infer P) => infer R\n        ? (\n            ...args: {\n              [K in keyof P]: $replace<P[K], S>; // tuple\n            }\n          ) => $replace<R, S>\n        : // handle objects\n          Meta extends object\n          ? { [K in keyof Meta]: $replace<Meta[K], S> }\n          : Meta;\n\ntype MetadataType = Record<string, unknown> | undefined;\nexport class $ZodRegistry<Meta extends MetadataType = MetadataType, Schema extends $ZodType = $ZodType> {\n  _meta!: Meta;\n  _schema!: Schema;\n  _map: Map<Schema, $replace<Meta, Schema>> = new Map();\n  _idmap: Map<string, Schema> = new Map();\n\n  add<S extends Schema>(\n    schema: S,\n    ..._meta: undefined extends Meta ? [$replace<Meta, S>?] : [$replace<Meta, S>]\n  ): this {\n    const meta: any = _meta[0];\n    this._map.set(schema, meta!);\n    if (meta && typeof meta === \"object\" && \"id\" in meta) {\n      if (this._idmap.has(meta.id!)) {\n        throw new Error(`ID ${meta.id} already exists in the registry`);\n      }\n      this._idmap.set(meta.id!, schema);\n    }\n    return this as any;\n  }\n\n  clear(): this {\n    this._map = new Map();\n    this._idmap = new Map();\n    return this;\n  }\n\n  remove(schema: Schema): this {\n    const meta: any = this._map.get(schema);\n    if (meta && typeof meta === \"object\" && \"id\" in meta) {\n      this._idmap.delete(meta.id!);\n    }\n    this._map.delete(schema);\n    return this;\n  }\n\n  get<S extends Schema>(schema: S): $replace<Meta, S> | undefined {\n    // return this._map.get(schema) as any;\n\n    // inherit metadata\n    const p = schema._zod.parent as Schema;\n    if (p) {\n      const pm: any = { ...(this.get(p) ?? {}) };\n      delete pm.id; // do not inherit id\n      return { ...pm, ...this._map.get(schema) } as any;\n    }\n    return this._map.get(schema) as any;\n  }\n\n  has(schema: Schema): boolean {\n    return this._map.has(schema);\n  }\n}\n\nexport interface JSONSchemaMeta {\n  id?: string | undefined;\n  title?: string | undefined;\n  description?: string | undefined;\n  deprecated?: boolean | undefined;\n  [k: string]: unknown;\n}\n\nexport interface GlobalMeta extends JSONSchemaMeta {}\n\n// registries\nexport function registry<T extends MetadataType = MetadataType, S extends $ZodType = $ZodType>(): $ZodRegistry<T, S> {\n  return new $ZodRegistry<T, S>();\n}\n\nexport const globalRegistry: $ZodRegistry<GlobalMeta> = /*@__PURE__*/ registry<GlobalMeta>();",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/core/registries.ts",
        "start": 1,
        "end": 96,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 96,
          "column": 2,
          "position": 1113
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/registries.ts",
        "start": 1,
        "end": 96,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 96,
          "column": 2,
          "position": 1113
        }
      }
    },
    {
      "format": "typescript",
      "lines": 135,
      "fragment": "export const cuid: RegExp = /^[cC][^\\s-]{8,}$/;\nexport const cuid2: RegExp = /^[0-9a-z]+$/;\nexport const ulid: RegExp = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;\nexport const xid: RegExp = /^[0-9a-vA-V]{20}$/;\nexport const ksuid: RegExp = /^[A-Za-z0-9]{27}$/;\nexport const nanoid: RegExp = /^[a-zA-Z0-9_-]{21}$/;\n\n/** ISO 8601-1 duration regex. Does not support the 8601-2 extensions like negative durations or fractional/negative components. */\nexport const duration: RegExp =\n  /^P(?:(\\d+W)|(?!.*W)(?=\\d|T\\d)(\\d+Y)?(\\d+M)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+([.,]\\d+)?S)?)?)$/;\n\n/** Implements ISO 8601-2 extensions like explicit +- prefixes, mixing weeks with other units, and fractional/negative components. */\nexport const extendedDuration: RegExp =\n  /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\n\n/** A regex for any UUID-like identifier: 8-4-4-4-12 hex pattern */\nexport const guid: RegExp = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;\n\n/** Returns a regex for validating an RFC 4122 UUID.\n *\n * @param version Optionally specify a version 1-8. If no version is specified, all versions are supported. */\nexport const uuid = (version?: number | undefined): RegExp => {\n  if (!version)\n    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;\n  return new RegExp(\n    `^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`\n  );\n};\nexport const uuid4: RegExp = /*@__PURE__*/ uuid(4);\nexport const uuid6: RegExp = /*@__PURE__*/ uuid(6);\nexport const uuid7: RegExp = /*@__PURE__*/ uuid(7);\n\n/** Practical email validation */\nexport const email: RegExp =\n  /^(?!\\.)(?!.*\\.\\.)([A-Za-z0-9_'+\\-\\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\\-]*\\.)+[A-Za-z]{2,}$/;\n\n/** Equivalent to the HTML5 input[type=email] validation implemented by browsers. Source: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email */\nexport const html5Email: RegExp =\n  /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n\n/** The classic emailregex.com regex for RFC 5322-compliant emails */\nexport const rfc5322Email =\n  /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n\n/** A loose regex that allows Unicode characters, enforces length limits, and that's about it. */\nexport const unicodeEmail = /^[^\\s@\"]{1,64}@[^\\s@]{1,255}$/u;\n\nexport const browserEmail: RegExp =\n  /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\n\nexport const _emoji = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nexport function emoji(): RegExp {\n  return new RegExp(_emoji, \"u\");\n}\n\nexport const ipv4: RegExp =\n  /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nexport const ipv6: RegExp =\n  /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;\n\nexport const cidrv4: RegExp =\n  /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/([0-9]|[1-2][0-9]|3[0-2])$/;\nexport const cidrv6: RegExp =\n  /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\n\n// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript\nexport const base64: RegExp = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;\nexport const base64url: RegExp = /^[A-Za-z0-9_-]*$/;\n\n// based on https://stackoverflow.com/questions/106179/regular-expression-to-match-dns-hostname-or-ip-address\n// export const hostname: RegExp =\n//   /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)+([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$/;\nexport const hostname: RegExp = /^([a-zA-Z0-9-]+\\.)*[a-zA-Z0-9-]+$/;\nexport const domain: RegExp = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,}$/;\n\n// https://blog.stevenlevithan.com/archives/validate-phone-number#r4-3 (regex sans spaces)\nexport const e164: RegExp = /^\\+(?:[0-9]){6,14}[0-9]$/;\n\n// const dateSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\nconst dateSource = `(?:(?:\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\\\d|30)|(?:02)-(?:0[1-9]|1\\\\d|2[0-8])))`;\nexport const date: RegExp = /*@__PURE__*/ new RegExp(`^${dateSource}$`);\n\nfunction timeSource(args: { precision?: number | null | undefined }) {\n  const hhmm = `(?:[01]\\\\d|2[0-3]):[0-5]\\\\d`;\n  const regex =\n    typeof args.precision === \"number\"\n      ? args.precision === -1\n        ? `${hhmm}`\n        : args.precision === 0\n          ? `${hhmm}:[0-5]\\\\d`\n          : `${hhmm}:[0-5]\\\\d\\\\.\\\\d{${args.precision}}`\n      : `${hhmm}(?::[0-5]\\\\d(?:\\\\.\\\\d+)?)?`;\n  return regex;\n}\nexport function time(args: {\n  precision?: number | null;\n  // local?: boolean;\n}): RegExp {\n  return new RegExp(`^${timeSource(args)}$`);\n}\n\n// Adapted from https://stackoverflow.com/a/3143231\nexport function datetime(args: {\n  precision?: number | null;\n  offset?: boolean;\n  local?: boolean;\n}): RegExp {\n  const time = timeSource({ precision: args.precision });\n  const opts = [\"Z\"];\n  if (args.local) opts.push(\"\");\n  if (args.offset) opts.push(`([+-]\\\\d{2}:\\\\d{2})`);\n  const timeRegex = `${time}(?:${opts.join(\"|\")})`;\n\n  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);\n}\n\nexport const string = (params?: { minimum?: number | undefined; maximum?: number | undefined }): RegExp => {\n  const regex = params ? `[\\\\s\\\\S]{${params?.minimum ?? 0},${params?.maximum ?? \"\"}}` : `[\\\\s\\\\S]*`;\n  return new RegExp(`^${regex}$`);\n};\n\nexport const bigint: RegExp = /^\\d+n?$/;\nexport const integer: RegExp = /^\\d+$/;\nexport const number: RegExp = /^-?\\d+(?:\\.\\d+)?/i;\nexport const boolean: RegExp = /true|false/i;\nconst _null: RegExp = /null/i;\nexport { _null as null };\nconst _undefined: RegExp = /undefined/i;\nexport { _undefined as undefined };\n\n// regex for string with no uppercase letters\nexport const lowercase: RegExp = /^[^A-Z]*$/;\n// regex for string with no lowercase letters\nexport const uppercase: RegExp = /^[^a-z]*$/;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/core/regexes.ts",
        "start": 1,
        "end": 135,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 135,
          "column": 2,
          "position": 1471
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/regexes.ts",
        "start": 1,
        "end": 135,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 135,
          "column": 2,
          "position": 1471
        }
      }
    },
    {
      "format": "typescript",
      "lines": 94,
      "fragment": "import * as core from \"./core.js\";\nimport * as errors from \"./errors.js\";\nimport type * as schemas from \"./schemas.js\";\nimport * as util from \"./util.js\";\n\nexport type $ZodErrorClass = { new (issues: errors.$ZodIssue[]): errors.$ZodError };\n\n///////////        METHODS       ///////////\nexport type $Parse = <T extends schemas.$ZodType>(\n  schema: T,\n  value: unknown,\n  _ctx?: schemas.ParseContext<errors.$ZodIssue>,\n  _params?: { callee?: util.AnyFunc; Err?: $ZodErrorClass }\n) => core.output<T>;\n\nexport const _parse: (_Err: $ZodErrorClass) => $Parse = (_Err) => (schema, value, _ctx, _params) => {\n  const ctx: schemas.ParseContextInternal = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };\n  const result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise) {\n    throw new core.$ZodAsyncError();\n  }\n  if (result.issues.length) {\n    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())));\n    util.captureStackTrace(e, _params?.callee);\n    throw e;\n  }\n  return result.value as core.output<typeof schema>;\n};\n\nexport const parse: $Parse = /* @__PURE__*/ _parse(errors.$ZodRealError);\n\nexport type $ParseAsync = <T extends schemas.$ZodType>(\n  schema: T,\n  value: unknown,\n  _ctx?: schemas.ParseContext<errors.$ZodIssue>,\n  _params?: { callee?: util.AnyFunc; Err?: $ZodErrorClass }\n) => Promise<core.output<T>>;\n\nexport const _parseAsync: (_Err: $ZodErrorClass) => $ParseAsync = (_Err) => async (schema, value, _ctx, params) => {\n  const ctx: schemas.ParseContextInternal = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };\n  let result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise) result = await result;\n  if (result.issues.length) {\n    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())));\n    util.captureStackTrace(e, params?.callee);\n    throw e;\n  }\n  return result.value as core.output<typeof schema>;\n};\n\nexport const parseAsync: $ParseAsync = /* @__PURE__*/ _parseAsync(errors.$ZodRealError);\n\nexport type $SafeParse = <T extends schemas.$ZodType>(\n  schema: T,\n  value: unknown,\n  _ctx?: schemas.ParseContext<errors.$ZodIssue>\n) => util.SafeParseResult<core.output<T>>;\n\nexport const _safeParse: (_Err: $ZodErrorClass) => $SafeParse = (_Err) => (schema, value, _ctx) => {\n  const ctx: schemas.ParseContextInternal = _ctx ? { ..._ctx, async: false } : { async: false };\n  const result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise) {\n    throw new core.$ZodAsyncError();\n  }\n\n  return result.issues.length\n    ? {\n        success: false,\n        error: new (_Err ?? errors.$ZodError)(result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config()))),\n      }\n    : ({ success: true, data: result.value } as any);\n};\nexport const safeParse: $SafeParse = /* @__PURE__*/ _safeParse(errors.$ZodRealError);\n\nexport type $SafeParseAsync = <T extends schemas.$ZodType>(\n  schema: T,\n  value: unknown,\n  _ctx?: schemas.ParseContext<errors.$ZodIssue>\n) => Promise<util.SafeParseResult<core.output<T>>>;\n\nexport const _safeParseAsync: (_Err: $ZodErrorClass) => $SafeParseAsync = (_Err) => async (schema, value, _ctx) => {\n  const ctx: schemas.ParseContextInternal = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };\n  let result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise) result = await result;\n\n  return result.issues.length\n    ? {\n        success: false,\n        error: new _Err(result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config()))),\n      }\n    : ({ success: true, data: result.value } as any);\n};\n\nexport const safeParseAsync: $SafeParseAsync = /* @__PURE__*/ _safeParseAsync(errors.$ZodRealError);",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/core/parse.ts",
        "start": 1,
        "end": 94,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 94,
          "column": 2,
          "position": 1468
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/parse.ts",
        "start": 1,
        "end": 94,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 94,
          "column": 2,
          "position": 1468
        }
      }
    },
    {
      "format": "typescript",
      "lines": 143,
      "fragment": "export type Schema =\n  | ObjectSchema\n  | ArraySchema\n  | StringSchema\n  | NumberSchema\n  | IntegerSchema\n  | BooleanSchema\n  | NullSchema;\n\n// export type JsonType = \"object\" | \"array\" | \"string\" | \"number\" | \"boolean\" | \"null\" | \"integer\";\n\n// export interface JSONSchema {\n//   type?: string ;\n//   $id?: string ;\n//   id?: string ;\n//   $schema?: string ;\n//   $ref?: string ;\n//   $anchor?: string ;\n//   $defs?: { [key: string]: JSONSchema } ;\n//   definitions?: { [key: string]: JSONSchema } ;\n//   $comment?: string ;\n//   title?: string ;\n//   description?: string ;\n//   default?: unknown ;\n//   examples?: unknown[] ;\n//   readOnly?: boolean ;\n//   writeOnly?: boolean ;\n//   deprecated?: boolean ;\n//   allOf?: JSONSchema[] ;\n//   anyOf?: JSONSchema[] ;\n//   oneOf?: JSONSchema[] ;\n//   not?: JSONSchema ;\n//   if?: JSONSchema ;\n//   then?: JSONSchema ;\n//   else?: JSONSchema ;\n//   enum?: Array<string | number | boolean | null> ;\n//   const?: string | number | boolean | null ;\n//   [k: string]: unknown;\n\n//   /** A special key used as an intermediate representation of extends-style relationships. Omitted as a $ref with additional properties. */\n//   // _ref?: JSONSchema;\n//   _prefault?: unknown ;\n// }\n\nexport type _JSONSchema = boolean | JSONSchema;\nexport type JSONSchema = {\n  [k: string]: unknown;\n  $schema?: \"https://json-schema.org/draft/2020-12/schema\" | \"http://json-schema.org/draft-07/schema#\";\n  $id?: string;\n  $anchor?: string;\n  $ref?: string;\n  $dynamicRef?: string;\n  $dynamicAnchor?: string;\n  $vocabulary?: Record<string, boolean>;\n  $comment?: string;\n  $defs?: Record<string, JSONSchema>;\n  type?: \"object\" | \"array\" | \"string\" | \"number\" | \"boolean\" | \"null\" | \"integer\";\n  additionalItems?: _JSONSchema;\n  unevaluatedItems?: _JSONSchema;\n  prefixItems?: _JSONSchema[];\n  items?: _JSONSchema | _JSONSchema[];\n  contains?: _JSONSchema;\n  additionalProperties?: _JSONSchema;\n  unevaluatedProperties?: _JSONSchema;\n  properties?: Record<string, _JSONSchema>;\n  patternProperties?: Record<string, _JSONSchema>;\n  dependentSchemas?: Record<string, _JSONSchema>;\n  propertyNames?: _JSONSchema;\n  if?: _JSONSchema;\n  then?: _JSONSchema;\n  else?: _JSONSchema;\n  allOf?: JSONSchema[];\n  anyOf?: JSONSchema[];\n  oneOf?: JSONSchema[];\n  not?: _JSONSchema;\n  multipleOf?: number;\n  maximum?: number;\n  exclusiveMaximum?: number;\n  minimum?: number;\n  exclusiveMinimum?: number;\n  maxLength?: number;\n  minLength?: number;\n  pattern?: string;\n  maxItems?: number;\n  minItems?: number;\n  uniqueItems?: boolean;\n  maxContains?: number;\n  minContains?: number;\n  maxProperties?: number;\n  minProperties?: number;\n  required?: string[];\n  dependentRequired?: Record<string, string[]>;\n  enum?: Array<string | number | boolean | null>;\n  const?: string | number | boolean | null;\n\n  // metadata\n  id?: string;\n  title?: string;\n  description?: string;\n  default?: unknown;\n  deprecated?: boolean;\n  readOnly?: boolean;\n  writeOnly?: boolean;\n  examples?: unknown[];\n  format?: string;\n  contentMediaType?: string;\n  contentEncoding?: string;\n  contentSchema?: JSONSchema;\n\n  // internal\n  _prefault?: unknown;\n};\n\n// for backwards compatibility\nexport type BaseSchema = JSONSchema;\n\nexport interface ObjectSchema extends JSONSchema {\n  type: \"object\";\n}\n\nexport interface ArraySchema extends JSONSchema {\n  type: \"array\";\n}\n\nexport interface StringSchema extends JSONSchema {\n  type: \"string\";\n}\n\nexport interface NumberSchema extends JSONSchema {\n  type: \"number\";\n}\n\nexport interface IntegerSchema extends JSONSchema {\n  type: \"integer\";\n}\n\nexport interface BooleanSchema extends JSONSchema {\n  type: \"boolean\";\n}\n\nexport interface NullSchema extends JSONSchema {\n  type: \"null\";\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/core/json-schema.ts",
        "start": 1,
        "end": 143,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 143,
          "column": 2,
          "position": 920
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/json-schema.ts",
        "start": 1,
        "end": 143,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 143,
          "column": 2,
          "position": 920
        }
      }
    },
    {
      "format": "typescript",
      "lines": 15,
      "fragment": "export * from \"./core.js\";\nexport * from \"./parse.js\";\nexport * from \"./errors.js\";\nexport * from \"./schemas.js\";\nexport * from \"./checks.js\";\nexport * from \"./versions.js\";\nexport * as util from \"./util.js\";\nexport * as regexes from \"./regexes.js\";\nexport * as locales from \"../locales/index.js\";\nexport * from \"./registries.js\";\nexport * from \"./doc.js\";\nexport * from \"./function.js\";\nexport * from \"./api.js\";\nexport * from \"./to-json-schema.js\";\nexport * as JSONSchema from \"./json-schema.js\";",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/core/index.ts",
        "start": 1,
        "end": 15,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 15,
          "column": 2,
          "position": 149
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/index.ts",
        "start": 1,
        "end": 15,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 15,
          "column": 2,
          "position": 149
        }
      }
    },
    {
      "format": "typescript",
      "lines": 176,
      "fragment": "import { _array, _tuple, _unknown } from \"./api.js\";\nimport type * as core from \"./core.js\";\nimport { parse, parseAsync } from \"./parse.js\";\nimport * as schemas from \"./schemas.js\";\nimport { $ZodTuple } from \"./schemas.js\";\nimport type * as util from \"./util.js\";\n\n//////////////////////////////////////////\n//////////////////////////////////////////\n//////////                      //////////\n//////////     $ZodFunction     //////////\n//////////                      //////////\n//////////////////////////////////////////\n//////////////////////////////////////////\nexport interface $ZodFunctionDef<\n  In extends $ZodFunctionIn = $ZodFunctionIn,\n  Out extends $ZodFunctionOut = $ZodFunctionOut,\n> {\n  type: \"function\";\n  input: In;\n  output: Out;\n}\n\nexport type $ZodFunctionArgs = schemas.$ZodType<unknown[], unknown[]>;\nexport type $ZodFunctionIn = $ZodFunctionArgs;\nexport type $ZodFunctionOut = schemas.$ZodType;\n\nexport type $InferInnerFunctionType<Args extends $ZodFunctionIn, Returns extends $ZodFunctionOut> = (\n  ...args: $ZodFunctionIn extends Args ? never[] : core.output<Args>\n) => core.input<Returns>;\n\nexport type $InferInnerFunctionTypeAsync<Args extends $ZodFunctionIn, Returns extends $ZodFunctionOut> = (\n  ...args: $ZodFunctionIn extends Args ? never[] : core.output<Args>\n) => util.MaybeAsync<core.input<Returns>>;\n\nexport type $InferOuterFunctionType<Args extends $ZodFunctionIn, Returns extends $ZodFunctionOut> = (\n  ...args: $ZodFunctionIn extends Args ? never[] : core.input<Args>\n) => core.output<Returns>;\n\nexport type $InferOuterFunctionTypeAsync<Args extends $ZodFunctionIn, Returns extends $ZodFunctionOut> = (\n  ...args: $ZodFunctionIn extends Args ? never[] : core.input<Args>\n) => util.MaybeAsync<core.output<Returns>>;\n\nexport class $ZodFunction<\n  Args extends $ZodFunctionIn = $ZodFunctionIn,\n  Returns extends $ZodFunctionOut = $ZodFunctionOut,\n> {\n  def: $ZodFunctionDef<Args, Returns>;\n\n  /** @deprecated */\n  _def!: $ZodFunctionDef<Args, Returns>;\n  _input!: $InferInnerFunctionType<Args, Returns>;\n  _output!: $InferOuterFunctionType<Args, Returns>;\n\n  constructor(def: $ZodFunctionDef<Args, Returns>) {\n    this._def = def;\n    this.def = def;\n  }\n\n  implement<F extends $InferInnerFunctionType<Args, Returns>>(\n    func: F\n  ): // allow for return type inference\n  (\n    ...args: Parameters<this[\"_output\"]>\n  ) => ReturnType<F> extends ReturnType<this[\"_output\"]> ? ReturnType<F> : ReturnType<this[\"_output\"]> {\n    if (typeof func !== \"function\") {\n      throw new Error(\"implement() must be called with a function\");\n    }\n    const impl = ((...args: any[]) => {\n      const parsedArgs = this._def.input ? parse(this._def.input, args, undefined, { callee: impl }) : args;\n      if (!Array.isArray(parsedArgs)) {\n        throw new Error(\"Invalid arguments schema: not an array or tuple schema.\");\n      }\n      const output = func(...(parsedArgs as any));\n      return this._def.output ? parse(this._def.output, output, undefined, { callee: impl }) : output;\n    }) as any;\n    return impl;\n  }\n\n  implementAsync<F extends $InferInnerFunctionTypeAsync<Args, Returns>>(\n    func: F\n  ): F extends $InferOuterFunctionTypeAsync<Args, Returns> ? F : $InferOuterFunctionTypeAsync<Args, Returns> {\n    if (typeof func !== \"function\") {\n      throw new Error(\"implement() must be called with a function\");\n    }\n\n    const impl = (async (...args: any[]) => {\n      const parsedArgs = this._def.input ? await parseAsync(this._def.input, args, undefined, { callee: impl }) : args;\n      if (!Array.isArray(parsedArgs)) {\n        throw new Error(\"Invalid arguments schema: not an array or tuple schema.\");\n      }\n      const output = await func(...(parsedArgs as any));\n      return this._def.output ? parseAsync(this._def.output, output, undefined, { callee: impl }) : output;\n    }) as any;\n    return impl;\n  }\n\n  input<const Items extends util.TupleItems, const Rest extends $ZodFunctionOut = $ZodFunctionOut>(\n    args: Items,\n    rest?: Rest\n  ): $ZodFunction<schemas.$ZodTuple<Items, Rest>, Returns>;\n  input<NewArgs extends $ZodFunctionIn>(args: NewArgs): $ZodFunction<NewArgs, Returns>;\n  input(...args: any[]): $ZodFunction<any, Returns> {\n    const F: any = this.constructor;\n    if (Array.isArray(args[0])) {\n      return new F({\n        type: \"function\",\n        input: new $ZodTuple({\n          type: \"tuple\",\n          items: args[0],\n          rest: args[1],\n        }),\n        output: this._def.output,\n      });\n    }\n\n    return new F({\n      type: \"function\",\n      input: args[0],\n      output: this._def.output,\n    });\n  }\n\n  output<NewReturns extends schemas.$ZodType>(output: NewReturns): $ZodFunction<Args, NewReturns> {\n    const F: any = this.constructor;\n    return new F({\n      type: \"function\",\n      input: this._def.input,\n      output,\n    });\n  }\n}\n\nexport interface $ZodFunctionParams<I extends $ZodFunctionIn, O extends schemas.$ZodType> {\n  input?: I;\n  output?: O;\n}\n\nfunction _function(): $ZodFunction;\nfunction _function<const In extends Array<schemas.$ZodType> = Array<schemas.$ZodType>>(params: {\n  input: In;\n}): $ZodFunction<$ZodTuple<In, null>, $ZodFunctionOut>;\nfunction _function<\n  const In extends Array<schemas.$ZodType> = Array<schemas.$ZodType>,\n  const Out extends $ZodFunctionOut = $ZodFunctionOut,\n>(params: {\n  input: In;\n  output: Out;\n}): $ZodFunction<$ZodTuple<In, null>, Out>;\nfunction _function<const In extends $ZodFunctionIn = $ZodFunctionIn>(params: {\n  input: In;\n}): $ZodFunction<In, $ZodFunctionOut>;\nfunction _function<const Out extends $ZodFunctionOut = $ZodFunctionOut>(params: {\n  output: Out;\n}): $ZodFunction<$ZodFunctionIn, Out>;\nfunction _function<\n  In extends $ZodFunctionIn = $ZodFunctionIn,\n  Out extends schemas.$ZodType = schemas.$ZodType,\n>(params?: {\n  input: In;\n  output: Out;\n}): $ZodFunction<In, Out>;\nfunction _function(params?: {\n  output?: schemas.$ZodType;\n  input?: $ZodFunctionArgs | Array<schemas.$ZodType>;\n}): any {\n  return new $ZodFunction({\n    type: \"function\",\n    input: Array.isArray(params?.input)\n      ? _tuple(schemas.$ZodTuple, params?.input as any)\n      : (params?.input ?? _array(schemas.$ZodArray, _unknown(schemas.$ZodUnknown))),\n    output: params?.output ?? _unknown(schemas.$ZodUnknown),\n  });\n}\n\nexport { _function as function };",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/core/function.ts",
        "start": 1,
        "end": 176,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 176,
          "column": 2,
          "position": 2025
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/function.ts",
        "start": 1,
        "end": 176,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 176,
          "column": 2,
          "position": 2025
        }
      }
    },
    {
      "format": "typescript",
      "lines": 424,
      "fragment": "import type { $ZodCheck, $ZodStringFormats } from \"./checks.js\";\nimport { $constructor } from \"./core.js\";\nimport type { $ZodType } from \"./schemas.js\";\nimport * as util from \"./util.js\";\n\n///////////////////////////\n////     base type     ////\n///////////////////////////\nexport interface $ZodIssueBase {\n  readonly code?: string;\n  readonly input?: unknown;\n  readonly path: PropertyKey[];\n  readonly message: string;\n  // [k: string]: unknown;\n}\n\n////////////////////////////////\n////     issue subtypes     ////\n////////////////////////////////\nexport interface $ZodIssueInvalidType<Input = unknown> extends $ZodIssueBase {\n  readonly code: \"invalid_type\";\n  readonly expected: $ZodType[\"_zod\"][\"def\"][\"type\"];\n  readonly input: Input;\n}\n\nexport interface $ZodIssueTooBig<Input = unknown> extends $ZodIssueBase {\n  readonly code: \"too_big\";\n  readonly origin: \"number\" | \"int\" | \"bigint\" | \"date\" | \"string\" | \"array\" | \"set\" | \"file\" | (string & {});\n  readonly maximum: number | bigint;\n  readonly inclusive?: boolean;\n  readonly exact?: boolean;\n  readonly input: Input;\n}\n\nexport interface $ZodIssueTooSmall<Input = unknown> extends $ZodIssueBase {\n  readonly code: \"too_small\";\n  readonly origin: \"number\" | \"int\" | \"bigint\" | \"date\" | \"string\" | \"array\" | \"set\" | \"file\" | (string & {});\n  readonly minimum: number | bigint;\n  /** True if the allowable range includes the minimum */\n  readonly inclusive?: boolean;\n  /** True if the allowed value is fixed (e.g.` z.length(5)`), not a range (`z.minLength(5)`) */\n  readonly exact?: boolean;\n  readonly input: Input;\n}\n\nexport interface $ZodIssueInvalidStringFormat extends $ZodIssueBase {\n  readonly code: \"invalid_format\";\n  readonly format: $ZodStringFormats | (string & {});\n  readonly pattern?: string;\n  readonly input: string;\n}\n\nexport interface $ZodIssueNotMultipleOf<Input extends number | bigint = number | bigint> extends $ZodIssueBase {\n  readonly code: \"not_multiple_of\";\n  readonly divisor: number;\n  readonly input: Input;\n}\n\nexport interface $ZodIssueUnrecognizedKeys extends $ZodIssueBase {\n  readonly code: \"unrecognized_keys\";\n  readonly keys: string[];\n  readonly input: Record<string, unknown>;\n}\n\nexport interface $ZodIssueInvalidUnion extends $ZodIssueBase {\n  readonly code: \"invalid_union\";\n  readonly errors: $ZodIssue[][];\n  readonly input: unknown;\n}\n\nexport interface $ZodIssueInvalidKey<Input = unknown> extends $ZodIssueBase {\n  readonly code: \"invalid_key\";\n  readonly origin: \"map\" | \"record\";\n  readonly issues: $ZodIssue[];\n  readonly input: Input;\n}\n\nexport interface $ZodIssueInvalidElement<Input = unknown> extends $ZodIssueBase {\n  readonly code: \"invalid_element\";\n  readonly origin: \"map\" | \"set\";\n  readonly key: unknown;\n  readonly issues: $ZodIssue[];\n  readonly input: Input;\n}\n\nexport interface $ZodIssueInvalidValue<Input = unknown> extends $ZodIssueBase {\n  readonly code: \"invalid_value\";\n  readonly values: util.Primitive[];\n  readonly input: Input;\n}\n\nexport interface $ZodIssueCustom extends $ZodIssueBase {\n  readonly code: \"custom\";\n  readonly params?: Record<string, any> | undefined;\n  readonly input: unknown;\n}\n\n////////////////////////////////////////////\n////     first-party string formats     ////\n////////////////////////////////////////////\n\nexport interface $ZodIssueStringCommonFormats extends $ZodIssueInvalidStringFormat {\n  format: Exclude<$ZodStringFormats, \"regex\" | \"jwt\" | \"starts_with\" | \"ends_with\" | \"includes\">;\n}\n\nexport interface $ZodIssueStringInvalidRegex extends $ZodIssueInvalidStringFormat {\n  format: \"regex\";\n  pattern: string;\n}\n\nexport interface $ZodIssueStringInvalidJWT extends $ZodIssueInvalidStringFormat {\n  format: \"jwt\";\n  algorithm?: string;\n}\n\nexport interface $ZodIssueStringStartsWith extends $ZodIssueInvalidStringFormat {\n  format: \"starts_with\";\n  prefix: string;\n}\n\nexport interface $ZodIssueStringEndsWith extends $ZodIssueInvalidStringFormat {\n  format: \"ends_with\";\n  suffix: string;\n}\n\nexport interface $ZodIssueStringIncludes extends $ZodIssueInvalidStringFormat {\n  format: \"includes\";\n  includes: string;\n}\n\nexport type $ZodStringFormatIssues =\n  | $ZodIssueStringCommonFormats\n  | $ZodIssueStringInvalidRegex\n  | $ZodIssueStringInvalidJWT\n  | $ZodIssueStringStartsWith\n  | $ZodIssueStringEndsWith\n  | $ZodIssueStringIncludes;\n\n////////////////////////\n////     utils     /////\n////////////////////////\n\nexport type $ZodIssue =\n  | $ZodIssueInvalidType\n  | $ZodIssueTooBig\n  | $ZodIssueTooSmall\n  | $ZodIssueInvalidStringFormat\n  | $ZodIssueNotMultipleOf\n  | $ZodIssueUnrecognizedKeys\n  | $ZodIssueInvalidUnion\n  | $ZodIssueInvalidKey\n  | $ZodIssueInvalidElement\n  | $ZodIssueInvalidValue\n  | $ZodIssueCustom;\n\nexport type $ZodIssueCode = $ZodIssue[\"code\"];\n\nexport type $ZodRawIssue<T extends $ZodIssueBase = $ZodIssue> = T extends any ? RawIssue<T> : never;\ntype RawIssue<T extends $ZodIssueBase> = util.Flatten<\n  util.MakePartial<T, \"message\" | \"path\"> & {\n    /** The input data */\n    readonly input?: unknown;\n    /** The schema or check that originated this issue. */\n    readonly inst?: $ZodType | $ZodCheck;\n    /** @deprecated Internal use only. If `true`, Zod will continue executing validation despite this issue. */\n    readonly continue?: boolean | undefined;\n  } & Record<string, any>\n>;\n\nexport interface $ZodErrorMap<T extends $ZodIssueBase = $ZodIssue> {\n  // biome-ignore lint:\n  (issue: $ZodRawIssue<T>): { message: string } | string | undefined | null;\n}\n\n////////////////////////    ERROR CLASS   ////////////////////////\n\n// const ZOD_ERROR: symbol = Symbol.for(\"{{zod.error}}\");\nexport interface $ZodError<T = unknown> extends Error {\n  type: T;\n  issues: $ZodIssue[];\n  _zod: {\n    output: T;\n    def: $ZodIssue[];\n  };\n  stack?: string;\n  name: string;\n}\n\nconst initializer = (inst: $ZodError, def: $ZodIssue[]): void => {\n  inst.name = \"$ZodError\";\n  Object.defineProperty(inst, \"_zod\", {\n    value: inst._zod,\n    enumerable: false,\n  });\n  Object.defineProperty(inst, \"issues\", {\n    value: def,\n    enumerable: false,\n  });\n  Object.defineProperty(inst, \"message\", {\n    get() {\n      return JSON.stringify(def, util.jsonStringifyReplacer, 2);\n    },\n    enumerable: true,\n    // configurable: false,\n  });\n  Object.defineProperty(inst, \"toString\", {\n    value: () => inst.message,\n    enumerable: false,\n  });\n};\n\nexport const $ZodError: $constructor<$ZodError> = $constructor(\"$ZodError\", initializer);\ninterface $ZodRealError<T = any> extends $ZodError<T> {}\nexport const $ZodRealError: $constructor<$ZodRealError> = $constructor(\"$ZodError\", initializer, { Parent: Error });\n\n///////////////////    ERROR UTILITIES   ////////////////////////\n\n// flatten\nexport type $ZodFlattenedError<T, U = string> = _FlattenedError<T, U>;\ntype _FlattenedError<T, U = string> = {\n  formErrors: U[];\n  fieldErrors: {\n    [P in keyof T]?: U[];\n  };\n};\n\nexport function flattenError<T>(error: $ZodError<T>): _FlattenedError<T>;\nexport function flattenError<T, U>(error: $ZodError<T>, mapper?: (issue: $ZodIssue) => U): _FlattenedError<T, U>;\nexport function flattenError(error: $ZodError, mapper = (issue: $ZodIssue) => issue.message): any {\n  const fieldErrors: any = {};\n  const formErrors: any[] = [];\n  for (const sub of error.issues) {\n    if (sub.path.length > 0) {\n      fieldErrors[sub.path[0]!] = fieldErrors[sub.path[0]!] || [];\n      fieldErrors[sub.path[0]!].push(mapper(sub));\n    } else {\n      formErrors.push(mapper(sub));\n    }\n  }\n  return { formErrors, fieldErrors };\n}\n\ntype _ZodFormattedError<T, U = string> = T extends [any, ...any[]]\n  ? { [K in keyof T]?: $ZodFormattedError<T[K], U> }\n  : T extends any[]\n    ? { [k: number]: $ZodFormattedError<T[number], U> }\n    : T extends object\n      ? util.Flatten<{ [K in keyof T]?: $ZodFormattedError<T[K], U> }>\n      : any;\n\nexport type $ZodFormattedError<T, U = string> = {\n  _errors: U[];\n} & util.Flatten<_ZodFormattedError<T, U>>;\n\nexport function formatError<T>(error: $ZodError<T>): $ZodFormattedError<T>;\nexport function formatError<T, U>(error: $ZodError<T>, mapper?: (issue: $ZodIssue) => U): $ZodFormattedError<T, U>;\nexport function formatError<T>(error: $ZodError, _mapper?: any) {\n  const mapper: (issue: $ZodIssue) => any =\n    _mapper ||\n    function (issue: $ZodIssue) {\n      return issue.message;\n    };\n  const fieldErrors: $ZodFormattedError<T> = { _errors: [] } as any;\n  const processError = (error: { issues: $ZodIssue[] }) => {\n    for (const issue of error.issues) {\n      if (issue.code === \"invalid_union\" && issue.errors.length) {\n        issue.errors.map((issues) => processError({ issues }));\n      } else if (issue.code === \"invalid_key\") {\n        processError({ issues: issue.issues });\n      } else if (issue.code === \"invalid_element\") {\n        processError({ issues: issue.issues });\n      } else if (issue.path.length === 0) {\n        (fieldErrors as any)._errors.push(mapper(issue));\n      } else {\n        let curr: any = fieldErrors;\n        let i = 0;\n        while (i < issue.path.length) {\n          const el = issue.path[i]!;\n          const terminal = i === issue.path.length - 1;\n\n          if (!terminal) {\n            curr[el] = curr[el] || { _errors: [] };\n          } else {\n            curr[el] = curr[el] || { _errors: [] };\n            curr[el]._errors.push(mapper(issue));\n          }\n\n          curr = curr[el];\n          i++;\n        }\n      }\n    }\n  };\n  processError(error);\n  return fieldErrors;\n}\n\nexport type $ZodErrorTree<T, U = string> = T extends [any, ...any[]]\n  ? { errors: U[]; items?: { [K in keyof T]?: $ZodErrorTree<T[K], U> } }\n  : T extends any[]\n    ? { errors: U[]; items?: Array<$ZodErrorTree<T[number], U>> }\n    : T extends object\n      ? { errors: U[]; properties?: { [K in keyof T]?: $ZodErrorTree<T[K], U> } }\n      : { errors: U[] };\n\nexport function treeifyError<T>(error: $ZodError<T>): $ZodErrorTree<T>;\nexport function treeifyError<T, U>(error: $ZodError<T>, mapper?: (issue: $ZodIssue) => U): $ZodErrorTree<T, U>;\nexport function treeifyError<T>(error: $ZodError, _mapper?: any) {\n  const mapper: (issue: $ZodIssue) => any =\n    _mapper ||\n    function (issue: $ZodIssue) {\n      return issue.message;\n    };\n  const result: $ZodErrorTree<T> = { errors: [] } as any;\n  const processError = (error: { issues: $ZodIssue[] }, path: PropertyKey[] = []) => {\n    for (const issue of error.issues) {\n      if (issue.code === \"invalid_union\" && issue.errors.length) {\n        // regular union error\n        issue.errors.map((issues) => processError({ issues }, issue.path));\n      } else if (issue.code === \"invalid_key\") {\n        processError({ issues: issue.issues }, issue.path);\n      } else if (issue.code === \"invalid_element\") {\n        processError({ issues: issue.issues }, issue.path);\n      } else {\n        const fullpath = [...path, ...issue.path];\n        if (fullpath.length === 0) {\n          result.errors.push(mapper(issue));\n          continue;\n        }\n\n        let curr: any = result;\n        let i = 0;\n        while (i < fullpath.length) {\n          const el = fullpath[i]!;\n\n          const terminal = i === fullpath.length - 1;\n          if (typeof el === \"string\") {\n            curr.properties ??= {};\n            curr.properties[el] ??= { errors: [] };\n            curr = curr.properties[el];\n          } else {\n            curr.items ??= [];\n            curr.items[el] ??= { errors: [] };\n            curr = curr.items[el];\n          }\n\n          if (terminal) {\n            curr.errors.push(mapper(issue));\n          }\n\n          i++;\n        }\n      }\n    }\n  };\n  processError(error);\n  return result;\n}\n\n/** Format a ZodError as a human-readable string in the following form.\n *\n * From\n *\n * ```ts\n * ZodError {\n *   issues: [\n *     {\n *       expected: 'string',\n *       code: 'invalid_type',\n *       path: [ 'username' ],\n *       message: 'Invalid input: expected string'\n *     },\n *     {\n *       expected: 'number',\n *       code: 'invalid_type',\n *       path: [ 'favoriteNumbers', 1 ],\n *       message: 'Invalid input: expected number'\n *     }\n *   ];\n * }\n * ```\n *\n * to\n *\n * ```\n * username\n *    Expected number, received string at \"username\n * favoriteNumbers[0]\n *    Invalid input: expected number\n * ```\n */\nexport function toDotPath(path: (string | number | symbol)[]): string {\n  const segs: string[] = [];\n  for (const seg of path) {\n    if (typeof seg === \"number\") segs.push(`[${seg}]`);\n    else if (typeof seg === \"symbol\") segs.push(`[${JSON.stringify(String(seg))}]`);\n    else if (/[^\\w$]/.test(seg)) segs.push(`[${JSON.stringify(seg)}]`);\n    else {\n      if (segs.length) segs.push(\".\");\n      segs.push(seg);\n    }\n  }\n\n  return segs.join(\"\");\n}\n\ninterface BaseError {\n  issues: $ZodIssueBase[];\n}\n\nexport function prettifyError(error: BaseError): string {\n  const lines: string[] = [];\n  // sort by path length\n  const issues = [...error.issues].sort((a, b) => a.path.length - b.path.length);\n\n  // Process each issue\n  for (const issue of issues) {\n    lines.push(` ${issue.message}`);\n    if (issue.path?.length) lines.push(`   at ${toDotPath(issue.path)}`);\n  }\n\n  // Convert Map to formatted string\n  return lines.join(\"\\n\");\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/core/errors.ts",
        "start": 1,
        "end": 424,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 424,
          "column": 2,
          "position": 4191
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/errors.ts",
        "start": 1,
        "end": 424,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 424,
          "column": 2,
          "position": 4191
        }
      }
    },
    {
      "format": "typescript",
      "lines": 44,
      "fragment": "type ModeWriter = (doc: Doc, modes: { execution: \"sync\" | \"async\" }) => void;\n\nexport class Doc {\n  args!: string[];\n  content: string[] = [];\n  indent = 0;\n\n  constructor(args: string[] = []) {\n    if (this) this.args = args;\n  }\n\n  indented(fn: (doc: Doc) => void) {\n    this.indent += 1;\n    fn(this);\n    this.indent -= 1;\n  }\n\n  write(fn: ModeWriter): void;\n  write(line: string): void;\n  write(arg: any) {\n    if (typeof arg === \"function\") {\n      (arg as ModeWriter)(this, { execution: \"sync\" });\n      (arg as ModeWriter)(this, { execution: \"async\" });\n      return;\n    }\n\n    const content = arg as string;\n    const lines = content.split(\"\\n\").filter((x) => x);\n    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));\n    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => \" \".repeat(this.indent * 2) + x);\n    for (const line of dedented) {\n      this.content.push(line);\n    }\n  }\n\n  compile() {\n    const F = Function;\n    const args = this?.args;\n    const content = this?.content ?? [``];\n    const lines = [...content.map((x) => `  ${x}`)];\n    // console.log(lines.join(\"\\n\"));\n    return new F(...args, lines.join(\"\\n\"));\n  }\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/core/doc.ts",
        "start": 1,
        "end": 44,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 44,
          "column": 2,
          "position": 540
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/doc.ts",
        "start": 1,
        "end": 44,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 44,
          "column": 2,
          "position": 540
        }
      }
    },
    {
      "format": "typescript",
      "lines": 134,
      "fragment": "import type * as errors from \"./errors.js\";\nimport type * as schemas from \"./schemas.js\";\nimport type { Class } from \"./util.js\";\n//////////////////////////////   CONSTRUCTORS   ///////////////////////////////////////\n\ntype ZodTrait = { _zod: { def: any; [k: string]: any } };\nexport interface $constructor<T extends ZodTrait, D = T[\"_zod\"][\"def\"]> {\n  new (def: D): T;\n  init(inst: T, def: D): asserts inst is T;\n}\n\n/** A special constant with type `never` */\nexport const NEVER: never = Object.freeze({\n  status: \"aborted\",\n}) as never;\n\nexport /*@__NO_SIDE_EFFECTS__*/ function $constructor<T extends ZodTrait, D = T[\"_zod\"][\"def\"]>(\n  name: string,\n  initializer: (inst: T, def: D) => void,\n  params?: { Parent?: typeof Class }\n): $constructor<T, D> {\n  function init(inst: T, def: D) {\n    Object.defineProperty(inst, \"_zod\", {\n      value: inst._zod ?? {},\n      enumerable: false,\n    });\n\n    inst._zod.traits ??= new Set();\n\n    inst._zod.traits.add(name);\n    initializer(inst, def);\n    // support prototype modifications\n    for (const k in _.prototype) {\n      if (!(k in inst)) Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });\n    }\n    inst._zod.constr = _;\n    inst._zod.def = def;\n  }\n\n  // doesn't work if Parent has a constructor with arguments\n  const Parent = params?.Parent ?? Object;\n  class Definition extends Parent {}\n  Object.defineProperty(Definition, \"name\", { value: name });\n\n  function _(this: any, def: D) {\n    const inst = params?.Parent ? new Definition() : this;\n    init(inst, def);\n    inst._zod.deferred ??= [];\n    for (const fn of inst._zod.deferred) {\n      fn();\n    }\n    return inst;\n  }\n\n  Object.defineProperty(_, \"init\", { value: init });\n  Object.defineProperty(_, Symbol.hasInstance, {\n    value: (inst: any) => {\n      if (params?.Parent && inst instanceof params.Parent) return true;\n      return inst?._zod?.traits?.has(name);\n    },\n  });\n  Object.defineProperty(_, \"name\", { value: name });\n  return _ as any;\n}\n\n//////////////////////////////   UTILITIES   ///////////////////////////////////////\nexport const $brand: unique symbol = Symbol(\"zod_brand\");\nexport type $brand<T extends string | number | symbol = string | number | symbol> = {\n  [$brand]: { [k in T]: true };\n};\n\nexport type $ZodBranded<T extends schemas.SomeType, Brand extends string | number | symbol> = T &\n  Record<\"_zod\", Record<\"output\", output<T> & $brand<Brand>>>;\n\nexport class $ZodAsyncError extends Error {\n  constructor() {\n    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);\n  }\n}\n\n////////////////////////////  TYPE HELPERS  ///////////////////////////////////\n\n// export type input<T extends schemas.$ZodType> = T[\"_zod\"][\"input\"];\n// export type output<T extends schemas.$ZodType> = T[\"_zod\"][\"output\"];\n// export type input<T extends schemas.$ZodType> = T[\"_zod\"][\"input\"];\n// export type output<T extends schemas.$ZodType> = T[\"_zod\"][\"output\"];\nexport type input<T> = T extends { _zod: { input: any } } ? Required<T[\"_zod\"]>[\"input\"] : unknown;\nexport type output<T> = T extends { _zod: { output: any } } ? Required<T[\"_zod\"]>[\"output\"] : unknown;\n\n// Mk2\n// export type input<T> = T extends { _zod: { \"~input\": any } }\n//   ? T[\"_zod\"][\"~input\"]\n//   : T extends { _zod: { input: any } }\n//     ? T[\"_zod\"][\"input\"]\n//     : never;\n// export type output<T> = T extends { _zod: { \"~output\": any } }\n//   ? T[\"_zod\"][\"~output\"]\n//   : T extends { _zod: { output: any } }\n//     ? T[\"_zod\"][\"output\"]\n//     : never;\n// Mk 3\n// export type input<T extends schemas.$ZodType> = T[\"_zod\"][\"input\"];\n// export type output<T extends schemas.$ZodType> = T[\"_zod\"][\"output\"];\n// Mk 4\n// export type input<T extends schemas.$ZodType> = T[] extends { _zod: { \"~input\": any } }\n//   ? T[\"_zod\"][\"~input\"]\n//   : T extends { _zod: { input: any } }\n//     ? T[\"_zod\"][\"input\"]\n//     : never;\n// export type output<T extends schemas.$ZodType> = T extends { _zod: { \"~output\": any } }\n//   ? T[\"_zod\"][\"~output\"]\n//   : T extends { _zod: { output: any } }\n//     ? T[\"_zod\"][\"output\"]\n//     : never;\n\nexport type { output as infer };\n\n//////////////////////////////   CONFIG   ///////////////////////////////////////\n\nexport interface $ZodConfig {\n  /** Custom error map. Overrides `config().localeError`. */\n  customError?: errors.$ZodErrorMap | undefined;\n  /** Localized error map. Lowest priority. */\n  localeError?: errors.$ZodErrorMap | undefined;\n  /** Disable JIT schema compilation. Useful in environments that disallow `eval`. */\n  jitless?: boolean | undefined;\n}\n\nexport const globalConfig: $ZodConfig = {};\n\nexport function config(newConfig?: Partial<$ZodConfig>): $ZodConfig {\n  if (newConfig) Object.assign(globalConfig, newConfig);\n  return globalConfig;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/core/core.ts",
        "start": 1,
        "end": 134,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 134,
          "column": 2,
          "position": 1256
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/core.ts",
        "start": 1,
        "end": 134,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 134,
          "column": 2,
          "position": 1256
        }
      }
    },
    {
      "format": "typescript",
      "lines": 15,
      "fragment": "import type * as errors from \"./errors.js\";\n\nexport interface $ZodConfig {\n  /** Custom error map. Overrides `config().localeError`. */\n  customError?: errors.$ZodErrorMap | undefined;\n  /** Localized error map. Lowest priority. */\n  localeError?: errors.$ZodErrorMap | undefined;\n}\n\nexport const globalConfig: $ZodConfig = {};\n\nexport function config(config?: Partial<$ZodConfig>): $ZodConfig {\n  if (config) Object.assign(globalConfig, config);\n  return globalConfig;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/core/config.ts",
        "start": 1,
        "end": 15,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 15,
          "column": 2,
          "position": 122
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/config.ts",
        "start": 1,
        "end": 15,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 15,
          "column": 2,
          "position": 122
        }
      }
    },
    {
      "format": "typescript",
      "lines": 33,
      "fragment": "import * as core from \"../core/index.js\";\nimport { type ZodError, ZodRealError } from \"./errors.js\";\n\nexport type ZodSafeParseResult<T> = ZodSafeParseSuccess<T> | ZodSafeParseError<T>;\nexport type ZodSafeParseSuccess<T> = { success: true; data: T; error?: never };\nexport type ZodSafeParseError<T> = { success: false; data?: never; error: ZodError<T> };\n\nexport const parse: <T extends core.$ZodType>(\n  schema: T,\n  value: unknown,\n  _ctx?: core.ParseContext<core.$ZodIssue>,\n  _params?: { callee?: core.util.AnyFunc; Err?: core.$ZodErrorClass }\n) => core.output<T> = /* @__PURE__ */ core._parse(ZodRealError) as any;\n\nexport const parseAsync: <T extends core.$ZodType>(\n  schema: T,\n  value: unknown,\n  _ctx?: core.ParseContext<core.$ZodIssue>,\n  _params?: { callee?: core.util.AnyFunc; Err?: core.$ZodErrorClass }\n) => Promise<core.output<T>> = /* @__PURE__ */ core._parseAsync(ZodRealError) as any;\n\nexport const safeParse: <T extends core.$ZodType>(\n  schema: T,\n  value: unknown,\n  _ctx?: core.ParseContext<core.$ZodIssue>\n  // _params?: { callee?: core.util.AnyFunc; Err?: core.$ZodErrorClass }\n) => ZodSafeParseResult<core.output<T>> = /* @__PURE__ */ core._safeParse(ZodRealError) as any;\n\nexport const safeParseAsync: <T extends core.$ZodType>(\n  schema: T,\n  value: unknown,\n  _ctx?: core.ParseContext<core.$ZodIssue>\n) => Promise<ZodSafeParseResult<core.output<T>>> = /* @__PURE__ */ core._safeParseAsync(ZodRealError) as any;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/parse.ts",
        "start": 1,
        "end": 33,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 33,
          "column": 2,
          "position": 490
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/parse.ts",
        "start": 1,
        "end": 33,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 33,
          "column": 2,
          "position": 490
        }
      }
    },
    {
      "format": "typescript",
      "lines": 90,
      "fragment": "import * as core from \"../core/index.js\";\nimport * as schemas from \"./schemas.js\";\n\n//////////////////////////////////////////////\n//////////////////////////////////////////////\n//////////                          //////////\n//////////      ZodISODateTime      //////////\n//////////                          //////////\n//////////////////////////////////////////////\n//////////////////////////////////////////////\n\nexport interface ZodISODateTime extends schemas.ZodStringFormat {\n  _zod: core.$ZodISODateTimeInternals;\n}\nexport const ZodISODateTime: core.$constructor<ZodISODateTime> = /*@__PURE__*/ core.$constructor(\n  \"ZodISODateTime\",\n  (inst, def) => {\n    core.$ZodISODateTime.init(inst, def);\n    schemas.ZodStringFormat.init(inst, def);\n  }\n);\n\nexport function datetime(params?: string | core.$ZodISODateTimeParams): ZodISODateTime {\n  return core._isoDateTime(ZodISODateTime, params);\n}\n\n//////////////////////////////////////////\n//////////////////////////////////////////\n//////////                      //////////\n//////////      ZodISODate      //////////\n//////////                      //////////\n//////////////////////////////////////////\n//////////////////////////////////////////\n\nexport interface ZodISODate extends schemas.ZodStringFormat {\n  _zod: core.$ZodISODateInternals;\n}\nexport const ZodISODate: core.$constructor<ZodISODate> = /*@__PURE__*/ core.$constructor(\"ZodISODate\", (inst, def) => {\n  core.$ZodISODate.init(inst, def);\n  schemas.ZodStringFormat.init(inst, def);\n});\n\nexport function date(params?: string | core.$ZodISODateParams): ZodISODate {\n  return core._isoDate(ZodISODate, params);\n}\n\n// ZodISOTime\n\n//////////////////////////////////////////\n//////////////////////////////////////////\n//////////                      //////////\n//////////      ZodISOTime      //////////\n//////////                      //////////\n//////////////////////////////////////////\n//////////////////////////////////////////\n\nexport interface ZodISOTime extends schemas.ZodStringFormat {\n  _zod: core.$ZodISOTimeInternals;\n}\nexport const ZodISOTime: core.$constructor<ZodISOTime> = /*@__PURE__*/ core.$constructor(\"ZodISOTime\", (inst, def) => {\n  core.$ZodISOTime.init(inst, def);\n  schemas.ZodStringFormat.init(inst, def);\n});\n\nexport function time(params?: string | core.$ZodISOTimeParams): ZodISOTime {\n  return core._isoTime(ZodISOTime, params);\n}\n\n//////////////////////////////////////////////\n//////////////////////////////////////////////\n//////////                          //////////\n//////////      ZodISODuration      //////////\n//////////                          //////////\n//////////////////////////////////////////////\n//////////////////////////////////////////////\n\nexport interface ZodISODuration extends schemas.ZodStringFormat {\n  _zod: core.$ZodISODurationInternals;\n}\nexport const ZodISODuration: core.$constructor<ZodISODuration> = /*@__PURE__*/ core.$constructor(\n  \"ZodISODuration\",\n  (inst, def) => {\n    core.$ZodISODuration.init(inst, def);\n    schemas.ZodStringFormat.init(inst, def);\n  }\n);\n\nexport function duration(params?: string | core.$ZodISODurationParams): ZodISODuration {\n  return core._isoDuration(ZodISODuration, params);\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/iso.ts",
        "start": 1,
        "end": 90,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 90,
          "column": 2,
          "position": 645
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/iso.ts",
        "start": 1,
        "end": 90,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 90,
          "column": 2,
          "position": 645
        }
      }
    },
    {
      "format": "typescript",
      "lines": 50,
      "fragment": "export * as core from \"../core/index.js\";\nexport * from \"./schemas.js\";\nexport * from \"./checks.js\";\nexport * from \"./errors.js\";\nexport * from \"./parse.js\";\nexport * from \"./compat.js\";\n\n// zod-specified\nimport { config } from \"../core/index.js\";\nimport en from \"../locales/en.js\";\nconfig(en());\n\nexport type { infer, output, input } from \"../core/index.js\";\nexport {\n  globalRegistry,\n  type GlobalMeta,\n  registry,\n  config,\n  function,\n  $output,\n  $input,\n  $brand,\n  clone,\n  regexes,\n  treeifyError,\n  prettifyError,\n  formatError,\n  flattenError,\n  toJSONSchema,\n  TimePrecision,\n  NEVER,\n} from \"../core/index.js\";\n\nexport * as locales from \"../locales/index.js\";\n\n// iso\n// must be exported from top-level\n// https://github.com/colinhacks/zod/issues/4491\nexport { ZodISODateTime, ZodISODate, ZodISOTime, ZodISODuration } from \"./iso.js\";\nexport * as iso from \"./iso.js\";\n\n// coerce\nexport type {\n  ZodCoercedString,\n  ZodCoercedNumber,\n  ZodCoercedBigInt,\n  ZodCoercedBoolean,\n  ZodCoercedDate,\n} from \"./coerce.js\";\nexport * as coerce from \"./coerce.js\";",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/external.ts",
        "start": 1,
        "end": 50,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 50,
          "column": 2,
          "position": 297
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/external.ts",
        "start": 1,
        "end": 50,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 50,
          "column": 2,
          "position": 297
        }
      }
    },
    {
      "format": "typescript",
      "lines": 75,
      "fragment": "import * as core from \"../core/index.js\";\nimport { $ZodError } from \"../core/index.js\";\n\n/** @deprecated Use `z.core.$ZodIssue` from `@zod/core` instead, especially if you are building a library on top of Zod. */\nexport type ZodIssue = core.$ZodIssue;\n\n/** An Error-like class used to store Zod validation issues.  */\nexport interface ZodError<T = unknown> extends $ZodError<T> {\n  /** @deprecated Use the `z.treeifyError(err)` function instead. */\n  format(): core.$ZodFormattedError<T>;\n  format<U>(mapper: (issue: core.$ZodIssue) => U): core.$ZodFormattedError<T, U>;\n  /** @deprecated Use the `z.treeifyError(err)` function instead. */\n  flatten(): core.$ZodFlattenedError<T>;\n  flatten<U>(mapper: (issue: core.$ZodIssue) => U): core.$ZodFlattenedError<T, U>;\n  /** @deprecated Push directly to `.issues` instead. */\n  addIssue(issue: core.$ZodIssue): void;\n  /** @deprecated Push directly to `.issues` instead. */\n  addIssues(issues: core.$ZodIssue[]): void;\n\n  /** @deprecated Check `err.issues.length === 0` instead. */\n  isEmpty: boolean;\n}\n\nconst initializer = (inst: ZodError, issues: core.$ZodIssue[]) => {\n  $ZodError.init(inst, issues);\n  inst.name = \"ZodError\";\n  Object.defineProperties(inst, {\n    format: {\n      value: (mapper: any) => core.formatError(inst, mapper),\n      // enumerable: false,\n    },\n    flatten: {\n      value: (mapper: any) => core.flattenError(inst, mapper),\n      // enumerable: false,\n    },\n    addIssue: {\n      value: (issue: any) => inst.issues.push(issue),\n      // enumerable: false,\n    },\n    addIssues: {\n      value: (issues: any) => inst.issues.push(...issues),\n      // enumerable: false,\n    },\n    isEmpty: {\n      get() {\n        return inst.issues.length === 0;\n      },\n      // enumerable: false,\n    },\n  });\n  // Object.defineProperty(inst, \"isEmpty\", {\n  //   get() {\n  //     return inst.issues.length === 0;\n  //   },\n  // });\n};\nexport const ZodError: core.$constructor<ZodError> = core.$constructor(\"ZodError\", initializer);\nexport const ZodRealError: core.$constructor<ZodError> = core.$constructor(\"ZodError\", initializer, {\n  Parent: Error,\n});\n\nexport type {\n  /** @deprecated Use `z.core.$ZodFlattenedError` instead. */\n  $ZodFlattenedError as ZodFlattenedError,\n  /** @deprecated Use `z.core.$ZodFormattedError` instead. */\n  $ZodFormattedError as ZodFormattedError,\n  /** @deprecated Use `z.core.$ZodErrorMap` instead. */\n  $ZodErrorMap as ZodErrorMap,\n} from \"../core/index.js\";\n\n/** @deprecated Use `z.core.$ZodRawIssue` instead. */\nexport type IssueData = core.$ZodRawIssue;\n\n// /** @deprecated Use `z.core.$ZodErrorMapCtx` instead. */\n// export type ErrorMapCtx = core.$ZodErrorMapCtx;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/errors.ts",
        "start": 1,
        "end": 75,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 75,
          "column": 2,
          "position": 640
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/errors.ts",
        "start": 1,
        "end": 75,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 75,
          "column": 2,
          "position": 640
        }
      }
    },
    {
      "format": "typescript",
      "lines": 66,
      "fragment": "// Zod 3 compat layer\n\nimport * as core from \"../core/index.js\";\nimport type { ZodType } from \"./schemas.js\";\n\nexport type {\n  /** @deprecated Use `z.output<T>` instead. */\n  output as TypeOf,\n  /** @deprecated Use `z.output<T>` instead. */\n  output as Infer,\n  /** @deprecated Use `z.core.$$ZodFirstPartyTypes` instead */\n  $ZodTypes as ZodFirstPartySchemaTypes,\n} from \"../core/index.js\";\n\n/** @deprecated Use the raw string literal codes instead, e.g. \"invalid_type\". */\nexport const ZodIssueCode = {\n  invalid_type: \"invalid_type\",\n  too_big: \"too_big\",\n  too_small: \"too_small\",\n  invalid_format: \"invalid_format\",\n  not_multiple_of: \"not_multiple_of\",\n  unrecognized_keys: \"unrecognized_keys\",\n  invalid_union: \"invalid_union\",\n  invalid_key: \"invalid_key\",\n  invalid_element: \"invalid_element\",\n  invalid_value: \"invalid_value\",\n  custom: \"custom\",\n} as const;\n\n/** @deprecated Use `z.$ZodFlattenedError` */\nexport type inferFlattenedErrors<T extends core.$ZodType, U = string> = core.$ZodFlattenedError<core.output<T>, U>;\n\n/** @deprecated Use `z.$ZodFormattedError` */\nexport type inferFormattedError<T extends core.$ZodType<any, any>, U = string> = core.$ZodFormattedError<\n  core.output<T>,\n  U\n>;\n\n/** Use `z.$brand` instead */\nexport type BRAND<T extends string | number | symbol = string | number | symbol> = {\n  [core.$brand]: { [k in T]: true };\n};\nexport { $brand, config } from \"../core/index.js\";\n\n/** @deprecated Use `z.config(params)` instead. */\nexport function setErrorMap(map: core.$ZodErrorMap): void {\n  core.config({\n    customError: map,\n  });\n}\n\n/** @deprecated Use `z.config()` instead. */\nexport function getErrorMap(): core.$ZodErrorMap<core.$ZodIssue> | undefined {\n  return core.config().customError;\n}\n\nexport type {\n  /** @deprecated Use z.ZodType (without generics) instead. */\n  ZodType as ZodTypeAny,\n  /** @deprecated Use `z.ZodType` */\n  ZodType as ZodSchema,\n  /** @deprecated Use `z.ZodType` */\n  ZodType as Schema,\n};\n\nexport type ZodRawShape = core.$ZodShape;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/compat.ts",
        "start": 1,
        "end": 66,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 66,
          "column": 2,
          "position": 493
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/compat.ts",
        "start": 1,
        "end": 66,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 66,
          "column": 2,
          "position": 493
        }
      }
    },
    {
      "format": "typescript",
      "lines": 27,
      "fragment": "import * as core from \"../core/index.js\";\nimport * as schemas from \"./schemas.js\";\n\nexport interface ZodCoercedString<T = unknown> extends schemas._ZodString<core.$ZodStringInternals<T>> {}\nexport function string<T = unknown>(params?: string | core.$ZodStringParams): ZodCoercedString<T> {\n  return core._coercedString(schemas.ZodString, params) as any;\n}\n\nexport interface ZodCoercedNumber<T = unknown> extends schemas._ZodNumber<core.$ZodNumberInternals<T>> {}\nexport function number<T = unknown>(params?: string | core.$ZodNumberParams): ZodCoercedNumber<T> {\n  return core._coercedNumber(schemas.ZodNumber, params) as ZodCoercedNumber<T>;\n}\n\nexport interface ZodCoercedBoolean<T = unknown> extends schemas._ZodBoolean<core.$ZodBooleanInternals<T>> {}\nexport function boolean<T = unknown>(params?: string | core.$ZodBooleanParams): ZodCoercedBoolean<T> {\n  return core._coercedBoolean(schemas.ZodBoolean, params) as ZodCoercedBoolean<T>;\n}\n\nexport interface ZodCoercedBigInt<T = unknown> extends schemas._ZodBigInt<core.$ZodBigIntInternals<T>> {}\nexport function bigint<T = unknown>(params?: string | core.$ZodBigIntParams): ZodCoercedBigInt<T> {\n  return core._coercedBigint(schemas.ZodBigInt, params) as ZodCoercedBigInt<T>;\n}\n\nexport interface ZodCoercedDate<T = unknown> extends schemas._ZodDate<core.$ZodDateInternals<T>> {}\nexport function date<T = unknown>(params?: string | core.$ZodDateParams): ZodCoercedDate<T> {\n  return core._coercedDate(schemas.ZodDate, params) as ZodCoercedDate<T>;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/coerce.ts",
        "start": 1,
        "end": 27,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 27,
          "column": 2,
          "position": 466
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/coerce.ts",
        "start": 1,
        "end": 27,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 27,
          "column": 2,
          "position": 466
        }
      }
    },
    {
      "format": "typescript",
      "lines": 30,
      "fragment": "export {\n  _lt as lt,\n  _lte as lte,\n  _gt as gt,\n  _gte as gte,\n  _positive as positive,\n  _negative as negative,\n  _nonpositive as nonpositive,\n  _nonnegative as nonnegative,\n  _multipleOf as multipleOf,\n  _maxSize as maxSize,\n  _minSize as minSize,\n  _size as size,\n  _maxLength as maxLength,\n  _minLength as minLength,\n  _length as length,\n  _regex as regex,\n  _lowercase as lowercase,\n  _uppercase as uppercase,\n  _includes as includes,\n  _startsWith as startsWith,\n  _endsWith as endsWith,\n  _property as property,\n  _mime as mime,\n  _overwrite as overwrite,\n  _normalize as normalize,\n  _trim as trim,\n  _toLowerCase as toLowerCase,\n  _toUpperCase as toUpperCase,\n} from \"../core/index.js\";",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v4/classic/checks.ts",
        "start": 1,
        "end": 30,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 30,
          "column": 2,
          "position": 233
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/checks.ts",
        "start": 1,
        "end": 32,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 32,
          "column": 2,
          "position": 249
        }
      }
    },
    {
      "format": "typescript",
      "lines": 15,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\ntest(\"void\", () => {\n  const v = z.void();\n  v.parse(undefined);\n\n  expect(() => v.parse(null)).toThrow();\n  expect(() => v.parse(\"\")).toThrow();\n\n  type v = z.infer<typeof v>;\n  util.assertEqual<v, void>(true);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/void.test.ts",
        "start": 1,
        "end": 15,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 15,
          "column": 2,
          "position": 158
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/void.test.ts",
        "start": 1,
        "end": 15,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 15,
          "column": 2,
          "position": 158
        }
      }
    },
    {
      "format": "typescript",
      "lines": 133,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\ntest(\"array min\", async () => {\n  try {\n    await z.array(z.string()).min(4).parseAsync([]);\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"Array must contain at least 4 element(s)\");\n  }\n});\n\ntest(\"array max\", async () => {\n  try {\n    await z.array(z.string()).max(2).parseAsync([\"asdf\", \"asdf\", \"asdf\"]);\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"Array must contain at most 2 element(s)\");\n  }\n});\n\ntest(\"array length\", async () => {\n  try {\n    await z.array(z.string()).length(2).parseAsync([\"asdf\", \"asdf\", \"asdf\"]);\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"Array must contain exactly 2 element(s)\");\n  }\n\n  try {\n    await z.array(z.string()).length(2).parseAsync([\"asdf\"]);\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"Array must contain exactly 2 element(s)\");\n  }\n});\n\ntest(\"string length\", async () => {\n  try {\n    await z.string().length(4).parseAsync(\"asd\");\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"String must contain exactly 4 character(s)\");\n  }\n\n  try {\n    await z.string().length(4).parseAsync(\"asdaa\");\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"String must contain exactly 4 character(s)\");\n  }\n});\n\ntest(\"string min\", async () => {\n  try {\n    await z.string().min(4).parseAsync(\"asd\");\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"String must contain at least 4 character(s)\");\n  }\n});\n\ntest(\"string max\", async () => {\n  try {\n    await z.string().max(4).parseAsync(\"aasdfsdfsd\");\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"String must contain at most 4 character(s)\");\n  }\n});\n\ntest(\"number min\", async () => {\n  try {\n    await z.number().gte(3).parseAsync(2);\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"Number must be greater than or equal to 3\");\n  }\n});\n\ntest(\"number max\", async () => {\n  try {\n    await z.number().lte(3).parseAsync(4);\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"Number must be less than or equal to 3\");\n  }\n});\n\ntest(\"number nonnegative\", async () => {\n  try {\n    await z.number().nonnegative().parseAsync(-1);\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"Number must be greater than or equal to 0\");\n  }\n});\n\ntest(\"number nonpositive\", async () => {\n  try {\n    await z.number().nonpositive().parseAsync(1);\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"Number must be less than or equal to 0\");\n  }\n});\n\ntest(\"number negative\", async () => {\n  try {\n    await z.number().negative().parseAsync(1);\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"Number must be less than 0\");\n  }\n});\n\ntest(\"number positive\", async () => {\n  try {\n    await z.number().positive().parseAsync(-1);\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"Number must be greater than 0\");\n  }\n});\n\ntest(\"instantiation\", () => {\n  z.string().min(5);\n  z.string().max(5);\n  z.string().length(5);\n  z.string().email();\n  z.string().url();\n  z.string().uuid();\n  z.string().min(5, { message: \"Must be 5 or more characters long\" });\n  z.string().max(5, { message: \"Must be 5 or fewer characters long\" });\n  z.string().length(5, { message: \"Must be exactly 5 characters long\" });\n  z.string().email({ message: \"Invalid email address.\" });\n  z.string().url({ message: \"Invalid url\" });\n  z.string().uuid({ message: \"Invalid UUID\" });\n});\n\ntest(\"int\", async () => {\n  const int = z.number().int();\n  int.parse(4);\n  expect(() => int.parse(3.5)).toThrow();\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/validations.test.ts",
        "start": 1,
        "end": 133,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 133,
          "column": 2,
          "position": 1509
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/validations.test.ts",
        "start": 1,
        "end": 133,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 133,
          "column": 2,
          "position": 1509
        }
      }
    },
    {
      "format": "typescript",
      "lines": 57,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\ntest(\"function parsing\", () => {\n  const schema = z.union([z.string().refine(() => false), z.number().refine(() => false)]);\n  const result = schema.safeParse(\"asdf\");\n  expect(result.success).toEqual(false);\n});\n\ntest(\"union 2\", () => {\n  const result = z.union([z.number(), z.string().refine(() => false)]).safeParse(\"a\");\n  expect(result.success).toEqual(false);\n});\n\ntest(\"return valid over invalid\", () => {\n  const schema = z.union([\n    z.object({\n      email: z.string().email(),\n    }),\n    z.string(),\n  ]);\n  expect(schema.parse(\"asdf\")).toEqual(\"asdf\");\n  expect(schema.parse({ email: \"asdlkjf@lkajsdf.com\" })).toEqual({\n    email: \"asdlkjf@lkajsdf.com\",\n  });\n});\n\ntest(\"return dirty result over aborted\", () => {\n  const result = z.union([z.number(), z.string().refine(() => false)]).safeParse(\"a\");\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues).toEqual([\n      {\n        code: \"custom\",\n        message: \"Invalid input\",\n        path: [],\n      },\n    ]);\n  }\n});\n\ntest(\"options getter\", async () => {\n  const union = z.union([z.string(), z.number()]);\n  union.options[0].parse(\"asdf\");\n  union.options[1].parse(1234);\n  await union.options[0].parseAsync(\"asdf\");\n  await union.options[1].parseAsync(1234);\n});\n\ntest(\"readonly union\", async () => {\n  const options = [z.string(), z.number()] as const;\n  const union = z.union(options);\n  union.parse(\"asdf\");\n  union.parse(12);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/unions.test.ts",
        "start": 1,
        "end": 57,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 57,
          "column": 2,
          "position": 642
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/unions.test.ts",
        "start": 1,
        "end": 75,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 75,
          "column": 2,
          "position": 611
        }
      }
    },
    {
      "format": "typescript",
      "lines": 90,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { ZodError } from \"../ZodError.js\";\nimport { util } from \"../helpers/util.js\";\n\nconst testTuple = z.tuple([z.string(), z.object({ name: z.literal(\"Rudy\") }), z.array(z.literal(\"blue\"))]);\nconst testData = [\"asdf\", { name: \"Rudy\" }, [\"blue\"]];\nconst badData = [123, { name: \"Rudy2\" }, [\"blue\", \"red\"]];\n\ntest(\"tuple inference\", () => {\n  const args1 = z.tuple([z.string()]);\n  const returns1 = z.number();\n  const func1 = z.function(args1, returns1);\n  type func1 = z.TypeOf<typeof func1>;\n  util.assertEqual<func1, (k: string) => number>(true);\n});\n\ntest(\"successful validation\", () => {\n  const val = testTuple.parse(testData);\n  expect(val).toEqual([\"asdf\", { name: \"Rudy\" }, [\"blue\"]]);\n});\n\ntest(\"successful async validation\", async () => {\n  const val = await testTuple.parseAsync(testData);\n  return expect(val).toEqual(testData);\n});\n\ntest(\"failed validation\", () => {\n  const checker = () => {\n    testTuple.parse([123, { name: \"Rudy2\" }, [\"blue\", \"red\"]] as any);\n  };\n  try {\n    checker();\n  } catch (err) {\n    if (err instanceof ZodError) {\n      expect(err.issues.length).toEqual(3);\n    }\n  }\n});\n\ntest(\"failed async validation\", async () => {\n  const res = await testTuple.safeParse(badData);\n  expect(res.success).toEqual(false);\n  if (!res.success) {\n    expect(res.error.issues.length).toEqual(3);\n  }\n  // try {\n  //   checker();\n  // } catch (err) {\n  //   if (err instanceof ZodError) {\n  //     expect(err.issues.length).toEqual(3);\n  //   }\n  // }\n});\n\ntest(\"tuple with transformers\", () => {\n  const stringToNumber = z.string().transform((val) => val.length);\n  const val = z.tuple([stringToNumber]);\n\n  type t1 = z.input<typeof val>;\n  util.assertEqual<t1, [string]>(true);\n  type t2 = z.output<typeof val>;\n  util.assertEqual<t2, [number]>(true);\n  expect(val.parse([\"1234\"])).toEqual([4]);\n});\n\ntest(\"tuple with rest schema\", () => {\n  const myTuple = z.tuple([z.string(), z.number()]).rest(z.boolean());\n  expect(myTuple.parse([\"asdf\", 1234, true, false, true])).toEqual([\"asdf\", 1234, true, false, true]);\n\n  expect(myTuple.parse([\"asdf\", 1234])).toEqual([\"asdf\", 1234]);\n\n  expect(() => myTuple.parse([\"asdf\", 1234, \"asdf\"])).toThrow();\n  type t1 = z.output<typeof myTuple>;\n\n  util.assertEqual<t1, [string, number, ...boolean[]]>(true);\n});\n\ntest(\"parse should fail given sparse array as tuple\", () => {\n  expect(() => testTuple.parse(new Array(3))).toThrow();\n});\n\n// test('tuple with optional elements', () => {\n//   const result = z\n//     .tuple([z.string(), z.number().optional()])\n//     .safeParse(['asdf']);\n//   expect(result).toEqual(['asdf']);\n// });",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/tuple.test.ts",
        "start": 1,
        "end": 90,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 90,
          "column": 7,
          "position": 1024
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/tuple.test.ts",
        "start": 1,
        "end": 90,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 90,
          "column": 7,
          "position": 1024
        }
      }
    },
    {
      "format": "typescript",
      "lines": 233,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\nconst stringToNumber = z.string().transform((arg) => Number.parseFloat(arg));\n// const numberToString = z\n//   .transformer(z.number())\n//   .transform((n) => String(n));\nconst asyncNumberToString = z.number().transform(async (n) => String(n));\n\ntest(\"transform ctx.addIssue with parse\", () => {\n  const strs = [\"foo\", \"bar\"];\n\n  expect(() => {\n    z.string()\n      .transform((data, ctx) => {\n        const i = strs.indexOf(data);\n        if (i === -1) {\n          ctx.addIssue({\n            code: \"custom\",\n            message: `${data} is not one of our allowed strings`,\n          });\n        }\n        return data.length;\n      })\n      .parse(\"asdf\");\n  }).toThrow(\n    JSON.stringify(\n      [\n        {\n          code: \"custom\",\n          message: \"asdf is not one of our allowed strings\",\n          path: [],\n        },\n      ],\n      null,\n      2\n    )\n  );\n});\n\ntest(\"transform ctx.addIssue with parseAsync\", async () => {\n  const strs = [\"foo\", \"bar\"];\n\n  const result = await z\n    .string()\n    .transform(async (data, ctx) => {\n      const i = strs.indexOf(data);\n      if (i === -1) {\n        ctx.addIssue({\n          code: \"custom\",\n          message: `${data} is not one of our allowed strings`,\n        });\n      }\n      return data.length;\n    })\n    .safeParseAsync(\"asdf\");\n\n  expect(JSON.parse(JSON.stringify(result))).toEqual({\n    success: false,\n    error: {\n      issues: [\n        {\n          code: \"custom\",\n          message: \"asdf is not one of our allowed strings\",\n          path: [],\n        },\n      ],\n      name: \"ZodError\",\n    },\n  });\n});\n\ntest(\"z.NEVER in transform\", () => {\n  const foo = z\n    .number()\n    .optional()\n    .transform((val, ctx) => {\n      if (!val) {\n        ctx.addIssue({ code: z.ZodIssueCode.custom, message: \"bad\" });\n        return z.NEVER;\n      }\n      return val;\n    });\n  type foo = z.infer<typeof foo>;\n  util.assertEqual<foo, number>(true);\n  const arg = foo.safeParse(undefined);\n  if (!arg.success) {\n    expect(arg.error.issues[0].message).toEqual(\"bad\");\n  }\n});\n\ntest(\"basic transformations\", () => {\n  const r1 = z\n    .string()\n    .transform((data) => data.length)\n    .parse(\"asdf\");\n  expect(r1).toEqual(4);\n});\n\ntest(\"coercion\", () => {\n  const numToString = z.number().transform((n) => String(n));\n  const data = z\n    .object({\n      id: numToString,\n    })\n    .parse({ id: 5 });\n\n  expect(data).toEqual({ id: \"5\" });\n});\n\ntest(\"async coercion\", async () => {\n  const numToString = z.number().transform(async (n) => String(n));\n  const data = await z\n    .object({\n      id: numToString,\n    })\n    .parseAsync({ id: 5 });\n\n  expect(data).toEqual({ id: \"5\" });\n});\n\ntest(\"sync coercion async error\", async () => {\n  expect(() =>\n    z\n      .object({\n        id: asyncNumberToString,\n      })\n      .parse({ id: 5 })\n  ).toThrow();\n  // expect(data).toEqual({ id: '5' });\n});\n\ntest(\"default\", () => {\n  const data = z.string().default(\"asdf\").parse(undefined); // => \"asdf\"\n  expect(data).toEqual(\"asdf\");\n});\n\ntest(\"dynamic default\", () => {\n  const data = z\n    .string()\n    .default(() => \"string\")\n    .parse(undefined); // => \"asdf\"\n  expect(data).toEqual(\"string\");\n});\n\ntest(\"default when property is null or undefined\", () => {\n  const data = z\n    .object({\n      foo: z.boolean().nullable().default(true),\n      bar: z.boolean().default(true),\n    })\n    .parse({ foo: null });\n\n  expect(data).toEqual({ foo: null, bar: true });\n});\n\ntest(\"default with falsy values\", () => {\n  const schema = z.object({\n    emptyStr: z.string().default(\"def\"),\n    zero: z.number().default(5),\n    falseBoolean: z.boolean().default(true),\n  });\n  const input = { emptyStr: \"\", zero: 0, falseBoolean: true };\n  const output = schema.parse(input);\n  // defaults are not supposed to be used\n  expect(output).toEqual(input);\n});\n\ntest(\"object typing\", () => {\n  const t1 = z.object({\n    stringToNumber,\n  });\n\n  type t1 = z.input<typeof t1>;\n  type t2 = z.output<typeof t1>;\n\n  util.assertEqual<t1, { stringToNumber: string }>(true);\n  util.assertEqual<t2, { stringToNumber: number }>(true);\n});\n\ntest(\"transform method overloads\", () => {\n  const t1 = z.string().transform((val) => val.toUpperCase());\n  expect(t1.parse(\"asdf\")).toEqual(\"ASDF\");\n\n  const t2 = z.string().transform((val) => val.length);\n  expect(t2.parse(\"asdf\")).toEqual(4);\n});\n\ntest(\"multiple transformers\", () => {\n  const doubler = stringToNumber.transform((val) => {\n    return val * 2;\n  });\n  expect(doubler.parse(\"5\")).toEqual(10);\n});\n\ntest(\"short circuit on dirty\", () => {\n  const schema = z\n    .string()\n    .refine(() => false)\n    .transform((val) => val.toUpperCase());\n  const result = schema.safeParse(\"asdf\");\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues[0].code).toEqual(z.ZodIssueCode.custom);\n  }\n\n  const result2 = schema.safeParse(1234);\n  expect(result2.success).toEqual(false);\n  if (!result2.success) {\n    expect(result2.error.issues[0].code).toEqual(z.ZodIssueCode.invalid_type);\n  }\n});\n\ntest(\"async short circuit on dirty\", async () => {\n  const schema = z\n    .string()\n    .refine(() => false)\n    .transform((val) => val.toUpperCase());\n  const result = await schema.spa(\"asdf\");\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues[0].code).toEqual(z.ZodIssueCode.custom);\n  }\n\n  const result2 = await schema.spa(1234);\n  expect(result2.success).toEqual(false);\n  if (!result2.success) {\n    expect(result2.error.issues[0].code).toEqual(z.ZodIssueCode.invalid_type);\n  }\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/transformer.test.ts",
        "start": 1,
        "end": 233,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 233,
          "column": 2,
          "position": 2188
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/transformer.test.ts",
        "start": 1,
        "end": 217,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 217,
          "column": 2,
          "position": 1889
        }
      }
    },
    {
      "format": "typescript",
      "lines": 916,
      "fragment": "import { Buffer } from \"node:buffer\";\n// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\nconst minFive = z.string().min(5, \"min5\");\nconst maxFive = z.string().max(5, \"max5\");\nconst justFive = z.string().length(5);\nconst nonempty = z.string().nonempty(\"nonempty\");\nconst includes = z.string().includes(\"includes\");\nconst includesFromIndex2 = z.string().includes(\"includes\", { position: 2 });\nconst startsWith = z.string().startsWith(\"startsWith\");\nconst endsWith = z.string().endsWith(\"endsWith\");\n\ntest(\"passing validations\", () => {\n  minFive.parse(\"12345\");\n  minFive.parse(\"123456\");\n  maxFive.parse(\"12345\");\n  maxFive.parse(\"1234\");\n  nonempty.parse(\"1\");\n  justFive.parse(\"12345\");\n  includes.parse(\"XincludesXX\");\n  includesFromIndex2.parse(\"XXXincludesXX\");\n  startsWith.parse(\"startsWithX\");\n  endsWith.parse(\"XendsWith\");\n});\n\ntest(\"failing validations\", () => {\n  expect(() => minFive.parse(\"1234\")).toThrow();\n  expect(() => maxFive.parse(\"123456\")).toThrow();\n  expect(() => nonempty.parse(\"\")).toThrow();\n  expect(() => justFive.parse(\"1234\")).toThrow();\n  expect(() => justFive.parse(\"123456\")).toThrow();\n  expect(() => includes.parse(\"XincludeXX\")).toThrow();\n  expect(() => includesFromIndex2.parse(\"XincludesXX\")).toThrow();\n  expect(() => startsWith.parse(\"x\")).toThrow();\n  expect(() => endsWith.parse(\"x\")).toThrow();\n});\n\ntest(\"email validations\", () => {\n  const validEmails = [\n    `email@domain.com`,\n    `firstname.lastname@domain.com`,\n    `email@subdomain.domain.com`,\n    `firstname+lastname@domain.com`,\n    `1234567890@domain.com`,\n    `email@domain-one.com`,\n    `_______@domain.com`,\n    `email@domain.name`,\n    `email@domain.co.jp`,\n    `firstname-lastname@domain.com`,\n    `very.common@example.com`,\n    `disposable.style.email.with+symbol@example.com`,\n    `other.email-with-hyphen@example.com`,\n    `fully-qualified-domain@example.com`,\n    `user.name+tag+sorting@example.com`,\n    `x@example.com`,\n    `mojojojo@asdf.example.com`,\n    `example-indeed@strange-example.com`,\n    `example@s.example`,\n    `user-@example.org`,\n    `user@my-example.com`,\n    `a@b.cd`,\n    `work+user@mail.com`,\n    `tom@test.te-st.com`,\n    `something@subdomain.domain-with-hyphens.tld`,\n    `common'name@domain.com`,\n    `francois@etu.inp-n7.fr`,\n  ];\n  const invalidEmails = [\n    // no \"printable characters\"\n    // `user%example.com@example.org`,\n    // `mailhost!username@example.org`,\n    // `test/test@test.com`,\n\n    // double @\n    `francois@@etu.inp-n7.fr`,\n    // do not support quotes\n    `\"email\"@domain.com`,\n    `\"e asdf sadf ?<>ail\"@domain.com`,\n    `\" \"@example.org`,\n    `\"john..doe\"@example.org`,\n    `\"very.(),:;<>[]\\\".VERY.\\\"very@\\\\ \\\"very\\\".unusual\"@strange.example.com`,\n    // do not support comma\n    `a,b@domain.com`,\n\n    // do not support IPv4\n    `email@123.123.123.123`,\n    `email@[123.123.123.123]`,\n    `postmaster@123.123.123.123`,\n    `user@[68.185.127.196]`,\n    `ipv4@[85.129.96.247]`,\n    `valid@[79.208.229.53]`,\n    `valid@[255.255.255.255]`,\n    `valid@[255.0.55.2]`,\n    `valid@[255.0.55.2]`,\n\n    // do not support ipv6\n    `hgrebert0@[IPv6:4dc8:ac7:ce79:8878:1290:6098:5c50:1f25]`,\n    `bshapiro4@[IPv6:3669:c709:e981:4884:59a3:75d1:166b:9ae]`,\n    `jsmith@[IPv6:2001:db8::1]`,\n    `postmaster@[IPv6:2001:0db8:85a3:0000:0000:8a2e:0370:7334]`,\n    `postmaster@[IPv6:2001:0db8:85a3:0000:0000:8a2e:0370:192.168.1.1]`,\n\n    // microsoft test cases\n    `plainaddress`,\n    `#@%^%#$@#$@#.com`,\n    `@domain.com`,\n    `Joe Smith &lt;email@domain.com&gt;`,\n    `email.domain.com`,\n    `email@domain@domain.com`,\n    `.email@domain.com`,\n    `email.@domain.com`,\n    `email..email@domain.com`,\n    `@domain.com`,\n    `email@domain.com (Joe Smith)`,\n    `email@domain`,\n    `email@-domain.com`,\n    `email@111.222.333.44444`,\n    `email@domain..com`,\n    `Abc.example.com`,\n    `A@b@c@example.com`,\n    `colin..hacks@domain.com`,\n    `a\"b(c)d,e:f;g<h>i[j\\k]l@example.com`,\n    `just\"not\"right@example.com`,\n    `this is\"not\\allowed@example.com`,\n    `this\\ still\\\"not\\\\allowed@example.com`,\n\n    // random\n    `i_like_underscore@but_its_not_allowed_in_this_part.example.com`,\n    `QA[icon]CHOCOLATE[icon]@test.com`,\n    `invalid@-start.com`,\n    `invalid@end.com-`,\n    `a.b@c.d`,\n    `invalid@[1.1.1.-1]`,\n    `invalid@[68.185.127.196.55]`,\n    `temp@[192.168.1]`,\n    `temp@[9.18.122.]`,\n    `double..point@test.com`,\n    `asdad@test..com`,\n    `asdad@hghg...sd...au`,\n    `asdad@hghg........au`,\n    `invalid@[256.2.2.48]`,\n    `invalid@[256.2.2.48]`,\n    `invalid@[999.465.265.1]`,\n    `jkibbey4@[IPv6:82c4:19a8::70a9:2aac:557::ea69:d985:28d]`,\n    `mlivesay3@[9952:143f:b4df:2179:49a1:5e82:b92e:6b6]`,\n    `gbacher0@[IPv6:bc37:4d3f:5048:2e26:37cc:248e:df8e:2f7f:af]`,\n    `invalid@[IPv6:5348:4ed3:5d38:67fb:e9b:acd2:c13:192.168.256.1]`,\n    `test@.com`,\n    `aaaaaaaaaaaaaaalongemailthatcausesregexDoSvulnerability@test.c`,\n  ];\n  const emailSchema = z.string().email();\n\n  expect(\n    validEmails.every((email) => {\n      return emailSchema.safeParse(email).success;\n    })\n  ).toBe(true);\n  expect(\n    invalidEmails.every((email) => {\n      return emailSchema.safeParse(email).success === false;\n    })\n  ).toBe(true);\n});\n\nconst validBase64Strings = [\n  \"SGVsbG8gV29ybGQ=\", // \"Hello World\"\n  \"VGhpcyBpcyBhbiBlbmNvZGVkIHN0cmluZw==\", // \"This is an encoded string\"\n  \"TWFueSBoYW5kcyBtYWtlIGxpZ2h0IHdvcms=\", // \"Many hands make light work\"\n  \"UGF0aWVuY2UgaXMgdGhlIGtleSB0byBzdWNjZXNz\", // \"Patience is the key to success\"\n  \"QmFzZTY0IGVuY29kaW5nIGlzIGZ1bg==\", // \"Base64 encoding is fun\"\n  \"MTIzNDU2Nzg5MA==\", // \"1234567890\"\n  \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo=\", // \"abcdefghijklmnopqrstuvwxyz\"\n  \"QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVo=\", // \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  \"ISIkJSMmJyonKCk=\", // \"!\\\"#$%&'()*\"\n  \"\", // Empty string is technically valid base64\n  \"w7/Dv8O+w74K\", // \n];\n\nfor (const str of validBase64Strings) {\n  test(`base64 should accept ${str}`, () => {\n    expect(z.string().base64().safeParse(str).success).toBe(true);\n  });\n}\n\nconst invalidBase64Strings = [\n  \"12345\", // Not padded correctly, not a multiple of 4 characters\n  \"12345===\", // Not padded correctly\n  \"SGVsbG8gV29ybGQ\", // Missing padding\n  \"VGhpcyBpcyBhbiBlbmNvZGVkIHN0cmluZw\", // Missing padding\n  \"!UGF0aWVuY2UgaXMgdGhlIGtleSB0byBzdWNjZXNz\", // Invalid character '!'\n  \"?QmFzZTY0IGVuY29kaW5nIGlzIGZ1bg==\", // Invalid character '?'\n  \".MTIzND2Nzg5MC4=\", // Invalid character '.'\n  \"QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVo\", // Missing padding\n  \"w7_Dv8O-w74K\", // Has - and _ characters (is base64url)\n];\n\nfor (const str of invalidBase64Strings) {\n  test(`base64 should reject ${str}`, () => {\n    expect(z.string().base64().safeParse(str).success).toBe(false);\n  });\n}\n\nconst validBase64URLStrings = [\n  \"SGVsbG8gV29ybGQ\", // \"Hello World\"\n  \"SGVsbG8gV29ybGQ=\", // \"Hello World\" with padding\n  \"VGhpcyBpcyBhbiBlbmNvZGVkIHN0cmluZw\", // \"This is an encoded string\"\n  \"VGhpcyBpcyBhbiBlbmNvZGVkIHN0cmluZw==\", // \"This is an encoded string\" with padding\n  \"TWFueSBoYW5kcyBtYWtlIGxpZ2h0IHdvcms\", // \"Many hands make light work\"\n  \"TWFueSBoYW5kcyBtYWtlIGxpZ2h0IHdvcms=\", // \"Many hands make light work\" with padding\n  \"UGF0aWVuY2UgaXMgdGhlIGtleSB0byBzdWNjZXNz\", // \"Patience is the key to success\"\n  \"QmFzZTY0IGVuY29kaW5nIGlzIGZ1bg\", // \"Base64 encoding is fun\"\n  \"QmFzZTY0IGVuY29kaW5nIGlzIGZ1bg==\", // \"Base64 encoding is fun\" with padding\n  \"MTIzNDU2Nzg5MA\", // \"1234567890\"\n  \"MTIzNDU2Nzg5MA==\", // \"1234567890\" with padding\n  \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo\", // \"abcdefghijklmnopqrstuvwxyz\"\n  \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo=\", // \"abcdefghijklmnopqrstuvwxyz with padding\"\n  \"QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVo\", // \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  \"QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVo=\", // \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" with padding\n  \"ISIkJSMmJyonKCk\", // \"!\\\"#$%&'()*\"\n  \"ISIkJSMmJyonKCk=\", // \"!\\\"#$%&'()*\" with padding\n  \"\", // Empty string is technically valid base64url\n  \"w7_Dv8O-w74K\", // \n  \"123456\",\n];\n\nfor (const str of validBase64URLStrings) {\n  test(`base64url should accept ${str}`, () => {\n    expect(z.string().base64url().safeParse(str).success).toBe(true);\n  });\n}\n\nconst invalidBase64URLStrings = [\n  \"w7/Dv8O+w74K\", // Has + and / characters (is base64)\n  \"12345\", // Invalid length (not a multiple of 4 characters when adding allowed number of padding characters)\n  \"12345===\", // Not padded correctly\n  \"!UGF0aWVuY2UgaXMgdGhlIGtleSB0byBzdWNjZXNz\", // Invalid character '!'\n  \"?QmFzZTY0IGVuY29kaW5nIGlzIGZ1bg==\", // Invalid character '?'\n  \".MTIzND2Nzg5MC4=\", // Invalid character '.'\n];\n\nfor (const str of invalidBase64URLStrings) {\n  test(`base64url should reject ${str}`, () => {\n    expect(z.string().base64url().safeParse(str).success).toBe(false);\n  });\n}\n\nfunction makeJwt(header: object, payload: object) {\n  const headerBase64 = Buffer.from(JSON.stringify(header)).toString(\"base64url\");\n  const payloadBase64 = Buffer.from(JSON.stringify(payload)).toString(\"base64url\");\n  const signature = \"signature\"; // Placeholder for the signature\n  return `${headerBase64}.${payloadBase64}.${signature}`;\n}\n\ntest(\"jwt validations\", () => {\n  const jwt = z.string().jwt();\n  const jwtWithAlg = z.string().jwt({ alg: \"HS256\" });\n\n  expect(() => jwt.parse(\"invalid\")).toThrow();\n  expect(() => jwt.parse(\"invalid.invalid\")).toThrow();\n  expect(() => jwt.parse(\"invalid.invalid.invalid\")).toThrow();\n\n  // Valid JWTs\n  const d1 = makeJwt({ typ: \"JWT\", alg: \"HS256\" }, {});\n  expect(() => jwt.parse(d1)).not.toThrow();\n  expect(() => jwtWithAlg.parse(d1)).not.toThrow();\n\n  // Invalid header\n  const d2 = makeJwt({}, {});\n  expect(() => jwt.parse(d2)).toThrow();\n\n  // Wrong algorithm\n  const d3 = makeJwt({ typ: \"JWT\", alg: \"RS256\" }, {});\n  expect(() => jwtWithAlg.parse(d3)).toThrow();\n\n  // missing typ is fine\n  const d4 = makeJwt({ alg: \"HS256\" }, {});\n  jwt.parse(d4);\n\n  // type isn't JWT\n  const d5 = makeJwt({ typ: \"SUP\", alg: \"HS256\" }, { foo: \"bar\" });\n  expect(() => jwt.parse(d5)).toThrow();\n\n  // Custom error message\n  const customMsg = \"Invalid JWT token\";\n  const jwtWithMsg = z.string().jwt({ message: customMsg });\n  try {\n    jwtWithMsg.parse(\"invalid\");\n  } catch (error) {\n    expect((error as z.ZodError).issues[0].message).toBe(customMsg);\n  }\n});\n\ntest(\"url validations\", () => {\n  const url = z.string().url();\n  url.parse(\"http://google.com\");\n  url.parse(\"https://google.com/asdf?asdf=ljk3lk4&asdf=234#asdf\");\n  expect(() => url.parse(\"asdf\")).toThrow();\n  expect(() => url.parse(\"https:/\")).toThrow();\n  expect(() => url.parse(\"asdfj@lkjsdf.com\")).toThrow();\n});\n\ntest(\"url error overrides\", () => {\n  try {\n    z.string().url().parse(\"https\");\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"Invalid url\");\n  }\n  try {\n    z.string().url(\"badurl\").parse(\"https\");\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"badurl\");\n  }\n  try {\n    z.string().url({ message: \"badurl\" }).parse(\"https\");\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"badurl\");\n  }\n});\n\ntest(\"emoji validations\", () => {\n  const emoji = z.string().emoji();\n\n  emoji.parse(\"\");\n  emoji.parse(\"\");\n  emoji.parse(\"\");\n  emoji.parse(\"\");\n  emoji.parse(\"\");\n  emoji.parse(\n    \"##**00112233445566778899\"\n  );\n  expect(() => emoji.parse(\":-)\")).toThrow();\n  expect(() => emoji.parse(\" is an emoji\")).toThrow();\n  expect(() => emoji.parse(\"stuff\")).toThrow();\n  expect(() => emoji.parse(\"stuff\")).toThrow();\n});\n\ntest(\"uuid\", () => {\n  const uuid = z.string().uuid(\"custom error\");\n  uuid.parse(\"9491d710-3185-4e06-bea0-6a2f275345e0\");\n  uuid.parse(\"d89e7b01-7598-ed11-9d7a-0022489382fd\"); // new sequential id\n  uuid.parse(\"00000000-0000-0000-0000-000000000000\");\n  uuid.parse(\"b3ce60f8-e8b9-40f5-1150-172ede56ff74\"); // Variant 0 - RFC 4122: Reserved, NCS backward compatibility\n  uuid.parse(\"92e76bf9-28b3-4730-cd7f-cb6bc51f8c09\"); // Variant 2 - RFC 4122: Reserved, Microsoft Corporation backward compatibility\n  const result = uuid.safeParse(\"9491d710-3185-4e06-bea0-6a2f275345e0X\");\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues[0].message).toEqual(\"custom error\");\n  }\n});\n\ntest(\"bad uuid\", () => {\n  const uuid = z.string().uuid(\"custom error\");\n  uuid.parse(\"9491d710-3185-4e06-bea0-6a2f275345e0\");\n  const result = uuid.safeParse(\"invalid uuid\");\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues[0].message).toEqual(\"custom error\");\n  }\n});\n\ntest(\"nanoid\", () => {\n  const nanoid = z.string().nanoid(\"custom error\");\n  nanoid.parse(\"lfNZluvAxMkf7Q8C5H-QS\");\n  nanoid.parse(\"mIU_4PJWikaU8fMbmkouz\");\n  nanoid.parse(\"Hb9ZUtUa2JDm_dD-47EGv\");\n  nanoid.parse(\"5Noocgv_8vQ9oPijj4ioQ\");\n  const result = nanoid.safeParse(\"Xq90uDyhddC53KsoASYJGX\");\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues[0].message).toEqual(\"custom error\");\n  }\n});\n\ntest(\"bad nanoid\", () => {\n  const nanoid = z.string().nanoid(\"custom error\");\n  nanoid.parse(\"ySh_984wpDUu7IQRrLXAp\");\n  const result = nanoid.safeParse(\"invalid nanoid\");\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues[0].message).toEqual(\"custom error\");\n  }\n});\n\ntest(\"cuid\", () => {\n  const cuid = z.string().cuid();\n  cuid.parse(\"ckopqwooh000001la8mbi2im9\");\n  const result = cuid.safeParse(\"cifjhdsfhsd-invalid-cuid\");\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues[0].message).toEqual(\"Invalid cuid\");\n  }\n});\n\ntest(\"cuid2\", () => {\n  const cuid2 = z.string().cuid2();\n  const validStrings = [\n    \"a\", // short string\n    \"tz4a98xxat96iws9zmbrgj3a\", // normal string\n    \"kf5vz6ssxe4zjcb409rjgo747tc5qjazgptvotk6\", // longer than require(\"@paralleldrive/cuid2\").bigLength\n  ];\n  for (const s of validStrings) {\n    cuid2.parse(s);\n  }\n\n  const invalidStrings = [\n    \"\", // empty string\n    \"tz4a98xxat96iws9zMbrgj3a\", // include uppercase\n    \"tz4a98xxat96iws-zmbrgj3a\", // involve symbols\n  ];\n  const results = invalidStrings.map((s) => cuid2.safeParse(s));\n  expect(results.every((r) => !r.success)).toEqual(true);\n  if (!results[0].success) {\n    expect(results[0].error.issues[0].message).toEqual(\"Invalid cuid2\");\n  }\n});\n\ntest(\"ulid\", () => {\n  const ulid = z.string().ulid();\n  ulid.parse(\"01ARZ3NDEKTSV4RRFFQ69G5FAV\");\n  const result = ulid.safeParse(\"invalidulid\");\n  expect(result.success).toEqual(false);\n  const tooLong = \"01ARZ3NDEKTSV4RRFFQ69G5FAVA\";\n  expect(ulid.safeParse(tooLong).success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues[0].message).toEqual(\"Invalid ulid\");\n  }\n  const caseInsensitive = ulid.safeParse(\"01arZ3nDeKTsV4RRffQ69G5FAV\");\n  expect(caseInsensitive.success).toEqual(true);\n});\n\ntest(\"regex\", () => {\n  z.string()\n    .regex(/^moo+$/)\n    .parse(\"mooooo\");\n  expect(() => z.string().uuid().parse(\"purr\")).toThrow();\n});\n\ntest(\"regexp error message\", () => {\n  const result = z\n    .string()\n    .regex(/^moo+$/)\n    .safeParse(\"boooo\");\n  if (!result.success) {\n    expect(result.error.issues[0].message).toEqual(\"Invalid\");\n  } else {\n    throw new Error(\"validation should have failed\");\n  }\n\n  expect(() => z.string().uuid().parse(\"purr\")).toThrow();\n});\n\ntest(\"regex lastIndex reset\", () => {\n  const schema = z.string().regex(/^\\d+$/g);\n  expect(schema.safeParse(\"123\").success).toEqual(true);\n  expect(schema.safeParse(\"123\").success).toEqual(true);\n  expect(schema.safeParse(\"123\").success).toEqual(true);\n  expect(schema.safeParse(\"123\").success).toEqual(true);\n  expect(schema.safeParse(\"123\").success).toEqual(true);\n});\n\ntest(\"checks getters\", () => {\n  expect(z.string().email().isEmail).toEqual(true);\n  expect(z.string().email().isURL).toEqual(false);\n  expect(z.string().email().isCUID).toEqual(false);\n  expect(z.string().email().isCUID2).toEqual(false);\n  expect(z.string().email().isUUID).toEqual(false);\n  expect(z.string().email().isNANOID).toEqual(false);\n  expect(z.string().email().isIP).toEqual(false);\n  expect(z.string().email().isCIDR).toEqual(false);\n  expect(z.string().email().isULID).toEqual(false);\n\n  expect(z.string().url().isEmail).toEqual(false);\n  expect(z.string().url().isURL).toEqual(true);\n  expect(z.string().url().isCUID).toEqual(false);\n  expect(z.string().url().isCUID2).toEqual(false);\n  expect(z.string().url().isUUID).toEqual(false);\n  expect(z.string().url().isNANOID).toEqual(false);\n  expect(z.string().url().isIP).toEqual(false);\n  expect(z.string().url().isCIDR).toEqual(false);\n  expect(z.string().url().isULID).toEqual(false);\n\n  expect(z.string().cuid().isEmail).toEqual(false);\n  expect(z.string().cuid().isURL).toEqual(false);\n  expect(z.string().cuid().isCUID).toEqual(true);\n  expect(z.string().cuid().isCUID2).toEqual(false);\n  expect(z.string().cuid().isUUID).toEqual(false);\n  expect(z.string().cuid().isNANOID).toEqual(false);\n  expect(z.string().cuid().isIP).toEqual(false);\n  expect(z.string().cuid().isCIDR).toEqual(false);\n  expect(z.string().cuid().isULID).toEqual(false);\n\n  expect(z.string().cuid2().isEmail).toEqual(false);\n  expect(z.string().cuid2().isURL).toEqual(false);\n  expect(z.string().cuid2().isCUID).toEqual(false);\n  expect(z.string().cuid2().isCUID2).toEqual(true);\n  expect(z.string().cuid2().isUUID).toEqual(false);\n  expect(z.string().cuid2().isNANOID).toEqual(false);\n  expect(z.string().cuid2().isIP).toEqual(false);\n  expect(z.string().cuid2().isCIDR).toEqual(false);\n  expect(z.string().cuid2().isULID).toEqual(false);\n\n  expect(z.string().uuid().isEmail).toEqual(false);\n  expect(z.string().uuid().isURL).toEqual(false);\n  expect(z.string().uuid().isCUID).toEqual(false);\n  expect(z.string().uuid().isCUID2).toEqual(false);\n  expect(z.string().uuid().isUUID).toEqual(true);\n  expect(z.string().uuid().isNANOID).toEqual(false);\n  expect(z.string().uuid().isIP).toEqual(false);\n  expect(z.string().uuid().isCIDR).toEqual(false);\n  expect(z.string().uuid().isULID).toEqual(false);\n\n  expect(z.string().nanoid().isEmail).toEqual(false);\n  expect(z.string().nanoid().isURL).toEqual(false);\n  expect(z.string().nanoid().isCUID).toEqual(false);\n  expect(z.string().nanoid().isCUID2).toEqual(false);\n  expect(z.string().nanoid().isUUID).toEqual(false);\n  expect(z.string().nanoid().isNANOID).toEqual(true);\n  expect(z.string().nanoid().isIP).toEqual(false);\n  expect(z.string().nanoid().isCIDR).toEqual(false);\n  expect(z.string().nanoid().isULID).toEqual(false);\n\n  expect(z.string().ip().isEmail).toEqual(false);\n  expect(z.string().ip().isURL).toEqual(false);\n  expect(z.string().ip().isCUID).toEqual(false);\n  expect(z.string().ip().isCUID2).toEqual(false);\n  expect(z.string().ip().isUUID).toEqual(false);\n  expect(z.string().ip().isNANOID).toEqual(false);\n  expect(z.string().ip().isIP).toEqual(true);\n  expect(z.string().ip().isCIDR).toEqual(false);\n  expect(z.string().ip().isULID).toEqual(false);\n\n  expect(z.string().cidr().isEmail).toEqual(false);\n  expect(z.string().cidr().isURL).toEqual(false);\n  expect(z.string().cidr().isCUID).toEqual(false);\n  expect(z.string().cidr().isCUID2).toEqual(false);\n  expect(z.string().cidr().isUUID).toEqual(false);\n  expect(z.string().cidr().isNANOID).toEqual(false);\n  expect(z.string().cidr().isIP).toEqual(false);\n  expect(z.string().cidr().isCIDR).toEqual(true);\n  expect(z.string().cidr().isULID).toEqual(false);\n\n  expect(z.string().ulid().isEmail).toEqual(false);\n  expect(z.string().ulid().isURL).toEqual(false);\n  expect(z.string().ulid().isCUID).toEqual(false);\n  expect(z.string().ulid().isCUID2).toEqual(false);\n  expect(z.string().ulid().isUUID).toEqual(false);\n  expect(z.string().ulid().isNANOID).toEqual(false);\n  expect(z.string().ulid().isIP).toEqual(false);\n  expect(z.string().ulid().isCIDR).toEqual(false);\n  expect(z.string().ulid().isULID).toEqual(true);\n});\n\ntest(\"min max getters\", () => {\n  expect(z.string().min(5).minLength).toEqual(5);\n  expect(z.string().min(5).min(10).minLength).toEqual(10);\n  expect(z.string().minLength).toEqual(null);\n\n  expect(z.string().max(5).maxLength).toEqual(5);\n  expect(z.string().max(5).max(1).maxLength).toEqual(1);\n  expect(z.string().maxLength).toEqual(null);\n});\n\ntest(\"trim\", () => {\n  expect(z.string().trim().min(2).parse(\" 12 \")).toEqual(\"12\");\n\n  // ordering of methods is respected\n  expect(z.string().min(2).trim().parse(\" 1 \")).toEqual(\"1\");\n  expect(() => z.string().trim().min(2).parse(\" 1 \")).toThrow();\n});\n\ntest(\"lowerCase\", () => {\n  expect(z.string().toLowerCase().parse(\"ASDF\")).toEqual(\"asdf\");\n  expect(z.string().toUpperCase().parse(\"asdf\")).toEqual(\"ASDF\");\n});\n\ntest(\"datetime\", () => {\n  const a = z.string().datetime({});\n  expect(a.isDatetime).toEqual(true);\n\n  const b = z.string().datetime({ offset: true });\n  expect(b.isDatetime).toEqual(true);\n\n  const c = z.string().datetime({ precision: 3 });\n  expect(c.isDatetime).toEqual(true);\n\n  const d = z.string().datetime({ offset: true, precision: 0 });\n  expect(d.isDatetime).toEqual(true);\n\n  const { isDatetime } = z.string().datetime();\n  expect(isDatetime).toEqual(true);\n});\n\ntest(\"datetime parsing\", () => {\n  const datetime = z.string().datetime();\n  datetime.parse(\"1970-01-01T00:00:00.000Z\");\n  datetime.parse(\"2022-10-13T09:52:31.816Z\");\n  datetime.parse(\"2022-10-13T09:52:31.8162314Z\");\n  datetime.parse(\"1970-01-01T00:00:00Z\");\n  datetime.parse(\"2022-10-13T09:52:31Z\");\n  datetime.parse(\"2022-10-13T09:52Z\");\n  expect(() => datetime.parse(\"\")).toThrow();\n  expect(() => datetime.parse(\"foo\")).toThrow();\n  expect(() => datetime.parse(\"2020-10-14\")).toThrow();\n  expect(() => datetime.parse(\"T18:45:12.123\")).toThrow();\n  expect(() => datetime.parse(\"2020-10-14T17:42:29+00:00\")).toThrow();\n  expect(() => datetime.parse(\"2020-10-14T17:42.123+00:00\")).toThrow();\n\n  const datetimeNoMs = z.string().datetime({ precision: 0 });\n  datetimeNoMs.parse(\"1970-01-01T00:00:00Z\");\n  datetimeNoMs.parse(\"2022-10-13T09:52:31Z\");\n  datetimeNoMs.parse(\"2022-10-13T09:52Z\");\n  expect(() => datetimeNoMs.parse(\"tuna\")).toThrow();\n  expect(() => datetimeNoMs.parse(\"1970-01-01T00:00:00.000Z\")).toThrow();\n  expect(() => datetimeNoMs.parse(\"1970-01-01T00:00:00.Z\")).toThrow();\n  expect(() => datetimeNoMs.parse(\"2022-10-13T09:52:31.816Z\")).toThrow();\n\n  const datetime3Ms = z.string().datetime({ precision: 3 });\n  datetime3Ms.parse(\"1970-01-01T00:00:00.000Z\");\n  datetime3Ms.parse(\"2022-10-13T09:52:31.123Z\");\n  expect(() => datetime3Ms.parse(\"tuna\")).toThrow();\n  expect(() => datetime3Ms.parse(\"1970-01-01T00:00:00.1Z\")).toThrow();\n  expect(() => datetime3Ms.parse(\"1970-01-01T00:00:00.12Z\")).toThrow();\n  expect(() => datetime3Ms.parse(\"2022-10-13T09:52:31Z\")).toThrow();\n  expect(() => datetime3Ms.parse(\"2022-10-13T09:52Z\")).toThrow();\n\n  const datetimeOffset = z.string().datetime({ offset: true });\n  datetimeOffset.parse(\"1970-01-01T00:00:00.000Z\");\n  datetimeOffset.parse(\"2022-10-13T09:52:31.816234134Z\");\n  datetimeOffset.parse(\"1970-01-01T00:00:00Z\");\n  datetimeOffset.parse(\"2022-10-13T09:52:31.4Z\");\n  datetimeOffset.parse(\"2020-10-14T17:42:29+00:00\");\n  datetimeOffset.parse(\"2020-10-14T17:42:29+03:15\");\n  datetimeOffset.parse(\"2020-10-14T17:42:29+0315\");\n  datetimeOffset.parse(\"2020-10-14T17:42+0315\");\n  expect(() => datetimeOffset.parse(\"2020-10-14T17:42:29+03\"));\n  expect(() => datetimeOffset.parse(\"tuna\")).toThrow();\n  expect(() => datetimeOffset.parse(\"2022-10-13T09:52:31.Z\")).toThrow();\n\n  const datetimeOffsetNoMs = z.string().datetime({ offset: true, precision: 0 });\n  datetimeOffsetNoMs.parse(\"1970-01-01T00:00:00Z\");\n  datetimeOffsetNoMs.parse(\"2022-10-13T09:52:31Z\");\n  datetimeOffsetNoMs.parse(\"2020-10-14T17:42:29+00:00\");\n  datetimeOffsetNoMs.parse(\"2020-10-14T17:42:29+0000\");\n  datetimeOffsetNoMs.parse(\"2020-10-14T17:42+0000\");\n  expect(() => datetimeOffsetNoMs.parse(\"2020-10-14T17:42:29+00\")).toThrow();\n  expect(() => datetimeOffsetNoMs.parse(\"tuna\")).toThrow();\n  expect(() => datetimeOffsetNoMs.parse(\"1970-01-01T00:00:00.000Z\")).toThrow();\n  expect(() => datetimeOffsetNoMs.parse(\"1970-01-01T00:00:00.Z\")).toThrow();\n  expect(() => datetimeOffsetNoMs.parse(\"2022-10-13T09:52:31.816Z\")).toThrow();\n  expect(() => datetimeOffsetNoMs.parse(\"2020-10-14T17:42:29.124+00:00\")).toThrow();\n\n  const datetimeOffset4Ms = z.string().datetime({ offset: true, precision: 4 });\n  datetimeOffset4Ms.parse(\"1970-01-01T00:00:00.1234Z\");\n  datetimeOffset4Ms.parse(\"2020-10-14T17:42:29.1234+00:00\");\n  datetimeOffset4Ms.parse(\"2020-10-14T17:42:29.1234+0000\");\n  expect(() => datetimeOffset4Ms.parse(\"2020-10-14T17:42:29.1234+00\")).toThrow();\n  expect(() => datetimeOffset4Ms.parse(\"tuna\")).toThrow();\n  expect(() => datetimeOffset4Ms.parse(\"1970-01-01T00:00:00.123Z\")).toThrow();\n  expect(() => datetimeOffset4Ms.parse(\"2020-10-14T17:42:29.124+00:00\")).toThrow();\n  expect(() => datetimeOffset4Ms.parse(\"2020-10-14T17:42+00:00\")).toThrow();\n});\n\ntest(\"date\", () => {\n  const a = z.string().date();\n  expect(a.isDate).toEqual(true);\n});\n\ntest(\"date parsing\", () => {\n  const date = z.string().date();\n  date.parse(\"1970-01-01\");\n  date.parse(\"2022-01-31\");\n  date.parse(\"2022-03-31\");\n  date.parse(\"2022-04-30\");\n  date.parse(\"2022-05-31\");\n  date.parse(\"2022-06-30\");\n  date.parse(\"2022-07-31\");\n  date.parse(\"2022-08-31\");\n  date.parse(\"2022-09-30\");\n  date.parse(\"2022-10-31\");\n  date.parse(\"2022-11-30\");\n  date.parse(\"2022-12-31\");\n\n  date.parse(\"2000-02-29\");\n  date.parse(\"2400-02-29\");\n  expect(() => date.parse(\"2022-02-29\")).toThrow();\n  expect(() => date.parse(\"2100-02-29\")).toThrow();\n  expect(() => date.parse(\"2200-02-29\")).toThrow();\n  expect(() => date.parse(\"2300-02-29\")).toThrow();\n  expect(() => date.parse(\"2500-02-29\")).toThrow();\n\n  expect(() => date.parse(\"\")).toThrow();\n  expect(() => date.parse(\"foo\")).toThrow();\n  expect(() => date.parse(\"200-01-01\")).toThrow();\n  expect(() => date.parse(\"20000-01-01\")).toThrow();\n  expect(() => date.parse(\"2000-0-01\")).toThrow();\n  expect(() => date.parse(\"2000-011-01\")).toThrow();\n  expect(() => date.parse(\"2000-01-0\")).toThrow();\n  expect(() => date.parse(\"2000-01-011\")).toThrow();\n  expect(() => date.parse(\"2000/01/01\")).toThrow();\n  expect(() => date.parse(\"01-01-2022\")).toThrow();\n  expect(() => date.parse(\"01/01/2022\")).toThrow();\n  expect(() => date.parse(\"2000-01-01 00:00:00Z\")).toThrow();\n  expect(() => date.parse(\"2020-10-14T17:42:29+00:00\")).toThrow();\n  expect(() => date.parse(\"2020-10-14T17:42:29Z\")).toThrow();\n  expect(() => date.parse(\"2020-10-14T17:42:29\")).toThrow();\n  expect(() => date.parse(\"2020-10-14T17:42:29.123Z\")).toThrow();\n\n  expect(() => date.parse(\"2000-00-12\")).toThrow();\n  expect(() => date.parse(\"2000-12-00\")).toThrow();\n  expect(() => date.parse(\"2000-01-32\")).toThrow();\n  expect(() => date.parse(\"2000-13-01\")).toThrow();\n  expect(() => date.parse(\"2000-21-01\")).toThrow();\n\n  expect(() => date.parse(\"2000-02-30\")).toThrow();\n  expect(() => date.parse(\"2000-02-31\")).toThrow();\n  expect(() => date.parse(\"2000-04-31\")).toThrow();\n  expect(() => date.parse(\"2000-06-31\")).toThrow();\n  expect(() => date.parse(\"2000-09-31\")).toThrow();\n  expect(() => date.parse(\"2000-11-31\")).toThrow();\n});\n\ntest(\"time\", () => {\n  const a = z.string().time();\n  expect(a.isTime).toEqual(true);\n});\n\ntest(\"time parsing\", () => {\n  const time = z.string().time();\n  time.parse(\"00:00:00\");\n  time.parse(\"23:00:00\");\n  time.parse(\"00:59:00\");\n  time.parse(\"00:00:59\");\n  time.parse(\"23:59:59\");\n  time.parse(\"09:52:31\");\n  time.parse(\"23:59:59.9999999\");\n  time.parse(\"23:59\");\n  expect(() => time.parse(\"\")).toThrow();\n  expect(() => time.parse(\"foo\")).toThrow();\n  expect(() => time.parse(\"00:00:00Z\")).toThrow();\n  expect(() => time.parse(\"0:00:00\")).toThrow();\n  expect(() => time.parse(\"00:0:00\")).toThrow();\n  expect(() => time.parse(\"00:00:0\")).toThrow();\n  expect(() => time.parse(\"00:00:00.000+00:00\")).toThrow();\n\n  expect(() => time.parse(\"24:00:00\")).toThrow();\n  expect(() => time.parse(\"00:60:00\")).toThrow();\n  expect(() => time.parse(\"00:00:60\")).toThrow();\n  expect(() => time.parse(\"24:60:60\")).toThrow();\n  expect(() => time.parse(\"24:60\")).toThrow();\n\n  const time2 = z.string().time({ precision: 2 });\n  time2.parse(\"00:00:00.00\");\n  time2.parse(\"09:52:31.12\");\n  time2.parse(\"23:59:59.99\");\n  expect(() => time2.parse(\"\")).toThrow();\n  expect(() => time2.parse(\"foo\")).toThrow();\n  expect(() => time2.parse(\"00:00:00\")).toThrow();\n  expect(() => time2.parse(\"00:00:00.00Z\")).toThrow();\n  expect(() => time2.parse(\"00:00:00.0\")).toThrow();\n  expect(() => time2.parse(\"00:00:00.000\")).toThrow();\n  expect(() => time2.parse(\"00:00:00.00+00:00\")).toThrow();\n  expect(() => time2.parse(\"23:59\")).toThrow();\n\n  // const time3 = z.string().time({ offset: true });\n  // time3.parse(\"00:00:00Z\");\n  // time3.parse(\"09:52:31Z\");\n  // time3.parse(\"00:00:00+00:00\");\n  // time3.parse(\"00:00:00+0000\");\n  // time3.parse(\"00:00:00.000Z\");\n  // time3.parse(\"00:00:00.000+00:00\");\n  // time3.parse(\"00:00:00.000+0000\");\n  // expect(() => time3.parse(\"\")).toThrow();\n  // expect(() => time3.parse(\"foo\")).toThrow();\n  // expect(() => time3.parse(\"00:00:00\")).toThrow();\n  // expect(() => time3.parse(\"00:00:00.000\")).toThrow();\n\n  // const time4 = z.string().time({ offset: true, precision: 0 });\n  // time4.parse(\"00:00:00Z\");\n  // time4.parse(\"09:52:31Z\");\n  // time4.parse(\"00:00:00+00:00\");\n  // time4.parse(\"00:00:00+0000\");\n  // expect(() => time4.parse(\"\")).toThrow();\n  // expect(() => time4.parse(\"foo\")).toThrow();\n  // expect(() => time4.parse(\"00:00:00.0\")).toThrow();\n  // expect(() => time4.parse(\"00:00:00.000\")).toThrow();\n  // expect(() => time4.parse(\"00:00:00.000+00:00\")).toThrow();\n});\n\ntest(\"duration\", () => {\n  const duration = z.string().duration();\n  expect(duration.isDuration).toEqual(true);\n\n  const validDurations = [\n    \"P3Y6M4DT12H30M5S\",\n    \"P2Y9M3DT12H31M8.001S\",\n    \"+P3Y6M4DT12H30M5S\",\n    \"-PT0.001S\",\n    \"+PT0.001S\",\n    \"PT0,001S\",\n    \"PT12H30M5S\",\n    \"-P2M1D\",\n    \"P-2M-1D\",\n    \"-P5DT10H\",\n    \"P-5DT-10H\",\n    \"P1Y\",\n    \"P2MT30M\",\n    \"PT6H\",\n    \"P5W\",\n    \"P0.5Y\",\n    \"P0,5Y\",\n    \"P42YT7.004M\",\n  ];\n\n  const invalidDurations = [\"foo bar\", \"\", \" \", \"P\", \"T1H\", \"P0.5Y1D\", \"P0,5Y6M\", \"P1YT\"];\n\n  for (const val of validDurations) {\n    const result = duration.safeParse(val);\n    if (!result.success) {\n      throw Error(`Valid duration could not be parsed: ${val}`);\n    }\n  }\n\n  for (const val of invalidDurations) {\n    const result = duration.safeParse(val);\n\n    if (result.success) {\n      throw Error(`Invalid duration was successful parsed: ${val}`);\n    }\n\n    expect(result.error.issues[0].message).toEqual(\"Invalid duration\");\n  }\n});\n\ntest(\"IP validation\", () => {\n  const ip = z.string().ip();\n  expect(ip.safeParse(\"122.122.122.122\").success).toBe(true);\n\n  const ipv4 = z.string().ip({ version: \"v4\" });\n  expect(() => ipv4.parse(\"6097:adfa:6f0b:220d:db08:5021:6191:7990\")).toThrow();\n\n  const ipv6 = z.string().ip({ version: \"v6\" });\n  expect(() => ipv6.parse(\"254.164.77.1\")).toThrow();\n\n  const validIPs = [\n    \"1e5e:e6c8:daac:514b:114b:e360:d8c0:682c\",\n    \"9d4:c956:420f:5788:4339:9b3b:2418:75c3\",\n    \"474f:4c83::4e40:a47:ff95:0cda\",\n    \"d329:0:25b4:db47:a9d1:0:4926:0000\",\n    \"e48:10fb:1499:3e28:e4b6:dea5:4692:912c\",\n    \"114.71.82.94\",\n    \"0.0.0.0\",\n    \"37.85.236.115\",\n    \"2001:4888:50:ff00:500:d::\",\n    \"2001:4888:50:ff00:0500:000d:000:0000\",\n    \"2001:4888:50:ff00:0500:000d:0000:0000\",\n  ];\n\n  const invalidIPs = [\n    \"d329:1be4:25b4:db47:a9d1:dc71:4926:992c:14af\",\n    \"d5e7:7214:2b78::3906:85e6:53cc:709:32ba\",\n    \"8f69::c757:395e:976e::3441\",\n    \"54cb::473f:d516:0.255.256.22\",\n    \"54cb::473f:d516:192.168.1\",\n    \"256.0.4.4\",\n    \"-1.0.555.4\",\n    \"0.0.0.0.0\",\n    \"1.1.1\",\n  ];\n  // no parameters check IPv4 or IPv6\n  const ipSchema = z.string().ip();\n  expect(validIPs.every((ip) => ipSchema.safeParse(ip).success)).toBe(true);\n  expect(invalidIPs.every((ip) => ipSchema.safeParse(ip).success === false)).toBe(true);\n});\n\ntest(\"CIDR validation\", () => {\n  const ipv4Cidr = z.string().cidr({ version: \"v4\" });\n  expect(() => ipv4Cidr.parse(\"2001:0db8:85a3::8a2e:0370:7334/64\")).toThrow();\n\n  const ipv6Cidr = z.string().cidr({ version: \"v6\" });\n  expect(() => ipv6Cidr.parse(\"192.168.0.1/24\")).toThrow();\n\n  const validCidrs = [\n    \"192.168.0.0/24\",\n    \"10.0.0.0/8\",\n    \"203.0.113.0/24\",\n    \"192.0.2.0/24\",\n    \"127.0.0.0/8\",\n    \"172.16.0.0/12\",\n    \"192.168.1.0/24\",\n    \"fc00::/7\",\n    \"fd00::/8\",\n    \"2001:db8::/32\",\n    \"2607:f0d0:1002:51::4/64\",\n    \"2001:0db8:85a3:0000:0000:8a2e:0370:7334/128\",\n    \"2001:0db8:1234:0000::/64\",\n  ];\n\n  const invalidCidrs = [\n    \"192.168.1.1/33\",\n    \"10.0.0.1/-1\",\n    \"192.168.1.1/24/24\",\n    \"192.168.1.0/abc\",\n    \"2001:db8::1/129\",\n    \"2001:db8::1/-1\",\n    \"2001:db8::1/64/64\",\n    \"2001:db8::1/abc\",\n  ];\n\n  // no parameters check IPv4 or IPv6\n  const cidrSchema = z.string().cidr();\n  expect(validCidrs.every((ip) => cidrSchema.safeParse(ip).success)).toBe(true);\n  expect(invalidCidrs.every((ip) => cidrSchema.safeParse(ip).success === false)).toBe(true);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/string.test.ts",
        "start": 1,
        "end": 916,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 916,
          "column": 2,
          "position": 10044
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/string.test.ts",
        "start": 1,
        "end": 916,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 916,
          "column": 2,
          "position": 10044
        }
      }
    },
    {
      "format": "typescript",
      "lines": 83,
      "fragment": "// import type { StandardSchemaV1 } from \"@standard-schema/spec\";\n// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\nimport type { StandardSchemaV1 } from \"../standard-schema.js\";\n\ntest(\"assignability\", () => {\n  const _s1: StandardSchemaV1 = z.string();\n  const _s2: StandardSchemaV1<string> = z.string();\n  const _s3: StandardSchemaV1<string, string> = z.string();\n  const _s4: StandardSchemaV1<unknown, string> = z.string();\n  [_s1, _s2, _s3, _s4];\n});\n\ntest(\"type inference\", () => {\n  const stringToNumber = z.string().transform((x) => x.length);\n  type input = StandardSchemaV1.InferInput<typeof stringToNumber>;\n  util.assertEqual<input, string>(true);\n  type output = StandardSchemaV1.InferOutput<typeof stringToNumber>;\n  util.assertEqual<output, number>(true);\n});\n\ntest(\"valid parse\", () => {\n  const schema = z.string();\n  const result = schema[\"~standard\"].validate(\"hello\");\n  if (result instanceof Promise) {\n    throw new Error(\"Expected sync result\");\n  }\n  expect(result.issues).toEqual(undefined);\n  if (result.issues) {\n    throw new Error(\"Expected no issues\");\n  } else {\n    expect(result.value).toEqual(\"hello\");\n  }\n});\n\ntest(\"invalid parse\", () => {\n  const schema = z.string();\n  const result = schema[\"~standard\"].validate(1234);\n  if (result instanceof Promise) {\n    throw new Error(\"Expected sync result\");\n  }\n  expect(result.issues).toBeDefined();\n  if (!result.issues) {\n    throw new Error(\"Expected issues\");\n  }\n  expect(result.issues.length).toEqual(1);\n  expect(result.issues[0].path).toEqual([]);\n});\n\ntest(\"valid parse async\", async () => {\n  const schema = z.string().refine(async () => true);\n  const _result = schema[\"~standard\"].validate(\"hello\");\n  if (_result instanceof Promise) {\n    const result = await _result;\n    expect(result.issues).toEqual(undefined);\n    if (result.issues) {\n      throw new Error(\"Expected no issues\");\n    } else {\n      expect(result.value).toEqual(\"hello\");\n    }\n  } else {\n    throw new Error(\"Expected async result\");\n  }\n});\n\ntest(\"invalid parse async\", async () => {\n  const schema = z.string().refine(async () => false);\n  const _result = schema[\"~standard\"].validate(\"hello\");\n  if (_result instanceof Promise) {\n    const result = await _result;\n    expect(result.issues).toBeDefined();\n    if (!result.issues) {\n      throw new Error(\"Expected issues\");\n    }\n    expect(result.issues.length).toEqual(1);\n    expect(result.issues[0].path).toEqual([]);\n  } else {\n    throw new Error(\"Expected async result\");\n  }\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/standard-schema.test.ts",
        "start": 1,
        "end": 83,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 83,
          "column": 2,
          "position": 923
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/standard-schema.test.ts",
        "start": 1,
        "end": 83,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 83,
          "column": 2,
          "position": 923
        }
      }
    },
    {
      "format": "typescript",
      "lines": 142,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { ZodIssueCode } from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\nconst stringSet = z.set(z.string());\ntype stringSet = z.infer<typeof stringSet>;\n\nconst minTwo = z.set(z.string()).min(2);\nconst maxTwo = z.set(z.string()).max(2);\nconst justTwo = z.set(z.string()).size(2);\nconst nonEmpty = z.set(z.string()).nonempty();\nconst nonEmptyMax = z.set(z.string()).nonempty().max(2);\n\ntest(\"type inference\", () => {\n  util.assertEqual<stringSet, Set<string>>(true);\n});\n\ntest(\"valid parse\", () => {\n  const result = stringSet.safeParse(new Set([\"first\", \"second\"]));\n  expect(result.success).toEqual(true);\n  if (result.success) {\n    expect(result.data.has(\"first\")).toEqual(true);\n    expect(result.data.has(\"second\")).toEqual(true);\n    expect(result.data.has(\"third\")).toEqual(false);\n  }\n\n  expect(() => {\n    minTwo.parse(new Set([\"a\", \"b\"]));\n    minTwo.parse(new Set([\"a\", \"b\", \"c\"]));\n    maxTwo.parse(new Set([\"a\", \"b\"]));\n    maxTwo.parse(new Set([\"a\"]));\n    justTwo.parse(new Set([\"a\", \"b\"]));\n    nonEmpty.parse(new Set([\"a\"]));\n    nonEmptyMax.parse(new Set([\"a\"]));\n  }).not.toThrow();\n});\n\ntest(\"valid parse async\", async () => {\n  const result = await stringSet.spa(new Set([\"first\", \"second\"]));\n  expect(result.success).toEqual(true);\n  if (result.success) {\n    expect(result.data.has(\"first\")).toEqual(true);\n    expect(result.data.has(\"second\")).toEqual(true);\n    expect(result.data.has(\"third\")).toEqual(false);\n  }\n\n  const asyncResult = await stringSet.safeParse(new Set([\"first\", \"second\"]));\n  expect(asyncResult.success).toEqual(true);\n  if (asyncResult.success) {\n    expect(asyncResult.data.has(\"first\")).toEqual(true);\n    expect(asyncResult.data.has(\"second\")).toEqual(true);\n    expect(asyncResult.data.has(\"third\")).toEqual(false);\n  }\n});\n\ntest(\"valid parse: size-related methods\", () => {\n  expect(() => {\n    minTwo.parse(new Set([\"a\", \"b\"]));\n    minTwo.parse(new Set([\"a\", \"b\", \"c\"]));\n    maxTwo.parse(new Set([\"a\", \"b\"]));\n    maxTwo.parse(new Set([\"a\"]));\n    justTwo.parse(new Set([\"a\", \"b\"]));\n    nonEmpty.parse(new Set([\"a\"]));\n    nonEmptyMax.parse(new Set([\"a\"]));\n  }).not.toThrow();\n\n  const sizeZeroResult = stringSet.parse(new Set());\n  expect(sizeZeroResult.size).toBe(0);\n\n  const sizeTwoResult = minTwo.parse(new Set([\"a\", \"b\"]));\n  expect(sizeTwoResult.size).toBe(2);\n});\n\ntest(\"failing when parsing empty set in nonempty \", () => {\n  const result = nonEmpty.safeParse(new Set());\n  expect(result.success).toEqual(false);\n\n  if (result.success === false) {\n    expect(result.error.issues.length).toEqual(1);\n    expect(result.error.issues[0].code).toEqual(ZodIssueCode.too_small);\n  }\n});\n\ntest(\"failing when set is smaller than min() \", () => {\n  const result = minTwo.safeParse(new Set([\"just_one\"]));\n  expect(result.success).toEqual(false);\n\n  if (result.success === false) {\n    expect(result.error.issues.length).toEqual(1);\n    expect(result.error.issues[0].code).toEqual(ZodIssueCode.too_small);\n  }\n});\n\ntest(\"failing when set is bigger than max() \", () => {\n  const result = maxTwo.safeParse(new Set([\"one\", \"two\", \"three\"]));\n  expect(result.success).toEqual(false);\n\n  if (result.success === false) {\n    expect(result.error.issues.length).toEqual(1);\n    expect(result.error.issues[0].code).toEqual(ZodIssueCode.too_big);\n  }\n});\n\ntest(\"doesnt throw when an empty set is given\", () => {\n  const result = stringSet.safeParse(new Set([]));\n  expect(result.success).toEqual(true);\n});\n\ntest(\"throws when a Map is given\", () => {\n  const result = stringSet.safeParse(new Map([]));\n  expect(result.success).toEqual(false);\n  if (result.success === false) {\n    expect(result.error.issues.length).toEqual(1);\n    expect(result.error.issues[0].code).toEqual(ZodIssueCode.invalid_type);\n  }\n});\n\ntest(\"throws when the given set has invalid input\", () => {\n  const result = stringSet.safeParse(new Set([Symbol()]));\n  expect(result.success).toEqual(false);\n  if (result.success === false) {\n    expect(result.error.issues.length).toEqual(1);\n    expect(result.error.issues[0].code).toEqual(ZodIssueCode.invalid_type);\n    expect(result.error.issues[0].path).toEqual([0]);\n  }\n});\n\ntest(\"throws when the given set has multiple invalid entries\", () => {\n  const result = stringSet.safeParse(new Set([1, 2] as any[]) as Set<any>);\n\n  expect(result.success).toEqual(false);\n  if (result.success === false) {\n    expect(result.error.issues.length).toEqual(2);\n    expect(result.error.issues[0].code).toEqual(ZodIssueCode.invalid_type);\n    expect(result.error.issues[0].path).toEqual([0]);\n    expect(result.error.issues[1].code).toEqual(ZodIssueCode.invalid_type);\n    expect(result.error.issues[1].path).toEqual([1]);\n  }\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/set.test.ts",
        "start": 1,
        "end": 142,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 142,
          "column": 2,
          "position": 1843
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/set.test.ts",
        "start": 1,
        "end": 142,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 142,
          "column": 2,
          "position": 1843
        }
      }
    },
    {
      "format": "typescript",
      "lines": 27,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nconst stringSchema = z.string();\n\ntest(\"safeparse fail\", () => {\n  const safe = stringSchema.safeParse(12);\n  expect(safe.success).toEqual(false);\n  expect(safe.error).toBeInstanceOf(z.ZodError);\n});\n\ntest(\"safeparse pass\", () => {\n  const safe = stringSchema.safeParse(\"12\");\n  expect(safe.success).toEqual(true);\n  expect(safe.data).toEqual(\"12\");\n});\n\ntest(\"safeparse unexpected error\", () => {\n  expect(() =>\n    stringSchema\n      .refine((data) => {\n        throw new Error(data);\n      })\n      .safeParse(\"12\")\n  ).toThrow();\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/safeparse.test.ts",
        "start": 1,
        "end": 27,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 27,
          "column": 2,
          "position": 235
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/safeparse.test.ts",
        "start": 1,
        "end": 27,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 27,
          "column": 2,
          "position": 235
        }
      }
    },
    {
      "format": "typescript",
      "lines": 313,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { ZodIssueCode } from \"../ZodError.js\";\nimport { util } from \"../helpers/util.js\";\n\ntest(\"refinement\", () => {\n  const obj1 = z.object({\n    first: z.string(),\n    second: z.string(),\n  });\n  const obj2 = obj1.partial().strict();\n\n  const obj3 = obj2.refine((data) => data.first || data.second, \"Either first or second should be filled in.\");\n\n  expect(obj1 === (obj2 as any)).toEqual(false);\n  expect(obj2 === (obj3 as any)).toEqual(false);\n\n  expect(() => obj1.parse({})).toThrow();\n  expect(() => obj2.parse({ third: \"adsf\" })).toThrow();\n  expect(() => obj3.parse({})).toThrow();\n  obj3.parse({ first: \"a\" });\n  obj3.parse({ second: \"a\" });\n  obj3.parse({ first: \"a\", second: \"a\" });\n});\n\ntest(\"refinement 2\", () => {\n  const validationSchema = z\n    .object({\n      email: z.string().email(),\n      password: z.string(),\n      confirmPassword: z.string(),\n    })\n    .refine((data) => data.password === data.confirmPassword, \"Both password and confirmation must match\");\n\n  expect(() =>\n    validationSchema.parse({\n      email: \"aaaa@gmail.com\",\n      password: \"aaaaaaaa\",\n      confirmPassword: \"bbbbbbbb\",\n    })\n  ).toThrow();\n});\n\ntest(\"refinement type guard\", () => {\n  const validationSchema = z.object({\n    a: z.string().refine((s): s is \"a\" => s === \"a\"),\n  });\n  type Input = z.input<typeof validationSchema>;\n  type Schema = z.infer<typeof validationSchema>;\n\n  util.assertEqual<\"a\", Input[\"a\"]>(false);\n  util.assertEqual<string, Input[\"a\"]>(true);\n\n  util.assertEqual<\"a\", Schema[\"a\"]>(true);\n  util.assertEqual<string, Schema[\"a\"]>(false);\n});\n\ntest(\"refinement Promise\", async () => {\n  const validationSchema = z\n    .object({\n      email: z.string().email(),\n      password: z.string(),\n      confirmPassword: z.string(),\n    })\n    .refine(\n      (data) => Promise.resolve().then(() => data.password === data.confirmPassword),\n      \"Both password and confirmation must match\"\n    );\n\n  await validationSchema.parseAsync({\n    email: \"aaaa@gmail.com\",\n    password: \"password\",\n    confirmPassword: \"password\",\n  });\n});\n\ntest(\"custom path\", async () => {\n  const result = await z\n    .object({\n      password: z.string(),\n      confirm: z.string(),\n    })\n    .refine((data) => data.confirm === data.password, { path: [\"confirm\"] })\n    .spa({ password: \"asdf\", confirm: \"qewr\" });\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues[0].path).toEqual([\"confirm\"]);\n  }\n});\n\ntest(\"use path in refinement context\", async () => {\n  const noNested = z.string()._refinement((_val, ctx) => {\n    if (ctx.path.length > 0) {\n      ctx.addIssue({\n        code: ZodIssueCode.custom,\n        message: `schema cannot be nested. path: ${ctx.path.join(\".\")}`,\n      });\n      return false;\n    } else {\n      return true;\n    }\n  });\n\n  const data = z.object({\n    foo: noNested,\n  });\n\n  const t1 = await noNested.spa(\"asdf\");\n  const t2 = await data.spa({ foo: \"asdf\" });\n\n  expect(t1.success).toBe(true);\n  expect(t2.success).toBe(false);\n  if (t2.success === false) {\n    expect(t2.error.issues[0].message).toEqual(\"schema cannot be nested. path: foo\");\n  }\n});\n\ntest(\"superRefine\", () => {\n  const Strings = z.array(z.string()).superRefine((val, ctx) => {\n    if (val.length > 3) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.too_big,\n        maximum: 3,\n        type: \"array\",\n        inclusive: true,\n        exact: true,\n        message: \"Too many items \",\n      });\n    }\n\n    if (val.length !== new Set(val).size) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: `No duplicates allowed.`,\n      });\n    }\n  });\n\n  const result = Strings.safeParse([\"asfd\", \"asfd\", \"asfd\", \"asfd\"]);\n\n  expect(result.success).toEqual(false);\n  if (!result.success) expect(result.error.issues.length).toEqual(2);\n\n  Strings.parse([\"asfd\", \"qwer\"]);\n});\n\ntest(\"superRefine async\", async () => {\n  const Strings = z.array(z.string()).superRefine(async (val, ctx) => {\n    if (val.length > 3) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.too_big,\n        maximum: 3,\n        type: \"array\",\n        inclusive: true,\n        exact: true,\n        message: \"Too many items \",\n      });\n    }\n\n    if (val.length !== new Set(val).size) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: `No duplicates allowed.`,\n      });\n    }\n  });\n\n  const result = await Strings.safeParseAsync([\"asfd\", \"asfd\", \"asfd\", \"asfd\"]);\n\n  expect(result.success).toEqual(false);\n  if (!result.success) expect(result.error.issues.length).toEqual(2);\n\n  Strings.parseAsync([\"asfd\", \"qwer\"]);\n});\n\ntest(\"superRefine - type narrowing\", () => {\n  type NarrowType = { type: string; age: number };\n  const schema = z\n    .object({\n      type: z.string(),\n      age: z.number(),\n    })\n    .nullable()\n    .superRefine((arg, ctx): arg is NarrowType => {\n      if (!arg) {\n        // still need to make a call to ctx.addIssue\n        ctx.addIssue({\n          code: z.ZodIssueCode.custom,\n          message: \"cannot be null\",\n          fatal: true,\n        });\n        return false;\n      }\n      return true;\n    });\n\n  util.assertEqual<z.infer<typeof schema>, NarrowType>(true);\n\n  expect(schema.safeParse({ type: \"test\", age: 0 }).success).toEqual(true);\n  expect(schema.safeParse(null).success).toEqual(false);\n});\n\ntest(\"chained mixed refining types\", () => {\n  type firstRefinement = { first: string; second: number; third: true };\n  type secondRefinement = { first: \"bob\"; second: number; third: true };\n  type thirdRefinement = { first: \"bob\"; second: 33; third: true };\n  const schema = z\n    .object({\n      first: z.string(),\n      second: z.number(),\n      third: z.boolean(),\n    })\n    .nullable()\n    .refine((arg): arg is firstRefinement => !!arg?.third)\n    .superRefine((arg, ctx): arg is secondRefinement => {\n      util.assertEqual<typeof arg, firstRefinement>(true);\n      if (arg.first !== \"bob\") {\n        ctx.addIssue({\n          code: z.ZodIssueCode.custom,\n          message: \"`first` property must be `bob`\",\n        });\n        return false;\n      }\n      return true;\n    })\n    .refine((arg): arg is thirdRefinement => {\n      util.assertEqual<typeof arg, secondRefinement>(true);\n      return arg.second === 33;\n    });\n\n  util.assertEqual<z.infer<typeof schema>, thirdRefinement>(true);\n});\n\ntest(\"get inner type\", () => {\n  z.string()\n    .refine(() => true)\n    .innerType()\n    .parse(\"asdf\");\n});\n\ntest(\"chained refinements\", () => {\n  const objectSchema = z\n    .object({\n      length: z.number(),\n      size: z.number(),\n    })\n    .refine(({ length }) => length > 5, {\n      path: [\"length\"],\n      message: \"length greater than 5\",\n    })\n    .refine(({ size }) => size > 7, {\n      path: [\"size\"],\n      message: \"size greater than 7\",\n    });\n  const r1 = objectSchema.safeParse({\n    length: 4,\n    size: 9,\n  });\n  expect(r1.success).toEqual(false);\n  if (!r1.success) expect(r1.error.issues.length).toEqual(1);\n\n  const r2 = objectSchema.safeParse({\n    length: 4,\n    size: 3,\n  });\n  expect(r2.success).toEqual(false);\n  if (!r2.success) expect(r2.error.issues.length).toEqual(2);\n});\n\ntest(\"fatal superRefine\", () => {\n  const Strings = z\n    .string()\n    .superRefine((val, ctx) => {\n      if (val === \"\") {\n        ctx.addIssue({\n          code: z.ZodIssueCode.custom,\n          message: \"foo\",\n          fatal: true,\n        });\n      }\n    })\n    .superRefine((val, ctx) => {\n      if (val !== \" \") {\n        ctx.addIssue({\n          code: z.ZodIssueCode.custom,\n          message: \"bar\",\n        });\n      }\n    });\n\n  const result = Strings.safeParse(\"\");\n\n  expect(result.success).toEqual(false);\n  if (!result.success) expect(result.error.issues.length).toEqual(1);\n});\n\ntest(\"superRefine after skipped transform\", () => {\n  const schema = z\n    .string()\n    .regex(/^\\d+$/)\n    .transform((val) => Number(val))\n    .superRefine((val) => {\n      if (typeof val !== \"number\") {\n        throw new Error(\"Called without transform\");\n      }\n    });\n\n  const result = schema.safeParse(\"\");\n\n  expect(result.success).toEqual(false);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/refine.test.ts",
        "start": 1,
        "end": 313,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 313,
          "column": 2,
          "position": 3112
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/refine.test.ts",
        "start": 1,
        "end": 313,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 313,
          "column": 2,
          "position": 3112
        }
      }
    },
    {
      "format": "typescript",
      "lines": 197,
      "fragment": "// @ts-ignore TS6133\nimport { test } from \"vitest\";\n\nimport { z } from \"zod/v3\";\n\ninterface Category {\n  name: string;\n  subcategories: Category[];\n}\n\nconst testCategory: Category = {\n  name: \"I\",\n  subcategories: [\n    {\n      name: \"A\",\n      subcategories: [\n        {\n          name: \"1\",\n          subcategories: [\n            {\n              name: \"a\",\n              subcategories: [],\n            },\n          ],\n        },\n      ],\n    },\n  ],\n};\n\ntest(\"recursion with z.late.object\", () => {\n  const Category: z.ZodType<Category> = z.late.object(() => ({\n    name: z.string(),\n    subcategories: z.array(Category),\n  }));\n  Category.parse(testCategory);\n});\n\ntest(\"recursion with z.lazy\", () => {\n  const Category: z.ZodType<Category> = z.lazy(() =>\n    z.object({\n      name: z.string(),\n      subcategories: z.array(Category),\n    })\n  );\n  Category.parse(testCategory);\n});\n\ntest(\"schema getter\", () => {\n  z.lazy(() => z.string()).schema.parse(\"asdf\");\n});\n\ntype LinkedList = null | { value: number; next: LinkedList };\n\nconst linkedListExample = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: null,\n      },\n    },\n  },\n};\n\ntest(\"recursion involving union type\", () => {\n  const LinkedListSchema: z.ZodType<LinkedList> = z.lazy(() =>\n    z.union([\n      z.null(),\n      z.object({\n        value: z.number(),\n        next: LinkedListSchema,\n      }),\n    ])\n  );\n  LinkedListSchema.parse(linkedListExample);\n});\n\n// interface A {\n//   val: number;\n//   b: B;\n// }\n\n// interface B {\n//   val: number;\n//   a: A;\n// }\n\n// const A: z.ZodType<A> = z.late.object(() => ({\n//   val: z.number(),\n//   b: B,\n// }));\n\n// const B: z.ZodType<B> = z.late.object(() => ({\n//   val: z.number(),\n//   a: A,\n// }));\n\n// const Alazy: z.ZodType<A> = z.lazy(() => z.object({\n//   val: z.number(),\n//   b: B,\n// }));\n\n// const Blazy: z.ZodType<B> = z.lazy(() => z.object({\n//   val: z.number(),\n//   a: A,\n// }));\n\n// const a: any = { val: 1 };\n// const b: any = { val: 2 };\n// a.b = b;\n// b.a = a;\n\n// test('valid check', () => {\n//   A.parse(a);\n//   B.parse(b);\n// });\n\n// test(\"valid check lazy\", () => {\n//   A.parse({val:1, b:});\n//   B.parse(b);\n// });\n\n// test('masking check', () => {\n//   const FragmentOnA = z\n//     .object({\n//       val: z.number(),\n//       b: z\n//         .object({\n//           val: z.number(),\n//           a: z\n//             .object({\n//               val: z.number(),\n//             })\n//             .nonstrict(),\n//         })\n//         .nonstrict(),\n//     })\n//     .nonstrict();\n\n//   const fragment = FragmentOnA.parse(a);\n//   fragment;\n// });\n\n// test('invalid check', () => {\n//   expect(() => A.parse({} as any)).toThrow();\n// });\n\n// test('schema getter', () => {\n//   (A as z.ZodLazy<any>).schema;\n// });\n\n// test(\"self recursion with cyclical data\", () => {\n//   interface Category {\n//     name: string;\n//     subcategories: Category[];\n//   }\n\n//   const Category: z.ZodType<Category> = z.late.object(() => ({\n//     name: z.string(),\n//     subcategories: z.array(Category),\n//   }));\n\n//   const untypedCategory: any = {\n//     name: \"Category A\",\n//   };\n//   // creating a cycle\n//   untypedCategory.subcategories = [untypedCategory];\n//   Category.parse(untypedCategory);\n// });\n\n// test(\"self recursion with base type\", () => {\n//   const BaseCategory = z.object({\n//     name: z.string(),\n//   });\n//   type BaseCategory = z.infer<typeof BaseCategory>;\n\n//   type Category = BaseCategory & { subcategories: Category[] };\n\n//   const Category: z.ZodType<Category> = z.late\n//     .object(() => ({\n//       subcategories: z.array(Category),\n//     }))\n//     .extend({\n//       name: z.string(),\n//     });\n\n//   const untypedCategory: any = {\n//     name: \"Category A\",\n//   };\n//   // creating a cycle\n//   untypedCategory.subcategories = [untypedCategory];\n//   Category.parse(untypedCategory); // parses successfully\n// });",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/recursive.test.ts",
        "start": 1,
        "end": 197,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 197,
          "column": 7,
          "position": 789
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/recursive.test.ts",
        "start": 1,
        "end": 197,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 197,
          "column": 7,
          "position": 789
        }
      }
    },
    {
      "format": "typescript",
      "lines": 171,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\nconst booleanRecord = z.record(z.boolean());\ntype booleanRecord = z.infer<typeof booleanRecord>;\n\nconst recordWithEnumKeys = z.record(z.enum([\"Tuna\", \"Salmon\"]), z.string());\ntype recordWithEnumKeys = z.infer<typeof recordWithEnumKeys>;\n\nconst recordWithLiteralKeys = z.record(z.union([z.literal(\"Tuna\"), z.literal(\"Salmon\")]), z.string());\ntype recordWithLiteralKeys = z.infer<typeof recordWithLiteralKeys>;\n\ntest(\"type inference\", () => {\n  util.assertEqual<booleanRecord, Record<string, boolean>>(true);\n\n  util.assertEqual<recordWithEnumKeys, Partial<Record<\"Tuna\" | \"Salmon\", string>>>(true);\n\n  util.assertEqual<recordWithLiteralKeys, Partial<Record<\"Tuna\" | \"Salmon\", string>>>(true);\n});\n\ntest(\"methods\", () => {\n  booleanRecord.optional();\n  booleanRecord.nullable();\n});\n\ntest(\"string record parse - pass\", () => {\n  booleanRecord.parse({\n    k1: true,\n    k2: false,\n    1234: false,\n  });\n});\n\ntest(\"string record parse - fail\", () => {\n  const badCheck = () =>\n    booleanRecord.parse({\n      asdf: 1234,\n    } as any);\n  expect(badCheck).toThrow();\n\n  expect(() => booleanRecord.parse(\"asdf\")).toThrow();\n});\n\ntest(\"string record parse - fail\", () => {\n  const badCheck = () =>\n    booleanRecord.parse({\n      asdf: {},\n    } as any);\n  expect(badCheck).toThrow();\n});\n\ntest(\"string record parse - fail\", () => {\n  const badCheck = () =>\n    booleanRecord.parse({\n      asdf: [],\n    } as any);\n  expect(badCheck).toThrow();\n});\n\ntest(\"key schema\", () => {\n  const result1 = recordWithEnumKeys.parse({\n    Tuna: \"asdf\",\n    Salmon: \"asdf\",\n  });\n  expect(result1).toEqual({\n    Tuna: \"asdf\",\n    Salmon: \"asdf\",\n  });\n\n  const result2 = recordWithLiteralKeys.parse({\n    Tuna: \"asdf\",\n    Salmon: \"asdf\",\n  });\n  expect(result2).toEqual({\n    Tuna: \"asdf\",\n    Salmon: \"asdf\",\n  });\n\n  // shouldn't require us to specify all props in record\n  const result3 = recordWithEnumKeys.parse({\n    Tuna: \"abcd\",\n  });\n  expect(result3).toEqual({\n    Tuna: \"abcd\",\n  });\n\n  // shouldn't require us to specify all props in record\n  const result4 = recordWithLiteralKeys.parse({\n    Salmon: \"abcd\",\n  });\n  expect(result4).toEqual({\n    Salmon: \"abcd\",\n  });\n\n  expect(() =>\n    recordWithEnumKeys.parse({\n      Tuna: \"asdf\",\n      Salmon: \"asdf\",\n      Trout: \"asdf\",\n    })\n  ).toThrow();\n\n  expect(() =>\n    recordWithLiteralKeys.parse({\n      Tuna: \"asdf\",\n      Salmon: \"asdf\",\n\n      Trout: \"asdf\",\n    })\n  ).toThrow();\n});\n\n// test(\"record element\", () => {\n//   expect(booleanRecord.element).toBeInstanceOf(z.ZodBoolean);\n// });\n\ntest(\"key and value getters\", () => {\n  const rec = z.record(z.string(), z.number());\n\n  rec.keySchema.parse(\"asdf\");\n  rec.valueSchema.parse(1234);\n  rec.element.parse(1234);\n});\n\ntest(\"is not vulnerable to prototype pollution\", async () => {\n  const rec = z.record(\n    z.object({\n      a: z.string(),\n    })\n  );\n\n  const data = JSON.parse(`\n    {\n      \"__proto__\": {\n        \"a\": \"evil\"\n      },\n      \"b\": {\n        \"a\": \"good\"\n      }\n    }\n  `);\n\n  const obj1 = rec.parse(data);\n  expect(obj1.a).toBeUndefined();\n\n  const obj2 = rec.safeParse(data);\n  expect(obj2.success).toBe(true);\n  if (obj2.success) {\n    expect(obj2.data.a).toBeUndefined();\n  }\n\n  const obj3 = await rec.parseAsync(data);\n  expect(obj3.a).toBeUndefined();\n\n  const obj4 = await rec.safeParseAsync(data);\n  expect(obj4.success).toBe(true);\n  if (obj4.success) {\n    expect(obj4.data.a).toBeUndefined();\n  }\n});\n\ntest(\"dont parse undefined values\", () => {\n  const result1 = z.record(z.any()).parse({ foo: undefined });\n\n  expect(result1).toEqual({\n    foo: undefined,\n  });\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/record.test.ts",
        "start": 1,
        "end": 171,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 171,
          "column": 2,
          "position": 1320
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/record.test.ts",
        "start": 1,
        "end": 171,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 171,
          "column": 2,
          "position": 1320
        }
      }
    },
    {
      "format": "typescript",
      "lines": 194,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\nenum testEnum {\n  A = 0,\n  B = 1,\n}\n\nconst schemas = [\n  z.string().readonly(),\n  z.number().readonly(),\n  z.nan().readonly(),\n  z.bigint().readonly(),\n  z.boolean().readonly(),\n  z.date().readonly(),\n  z.undefined().readonly(),\n  z.null().readonly(),\n  z.any().readonly(),\n  z.unknown().readonly(),\n  z.void().readonly(),\n  z.function().args(z.string(), z.number()).readonly(),\n\n  z.array(z.string()).readonly(),\n  z.tuple([z.string(), z.number()]).readonly(),\n  z.map(z.string(), z.date()).readonly(),\n  z.set(z.promise(z.string())).readonly(),\n  z.record(z.string()).readonly(),\n  z.record(z.string(), z.number()).readonly(),\n  z.object({ a: z.string(), 1: z.number() }).readonly(),\n  z.nativeEnum(testEnum).readonly(),\n  z.promise(z.string()).readonly(),\n] as const;\n\ntest(\"flat inference\", () => {\n  util.assertEqual<z.infer<(typeof schemas)[0]>, string>(true);\n  util.assertEqual<z.infer<(typeof schemas)[1]>, number>(true);\n  util.assertEqual<z.infer<(typeof schemas)[2]>, number>(true);\n  util.assertEqual<z.infer<(typeof schemas)[3]>, bigint>(true);\n  util.assertEqual<z.infer<(typeof schemas)[4]>, boolean>(true);\n  util.assertEqual<z.infer<(typeof schemas)[5]>, Date>(true);\n  util.assertEqual<z.infer<(typeof schemas)[6]>, undefined>(true);\n  util.assertEqual<z.infer<(typeof schemas)[7]>, null>(true);\n  util.assertEqual<z.infer<(typeof schemas)[8]>, any>(true);\n  util.assertEqual<z.infer<(typeof schemas)[9]>, Readonly<unknown>>(true);\n  util.assertEqual<z.infer<(typeof schemas)[10]>, void>(true);\n  util.assertEqual<z.infer<(typeof schemas)[11]>, (args_0: string, args_1: number, ...args_2: unknown[]) => unknown>(\n    true\n  );\n  util.assertEqual<z.infer<(typeof schemas)[12]>, readonly string[]>(true);\n\n  util.assertEqual<z.infer<(typeof schemas)[13]>, readonly [string, number]>(true);\n  util.assertEqual<z.infer<(typeof schemas)[14]>, ReadonlyMap<string, Date>>(true);\n  util.assertEqual<z.infer<(typeof schemas)[15]>, ReadonlySet<Promise<string>>>(true);\n  util.assertEqual<z.infer<(typeof schemas)[16]>, Readonly<Record<string, string>>>(true);\n  util.assertEqual<z.infer<(typeof schemas)[17]>, Readonly<Record<string, number>>>(true);\n  util.assertEqual<z.infer<(typeof schemas)[18]>, { readonly a: string; readonly 1: number }>(true);\n  util.assertEqual<z.infer<(typeof schemas)[19]>, Readonly<testEnum>>(true);\n  util.assertEqual<z.infer<(typeof schemas)[20]>, Promise<string>>(true);\n});\n\n// test(\"deep inference\", () => {\n//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[0]>, string>(true);\n//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[1]>, number>(true);\n//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[2]>, number>(true);\n//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[3]>, bigint>(true);\n//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[4]>, boolean>(true);\n//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[5]>, Date>(true);\n//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[6]>, undefined>(true);\n//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[7]>, null>(true);\n//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[8]>, any>(true);\n//   util.assertEqual<\n//     z.infer<(typeof deepReadonlySchemas_0)[9]>,\n//     Readonly<unknown>\n//   >(true);\n//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[10]>, void>(true);\n//   util.assertEqual<\n//     z.infer<(typeof deepReadonlySchemas_0)[11]>,\n//     (args_0: string, args_1: number, ...args_2: unknown[]) => unknown\n//   >(true);\n//   util.assertEqual<\n//     z.infer<(typeof deepReadonlySchemas_0)[12]>,\n//     readonly string[]\n//   >(true);\n//   util.assertEqual<\n//     z.infer<(typeof deepReadonlySchemas_0)[13]>,\n//     readonly [string, number]\n//   >(true);\n//   util.assertEqual<\n//     z.infer<(typeof deepReadonlySchemas_0)[14]>,\n//     ReadonlyMap<string, Date>\n//   >(true);\n//   util.assertEqual<\n//     z.infer<(typeof deepReadonlySchemas_0)[15]>,\n//     ReadonlySet<Promise<string>>\n//   >(true);\n//   util.assertEqual<\n//     z.infer<(typeof deepReadonlySchemas_0)[16]>,\n//     Readonly<Record<string, string>>\n//   >(true);\n//   util.assertEqual<\n//     z.infer<(typeof deepReadonlySchemas_0)[17]>,\n//     Readonly<Record<string, number>>\n//   >(true);\n//   util.assertEqual<\n//     z.infer<(typeof deepReadonlySchemas_0)[18]>,\n//     { readonly a: string; readonly 1: number }\n//   >(true);\n//   util.assertEqual<\n//     z.infer<(typeof deepReadonlySchemas_0)[19]>,\n//     Readonly<testEnum>\n//   >(true);\n//   util.assertEqual<\n//     z.infer<(typeof deepReadonlySchemas_0)[20]>,\n//     Promise<string>\n//   >(true);\n\n//   util.assertEqual<\n//     z.infer<typeof crazyDeepReadonlySchema>,\n//     ReadonlyMap<\n//       ReadonlySet<readonly [string, number]>,\n//       {\n//         readonly a: {\n//           readonly [x: string]: readonly any[];\n//         };\n//         readonly b: {\n//           readonly c: {\n//             readonly d: {\n//               readonly e: {\n//                 readonly f: {\n//                   readonly g?: {};\n//                 };\n//               };\n//             };\n//           };\n//         };\n//       }\n//     >\n//   >(true);\n// });\n\ntest(\"object freezing\", () => {\n  expect(Object.isFrozen(z.array(z.string()).readonly().parse([\"a\"]))).toBe(true);\n  expect(Object.isFrozen(z.tuple([z.string(), z.number()]).readonly().parse([\"a\", 1]))).toBe(true);\n  expect(\n    Object.isFrozen(\n      z\n        .map(z.string(), z.date())\n        .readonly()\n        .parse(new Map([[\"a\", new Date()]]))\n    )\n  ).toBe(true);\n  expect(\n    Object.isFrozen(\n      z\n        .set(z.promise(z.string()))\n        .readonly()\n        .parse(new Set([Promise.resolve(\"a\")]))\n    )\n  ).toBe(true);\n  expect(Object.isFrozen(z.record(z.string()).readonly().parse({ a: \"b\" }))).toBe(true);\n  expect(Object.isFrozen(z.record(z.string(), z.number()).readonly().parse({ a: 1 }))).toBe(true);\n  expect(Object.isFrozen(z.object({ a: z.string(), 1: z.number() }).readonly().parse({ a: \"b\", 1: 2 }))).toBe(true);\n  expect(Object.isFrozen(z.promise(z.string()).readonly().parse(Promise.resolve(\"a\")))).toBe(true);\n});\n\ntest(\"async object freezing\", async () => {\n  expect(Object.isFrozen(await z.array(z.string()).readonly().parseAsync([\"a\"]))).toBe(true);\n  expect(Object.isFrozen(await z.tuple([z.string(), z.number()]).readonly().parseAsync([\"a\", 1]))).toBe(true);\n  expect(\n    Object.isFrozen(\n      await z\n        .map(z.string(), z.date())\n        .readonly()\n        .parseAsync(new Map([[\"a\", new Date()]]))\n    )\n  ).toBe(true);\n  expect(\n    Object.isFrozen(\n      await z\n        .set(z.promise(z.string()))\n        .readonly()\n        .parseAsync(new Set([Promise.resolve(\"a\")]))\n    )\n  ).toBe(true);\n  expect(Object.isFrozen(await z.record(z.string()).readonly().parseAsync({ a: \"b\" }))).toBe(true);\n  expect(Object.isFrozen(await z.record(z.string(), z.number()).readonly().parseAsync({ a: 1 }))).toBe(true);\n  expect(\n    Object.isFrozen(await z.object({ a: z.string(), 1: z.number() }).readonly().parseAsync({ a: \"b\", 1: 2 }))\n  ).toBe(true);\n  expect(Object.isFrozen(await z.promise(z.string()).readonly().parseAsync(Promise.resolve(\"a\")))).toBe(true);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/readonly.test.ts",
        "start": 1,
        "end": 194,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 194,
          "column": 2,
          "position": 2163
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/readonly.test.ts",
        "start": 1,
        "end": 145,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 145,
          "column": 2,
          "position": 1559
        }
      }
    },
    {
      "format": "typescript",
      "lines": 90,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\nconst promSchema = z.promise(\n  z.object({\n    name: z.string(),\n    age: z.number(),\n  })\n);\n\ntest(\"promise inference\", () => {\n  type promSchemaType = z.infer<typeof promSchema>;\n  util.assertEqual<promSchemaType, Promise<{ name: string; age: number }>>(true);\n});\n\ntest(\"promise parsing success\", async () => {\n  const pr = promSchema.parse(Promise.resolve({ name: \"Bobby\", age: 10 }));\n  expect(pr).toBeInstanceOf(Promise);\n  const result = await pr;\n  expect(typeof result).toBe(\"object\");\n  expect(typeof result.age).toBe(\"number\");\n  expect(typeof result.name).toBe(\"string\");\n});\n\ntest(\"promise parsing success 2\", () => {\n  const fakePromise = {\n    then() {\n      return this;\n    },\n    catch() {\n      return this;\n    },\n  };\n  promSchema.parse(fakePromise);\n});\n\ntest(\"promise parsing fail\", async () => {\n  const bad = promSchema.parse(Promise.resolve({ name: \"Bobby\", age: \"10\" }));\n  // return await expect(bad).resolves.toBe({ name: 'Bobby', age: '10' });\n  return await expect(bad).rejects.toBeInstanceOf(z.ZodError);\n  // done();\n});\n\ntest(\"promise parsing fail 2\", async () => {\n  const failPromise = promSchema.parse(Promise.resolve({ name: \"Bobby\", age: \"10\" }));\n  await expect(failPromise).rejects.toBeInstanceOf(z.ZodError);\n  // done();/z\n});\n\ntest(\"promise parsing fail\", () => {\n  const bad = () => promSchema.parse({ then: () => {}, catch: {} });\n  expect(bad).toThrow();\n});\n\n// test('sync promise parsing', () => {\n//   expect(() => z.promise(z.string()).parse(Promise.resolve('asfd'))).toThrow();\n// });\n\nconst asyncFunction = z.function(z.tuple([]), promSchema);\n\ntest(\"async function pass\", async () => {\n  const validatedFunction = asyncFunction.implement(async () => {\n    return { name: \"jimmy\", age: 14 };\n  });\n  await expect(validatedFunction()).resolves.toEqual({\n    name: \"jimmy\",\n    age: 14,\n  });\n});\n\ntest(\"async function fail\", async () => {\n  const validatedFunction = asyncFunction.implement(() => {\n    return Promise.resolve(\"asdf\" as any);\n  });\n  await expect(validatedFunction()).rejects.toBeInstanceOf(z.ZodError);\n});\n\ntest(\"async promise parsing\", () => {\n  const res = z.promise(z.number()).parseAsync(Promise.resolve(12));\n  expect(res).toBeInstanceOf(Promise);\n});\n\ntest(\"resolves\", () => {\n  const foo = z.literal(\"foo\");\n  const res = z.promise(foo);\n  expect(res.unwrap()).toEqual(foo);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/promise.test.ts",
        "start": 1,
        "end": 90,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 90,
          "column": 2,
          "position": 896
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/promise.test.ts",
        "start": 1,
        "end": 81,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 81,
          "column": 2,
          "position": 855
        }
      }
    },
    {
      "format": "typescript",
      "lines": 440,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\nimport { Mocker } from \"./Mocker.js\";\n\nconst literalStringSchema = z.literal(\"asdf\");\nconst literalNumberSchema = z.literal(12);\nconst literalBooleanSchema = z.literal(true);\nconst literalBigIntSchema = z.literal(BigInt(42));\nconst MySymbol = Symbol(\"stuff\");\nconst literalSymbolSchema = z.literal(MySymbol);\nconst stringSchema = z.string();\nconst numberSchema = z.number();\nconst bigintSchema = z.bigint();\nconst booleanSchema = z.boolean();\nconst dateSchema = z.date();\nconst symbolSchema = z.symbol();\n\nconst nullSchema = z.null();\nconst undefinedSchema = z.undefined();\nconst stringSchemaOptional = z.string().optional();\nconst stringSchemaNullable = z.string().nullable();\nconst numberSchemaOptional = z.number().optional();\nconst numberSchemaNullable = z.number().nullable();\nconst bigintSchemaOptional = z.bigint().optional();\nconst bigintSchemaNullable = z.bigint().nullable();\nconst booleanSchemaOptional = z.boolean().optional();\nconst booleanSchemaNullable = z.boolean().nullable();\nconst dateSchemaOptional = z.date().optional();\nconst dateSchemaNullable = z.date().nullable();\nconst symbolSchemaOptional = z.symbol().optional();\nconst symbolSchemaNullable = z.symbol().nullable();\n\nconst val = new Mocker();\n\ntest(\"literal string correct\", () => {\n  expect(literalStringSchema.parse(\"asdf\")).toBe(\"asdf\");\n});\n\ntest(\"literal string incorrect\", () => {\n  const f = () => literalStringSchema.parse(\"not_asdf\");\n  expect(f).toThrow();\n});\n\ntest(\"literal string number\", () => {\n  const f = () => literalStringSchema.parse(123);\n  expect(f).toThrow();\n});\n\ntest(\"literal string boolean\", () => {\n  const f = () => literalStringSchema.parse(true);\n  expect(f).toThrow();\n});\n\ntest(\"literal string boolean\", () => {\n  const f = () => literalStringSchema.parse(true);\n  expect(f).toThrow();\n});\n\ntest(\"literal string object\", () => {\n  const f = () => literalStringSchema.parse({});\n  expect(f).toThrow();\n});\n\ntest(\"literal number correct\", () => {\n  expect(literalNumberSchema.parse(12)).toBe(12);\n});\n\ntest(\"literal number incorrect\", () => {\n  const f = () => literalNumberSchema.parse(13);\n  expect(f).toThrow();\n});\n\ntest(\"literal number number\", () => {\n  const f = () => literalNumberSchema.parse(val.string);\n  expect(f).toThrow();\n});\n\ntest(\"literal number boolean\", () => {\n  const f = () => literalNumberSchema.parse(val.boolean);\n  expect(f).toThrow();\n});\n\ntest(\"literal number object\", () => {\n  const f = () => literalStringSchema.parse({});\n  expect(f).toThrow();\n});\n\ntest(\"literal boolean correct\", () => {\n  expect(literalBooleanSchema.parse(true)).toBe(true);\n});\n\ntest(\"literal boolean incorrect\", () => {\n  const f = () => literalBooleanSchema.parse(false);\n  expect(f).toThrow();\n});\n\ntest(\"literal boolean number\", () => {\n  const f = () => literalBooleanSchema.parse(\"asdf\");\n  expect(f).toThrow();\n});\n\ntest(\"literal boolean boolean\", () => {\n  const f = () => literalBooleanSchema.parse(123);\n  expect(f).toThrow();\n});\n\ntest(\"literal boolean object\", () => {\n  const f = () => literalBooleanSchema.parse({});\n  expect(f).toThrow();\n});\n\ntest(\"literal bigint correct\", () => {\n  expect(literalBigIntSchema.parse(BigInt(42))).toBe(BigInt(42));\n});\n\ntest(\"literal bigint incorrect\", () => {\n  const f = () => literalBigIntSchema.parse(BigInt(43));\n  expect(f).toThrow();\n});\n\ntest(\"literal bigint number\", () => {\n  const f = () => literalBigIntSchema.parse(\"asdf\");\n  expect(f).toThrow();\n});\n\ntest(\"literal bigint boolean\", () => {\n  const f = () => literalBigIntSchema.parse(123);\n  expect(f).toThrow();\n});\n\ntest(\"literal bigint object\", () => {\n  const f = () => literalBigIntSchema.parse({});\n  expect(f).toThrow();\n});\n\ntest(\"literal symbol\", () => {\n  util.assertEqual<z.infer<typeof literalSymbolSchema>, typeof MySymbol>(true);\n  literalSymbolSchema.parse(MySymbol);\n  expect(() => literalSymbolSchema.parse(Symbol(\"asdf\"))).toThrow();\n});\n\ntest(\"parse stringSchema string\", () => {\n  stringSchema.parse(val.string);\n});\n\ntest(\"parse stringSchema number\", () => {\n  const f = () => stringSchema.parse(val.number);\n  expect(f).toThrow();\n});\n\ntest(\"parse stringSchema boolean\", () => {\n  const f = () => stringSchema.parse(val.boolean);\n  expect(f).toThrow();\n});\n\ntest(\"parse stringSchema undefined\", () => {\n  const f = () => stringSchema.parse(val.undefined);\n  expect(f).toThrow();\n});\n\ntest(\"parse stringSchema null\", () => {\n  const f = () => stringSchema.parse(val.null);\n  expect(f).toThrow();\n});\n\ntest(\"parse numberSchema string\", () => {\n  const f = () => numberSchema.parse(val.string);\n  expect(f).toThrow();\n});\n\ntest(\"parse numberSchema number\", () => {\n  numberSchema.parse(val.number);\n});\n\ntest(\"parse numberSchema bigint\", () => {\n  const f = () => numberSchema.parse(val.bigint);\n  expect(f).toThrow();\n});\n\ntest(\"parse numberSchema boolean\", () => {\n  const f = () => numberSchema.parse(val.boolean);\n  expect(f).toThrow();\n});\n\ntest(\"parse numberSchema undefined\", () => {\n  const f = () => numberSchema.parse(val.undefined);\n  expect(f).toThrow();\n});\n\ntest(\"parse numberSchema null\", () => {\n  const f = () => numberSchema.parse(val.null);\n  expect(f).toThrow();\n});\n\ntest(\"parse bigintSchema string\", () => {\n  const f = () => bigintSchema.parse(val.string);\n  expect(f).toThrow();\n});\n\ntest(\"parse bigintSchema number\", () => {\n  const f = () => bigintSchema.parse(val.number);\n  expect(f).toThrow();\n});\n\ntest(\"parse bigintSchema bigint\", () => {\n  bigintSchema.parse(val.bigint);\n});\n\ntest(\"parse bigintSchema boolean\", () => {\n  const f = () => bigintSchema.parse(val.boolean);\n  expect(f).toThrow();\n});\n\ntest(\"parse bigintSchema undefined\", () => {\n  const f = () => bigintSchema.parse(val.undefined);\n  expect(f).toThrow();\n});\n\ntest(\"parse bigintSchema null\", () => {\n  const f = () => bigintSchema.parse(val.null);\n  expect(f).toThrow();\n});\n\ntest(\"parse booleanSchema string\", () => {\n  const f = () => booleanSchema.parse(val.string);\n  expect(f).toThrow();\n});\n\ntest(\"parse booleanSchema number\", () => {\n  const f = () => booleanSchema.parse(val.number);\n  expect(f).toThrow();\n});\n\ntest(\"parse booleanSchema boolean\", () => {\n  booleanSchema.parse(val.boolean);\n});\n\ntest(\"parse booleanSchema undefined\", () => {\n  const f = () => booleanSchema.parse(val.undefined);\n  expect(f).toThrow();\n});\n\ntest(\"parse booleanSchema null\", () => {\n  const f = () => booleanSchema.parse(val.null);\n  expect(f).toThrow();\n});\n\n// ==============\n\ntest(\"parse dateSchema string\", () => {\n  const f = () => dateSchema.parse(val.string);\n  expect(f).toThrow();\n});\n\ntest(\"parse dateSchema number\", () => {\n  const f = () => dateSchema.parse(val.number);\n  expect(f).toThrow();\n});\n\ntest(\"parse dateSchema boolean\", () => {\n  const f = () => dateSchema.parse(val.boolean);\n  expect(f).toThrow();\n});\n\ntest(\"parse dateSchema date\", () => {\n  dateSchema.parse(val.date);\n});\n\ntest(\"parse dateSchema undefined\", () => {\n  const f = () => dateSchema.parse(val.undefined);\n  expect(f).toThrow();\n});\n\ntest(\"parse dateSchema null\", () => {\n  const f = () => dateSchema.parse(val.null);\n  expect(f).toThrow();\n});\n\ntest(\"parse dateSchema invalid date\", async () => {\n  try {\n    await dateSchema.parseAsync(new Date(\"invalid\"));\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].code).toEqual(z.ZodIssueCode.invalid_date);\n  }\n});\n// ==============\n\ntest(\"parse symbolSchema string\", () => {\n  const f = () => symbolSchema.parse(val.string);\n  expect(f).toThrow();\n});\n\ntest(\"parse symbolSchema number\", () => {\n  const f = () => symbolSchema.parse(val.number);\n  expect(f).toThrow();\n});\n\ntest(\"parse symbolSchema boolean\", () => {\n  const f = () => symbolSchema.parse(val.boolean);\n  expect(f).toThrow();\n});\n\ntest(\"parse symbolSchema date\", () => {\n  const f = () => symbolSchema.parse(val.date);\n  expect(f).toThrow();\n});\n\ntest(\"parse symbolSchema symbol\", () => {\n  symbolSchema.parse(val.symbol);\n});\n\ntest(\"parse symbolSchema undefined\", () => {\n  const f = () => symbolSchema.parse(val.undefined);\n  expect(f).toThrow();\n});\n\ntest(\"parse symbolSchema null\", () => {\n  const f = () => symbolSchema.parse(val.null);\n  expect(f).toThrow();\n});\n\n// ==============\n\ntest(\"parse undefinedSchema string\", () => {\n  const f = () => undefinedSchema.parse(val.string);\n  expect(f).toThrow();\n});\n\ntest(\"parse undefinedSchema number\", () => {\n  const f = () => undefinedSchema.parse(val.number);\n  expect(f).toThrow();\n});\n\ntest(\"parse undefinedSchema boolean\", () => {\n  const f = () => undefinedSchema.parse(val.boolean);\n  expect(f).toThrow();\n});\n\ntest(\"parse undefinedSchema undefined\", () => {\n  undefinedSchema.parse(val.undefined);\n});\n\ntest(\"parse undefinedSchema null\", () => {\n  const f = () => undefinedSchema.parse(val.null);\n  expect(f).toThrow();\n});\n\ntest(\"parse nullSchema string\", () => {\n  const f = () => nullSchema.parse(val.string);\n  expect(f).toThrow();\n});\n\ntest(\"parse nullSchema number\", () => {\n  const f = () => nullSchema.parse(val.number);\n  expect(f).toThrow();\n});\n\ntest(\"parse nullSchema boolean\", () => {\n  const f = () => nullSchema.parse(val.boolean);\n  expect(f).toThrow();\n});\n\ntest(\"parse nullSchema undefined\", () => {\n  const f = () => nullSchema.parse(val.undefined);\n  expect(f).toThrow();\n});\n\ntest(\"parse nullSchema null\", () => {\n  nullSchema.parse(val.null);\n});\n\ntest(\"primitive inference\", () => {\n  util.assertEqual<z.TypeOf<typeof literalStringSchema>, \"asdf\">(true);\n  util.assertEqual<z.TypeOf<typeof literalNumberSchema>, 12>(true);\n  util.assertEqual<z.TypeOf<typeof literalBooleanSchema>, true>(true);\n  util.assertEqual<z.TypeOf<typeof literalBigIntSchema>, bigint>(true);\n  util.assertEqual<z.TypeOf<typeof stringSchema>, string>(true);\n  util.assertEqual<z.TypeOf<typeof numberSchema>, number>(true);\n  util.assertEqual<z.TypeOf<typeof bigintSchema>, bigint>(true);\n  util.assertEqual<z.TypeOf<typeof booleanSchema>, boolean>(true);\n  util.assertEqual<z.TypeOf<typeof dateSchema>, Date>(true);\n  util.assertEqual<z.TypeOf<typeof symbolSchema>, symbol>(true);\n\n  util.assertEqual<z.TypeOf<typeof nullSchema>, null>(true);\n  util.assertEqual<z.TypeOf<typeof undefinedSchema>, undefined>(true);\n  util.assertEqual<z.TypeOf<typeof stringSchemaOptional>, string | undefined>(true);\n  util.assertEqual<z.TypeOf<typeof stringSchemaNullable>, string | null>(true);\n  util.assertEqual<z.TypeOf<typeof numberSchemaOptional>, number | undefined>(true);\n  util.assertEqual<z.TypeOf<typeof numberSchemaNullable>, number | null>(true);\n  util.assertEqual<z.TypeOf<typeof bigintSchemaOptional>, bigint | undefined>(true);\n  util.assertEqual<z.TypeOf<typeof bigintSchemaNullable>, bigint | null>(true);\n  util.assertEqual<z.TypeOf<typeof booleanSchemaOptional>, boolean | undefined>(true);\n  util.assertEqual<z.TypeOf<typeof booleanSchemaNullable>, boolean | null>(true);\n  util.assertEqual<z.TypeOf<typeof dateSchemaOptional>, Date | undefined>(true);\n  util.assertEqual<z.TypeOf<typeof dateSchemaNullable>, Date | null>(true);\n  util.assertEqual<z.TypeOf<typeof symbolSchemaOptional>, symbol | undefined>(true);\n  util.assertEqual<z.TypeOf<typeof symbolSchemaNullable>, symbol | null>(true);\n\n  // [\n  //   literalStringSchemaTest,\n  //   literalNumberSchemaTest,\n  //   literalBooleanSchemaTest,\n  //   literalBigIntSchemaTest,\n  //   stringSchemaTest,\n  //   numberSchemaTest,\n  //   bigintSchemaTest,\n  //   booleanSchemaTest,\n  //   dateSchemaTest,\n  //   symbolSchemaTest,\n\n  //   nullSchemaTest,\n  //   undefinedSchemaTest,\n  //   stringSchemaOptionalTest,\n  //   stringSchemaNullableTest,\n  //   numberSchemaOptionalTest,\n  //   numberSchemaNullableTest,\n  //   bigintSchemaOptionalTest,\n  //   bigintSchemaNullableTest,\n  //   booleanSchemaOptionalTest,\n  //   booleanSchemaNullableTest,\n  //   dateSchemaOptionalTest,\n  //   dateSchemaNullableTest,\n  //   symbolSchemaOptionalTest,\n  //   symbolSchemaNullableTest,\n\n  // ];\n});\n\ntest(\"get literal value\", () => {\n  expect(literalStringSchema.value).toEqual(\"asdf\");\n});\n\ntest(\"optional convenience method\", () => {\n  z.ostring().parse(undefined);\n  z.onumber().parse(undefined);\n  z.oboolean().parse(undefined);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/primitive.test.ts",
        "start": 1,
        "end": 440,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 440,
          "column": 2,
          "position": 4437
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/primitive.test.ts",
        "start": 1,
        "end": 440,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 440,
          "column": 2,
          "position": 4437
        }
      }
    },
    {
      "format": "typescript",
      "lines": 186,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\ntest(\"preprocess\", () => {\n  const schema = z.preprocess((data) => [data], z.string().array());\n\n  const value = schema.parse(\"asdf\");\n  expect(value).toEqual([\"asdf\"]);\n  util.assertEqual<(typeof schema)[\"_input\"], unknown>(true);\n});\n\ntest(\"async preprocess\", async () => {\n  const schema = z.preprocess(async (data) => [data], z.string().array());\n\n  const value = await schema.parseAsync(\"asdf\");\n  expect(value).toEqual([\"asdf\"]);\n});\n\ntest(\"preprocess ctx.addIssue with parse\", () => {\n  expect(() => {\n    z.preprocess((data, ctx) => {\n      ctx.addIssue({\n        code: \"custom\",\n        message: `${data} is not one of our allowed strings`,\n      });\n      return data;\n    }, z.string()).parse(\"asdf\");\n  }).toThrow(\n    JSON.stringify(\n      [\n        {\n          code: \"custom\",\n          message: \"asdf is not one of our allowed strings\",\n          path: [],\n        },\n      ],\n      null,\n      2\n    )\n  );\n});\n\ntest(\"preprocess ctx.addIssue non-fatal by default\", () => {\n  try {\n    z.preprocess((data, ctx) => {\n      ctx.addIssue({\n        code: \"custom\",\n        message: `custom error`,\n      });\n      return data;\n    }, z.string()).parse(1234);\n  } catch (err) {\n    z.ZodError.assert(err);\n    expect(err.issues.length).toEqual(2);\n  }\n});\n\ntest(\"preprocess ctx.addIssue fatal true\", () => {\n  try {\n    z.preprocess((data, ctx) => {\n      ctx.addIssue({\n        code: \"custom\",\n        message: `custom error`,\n        fatal: true,\n      });\n      return data;\n    }, z.string()).parse(1234);\n  } catch (err) {\n    z.ZodError.assert(err);\n    expect(err.issues.length).toEqual(1);\n  }\n});\n\ntest(\"async preprocess ctx.addIssue with parse\", async () => {\n  const schema = z.preprocess(async (data, ctx) => {\n    ctx.addIssue({\n      code: \"custom\",\n      message: `custom error`,\n    });\n    return data;\n  }, z.string());\n\n  expect(await schema.safeParseAsync(\"asdf\")).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"message\": \"custom error\",\n        \"path\": []\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"preprocess ctx.addIssue with parseAsync\", async () => {\n  const result = await z\n    .preprocess(async (data, ctx) => {\n      ctx.addIssue({\n        code: \"custom\",\n        message: `${data} is not one of our allowed strings`,\n      });\n      return data;\n    }, z.string())\n    .safeParseAsync(\"asdf\");\n\n  expect(JSON.parse(JSON.stringify(result))).toEqual({\n    success: false,\n    error: {\n      issues: [\n        {\n          code: \"custom\",\n          message: \"asdf is not one of our allowed strings\",\n          path: [],\n        },\n      ],\n      name: \"ZodError\",\n    },\n  });\n});\n\ntest(\"z.NEVER in preprocess\", () => {\n  const foo = z.preprocess((val, ctx) => {\n    if (!val) {\n      ctx.addIssue({ code: z.ZodIssueCode.custom, message: \"bad\" });\n      return z.NEVER;\n    }\n    return val;\n  }, z.number());\n\n  type foo = z.infer<typeof foo>;\n  util.assertEqual<foo, number>(true);\n  const arg = foo.safeParse(undefined);\n  expect(arg.error!.issues).toHaveLength(2);\n  expect(arg.error!.issues[0].message).toEqual(\"bad\");\n});\ntest(\"preprocess as the second property of object\", () => {\n  const schema = z.object({\n    nonEmptyStr: z.string().min(1),\n    positiveNum: z.preprocess((v) => Number(v), z.number().positive()),\n  });\n  const result = schema.safeParse({\n    nonEmptyStr: \"\",\n    positiveNum: \"\",\n  });\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues.length).toEqual(2);\n    expect(result.error.issues[0].code).toEqual(z.ZodIssueCode.too_small);\n    expect(result.error.issues[1].code).toEqual(z.ZodIssueCode.too_small);\n  }\n});\n\ntest(\"preprocess validates with sibling errors\", () => {\n  expect(() => {\n    z.object({\n      // Must be first\n      missing: z.string().refine(() => false),\n      preprocess: z.preprocess((data: any) => data?.trim(), z.string().regex(/ asdf/)),\n    }).parse({ preprocess: \" asdf\" });\n  }).toThrow(\n    JSON.stringify(\n      [\n        {\n          code: \"invalid_type\",\n          expected: \"string\",\n          received: \"undefined\",\n          path: [\"missing\"],\n          message: \"Required\",\n        },\n        {\n          validation: \"regex\",\n          code: \"invalid_string\",\n          message: \"Invalid\",\n          path: [\"preprocess\"],\n        },\n      ],\n      null,\n      2\n    )\n  );\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/preprocess.test.ts",
        "start": 1,
        "end": 186,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 186,
          "column": 2,
          "position": 1583
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/preprocess.test.ts",
        "start": 1,
        "end": 186,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 186,
          "column": 2,
          "position": 1583
        }
      }
    },
    {
      "format": "typescript",
      "lines": 29,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\ntest(\"string to number pipeline\", () => {\n  const schema = z.string().transform(Number).pipe(z.number());\n  expect(schema.parse(\"1234\")).toEqual(1234);\n});\n\ntest(\"string to number pipeline async\", async () => {\n  const schema = z\n    .string()\n    .transform(async (val) => Number(val))\n    .pipe(z.number());\n  expect(await schema.parseAsync(\"1234\")).toEqual(1234);\n});\n\ntest(\"break if dirty\", () => {\n  const schema = z\n    .string()\n    .refine((c) => c === \"1234\")\n    .transform(async (val) => Number(val))\n    .pipe(z.number().refine((v) => v < 100));\n  const r1: any = schema.safeParse(\"12345\");\n  expect(r1.error.issues.length).toBe(1);\n  const r2: any = schema.safeParse(\"3\");\n  expect(r2.error.issues.length).toBe(1);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/pipeline.test.ts",
        "start": 1,
        "end": 29,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 29,
          "column": 2,
          "position": 341
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/pipeline.test.ts",
        "start": 1,
        "end": 29,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 29,
          "column": 2,
          "position": 341
        }
      }
    },
    {
      "format": "typescript",
      "lines": 111,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\nconst fish = z.object({\n  name: z.string(),\n  age: z.number(),\n  nested: z.object({}),\n});\n\ntest(\"pick type inference\", () => {\n  const nameonlyFish = fish.pick({ name: true });\n  type nameonlyFish = z.infer<typeof nameonlyFish>;\n  util.assertEqual<nameonlyFish, { name: string }>(true);\n});\n\ntest(\"pick parse - success\", () => {\n  const nameonlyFish = fish.pick({ name: true });\n  nameonlyFish.parse({ name: \"bob\" });\n\n  // @ts-expect-error checking runtime picks `name` only.\n  const anotherNameonlyFish = fish.pick({ name: true, age: false });\n  anotherNameonlyFish.parse({ name: \"bob\" });\n});\n\ntest(\"pick parse - fail\", () => {\n  fish.pick({ name: true }).parse({ name: \"12\" } as any);\n  fish.pick({ name: true }).parse({ name: \"bob\", age: 12 } as any);\n  fish.pick({ age: true }).parse({ age: 12 } as any);\n\n  const nameonlyFish = fish.pick({ name: true }).strict();\n  const bad1 = () => nameonlyFish.parse({ name: 12 } as any);\n  const bad2 = () => nameonlyFish.parse({ name: \"bob\", age: 12 } as any);\n  const bad3 = () => nameonlyFish.parse({ age: 12 } as any);\n\n  // @ts-expect-error checking runtime picks `name` only.\n  const anotherNameonlyFish = fish.pick({ name: true, age: false }).strict();\n  const bad4 = () => anotherNameonlyFish.parse({ name: \"bob\", age: 12 } as any);\n\n  expect(bad1).toThrow();\n  expect(bad2).toThrow();\n  expect(bad3).toThrow();\n  expect(bad4).toThrow();\n});\n\ntest(\"omit type inference\", () => {\n  const nonameFish = fish.omit({ name: true });\n  type nonameFish = z.infer<typeof nonameFish>;\n  util.assertEqual<nonameFish, { age: number; nested: {} }>(true);\n});\n\ntest(\"omit parse - success\", () => {\n  const nonameFish = fish.omit({ name: true });\n  nonameFish.parse({ age: 12, nested: {} });\n\n  // @ts-expect-error checking runtime omits `name` only.\n  const anotherNonameFish = fish.omit({ name: true, age: false });\n  anotherNonameFish.parse({ age: 12, nested: {} });\n});\n\ntest(\"omit parse - fail\", () => {\n  const nonameFish = fish.omit({ name: true });\n  const bad1 = () => nonameFish.parse({ name: 12 } as any);\n  const bad2 = () => nonameFish.parse({ age: 12 } as any);\n  const bad3 = () => nonameFish.parse({} as any);\n\n  // @ts-expect-error checking runtime omits `name` only.\n  const anotherNonameFish = fish.omit({ name: true, age: false });\n  const bad4 = () => anotherNonameFish.parse({ nested: {} } as any);\n\n  expect(bad1).toThrow();\n  expect(bad2).toThrow();\n  expect(bad3).toThrow();\n  expect(bad4).toThrow();\n});\n\ntest(\"nonstrict inference\", () => {\n  const laxfish = fish.pick({ name: true }).catchall(z.any());\n  type laxfish = z.infer<typeof laxfish>;\n  util.assertEqual<laxfish, { name: string } & { [k: string]: any }>(true);\n});\n\ntest(\"nonstrict parsing - pass\", () => {\n  const laxfish = fish.passthrough().pick({ name: true });\n  laxfish.parse({ name: \"asdf\", whatever: \"asdf\" });\n  laxfish.parse({ name: \"asdf\", age: 12, nested: {} });\n});\n\ntest(\"nonstrict parsing - fail\", () => {\n  const laxfish = fish.passthrough().pick({ name: true });\n  const bad = () => laxfish.parse({ whatever: \"asdf\" } as any);\n  expect(bad).toThrow();\n});\n\ntest(\"pick/omit/required/partial - do not allow unknown keys\", () => {\n  const schema = z.object({\n    name: z.string(),\n    age: z.number(),\n  });\n\n  // @ts-expect-error\n  schema.pick({ $unknown: true });\n  // @ts-expect-error\n  schema.omit({ $unknown: true });\n  // @ts-expect-error\n  schema.required({ $unknown: true });\n  // @ts-expect-error\n  schema.partial({ $unknown: true });\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/pickomit.test.ts",
        "start": 1,
        "end": 111,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 111,
          "column": 2,
          "position": 1492
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/pickomit.test.ts",
        "start": 1,
        "end": 111,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 111,
          "column": 2,
          "position": 1492
        }
      }
    },
    {
      "format": "typescript",
      "lines": 243,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { ZodNullable, ZodOptional } from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\nconst nested = z.object({\n  name: z.string(),\n  age: z.number(),\n  outer: z.object({\n    inner: z.string(),\n  }),\n  array: z.array(z.object({ asdf: z.string() })),\n});\n\ntest(\"shallow inference\", () => {\n  const shallow = nested.partial();\n  type shallow = z.infer<typeof shallow>;\n  type correct = {\n    name?: string | undefined;\n    age?: number | undefined;\n    outer?: { inner: string } | undefined;\n    array?: { asdf: string }[];\n  };\n  util.assertEqual<shallow, correct>(true);\n});\n\ntest(\"shallow partial parse\", () => {\n  const shallow = nested.partial();\n  shallow.parse({});\n  shallow.parse({\n    name: \"asdf\",\n    age: 23143,\n  });\n});\n\ntest(\"deep partial inference\", () => {\n  const deep = nested.deepPartial();\n  const asdf = deep.shape.array.unwrap().element.shape.asdf.unwrap();\n  asdf.parse(\"asdf\");\n  type deep = z.infer<typeof deep>;\n  type correct = {\n    array?: { asdf?: string }[];\n    name?: string | undefined;\n    age?: number | undefined;\n    outer?: { inner?: string | undefined } | undefined;\n  };\n\n  util.assertEqual<deep, correct>(true);\n});\n\ntest(\"deep partial parse\", () => {\n  const deep = nested.deepPartial();\n\n  expect(deep.shape.name instanceof z.ZodOptional).toBe(true);\n  expect(deep.shape.outer instanceof z.ZodOptional).toBe(true);\n  expect(deep.shape.outer._def.innerType instanceof z.ZodObject).toBe(true);\n  expect(deep.shape.outer._def.innerType.shape.inner instanceof z.ZodOptional).toBe(true);\n  expect(deep.shape.outer._def.innerType.shape.inner._def.innerType instanceof z.ZodString).toBe(true);\n});\n\ntest(\"deep partial runtime tests\", () => {\n  const deep = nested.deepPartial();\n  deep.parse({});\n  deep.parse({\n    outer: {},\n  });\n  deep.parse({\n    name: \"asdf\",\n    age: 23143,\n    outer: {\n      inner: \"adsf\",\n    },\n  });\n});\n\ntest(\"deep partial optional/nullable\", () => {\n  const schema = z\n    .object({\n      name: z.string().optional(),\n      age: z.number().nullable(),\n    })\n    .deepPartial();\n\n  expect(schema.shape.name.unwrap()).toBeInstanceOf(ZodOptional);\n  expect(schema.shape.age.unwrap()).toBeInstanceOf(ZodNullable);\n});\n\ntest(\"deep partial tuple\", () => {\n  const schema = z\n    .object({\n      tuple: z.tuple([\n        z.object({\n          name: z.string().optional(),\n          age: z.number().nullable(),\n        }),\n      ]),\n    })\n    .deepPartial();\n\n  expect(schema.shape.tuple.unwrap().items[0].shape.name).toBeInstanceOf(ZodOptional);\n});\n\ntest(\"deep partial inference\", () => {\n  const mySchema = z.object({\n    name: z.string(),\n    array: z.array(z.object({ asdf: z.string() })),\n    tuple: z.tuple([z.object({ value: z.string() })]),\n  });\n\n  const partialed = mySchema.deepPartial();\n  type partialed = z.infer<typeof partialed>;\n  type expected = {\n    name?: string | undefined;\n    array?:\n      | {\n          asdf?: string | undefined;\n        }[]\n      | undefined;\n    tuple?: [{ value?: string }] | undefined;\n  };\n  util.assertEqual<expected, partialed>(true);\n});\n\ntest(\"required\", () => {\n  const object = z.object({\n    name: z.string(),\n    age: z.number().optional(),\n    field: z.string().optional().default(\"asdf\"),\n    nullableField: z.number().nullable(),\n    nullishField: z.string().nullish(),\n  });\n\n  const requiredObject = object.required();\n  expect(requiredObject.shape.name).toBeInstanceOf(z.ZodString);\n  expect(requiredObject.shape.age).toBeInstanceOf(z.ZodNumber);\n  expect(requiredObject.shape.field).toBeInstanceOf(z.ZodDefault);\n  expect(requiredObject.shape.nullableField).toBeInstanceOf(z.ZodNullable);\n  expect(requiredObject.shape.nullishField).toBeInstanceOf(z.ZodNullable);\n});\n\ntest(\"required inference\", () => {\n  const object = z.object({\n    name: z.string(),\n    age: z.number().optional(),\n    field: z.string().optional().default(\"asdf\"),\n    nullableField: z.number().nullable(),\n    nullishField: z.string().nullish(),\n  });\n\n  const requiredObject = object.required();\n\n  type required = z.infer<typeof requiredObject>;\n  type expected = {\n    name: string;\n    age: number;\n    field: string;\n    nullableField: number | null;\n    nullishField: string | null;\n  };\n  util.assertEqual<expected, required>(true);\n});\n\ntest(\"required with mask\", () => {\n  const object = z.object({\n    name: z.string(),\n    age: z.number().optional(),\n    field: z.string().optional().default(\"asdf\"),\n    country: z.string().optional(),\n  });\n\n  const requiredObject = object.required({ age: true });\n  expect(requiredObject.shape.name).toBeInstanceOf(z.ZodString);\n  expect(requiredObject.shape.age).toBeInstanceOf(z.ZodNumber);\n  expect(requiredObject.shape.field).toBeInstanceOf(z.ZodDefault);\n  expect(requiredObject.shape.country).toBeInstanceOf(z.ZodOptional);\n});\n\ntest(\"required with mask -- ignore falsy values\", () => {\n  const object = z.object({\n    name: z.string(),\n    age: z.number().optional(),\n    field: z.string().optional().default(\"asdf\"),\n    country: z.string().optional(),\n  });\n\n  // @ts-expect-error\n  const requiredObject = object.required({ age: true, country: false });\n  expect(requiredObject.shape.name).toBeInstanceOf(z.ZodString);\n  expect(requiredObject.shape.age).toBeInstanceOf(z.ZodNumber);\n  expect(requiredObject.shape.field).toBeInstanceOf(z.ZodDefault);\n  expect(requiredObject.shape.country).toBeInstanceOf(z.ZodOptional);\n});\n\ntest(\"partial with mask\", async () => {\n  const object = z.object({\n    name: z.string(),\n    age: z.number().optional(),\n    field: z.string().optional().default(\"asdf\"),\n    country: z.string(),\n  });\n\n  const masked = object.partial({ age: true, field: true, name: true }).strict();\n\n  expect(masked.shape.name).toBeInstanceOf(z.ZodOptional);\n  expect(masked.shape.age).toBeInstanceOf(z.ZodOptional);\n  expect(masked.shape.field).toBeInstanceOf(z.ZodOptional);\n  expect(masked.shape.country).toBeInstanceOf(z.ZodString);\n\n  masked.parse({ country: \"US\" });\n  await masked.parseAsync({ country: \"US\" });\n});\n\ntest(\"partial with mask -- ignore falsy values\", async () => {\n  const object = z.object({\n    name: z.string(),\n    age: z.number().optional(),\n    field: z.string().optional().default(\"asdf\"),\n    country: z.string(),\n  });\n\n  // @ts-expect-error\n  const masked = object.partial({ name: true, country: false }).strict();\n\n  expect(masked.shape.name).toBeInstanceOf(z.ZodOptional);\n  expect(masked.shape.age).toBeInstanceOf(z.ZodOptional);\n  expect(masked.shape.field).toBeInstanceOf(z.ZodDefault);\n  expect(masked.shape.country).toBeInstanceOf(z.ZodString);\n\n  masked.parse({ country: \"US\" });\n  await masked.parseAsync({ country: \"US\" });\n});\n\ntest(\"deeppartial array\", () => {\n  const schema = z.object({ array: z.string().array().min(42) }).deepPartial();\n\n  // works as expected\n  schema.parse({});\n\n  // should be false, but is true\n  expect(schema.safeParse({ array: [] }).success).toBe(false);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/partials.test.ts",
        "start": 1,
        "end": 243,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 243,
          "column": 2,
          "position": 2682
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/partials.test.ts",
        "start": 1,
        "end": 243,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 243,
          "column": 2,
          "position": 2682
        }
      }
    },
    {
      "format": "typescript",
      "lines": 41,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\ntest(\"parse strict object with unknown keys\", () => {\n  expect(() =>\n    z\n      .object({ name: z.string() })\n      .strict()\n      .parse({ name: \"bill\", unknownKey: 12 } as any)\n  ).toThrow();\n});\n\ntest(\"parse nonstrict object with unknown keys\", () => {\n  z.object({ name: z.string() }).nonstrict().parse({ name: \"bill\", unknownKey: 12 });\n});\n\ntest(\"invalid left side of intersection\", () => {\n  expect(() => z.intersection(z.string(), z.number()).parse(12 as any)).toThrow();\n});\n\ntest(\"invalid right side of intersection\", () => {\n  expect(() => z.intersection(z.string(), z.number()).parse(\"12\" as any)).toThrow();\n});\n\ntest(\"parsing non-array in tuple schema\", () => {\n  expect(() => z.tuple([]).parse(\"12\" as any)).toThrow();\n});\n\ntest(\"incorrect num elements in tuple\", () => {\n  expect(() => z.tuple([]).parse([\"asdf\"] as any)).toThrow();\n});\n\ntest(\"invalid enum value\", () => {\n  expect(() => z.enum([\"Blue\"]).parse(\"Red\" as any)).toThrow();\n});\n\ntest(\"parsing unknown\", () => {\n  z.string().parse(\"Red\" as unknown);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/parser.test.ts",
        "start": 1,
        "end": 41,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 41,
          "column": 2,
          "position": 470
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/parser.test.ts",
        "start": 1,
        "end": 41,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 41,
          "column": 2,
          "position": 470
        }
      }
    },
    {
      "format": "typescript",
      "lines": 23,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport { type SyncParseReturnType, isAborted, isDirty, isValid } from \"../helpers/parseUtil.js\";\n\ntest(\"parseUtil isInvalid should use structural typing\", () => {\n  // Test for issue #556: https://github.com/colinhacks/zod/issues/556\n  const aborted: SyncParseReturnType = { status: \"aborted\" };\n  const dirty: SyncParseReturnType = { status: \"dirty\", value: \"whatever\" };\n  const valid: SyncParseReturnType = { status: \"valid\", value: \"whatever\" };\n\n  expect(isAborted(aborted)).toBe(true);\n  expect(isAborted(dirty)).toBe(false);\n  expect(isAborted(valid)).toBe(false);\n\n  expect(isDirty(aborted)).toBe(false);\n  expect(isDirty(dirty)).toBe(true);\n  expect(isDirty(valid)).toBe(false);\n\n  expect(isValid(aborted)).toBe(false);\n  expect(isValid(dirty)).toBe(false);\n  expect(isValid(valid)).toBe(true);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/parseUtil.test.ts",
        "start": 1,
        "end": 23,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 23,
          "column": 2,
          "position": 271
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/parseUtil.test.ts",
        "start": 1,
        "end": 23,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 23,
          "column": 2,
          "position": 271
        }
      }
    },
    {
      "format": "typescript",
      "lines": 42,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\nfunction checkErrors(a: z.ZodTypeAny, bad: any) {\n  let expected: any;\n  try {\n    a.parse(bad);\n  } catch (error) {\n    expected = (error as z.ZodError).formErrors;\n  }\n  try {\n    a.optional().parse(bad);\n  } catch (error) {\n    expect((error as z.ZodError).formErrors).toEqual(expected);\n  }\n}\n\ntest(\"Should have error messages appropriate for the underlying type\", () => {\n  checkErrors(z.string().min(2), 1);\n  z.string().min(2).optional().parse(undefined);\n  checkErrors(z.number().gte(2), 1);\n  z.number().gte(2).optional().parse(undefined);\n  checkErrors(z.boolean(), \"\");\n  z.boolean().optional().parse(undefined);\n  checkErrors(z.undefined(), null);\n  z.undefined().optional().parse(undefined);\n  checkErrors(z.null(), {});\n  z.null().optional().parse(undefined);\n  checkErrors(z.object({}), 1);\n  z.object({}).optional().parse(undefined);\n  checkErrors(z.tuple([]), 1);\n  z.tuple([]).optional().parse(undefined);\n  checkErrors(z.unknown(), 1);\n  z.unknown().optional().parse(undefined);\n});\n\ntest(\"unwrap\", () => {\n  const unwrapped = z.string().optional().unwrap();\n  expect(unwrapped).toBeInstanceOf(z.ZodString);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/optional.test.ts",
        "start": 1,
        "end": 42,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 42,
          "column": 2,
          "position": 509
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/optional.test.ts",
        "start": 1,
        "end": 42,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 42,
          "column": 2,
          "position": 509
        }
      }
    },
    {
      "format": "typescript",
      "lines": 434,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\nconst Test = z.object({\n  f1: z.number(),\n  f2: z.string().optional(),\n  f3: z.string().nullable(),\n  f4: z.array(z.object({ t: z.union([z.string(), z.boolean()]) })),\n});\n\ntest(\"object type inference\", () => {\n  type TestType = {\n    f1: number;\n    f2?: string | undefined;\n    f3: string | null;\n    f4: { t: string | boolean }[];\n  };\n\n  util.assertEqual<z.TypeOf<typeof Test>, TestType>(true);\n});\n\ntest(\"unknown throw\", () => {\n  const asdf: unknown = 35;\n  expect(() => Test.parse(asdf)).toThrow();\n});\n\ntest(\"shape() should return schema of particular key\", () => {\n  const f1Schema = Test.shape.f1;\n  const f2Schema = Test.shape.f2;\n  const f3Schema = Test.shape.f3;\n  const f4Schema = Test.shape.f4;\n\n  expect(f1Schema).toBeInstanceOf(z.ZodNumber);\n  expect(f2Schema).toBeInstanceOf(z.ZodOptional);\n  expect(f3Schema).toBeInstanceOf(z.ZodNullable);\n  expect(f4Schema).toBeInstanceOf(z.ZodArray);\n});\n\ntest(\"correct parsing\", () => {\n  Test.parse({\n    f1: 12,\n    f2: \"string\",\n    f3: \"string\",\n    f4: [\n      {\n        t: \"string\",\n      },\n    ],\n  });\n\n  Test.parse({\n    f1: 12,\n    f3: null,\n    f4: [\n      {\n        t: false,\n      },\n    ],\n  });\n});\n\ntest(\"incorrect #1\", () => {\n  expect(() => Test.parse({} as any)).toThrow();\n});\n\ntest(\"nonstrict by default\", () => {\n  z.object({ points: z.number() }).parse({\n    points: 2314,\n    unknown: \"asdf\",\n  });\n});\n\nconst data = {\n  points: 2314,\n  unknown: \"asdf\",\n};\n\ntest(\"strip by default\", () => {\n  const val = z.object({ points: z.number() }).parse(data);\n  expect(val).toEqual({ points: 2314 });\n});\n\ntest(\"unknownkeys override\", () => {\n  const val = z.object({ points: z.number() }).strict().passthrough().strip().nonstrict().parse(data);\n\n  expect(val).toEqual(data);\n});\n\ntest(\"passthrough unknown\", () => {\n  const val = z.object({ points: z.number() }).passthrough().parse(data);\n\n  expect(val).toEqual(data);\n});\n\ntest(\"strip unknown\", () => {\n  const val = z.object({ points: z.number() }).strip().parse(data);\n\n  expect(val).toEqual({ points: 2314 });\n});\n\ntest(\"strict\", () => {\n  const val = z.object({ points: z.number() }).strict().safeParse(data);\n\n  expect(val.success).toEqual(false);\n});\n\ntest(\"catchall inference\", () => {\n  const o1 = z\n    .object({\n      first: z.string(),\n    })\n    .catchall(z.number());\n\n  const d1 = o1.parse({ first: \"asdf\", num: 1243 });\n  util.assertEqual<number, (typeof d1)[\"asdf\"]>(true);\n  util.assertEqual<string, (typeof d1)[\"first\"]>(true);\n});\n\ntest(\"catchall overrides strict\", () => {\n  const o1 = z.object({ first: z.string().optional() }).strict().catchall(z.number());\n\n  // should run fine\n  // setting a catchall overrides the unknownKeys behavior\n  o1.parse({\n    asdf: 1234,\n  });\n\n  // should only run catchall validation\n  // against unknown keys\n  o1.parse({\n    first: \"asdf\",\n    asdf: 1234,\n  });\n});\n\ntest(\"catchall overrides strict\", () => {\n  const o1 = z\n    .object({\n      first: z.string(),\n    })\n    .strict()\n    .catchall(z.number());\n\n  // should run fine\n  // setting a catchall overrides the unknownKeys behavior\n  o1.parse({\n    first: \"asdf\",\n    asdf: 1234,\n  });\n});\n\ntest(\"test that optional keys are unset\", async () => {\n  const SNamedEntity = z.object({\n    id: z.string(),\n    set: z.string().optional(),\n    unset: z.string().optional(),\n  });\n  const result = await SNamedEntity.parse({\n    id: \"asdf\",\n    set: undefined,\n  });\n  // eslint-disable-next-line ban/ban\n  expect(Object.keys(result)).toEqual([\"id\", \"set\"]);\n});\n\ntest(\"test catchall parsing\", async () => {\n  const result = z.object({ name: z.string() }).catchall(z.number()).parse({ name: \"Foo\", validExtraKey: 61 });\n\n  expect(result).toEqual({ name: \"Foo\", validExtraKey: 61 });\n\n  const result2 = z\n    .object({ name: z.string() })\n    .catchall(z.number())\n    .safeParse({ name: \"Foo\", validExtraKey: 61, invalid: \"asdf\" });\n\n  expect(result2.success).toEqual(false);\n});\n\ntest(\"test nonexistent keys\", async () => {\n  const Schema = z.union([z.object({ a: z.string() }), z.object({ b: z.number() })]);\n  const obj = { a: \"A\" };\n  const result = await Schema.spa(obj); // Works with 1.11.10, breaks with 2.0.0-beta.21\n  expect(result.success).toBe(true);\n});\n\ntest(\"test async union\", async () => {\n  const Schema2 = z.union([\n    z.object({\n      ty: z.string(),\n    }),\n    z.object({\n      ty: z.number(),\n    }),\n  ]);\n\n  const obj = { ty: \"A\" };\n  const result = await Schema2.spa(obj); // Works with 1.11.10, breaks with 2.0.0-beta.21\n  expect(result.success).toEqual(true);\n});\n\ntest(\"test inferred merged type\", async () => {\n  const asdf = z.object({ a: z.string() }).merge(z.object({ a: z.number() }));\n  type asdf = z.infer<typeof asdf>;\n  util.assertEqual<asdf, { a: number }>(true);\n});\n\ntest(\"inferred merged object type with optional properties\", async () => {\n  const Merged = z\n    .object({ a: z.string(), b: z.string().optional() })\n    .merge(z.object({ a: z.string().optional(), b: z.string() }));\n  type Merged = z.infer<typeof Merged>;\n  util.assertEqual<Merged, { a?: string; b: string }>(true);\n  // todo\n  // util.assertEqual<Merged, { a?: string; b: string }>(true);\n});\n\ntest(\"inferred unioned object type with optional properties\", async () => {\n  const Unioned = z.union([\n    z.object({ a: z.string(), b: z.string().optional() }),\n    z.object({ a: z.string().optional(), b: z.string() }),\n  ]);\n  type Unioned = z.infer<typeof Unioned>;\n  util.assertEqual<Unioned, { a: string; b?: string } | { a?: string; b: string }>(true);\n});\n\ntest(\"inferred enum type\", async () => {\n  const Enum = z.object({ a: z.string(), b: z.string().optional() }).keyof();\n\n  expect(Enum.Values).toEqual({\n    a: \"a\",\n    b: \"b\",\n  });\n  expect(Enum.enum).toEqual({\n    a: \"a\",\n    b: \"b\",\n  });\n  expect(Enum._def.values).toEqual([\"a\", \"b\"]);\n  type Enum = z.infer<typeof Enum>;\n  util.assertEqual<Enum, \"a\" | \"b\">(true);\n});\n\ntest(\"inferred partial object type with optional properties\", async () => {\n  const Partial = z.object({ a: z.string(), b: z.string().optional() }).partial();\n  type Partial = z.infer<typeof Partial>;\n  util.assertEqual<Partial, { a?: string; b?: string }>(true);\n});\n\ntest(\"inferred picked object type with optional properties\", async () => {\n  const Picked = z.object({ a: z.string(), b: z.string().optional() }).pick({ b: true });\n  type Picked = z.infer<typeof Picked>;\n  util.assertEqual<Picked, { b?: string }>(true);\n});\n\ntest(\"inferred type for unknown/any keys\", () => {\n  const myType = z.object({\n    anyOptional: z.any().optional(),\n    anyRequired: z.any(),\n    unknownOptional: z.unknown().optional(),\n    unknownRequired: z.unknown(),\n  });\n  type myType = z.infer<typeof myType>;\n  util.assertEqual<\n    myType,\n    {\n      anyOptional?: any;\n      anyRequired?: any;\n      unknownOptional?: unknown;\n      unknownRequired?: unknown;\n    }\n  >(true);\n});\n\ntest(\"setKey\", () => {\n  const base = z.object({ name: z.string() });\n  const withNewKey = base.setKey(\"age\", z.number());\n\n  type withNewKey = z.infer<typeof withNewKey>;\n  util.assertEqual<withNewKey, { name: string; age: number }>(true);\n  withNewKey.parse({ name: \"asdf\", age: 1234 });\n});\n\ntest(\"strictcreate\", async () => {\n  const strictObj = z.strictObject({\n    name: z.string(),\n  });\n\n  const syncResult = strictObj.safeParse({ name: \"asdf\", unexpected: 13 });\n  expect(syncResult.success).toEqual(false);\n\n  const asyncResult = await strictObj.spa({ name: \"asdf\", unexpected: 13 });\n  expect(asyncResult.success).toEqual(false);\n});\n\ntest(\"object with refine\", async () => {\n  const schema = z\n    .object({\n      a: z.string().default(\"foo\"),\n      b: z.number(),\n    })\n    .refine(() => true);\n  expect(schema.parse({ b: 5 })).toEqual({ b: 5, a: \"foo\" });\n  const result = await schema.parseAsync({ b: 5 });\n  expect(result).toEqual({ b: 5, a: \"foo\" });\n});\n\ntest(\"intersection of object with date\", async () => {\n  const schema = z.object({\n    a: z.date(),\n  });\n  expect(schema.and(schema).parse({ a: new Date(1637353595983) })).toEqual({\n    a: new Date(1637353595983),\n  });\n  const result = await schema.parseAsync({ a: new Date(1637353595983) });\n  expect(result).toEqual({ a: new Date(1637353595983) });\n});\n\ntest(\"intersection of object with refine with date\", async () => {\n  const schema = z\n    .object({\n      a: z.date(),\n    })\n    .refine(() => true);\n  expect(schema.and(schema).parse({ a: new Date(1637353595983) })).toEqual({\n    a: new Date(1637353595983),\n  });\n  const result = await schema.parseAsync({ a: new Date(1637353595983) });\n  expect(result).toEqual({ a: new Date(1637353595983) });\n});\n\ntest(\"constructor key\", () => {\n  const person = z\n    .object({\n      name: z.string(),\n    })\n    .strict();\n\n  expect(() =>\n    person.parse({\n      name: \"bob dylan\",\n      constructor: 61,\n    })\n  ).toThrow();\n});\n\ntest(\"constructor key\", () => {\n  const Example = z.object({\n    prop: z.string(),\n    opt: z.number().optional(),\n    arr: z.string().array(),\n  });\n\n  type Example = z.infer<typeof Example>;\n  util.assertEqual<keyof Example, \"prop\" | \"opt\" | \"arr\">(true);\n});\n\ntest(\"unknownkeys merging\", () => {\n  // This one is \"strict\"\n  const schemaA = z\n    .object({\n      a: z.string(),\n    })\n    .strict();\n\n  // This one is \"strip\"\n  const schemaB = z\n    .object({\n      b: z.string(),\n    })\n    .catchall(z.string());\n\n  const mergedSchema = schemaA.merge(schemaB);\n  type mergedSchema = typeof mergedSchema;\n  util.assertEqual<mergedSchema[\"_def\"][\"unknownKeys\"], \"strip\">(true);\n  expect(mergedSchema._def.unknownKeys).toEqual(\"strip\");\n\n  util.assertEqual<mergedSchema[\"_def\"][\"catchall\"], z.ZodString>(true);\n  expect(mergedSchema._def.catchall instanceof z.ZodString).toEqual(true);\n});\n\nconst personToExtend = z.object({\n  firstName: z.string(),\n  lastName: z.string(),\n});\n\ntest(\"extend() should return schema with new key\", () => {\n  const PersonWithNickname = personToExtend.extend({ nickName: z.string() });\n  type PersonWithNickname = z.infer<typeof PersonWithNickname>;\n\n  const expected = { firstName: \"f\", nickName: \"n\", lastName: \"l\" };\n  const actual = PersonWithNickname.parse(expected);\n\n  expect(actual).toEqual(expected);\n  util.assertEqual<keyof PersonWithNickname, \"firstName\" | \"lastName\" | \"nickName\">(true);\n  util.assertEqual<PersonWithNickname, { firstName: string; lastName: string; nickName: string }>(true);\n});\n\ntest(\"extend() should have power to override existing key\", () => {\n  const PersonWithNumberAsLastName = personToExtend.extend({\n    lastName: z.number(),\n  });\n  type PersonWithNumberAsLastName = z.infer<typeof PersonWithNumberAsLastName>;\n\n  const expected = { firstName: \"f\", lastName: 42 };\n  const actual = PersonWithNumberAsLastName.parse(expected);\n\n  expect(actual).toEqual(expected);\n  util.assertEqual<PersonWithNumberAsLastName, { firstName: string; lastName: number }>(true);\n});\n\ntest(\"passthrough index signature\", () => {\n  const a = z.object({ a: z.string() });\n  type a = z.infer<typeof a>;\n  util.assertEqual<{ a: string }, a>(true);\n  const b = a.passthrough();\n  type b = z.infer<typeof b>;\n  util.assertEqual<{ a: string } & { [k: string]: unknown }, b>(true);\n});\n\ntest(\"xor\", () => {\n  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };\n  type XOR<T, U> = T extends object ? (U extends object ? (Without<T, U> & U) | (Without<U, T> & T) : U) : T;\n\n  type A = { name: string; a: number };\n  type B = { name: string; b: number };\n  type C = XOR<A, B>;\n  type Outer = { data: C };\n\n  const _Outer: z.ZodType<Outer> = z.object({\n    data: z.union([z.object({ name: z.string(), a: z.number() }), z.object({ name: z.string(), b: z.number() })]),\n  });\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/object.test.ts",
        "start": 1,
        "end": 434,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 434,
          "column": 2,
          "position": 4924
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/object.test.ts",
        "start": 1,
        "end": 434,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 434,
          "column": 2,
          "position": 4924
        }
      }
    },
    {
      "format": "typescript",
      "lines": 29,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\nconst RealSet = Set;\nconst RealMap = Map;\nconst RealDate = Date;\n\ntest(\"doesnt throw when Date is undefined\", () => {\n  delete (globalThis as any).Date;\n  const result = z.object({}).safeParse({});\n  expect(result.success).toEqual(true);\n  globalThis.Date = RealDate;\n});\n\ntest(\"doesnt throw when Set is undefined\", () => {\n  delete (globalThis as any).Set;\n  const result = z.object({}).safeParse({});\n  expect(result.success).toEqual(true);\n  globalThis.Set = RealSet;\n});\n\ntest(\"doesnt throw when Map is undefined\", () => {\n  delete (globalThis as any).Map;\n  const result = z.object({}).safeParse({});\n  expect(result.success).toEqual(true);\n  globalThis.Map = RealMap;\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/object-in-es5-env.test.ts",
        "start": 1,
        "end": 29,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 29,
          "column": 2,
          "position": 289
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/object-in-es5-env.test.ts",
        "start": 1,
        "end": 29,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 29,
          "column": 2,
          "position": 289
        }
      }
    },
    {
      "format": "typescript",
      "lines": 29,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\ntest(\"object augmentation\", () => {\n  const Animal = z\n    .object({\n      species: z.string(),\n    })\n    .augment({\n      population: z.number(),\n    });\n  // overwrites `species`\n  const ModifiedAnimal = Animal.augment({\n    species: z.array(z.string()),\n  });\n  ModifiedAnimal.parse({\n    species: [\"asd\"],\n    population: 1324,\n  });\n\n  const bad = () =>\n    ModifiedAnimal.parse({\n      species: \"asdf\",\n      population: 1324,\n    } as any);\n  expect(bad).toThrow();\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/object-augmentation.test.ts",
        "start": 1,
        "end": 29,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 29,
          "column": 2,
          "position": 218
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/object-augmentation.test.ts",
        "start": 1,
        "end": 29,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 29,
          "column": 2,
          "position": 218
        }
      }
    },
    {
      "format": "typescript",
      "lines": 176,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\nconst gtFive = z.number().gt(5);\nconst gteFive = z.number().gte(-5).gte(5);\nconst minFive = z.number().min(0).min(5);\nconst ltFive = z.number().lte(10).lt(5);\nconst lteFive = z.number().lte(5);\nconst maxFive = z.number().max(10).max(5);\nconst intNum = z.number().int();\nconst positive = z.number().positive();\nconst negative = z.number().negative();\nconst nonpositive = z.number().nonpositive();\nconst nonnegative = z.number().nonnegative();\nconst multipleOfFive = z.number().multipleOf(5);\nconst multipleOfNegativeFive = z.number().multipleOf(-5);\nconst finite = z.number().finite();\nconst safe = z.number().safe();\nconst stepPointOne = z.number().step(0.1);\nconst stepPointZeroZeroZeroOne = z.number().step(0.0001);\nconst stepSixPointFour = z.number().step(6.4);\n\ntest(\"passing validations\", () => {\n  z.number().parse(1);\n  z.number().parse(1.5);\n  z.number().parse(0);\n  z.number().parse(-1.5);\n  z.number().parse(-1);\n  z.number().parse(Number.POSITIVE_INFINITY);\n  z.number().parse(Number.NEGATIVE_INFINITY);\n  gtFive.parse(6);\n  gtFive.parse(Number.POSITIVE_INFINITY);\n  gteFive.parse(5);\n  gteFive.parse(Number.POSITIVE_INFINITY);\n  minFive.parse(5);\n  minFive.parse(Number.POSITIVE_INFINITY);\n  ltFive.parse(4);\n  ltFive.parse(Number.NEGATIVE_INFINITY);\n  lteFive.parse(5);\n  lteFive.parse(Number.NEGATIVE_INFINITY);\n  maxFive.parse(5);\n  maxFive.parse(Number.NEGATIVE_INFINITY);\n  intNum.parse(4);\n  positive.parse(1);\n  positive.parse(Number.POSITIVE_INFINITY);\n  negative.parse(-1);\n  negative.parse(Number.NEGATIVE_INFINITY);\n  nonpositive.parse(0);\n  nonpositive.parse(-1);\n  nonpositive.parse(Number.NEGATIVE_INFINITY);\n  nonnegative.parse(0);\n  nonnegative.parse(1);\n  nonnegative.parse(Number.POSITIVE_INFINITY);\n  multipleOfFive.parse(15);\n  multipleOfFive.parse(-15);\n  multipleOfNegativeFive.parse(-15);\n  multipleOfNegativeFive.parse(15);\n  finite.parse(123);\n  safe.parse(Number.MIN_SAFE_INTEGER);\n  safe.parse(Number.MAX_SAFE_INTEGER);\n  stepPointOne.parse(6);\n  stepPointOne.parse(6.1);\n  stepPointOne.parse(6.1);\n  stepSixPointFour.parse(12.8);\n  stepPointZeroZeroZeroOne.parse(3.01);\n});\n\ntest(\"failing validations\", () => {\n  expect(() => ltFive.parse(5)).toThrow();\n  expect(() => lteFive.parse(6)).toThrow();\n  expect(() => maxFive.parse(6)).toThrow();\n  expect(() => gtFive.parse(5)).toThrow();\n  expect(() => gteFive.parse(4)).toThrow();\n  expect(() => minFive.parse(4)).toThrow();\n  expect(() => intNum.parse(3.14)).toThrow();\n  expect(() => positive.parse(0)).toThrow();\n  expect(() => positive.parse(-1)).toThrow();\n  expect(() => negative.parse(0)).toThrow();\n  expect(() => negative.parse(1)).toThrow();\n  expect(() => nonpositive.parse(1)).toThrow();\n  expect(() => nonnegative.parse(-1)).toThrow();\n  expect(() => multipleOfFive.parse(7.5)).toThrow();\n  expect(() => multipleOfFive.parse(-7.5)).toThrow();\n  expect(() => multipleOfNegativeFive.parse(-7.5)).toThrow();\n  expect(() => multipleOfNegativeFive.parse(7.5)).toThrow();\n  expect(() => finite.parse(Number.POSITIVE_INFINITY)).toThrow();\n  expect(() => finite.parse(Number.NEGATIVE_INFINITY)).toThrow();\n  expect(() => safe.parse(Number.MIN_SAFE_INTEGER - 1)).toThrow();\n  expect(() => safe.parse(Number.MAX_SAFE_INTEGER + 1)).toThrow();\n\n  expect(() => stepPointOne.parse(6.11)).toThrow();\n  expect(() => stepPointOne.parse(6.1000000001)).toThrow();\n  expect(() => stepSixPointFour.parse(6.41)).toThrow();\n});\n\ntest(\"parse NaN\", () => {\n  expect(() => z.number().parse(Number.NaN)).toThrow();\n});\n\ntest(\"min max getters\", () => {\n  expect(z.number().minValue).toBeNull;\n  expect(ltFive.minValue).toBeNull;\n  expect(lteFive.minValue).toBeNull;\n  expect(maxFive.minValue).toBeNull;\n  expect(negative.minValue).toBeNull;\n  expect(nonpositive.minValue).toBeNull;\n  expect(intNum.minValue).toBeNull;\n  expect(multipleOfFive.minValue).toBeNull;\n  expect(finite.minValue).toBeNull;\n  expect(gtFive.minValue).toEqual(5);\n  expect(gteFive.minValue).toEqual(5);\n  expect(minFive.minValue).toEqual(5);\n  expect(minFive.min(10).minValue).toEqual(10);\n  expect(positive.minValue).toEqual(0);\n  expect(nonnegative.minValue).toEqual(0);\n  expect(safe.minValue).toEqual(Number.MIN_SAFE_INTEGER);\n\n  expect(z.number().maxValue).toBeNull;\n  expect(gtFive.maxValue).toBeNull;\n  expect(gteFive.maxValue).toBeNull;\n  expect(minFive.maxValue).toBeNull;\n  expect(positive.maxValue).toBeNull;\n  expect(nonnegative.maxValue).toBeNull;\n  expect(intNum.minValue).toBeNull;\n  expect(multipleOfFive.minValue).toBeNull;\n  expect(finite.minValue).toBeNull;\n  expect(ltFive.maxValue).toEqual(5);\n  expect(lteFive.maxValue).toEqual(5);\n  expect(maxFive.maxValue).toEqual(5);\n  expect(maxFive.max(1).maxValue).toEqual(1);\n  expect(negative.maxValue).toEqual(0);\n  expect(nonpositive.maxValue).toEqual(0);\n  expect(safe.maxValue).toEqual(Number.MAX_SAFE_INTEGER);\n});\n\ntest(\"int getter\", () => {\n  expect(z.number().isInt).toEqual(false);\n  expect(z.number().multipleOf(1.5).isInt).toEqual(false);\n  expect(gtFive.isInt).toEqual(false);\n  expect(gteFive.isInt).toEqual(false);\n  expect(minFive.isInt).toEqual(false);\n  expect(positive.isInt).toEqual(false);\n  expect(nonnegative.isInt).toEqual(false);\n  expect(finite.isInt).toEqual(false);\n  expect(ltFive.isInt).toEqual(false);\n  expect(lteFive.isInt).toEqual(false);\n  expect(maxFive.isInt).toEqual(false);\n  expect(negative.isInt).toEqual(false);\n  expect(nonpositive.isInt).toEqual(false);\n  expect(safe.isInt).toEqual(false);\n\n  expect(intNum.isInt).toEqual(true);\n  expect(multipleOfFive.isInt).toEqual(true);\n});\n\ntest(\"finite getter\", () => {\n  expect(z.number().isFinite).toEqual(false);\n  expect(gtFive.isFinite).toEqual(false);\n  expect(gteFive.isFinite).toEqual(false);\n  expect(minFive.isFinite).toEqual(false);\n  expect(positive.isFinite).toEqual(false);\n  expect(nonnegative.isFinite).toEqual(false);\n  expect(ltFive.isFinite).toEqual(false);\n  expect(lteFive.isFinite).toEqual(false);\n  expect(maxFive.isFinite).toEqual(false);\n  expect(negative.isFinite).toEqual(false);\n  expect(nonpositive.isFinite).toEqual(false);\n\n  expect(finite.isFinite).toEqual(true);\n  expect(intNum.isFinite).toEqual(true);\n  expect(multipleOfFive.isFinite).toEqual(true);\n  expect(z.number().min(5).max(10).isFinite).toEqual(true);\n  expect(safe.isFinite).toEqual(true);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/number.test.ts",
        "start": 1,
        "end": 176,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 176,
          "column": 2,
          "position": 2362
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/number.test.ts",
        "start": 1,
        "end": 176,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 176,
          "column": 2,
          "position": 2362
        }
      }
    },
    {
      "format": "typescript",
      "lines": 42,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\nfunction checkErrors(a: z.ZodTypeAny, bad: any) {\n  let expected: any;\n  try {\n    a.parse(bad);\n  } catch (error) {\n    expected = (error as z.ZodError).formErrors;\n  }\n  try {\n    a.nullable().parse(bad);\n  } catch (error) {\n    expect((error as z.ZodError).formErrors).toEqual(expected);\n  }\n}\n\ntest(\"Should have error messages appropriate for the underlying type\", () => {\n  checkErrors(z.string().min(2), 1);\n  z.string().min(2).nullable().parse(null);\n  checkErrors(z.number().gte(2), 1);\n  z.number().gte(2).nullable().parse(null);\n  checkErrors(z.boolean(), \"\");\n  z.boolean().nullable().parse(null);\n  checkErrors(z.null(), null);\n  z.null().nullable().parse(null);\n  checkErrors(z.null(), {});\n  z.null().nullable().parse(null);\n  checkErrors(z.object({}), 1);\n  z.object({}).nullable().parse(null);\n  checkErrors(z.tuple([]), 1);\n  z.tuple([]).nullable().parse(null);\n  checkErrors(z.unknown(), 1);\n  z.unknown().nullable().parse(null);\n});\n\ntest(\"unwrap\", () => {\n  const unwrapped = z.string().nullable().unwrap();\n  expect(unwrapped).toBeInstanceOf(z.ZodString);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/nullable.test.ts",
        "start": 1,
        "end": 42,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 42,
          "column": 2,
          "position": 509
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/optional.test.ts",
        "start": 1,
        "end": 42,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 42,
          "column": 2,
          "position": 509
        }
      }
    },
    {
      "format": "typescript",
      "lines": 87,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\ntest(\"nativeEnum test with consts\", () => {\n  const Fruits: { Apple: \"apple\"; Banana: \"banana\" } = {\n    Apple: \"apple\",\n    Banana: \"banana\",\n  };\n  const fruitEnum = z.nativeEnum(Fruits);\n  type fruitEnum = z.infer<typeof fruitEnum>;\n  fruitEnum.parse(\"apple\");\n  fruitEnum.parse(\"banana\");\n  fruitEnum.parse(Fruits.Apple);\n  fruitEnum.parse(Fruits.Banana);\n  util.assertEqual<fruitEnum, \"apple\" | \"banana\">(true);\n});\n\ntest(\"nativeEnum test with real enum\", () => {\n  enum Fruits {\n    Apple = \"apple\",\n    Banana = \"banana\",\n  }\n  // @ts-ignore\n  const fruitEnum = z.nativeEnum(Fruits);\n  type fruitEnum = z.infer<typeof fruitEnum>;\n  fruitEnum.parse(\"apple\");\n  fruitEnum.parse(\"banana\");\n  fruitEnum.parse(Fruits.Apple);\n  fruitEnum.parse(Fruits.Banana);\n  util.assertIs<fruitEnum extends Fruits ? true : false>(true);\n});\n\ntest(\"nativeEnum test with const with numeric keys\", () => {\n  const FruitValues = {\n    Apple: 10,\n    Banana: 20,\n    // @ts-ignore\n  } as const;\n  const fruitEnum = z.nativeEnum(FruitValues);\n  type fruitEnum = z.infer<typeof fruitEnum>;\n  fruitEnum.parse(10);\n  fruitEnum.parse(20);\n  fruitEnum.parse(FruitValues.Apple);\n  fruitEnum.parse(FruitValues.Banana);\n  util.assertEqual<fruitEnum, 10 | 20>(true);\n});\n\ntest(\"from enum\", () => {\n  enum Fruits {\n    Cantaloupe = 0,\n    Apple = \"apple\",\n    Banana = \"banana\",\n  }\n\n  const FruitEnum = z.nativeEnum(Fruits as any);\n  type _FruitEnum = z.infer<typeof FruitEnum>;\n  FruitEnum.parse(Fruits.Cantaloupe);\n  FruitEnum.parse(Fruits.Apple);\n  FruitEnum.parse(\"apple\");\n  FruitEnum.parse(0);\n  expect(() => FruitEnum.parse(1)).toThrow();\n  expect(() => FruitEnum.parse(\"Apple\")).toThrow();\n  expect(() => FruitEnum.parse(\"Cantaloupe\")).toThrow();\n});\n\ntest(\"from const\", () => {\n  const Greek = {\n    Alpha: \"a\",\n    Beta: \"b\",\n    Gamma: 3,\n    // @ts-ignore\n  } as const;\n\n  const GreekEnum = z.nativeEnum(Greek);\n  type _GreekEnum = z.infer<typeof GreekEnum>;\n  GreekEnum.parse(\"a\");\n  GreekEnum.parse(\"b\");\n  GreekEnum.parse(3);\n  expect(() => GreekEnum.parse(\"v\")).toThrow();\n  expect(() => GreekEnum.parse(\"Alpha\")).toThrow();\n  expect(() => GreekEnum.parse(2)).toThrow();\n\n  expect(GreekEnum.enum.Alpha).toEqual(\"a\");\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/nativeEnum.test.ts",
        "start": 1,
        "end": 87,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 87,
          "column": 2,
          "position": 867
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/nativeEnum.test.ts",
        "start": 1,
        "end": 87,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 87,
          "column": 2,
          "position": 867
        }
      }
    },
    {
      "format": "typescript",
      "lines": 21,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\nconst schema = z.nan();\n\ntest(\"passing validations\", () => {\n  schema.parse(Number.NaN);\n  schema.parse(Number(\"Not a number\"));\n});\n\ntest(\"failing validations\", () => {\n  expect(() => schema.parse(5)).toThrow();\n  expect(() => schema.parse(\"John\")).toThrow();\n  expect(() => schema.parse(true)).toThrow();\n  expect(() => schema.parse(null)).toThrow();\n  expect(() => schema.parse(undefined)).toThrow();\n  expect(() => schema.parse({})).toThrow();\n  expect(() => schema.parse([])).toThrow();\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/nan.test.ts",
        "start": 1,
        "end": 21,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 21,
          "column": 2,
          "position": 250
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/nan.test.ts",
        "start": 1,
        "end": 21,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 21,
          "column": 2,
          "position": 271
        }
      }
    },
    {
      "format": "typescript",
      "lines": 19,
      "fragment": "// @ts-ignore TS6133\nimport { test } from \"vitest\";\n\nimport { Mocker } from \"./Mocker.js\";\n\ntest(\"mocker\", () => {\n  const mocker = new Mocker();\n  mocker.string;\n  mocker.number;\n  mocker.boolean;\n  mocker.null;\n  mocker.undefined;\n  mocker.stringOptional;\n  mocker.stringNullable;\n  mocker.numberOptional;\n  mocker.numberNullable;\n  mocker.booleanOptional;\n  mocker.booleanNullable;\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/mocker.test.ts",
        "start": 1,
        "end": 19,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 19,
          "column": 2,
          "position": 124
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/mocker.test.ts",
        "start": 1,
        "end": 19,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 19,
          "column": 2,
          "position": 124
        }
      }
    },
    {
      "format": "typescript",
      "lines": 110,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { ZodIssueCode } from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\nconst stringMap = z.map(z.string(), z.string());\ntype stringMap = z.infer<typeof stringMap>;\n\ntest(\"type inference\", () => {\n  util.assertEqual<stringMap, Map<string, string>>(true);\n});\n\ntest(\"valid parse\", () => {\n  const result = stringMap.safeParse(\n    new Map([\n      [\"first\", \"foo\"],\n      [\"second\", \"bar\"],\n    ])\n  );\n  expect(result.success).toEqual(true);\n  if (result.success) {\n    expect(result.data.has(\"first\")).toEqual(true);\n    expect(result.data.has(\"second\")).toEqual(true);\n    expect(result.data.get(\"first\")).toEqual(\"foo\");\n    expect(result.data.get(\"second\")).toEqual(\"bar\");\n  }\n});\n\ntest(\"valid parse async\", async () => {\n  const result = await stringMap.spa(\n    new Map([\n      [\"first\", \"foo\"],\n      [\"second\", \"bar\"],\n    ])\n  );\n  expect(result.success).toEqual(true);\n  if (result.success) {\n    expect(result.data.has(\"first\")).toEqual(true);\n    expect(result.data.has(\"second\")).toEqual(true);\n    expect(result.data.get(\"first\")).toEqual(\"foo\");\n    expect(result.data.get(\"second\")).toEqual(\"bar\");\n  }\n});\n\ntest(\"throws when a Set is given\", () => {\n  const result = stringMap.safeParse(new Set([]));\n  expect(result.success).toEqual(false);\n  if (result.success === false) {\n    expect(result.error.issues.length).toEqual(1);\n    expect(result.error.issues[0].code).toEqual(ZodIssueCode.invalid_type);\n  }\n});\n\ntest(\"throws when the given map has invalid key and invalid input\", () => {\n  const result = stringMap.safeParse(new Map([[42, Symbol()]]));\n  expect(result.success).toEqual(false);\n  if (result.success === false) {\n    expect(result.error.issues.length).toEqual(2);\n    expect(result.error.issues[0].code).toEqual(ZodIssueCode.invalid_type);\n    expect(result.error.issues[0].path).toEqual([0, \"key\"]);\n    expect(result.error.issues[1].code).toEqual(ZodIssueCode.invalid_type);\n    expect(result.error.issues[1].path).toEqual([0, \"value\"]);\n  }\n});\n\ntest(\"throws when the given map has multiple invalid entries\", () => {\n  // const result = stringMap.safeParse(new Map([[42, Symbol()]]));\n\n  const result = stringMap.safeParse(\n    new Map([\n      [1, \"foo\"],\n      [\"bar\", 2],\n    ] as [any, any][]) as Map<any, any>\n  );\n\n  // const result = stringMap.safeParse(new Map([[42, Symbol()]]));\n  expect(result.success).toEqual(false);\n  if (result.success === false) {\n    expect(result.error.issues.length).toEqual(2);\n    expect(result.error.issues[0].code).toEqual(ZodIssueCode.invalid_type);\n    expect(result.error.issues[0].path).toEqual([0, \"key\"]);\n    expect(result.error.issues[1].code).toEqual(ZodIssueCode.invalid_type);\n    expect(result.error.issues[1].path).toEqual([1, \"value\"]);\n  }\n});\n\ntest(\"dirty\", async () => {\n  const map = z.map(\n    z.string().refine((val) => val === val.toUpperCase(), {\n      message: \"Keys must be uppercase\",\n    }),\n    z.string()\n  );\n  const result = await map.spa(\n    new Map([\n      [\"first\", \"foo\"],\n      [\"second\", \"bar\"],\n    ])\n  );\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues.length).toEqual(2);\n    expect(result.error.issues[0].code).toEqual(z.ZodIssueCode.custom);\n    expect(result.error.issues[0].message).toEqual(\"Keys must be uppercase\");\n    expect(result.error.issues[1].code).toEqual(z.ZodIssueCode.custom);\n    expect(result.error.issues[1].message).toEqual(\"Keys must be uppercase\");\n  }\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/map.test.ts",
        "start": 1,
        "end": 110,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 110,
          "column": 2,
          "position": 1283
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/map.test.ts",
        "start": 1,
        "end": 110,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 110,
          "column": 2,
          "position": 1283
        }
      }
    },
    {
      "format": "typescript",
      "lines": 36,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\nconst literalTuna = z.literal(\"tuna\");\nconst literalFortyTwo = z.literal(42);\nconst literalTrue = z.literal(true);\n\nconst terrificSymbol = Symbol(\"terrific\");\nconst literalTerrificSymbol = z.literal(terrificSymbol);\n\ntest(\"passing validations\", () => {\n  literalTuna.parse(\"tuna\");\n  literalFortyTwo.parse(42);\n  literalTrue.parse(true);\n  literalTerrificSymbol.parse(terrificSymbol);\n});\n\ntest(\"failing validations\", () => {\n  expect(() => literalTuna.parse(\"shark\")).toThrow();\n  expect(() => literalFortyTwo.parse(43)).toThrow();\n  expect(() => literalTrue.parse(false)).toThrow();\n  expect(() => literalTerrificSymbol.parse(Symbol(\"terrific\"))).toThrow();\n});\n\ntest(\"invalid_literal should have `received` field with data\", () => {\n  const data = \"shark\";\n  const result = literalTuna.safeParse(data);\n  if (!result.success) {\n    const issue = result.error.issues[0];\n    if (issue.code === \"invalid_literal\") {\n      expect(issue.received).toBe(data);\n    }\n  }\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/literal.test.ts",
        "start": 1,
        "end": 36,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 36,
          "column": 2,
          "position": 363
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/literal.test.ts",
        "start": 1,
        "end": 36,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 36,
          "column": 2,
          "position": 363
        }
      }
    },
    {
      "format": "typescript",
      "lines": 207,
      "fragment": "import { test } from \"vitest\";\n// import path from \"path\";\n// import { Node, Project, SyntaxKind } from \"ts-morph\";\n\n// import { filePath } from \"./language-server.source\";\n\n// The following tool is helpful for understanding the TypeScript AST associated with these tests:\n// https://ts-ast-viewer.com/ (just copy the contents of language-server.source into the viewer)\n\ntest(\"\", () => {});\n// describe(\"Executing Go To Definition (and therefore Find Usages and Rename Refactoring) using an IDE works on inferred object properties\", () => {\n//   // Compile file developmentEnvironment.source\n//   const project = new Project({\n//     tsConfigFilePath: path.join(__dirname, \"..\", \"..\", \"tsconfig.json\"),\n//     skipAddingFilesFromTsConfig: true,\n//   });\n//   const sourceFile = project.addSourceFileAtPath(filePath);\n\n//   test(\"works for object properties inferred from z.object()\", () => {\n//     // Find usage of Test.f1 property\n//     const instanceVariable =\n//       sourceFile.getVariableDeclarationOrThrow(\"instanceOfTest\");\n//     const propertyBeingAssigned = getPropertyBeingAssigned(\n//       instanceVariable,\n//       \"f1\"\n//     );\n\n//     // Find definition of Test.f1 property\n//     const definitionOfProperty = propertyBeingAssigned?.getDefinitionNodes()[0];\n//     const parentOfProperty = definitionOfProperty?.getFirstAncestorByKind(\n//       SyntaxKind.VariableDeclaration\n//     );\n\n//     // Assert that find definition returned the Zod definition of Test\n//     expect(definitionOfProperty?.getText()).toEqual(\"f1: z.number()\");\n//     expect(parentOfProperty?.getName()).toEqual(\"Test\");\n//   });\n\n//   // test(\"works for first object properties inferred from z.object().merge()\", () => {\n//   //   // Find usage of TestMerge.f1 property\n//   //   const instanceVariable = sourceFile.getVariableDeclarationOrThrow(\n//   //     \"instanceOfTestMerge\"\n//   //   );\n//   //   const propertyBeingAssigned = getPropertyBeingAssigned(\n//   //     instanceVariable,\n//   //     \"f1\"\n//   //   );\n\n//   //   // Find definition of TestMerge.f1 property\n//   //   const definitionOfProperty = propertyBeingAssigned?.getDefinitionNodes()[0];\n//   //   const parentOfProperty = definitionOfProperty?.getFirstAncestorByKind(\n//   //     SyntaxKind.VariableDeclaration\n//   //   );\n\n//   //   // Assert that find definition returned the Zod definition of Test\n//   //   expect(definitionOfProperty?.getText()).toEqual(\"f1: z.number()\");\n//   //   expect(parentOfProperty?.getName()).toEqual(\"Test\");\n//   // });\n\n//   // test(\"works for second object properties inferred from z.object().merge()\", () => {\n//   //   // Find usage of TestMerge.f2 property\n//   //   const instanceVariable = sourceFile.getVariableDeclarationOrThrow(\n//   //     \"instanceOfTestMerge\"\n//   //   );\n//   //   const propertyBeingAssigned = getPropertyBeingAssigned(\n//   //     instanceVariable,\n//   //     \"f2\"\n//   //   );\n\n//   //   // Find definition of TestMerge.f2 property\n//   //   const definitionOfProperty = propertyBeingAssigned?.getDefinitionNodes()[0];\n//   //   const parentOfProperty = definitionOfProperty?.getFirstAncestorByKind(\n//   //     SyntaxKind.VariableDeclaration\n//   //   );\n\n//   //   // Assert that find definition returned the Zod definition of TestMerge\n//   //   expect(definitionOfProperty?.getText()).toEqual(\n//   //     \"f2: z.string().optional()\"\n//   //   );\n//   //   expect(parentOfProperty?.getName()).toEqual(\"TestMerge\");\n//   // });\n\n//   test(\"works for first object properties inferred from z.union()\", () => {\n//     // Find usage of TestUnion.f1 property\n//     const instanceVariable = sourceFile.getVariableDeclarationOrThrow(\n//       \"instanceOfTestUnion\"\n//     );\n//     const propertyBeingAssigned = getPropertyBeingAssigned(\n//       instanceVariable,\n//       \"f1\"\n//     );\n\n//     // Find definition of TestUnion.f1 property\n//     const definitionOfProperty = propertyBeingAssigned?.getDefinitionNodes()[0];\n//     const parentOfProperty = definitionOfProperty?.getFirstAncestorByKind(\n//       SyntaxKind.VariableDeclaration\n//     );\n\n//     // Assert that find definition returned the Zod definition of Test\n//     expect(definitionOfProperty?.getText()).toEqual(\"f1: z.number()\");\n//     expect(parentOfProperty?.getName()).toEqual(\"Test\");\n//   });\n\n//   test(\"works for second object properties inferred from z.union()\", () => {\n//     // Find usage of TestUnion.f2 property\n//     const instanceVariable = sourceFile.getVariableDeclarationOrThrow(\n//       \"instanceOfTestUnion\"\n//     );\n//     const propertyBeingAssigned = getPropertyBeingAssigned(\n//       instanceVariable,\n//       \"f2\"\n//     );\n\n//     // Find definition of TestUnion.f2 property\n//     const definitionOfProperty = propertyBeingAssigned?.getDefinitionNodes()[0];\n//     const parentOfProperty = definitionOfProperty?.getFirstAncestorByKind(\n//       SyntaxKind.VariableDeclaration\n//     );\n\n//     // Assert that find definition returned the Zod definition of TestUnion\n//     expect(definitionOfProperty?.getText()).toEqual(\n//       \"f2: z.string().optional()\"\n//     );\n//     expect(parentOfProperty?.getName()).toEqual(\"TestUnion\");\n//   });\n\n//   test(\"works for object properties inferred from z.object().partial()\", () => {\n//     // Find usage of TestPartial.f1 property\n//     const instanceVariable = sourceFile.getVariableDeclarationOrThrow(\n//       \"instanceOfTestPartial\"\n//     );\n//     const propertyBeingAssigned = getPropertyBeingAssigned(\n//       instanceVariable,\n//       \"f1\"\n//     );\n\n//     // Find definition of TestPartial.f1 property\n//     const definitionOfProperty = propertyBeingAssigned?.getDefinitionNodes()[0];\n//     const parentOfProperty = definitionOfProperty?.getFirstAncestorByKind(\n//       SyntaxKind.VariableDeclaration\n//     );\n\n//     // Assert that find definition returned the Zod definition of Test\n//     expect(definitionOfProperty?.getText()).toEqual(\"f1: z.number()\");\n//     expect(parentOfProperty?.getName()).toEqual(\"Test\");\n//   });\n\n//   test(\"works for object properties inferred from z.object().pick()\", () => {\n//     // Find usage of TestPick.f1 property\n//     const instanceVariable =\n//       sourceFile.getVariableDeclarationOrThrow(\"instanceOfTestPick\");\n//     const propertyBeingAssigned = getPropertyBeingAssigned(\n//       instanceVariable,\n//       \"f1\"\n//     );\n\n//     // Find definition of TestPick.f1 property\n//     const definitionOfProperty = propertyBeingAssigned?.getDefinitionNodes()[0];\n//     const parentOfProperty = definitionOfProperty?.getFirstAncestorByKind(\n//       SyntaxKind.VariableDeclaration\n//     );\n\n//     // Assert that find definition returned the Zod definition of Test\n//     expect(definitionOfProperty?.getText()).toEqual(\"f1: z.number()\");\n//     expect(parentOfProperty?.getName()).toEqual(\"Test\");\n//   });\n\n//   test(\"works for object properties inferred from z.object().omit()\", () => {\n//     // Find usage of TestOmit.f1 property\n//     const instanceVariable =\n//       sourceFile.getVariableDeclarationOrThrow(\"instanceOfTestOmit\");\n//     const propertyBeingAssigned = getPropertyBeingAssigned(\n//       instanceVariable,\n//       \"f1\"\n//     );\n\n//     // Find definition of TestOmit.f1 property\n//     const definitionOfProperty = propertyBeingAssigned?.getDefinitionNodes()[0];\n//     const parentOfProperty = definitionOfProperty?.getFirstAncestorByKind(\n//       SyntaxKind.VariableDeclaration\n//     );\n\n//     // Assert that find definition returned the Zod definition of Test\n//     expect(definitionOfProperty?.getText()).toEqual(\"f1: z.number()\");\n//     expect(parentOfProperty?.getName()).toEqual(\"Test\");\n//   });\n// });\n\n// const getPropertyBeingAssigned = (node: Node, name: string) => {\n//   const propertyAssignment = node.forEachDescendant((descendent) =>\n//     Node.isPropertyAssignment(descendent) && descendent.getName() == name\n//       ? descendent\n//       : undefined\n//   );\n\n//   if (propertyAssignment == null)\n//     fail(`Could not find property assignment with name ${name}`);\n\n//   const propertyLiteral = propertyAssignment.getFirstDescendantByKind(\n//     SyntaxKind.Identifier\n//   );\n\n//   if (propertyLiteral == null)\n//     fail(`Could not find property literal with name ${name}`);\n\n//   return propertyLiteral;\n// };",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/language-server.test.ts",
        "start": 1,
        "end": 207,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 207,
          "column": 6,
          "position": 404
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/language-server.test.ts",
        "start": 1,
        "end": 207,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 207,
          "column": 6,
          "position": 404
        }
      }
    },
    {
      "format": "typescript",
      "lines": 76,
      "fragment": "import * as z from \"zod/v3\";\n\nexport const filePath = __filename;\n\n// z.object()\n\nexport const Test = z.object({\n  f1: z.number(),\n});\n\nexport type Test = z.infer<typeof Test>;\n\nexport const instanceOfTest: Test = {\n  f1: 1,\n};\n\n// z.object().merge()\n\nexport const TestMerge = z\n  .object({\n    f2: z.string().optional(),\n  })\n  .merge(Test);\n\nexport type TestMerge = z.infer<typeof TestMerge>;\n\nexport const instanceOfTestMerge: TestMerge = {\n  f1: 1,\n  f2: \"string\",\n};\n\n// z.union()\n\nexport const TestUnion = z.union([\n  z.object({\n    f2: z.string().optional(),\n  }),\n  Test,\n]);\n\nexport type TestUnion = z.infer<typeof TestUnion>;\n\nexport const instanceOfTestUnion: TestUnion = {\n  f1: 1,\n  f2: \"string\",\n};\n\n// z.object().partial()\n\nexport const TestPartial = Test.partial();\n\nexport type TestPartial = z.infer<typeof TestPartial>;\n\nexport const instanceOfTestPartial: TestPartial = {\n  f1: 1,\n};\n\n// z.object().pick()\n\nexport const TestPick = TestMerge.pick({ f1: true });\n\nexport type TestPick = z.infer<typeof TestPick>;\n\nexport const instanceOfTestPick: TestPick = {\n  f1: 1,\n};\n\n// z.object().omit()\n\nexport const TestOmit = TestMerge.omit({ f2: true });\n\nexport type TestOmit = z.infer<typeof TestOmit>;\n\nexport const instanceOfTestOmit: TestOmit = {\n  f1: 1,\n};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/language-server.source.ts",
        "start": 1,
        "end": 76,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 76,
          "column": 2,
          "position": 501
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/language-server.source.ts",
        "start": 1,
        "end": 76,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 76,
          "column": 2,
          "position": 501
        }
      }
    },
    {
      "format": "typescript",
      "lines": 110,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\ntest(\"object intersection\", () => {\n  const BaseTeacher = z.object({\n    subjects: z.array(z.string()),\n  });\n  const HasID = z.object({ id: z.string() });\n\n  const Teacher = z.intersection(BaseTeacher.passthrough(), HasID); // BaseTeacher.merge(HasID);\n  const data = {\n    subjects: [\"math\"],\n    id: \"asdfasdf\",\n  };\n  expect(Teacher.parse(data)).toEqual(data);\n  expect(() => Teacher.parse({ subject: data.subjects })).toThrow();\n  expect(Teacher.parse({ ...data, extra: 12 })).toEqual({ ...data, extra: 12 });\n\n  expect(() => z.intersection(BaseTeacher.strict(), HasID).parse({ ...data, extra: 12 })).toThrow();\n});\n\ntest(\"deep intersection\", () => {\n  const Animal = z.object({\n    properties: z.object({\n      is_animal: z.boolean(),\n    }),\n  });\n  const Cat = z\n    .object({\n      properties: z.object({\n        jumped: z.boolean(),\n      }),\n    })\n    .and(Animal);\n\n  type _Cat = z.infer<typeof Cat>;\n  // const cat:Cat = 'asdf' as any;\n  const cat = Cat.parse({ properties: { is_animal: true, jumped: true } });\n  expect(cat.properties).toEqual({ is_animal: true, jumped: true });\n});\n\ntest(\"deep intersection of arrays\", async () => {\n  const Author = z.object({\n    posts: z.array(\n      z.object({\n        post_id: z.number(),\n      })\n    ),\n  });\n  const Registry = z\n    .object({\n      posts: z.array(\n        z.object({\n          title: z.string(),\n        })\n      ),\n    })\n    .and(Author);\n\n  const posts = [\n    { post_id: 1, title: \"Novels\" },\n    { post_id: 2, title: \"Fairy tales\" },\n  ];\n  const cat = Registry.parse({ posts });\n  expect(cat.posts).toEqual(posts);\n  const asyncCat = await Registry.parseAsync({ posts });\n  expect(asyncCat.posts).toEqual(posts);\n});\n\ntest(\"invalid intersection types\", async () => {\n  const numberIntersection = z.intersection(\n    z.number(),\n    z.number().transform((x) => x + 1)\n  );\n\n  const syncResult = numberIntersection.safeParse(1234);\n  expect(syncResult.success).toEqual(false);\n  if (!syncResult.success) {\n    expect(syncResult.error.issues[0].code).toEqual(z.ZodIssueCode.invalid_intersection_types);\n  }\n\n  const asyncResult = await numberIntersection.spa(1234);\n  expect(asyncResult.success).toEqual(false);\n  if (!asyncResult.success) {\n    expect(asyncResult.error.issues[0].code).toEqual(z.ZodIssueCode.invalid_intersection_types);\n  }\n});\n\ntest(\"invalid array merge\", async () => {\n  const stringArrInt = z.intersection(\n    z.string().array(),\n    z\n      .string()\n      .array()\n      .transform((val) => [...val, \"asdf\"])\n  );\n  const syncResult = stringArrInt.safeParse([\"asdf\", \"qwer\"]);\n  expect(syncResult.success).toEqual(false);\n  if (!syncResult.success) {\n    expect(syncResult.error.issues[0].code).toEqual(z.ZodIssueCode.invalid_intersection_types);\n  }\n\n  const asyncResult = await stringArrInt.spa([\"asdf\", \"qwer\"]);\n  expect(asyncResult.success).toEqual(false);\n  if (!asyncResult.success) {\n    expect(asyncResult.error.issues[0].code).toEqual(z.ZodIssueCode.invalid_intersection_types);\n  }\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/intersection.test.ts",
        "start": 1,
        "end": 110,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 110,
          "column": 2,
          "position": 1178
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/intersection.test.ts",
        "start": 1,
        "end": 110,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 110,
          "column": 2,
          "position": 1178
        }
      }
    },
    {
      "format": "typescript",
      "lines": 37,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\ntest(\"instanceof\", async () => {\n  class Test {}\n  class Subtest extends Test {}\n  abstract class AbstractBar {\n    constructor(public val: string) {}\n  }\n  class Bar extends AbstractBar {}\n\n  const TestSchema = z.instanceof(Test);\n  const SubtestSchema = z.instanceof(Subtest);\n  const AbstractSchema = z.instanceof(AbstractBar);\n  const BarSchema = z.instanceof(Bar);\n\n  TestSchema.parse(new Test());\n  TestSchema.parse(new Subtest());\n  SubtestSchema.parse(new Subtest());\n  AbstractSchema.parse(new Bar(\"asdf\"));\n  const bar = BarSchema.parse(new Bar(\"asdf\"));\n  expect(bar.val).toEqual(\"asdf\");\n\n  await expect(() => SubtestSchema.parse(new Test())).toThrow(/Input not instance of Subtest/);\n  await expect(() => TestSchema.parse(12)).toThrow(/Input not instance of Test/);\n\n  util.assertEqual<Test, z.infer<typeof TestSchema>>(true);\n});\n\ntest(\"instanceof fatal\", () => {\n  const schema = z.instanceof(Date).refine((d) => d.toString());\n  const res = schema.safeParse(null);\n  expect(res.success).toBe(false);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/instanceof.test.ts",
        "start": 1,
        "end": 37,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 37,
          "column": 2,
          "position": 420
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/instanceof.test.ts",
        "start": 1,
        "end": 34,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 34,
          "column": 2,
          "position": 406
        }
      }
    },
    {
      "format": "typescript",
      "lines": 48,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\ntest(\"generics\", () => {\n  async function stripOuter<TData extends z.ZodTypeAny>(schema: TData, data: unknown) {\n    return z\n      .object({\n        nested: schema, // as z.ZodTypeAny,\n      })\n      .transform((data) => {\n        return data.nested!;\n      })\n      .parse({ nested: data });\n  }\n\n  const result = stripOuter(z.object({ a: z.string() }), { a: \"asdf\" });\n  util.assertEqual<typeof result, Promise<{ a: string }>>(true);\n});\n\n// test(\"assignability\", () => {\n//   const createSchemaAndParse = <K extends string, VS extends z.ZodString>(\n//     key: K,\n//     valueSchema: VS,\n//     data: unknown\n//   ) => {\n//     const schema = z.object({\n//       [key]: valueSchema,\n//     } as { [k in K]: VS });\n//     return { [key]: valueSchema };\n//     const parsed = schema.parse(data);\n//     return parsed;\n//     // const inferred: z.infer<z.ZodObject<{ [k in K]: VS }>> = parsed;\n//     // return inferred;\n//   };\n//   const parsed = createSchemaAndParse(\"foo\", z.string(), { foo: \"\" });\n//   util.assertEqual<typeof parsed, { foo: string }>(true);\n// });\n\ntest(\"nested no undefined\", () => {\n  const inner = z.string().or(z.array(z.string()));\n  const outer = z.object({ inner });\n  type outerSchema = z.infer<typeof outer>;\n  z.util.assertEqual<outerSchema, { inner: string | string[] }>(true);\n  expect(outer.safeParse({ inner: undefined }).success).toEqual(false);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/generics.test.ts",
        "start": 1,
        "end": 48,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 48,
          "column": 2,
          "position": 397
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/generics.test.ts",
        "start": 1,
        "end": 48,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 48,
          "column": 2,
          "position": 397
        }
      }
    },
    {
      "format": "typescript",
      "lines": 257,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\nconst args1 = z.tuple([z.string()]);\nconst returns1 = z.number();\nconst func1 = z.function(args1, returns1);\n\ntest(\"function parsing\", () => {\n  const parsed = func1.parse((arg: any) => arg.length);\n  parsed(\"asdf\");\n});\n\ntest(\"parsed function fail 1\", () => {\n  const parsed = func1.parse((x: string) => x);\n  expect(() => parsed(\"asdf\")).toThrow();\n});\n\ntest(\"parsed function fail 2\", () => {\n  const parsed = func1.parse((x: string) => x);\n  expect(() => parsed(13 as any)).toThrow();\n});\n\ntest(\"function inference 1\", () => {\n  type func1 = z.TypeOf<typeof func1>;\n  util.assertEqual<func1, (k: string) => number>(true);\n});\n\ntest(\"method parsing\", () => {\n  const methodObject = z.object({\n    property: z.number(),\n    method: z.function().args(z.string()).returns(z.number()),\n  });\n  const methodInstance = {\n    property: 3,\n    method: function (s: string) {\n      return s.length + this.property;\n    },\n  };\n  const parsed = methodObject.parse(methodInstance);\n  expect(parsed.method(\"length=8\")).toBe(11); // 8 length + 3 property\n});\n\ntest(\"async method parsing\", async () => {\n  const methodObject = z.object({\n    property: z.number(),\n    method: z.function().args(z.string()).returns(z.promise(z.number())),\n  });\n  const methodInstance = {\n    property: 3,\n    method: async function (s: string) {\n      return s.length + this.property;\n    },\n  };\n  const parsed = methodObject.parse(methodInstance);\n  expect(await parsed.method(\"length=8\")).toBe(11); // 8 length + 3 property\n});\n\ntest(\"args method\", () => {\n  const t1 = z.function();\n  type t1 = z.infer<typeof t1>;\n  util.assertEqual<t1, (...args_1: unknown[]) => unknown>(true);\n\n  const t2 = t1.args(z.string());\n  type t2 = z.infer<typeof t2>;\n  util.assertEqual<t2, (arg: string, ...args_1: unknown[]) => unknown>(true);\n\n  const t3 = t2.returns(z.boolean());\n  type t3 = z.infer<typeof t3>;\n  util.assertEqual<t3, (arg: string, ...args_1: unknown[]) => boolean>(true);\n});\n\nconst args2 = z.tuple([\n  z.object({\n    f1: z.number(),\n    f2: z.string().nullable(),\n    f3: z.array(z.boolean().optional()).optional(),\n  }),\n]);\nconst returns2 = z.union([z.string(), z.number()]);\n\nconst func2 = z.function(args2, returns2);\n\ntest(\"function inference 2\", () => {\n  type func2 = z.TypeOf<typeof func2>;\n  util.assertEqual<\n    func2,\n    (arg: {\n      f1: number;\n      f2: string | null;\n      f3?: (boolean | undefined)[] | undefined;\n    }) => string | number\n  >(true);\n});\n\ntest(\"valid function run\", () => {\n  const validFunc2Instance = func2.validate((_x) => {\n    return \"adf\" as any;\n  });\n\n  const checker = () => {\n    validFunc2Instance({\n      f1: 21,\n      f2: \"asdf\",\n      f3: [true, false],\n    });\n  };\n\n  checker();\n});\n\ntest(\"input validation error\", () => {\n  const invalidFuncInstance = func2.validate((_x) => {\n    return \"adf\" as any;\n  });\n\n  const checker = () => {\n    invalidFuncInstance(\"Invalid_input\" as any);\n  };\n\n  expect(checker).toThrow();\n});\n\ntest(\"output validation error\", () => {\n  const invalidFuncInstance = func2.validate((_x) => {\n    return [\"this\", \"is\", \"not\", \"valid\", \"output\"] as any;\n  });\n\n  const checker = () => {\n    invalidFuncInstance({\n      f1: 21,\n      f2: \"asdf\",\n      f3: [true, false],\n    });\n  };\n\n  expect(checker).toThrow();\n});\n\nz.function(z.tuple([z.string()])).args()._def.args;\n\ntest(\"special function error codes\", () => {\n  const checker = z.function(z.tuple([z.string()]), z.boolean()).implement((arg) => {\n    return arg.length as any;\n  });\n  try {\n    checker(\"12\" as any);\n  } catch (err) {\n    const zerr = err as z.ZodError;\n    const first = zerr.issues[0];\n    if (first.code !== z.ZodIssueCode.invalid_return_type) throw new Error();\n\n    expect(first.returnTypeError).toBeInstanceOf(z.ZodError);\n  }\n\n  try {\n    checker(12 as any);\n  } catch (err) {\n    const zerr = err as z.ZodError;\n    const first = zerr.issues[0];\n    if (first.code !== z.ZodIssueCode.invalid_arguments) throw new Error();\n    expect(first.argumentsError).toBeInstanceOf(z.ZodError);\n  }\n});\n\ntest(\"function with async refinements\", async () => {\n  const func = z\n    .function()\n    .args(z.string().refine(async (val) => val.length > 10))\n    .returns(z.promise(z.number().refine(async (val) => val > 10)))\n    .implement(async (val) => {\n      return val.length;\n    });\n  const results = [];\n  try {\n    await func(\"asdfasdf\");\n    results.push(\"success\");\n  } catch (_err) {\n    results.push(\"fail\");\n  }\n  try {\n    await func(\"asdflkjasdflkjsf\");\n    results.push(\"success\");\n  } catch (_err) {\n    results.push(\"fail\");\n  }\n\n  expect(results).toEqual([\"fail\", \"success\"]);\n});\n\ntest(\"non async function with async refinements should fail\", async () => {\n  const func = z\n    .function()\n    .args(z.string().refine(async (val) => val.length > 10))\n    .returns(z.number().refine(async (val) => val > 10))\n    .implement((val) => {\n      return val.length;\n    });\n\n  const results = [];\n  try {\n    await func(\"asdasdfasdffasdf\");\n    results.push(\"success\");\n  } catch (_err) {\n    results.push(\"fail\");\n  }\n\n  expect(results).toEqual([\"fail\"]);\n});\n\ntest(\"allow extra parameters\", () => {\n  const maxLength5 = z\n    .function()\n    .args(z.string())\n    .returns(z.boolean())\n    .implement((str, _arg, _qewr) => {\n      return str.length <= 5;\n    });\n\n  const filteredList = [\"apple\", \"orange\", \"pear\", \"banana\", \"strawberry\"].filter(maxLength5);\n  expect(filteredList.length).toEqual(2);\n});\n\ntest(\"params and returnType getters\", () => {\n  const func = z.function().args(z.string()).returns(z.string());\n\n  func.parameters().items[0].parse(\"asdf\");\n  func.returnType().parse(\"asdf\");\n});\n\ntest(\"inference with transforms\", () => {\n  const funcSchema = z\n    .function()\n    .args(z.string().transform((val) => val.length))\n    .returns(z.object({ val: z.number() }));\n  const myFunc = funcSchema.implement((val) => {\n    return { val, extra: \"stuff\" };\n  });\n  myFunc(\"asdf\");\n\n  util.assertEqual<typeof myFunc, (arg: string, ...args_1: unknown[]) => { val: number; extra: string }>(true);\n});\n\ntest(\"fallback to OuterTypeOfFunction\", () => {\n  const funcSchema = z\n    .function()\n    .args(z.string().transform((val) => val.length))\n    .returns(z.object({ arg: z.number() }).transform((val) => val.arg));\n\n  const myFunc = funcSchema.implement((val) => {\n    return { arg: val, arg2: false };\n  });\n\n  util.assertEqual<typeof myFunc, (arg: string, ...args_1: unknown[]) => number>(true);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/function.test.ts",
        "start": 1,
        "end": 257,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 257,
          "column": 2,
          "position": 2756
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/function.test.ts",
        "start": 1,
        "end": 257,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 257,
          "column": 2,
          "position": 2756
        }
      }
    },
    {
      "format": "typescript",
      "lines": 21,
      "fragment": "// @ts-ignore TS6133\nimport { test } from \"vitest\";\n\nimport type { ZodFirstPartySchemaTypes, ZodFirstPartyTypeKind } from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\ntest(\"Identify missing [ZodFirstPartySchemaTypes]\", () => {\n  type ZodFirstPartySchemaForType<T extends ZodFirstPartyTypeKind> = ZodFirstPartySchemaTypes extends infer Schema\n    ? Schema extends { _def: { typeName: T } }\n      ? Schema\n      : never\n    : never;\n  type ZodMappedTypes = {\n    [key in ZodFirstPartyTypeKind]: ZodFirstPartySchemaForType<key>;\n  };\n  type ZodFirstPartySchemaTypesMissingFromUnion = keyof {\n    [key in keyof ZodMappedTypes as ZodMappedTypes[key] extends { _def: never } ? key : never]: unknown;\n  };\n\n  util.assertEqual<ZodFirstPartySchemaTypesMissingFromUnion, never>(true);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/firstpartyschematypes.test.ts",
        "start": 1,
        "end": 21,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 21,
          "column": 2,
          "position": 224
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/firstpartyschematypes.test.ts",
        "start": 1,
        "end": 21,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 21,
          "column": 2,
          "position": 224
        }
      }
    },
    {
      "format": "typescript",
      "lines": 87,
      "fragment": "// @ts-ignore TS6133\nimport { test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\ntest(\"first party switch\", () => {\n  const myType = z.string() as z.ZodFirstPartySchemaTypes;\n  const def = myType._def;\n\n  switch (def.typeName) {\n    case z.ZodFirstPartyTypeKind.ZodString:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodNumber:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodNaN:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodBigInt:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodBoolean:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodDate:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodUndefined:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodNull:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodAny:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodUnknown:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodNever:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodVoid:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodArray:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodObject:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodUnion:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodIntersection:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodTuple:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodRecord:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodMap:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodSet:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodFunction:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodLazy:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodLiteral:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodEnum:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodEffects:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodNativeEnum:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodOptional:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodNullable:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodDefault:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodCatch:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodPromise:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodBranded:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodPipeline:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodSymbol:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodReadonly:\n      break;\n    default:\n      util.assertNever(def);\n  }\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/firstparty.test.ts",
        "start": 1,
        "end": 87,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 87,
          "column": 2,
          "position": 621
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/firstparty.test.ts",
        "start": 1,
        "end": 87,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 87,
          "column": 2,
          "position": 621
        }
      }
    },
    {
      "format": "typescript",
      "lines": 551,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { ZodError, ZodIssueCode } from \"../ZodError.js\";\nimport { ZodParsedType } from \"../helpers/util.js\";\n\ntest(\"error creation\", () => {\n  const err1 = ZodError.create([]);\n  err1.addIssue({\n    code: ZodIssueCode.invalid_type,\n    expected: ZodParsedType.object,\n    received: ZodParsedType.string,\n    path: [],\n    message: \"\",\n    fatal: true,\n  });\n  err1.isEmpty;\n\n  const err2 = ZodError.create(err1.issues);\n  const err3 = new ZodError([]);\n  err3.addIssues(err1.issues);\n  err3.addIssue(err1.issues[0]);\n  err1.message;\n  err2.message;\n  err3.message;\n});\n\nconst errorMap: z.ZodErrorMap = (error, ctx) => {\n  if (error.code === ZodIssueCode.invalid_type) {\n    if (error.expected === \"string\") {\n      return { message: \"bad type!\" };\n    }\n  }\n  if (error.code === ZodIssueCode.custom) {\n    return { message: `less-than-${error.params?.minimum}` };\n  }\n  return { message: ctx.defaultError };\n};\n\ntest(\"type error with custom error map\", () => {\n  try {\n    z.string().parse(234, { errorMap });\n  } catch (err) {\n    const zerr: z.ZodError = err as any;\n\n    expect(zerr.issues[0].code).toEqual(z.ZodIssueCode.invalid_type);\n    expect(zerr.issues[0].message).toEqual(`bad type!`);\n  }\n});\n\ntest(\"refinement fail with params\", () => {\n  try {\n    z.number()\n      .refine((val) => val >= 3, {\n        params: { minimum: 3 },\n      })\n      .parse(2, { errorMap });\n  } catch (err) {\n    const zerr: z.ZodError = err as any;\n    expect(zerr.issues[0].code).toEqual(z.ZodIssueCode.custom);\n    expect(zerr.issues[0].message).toEqual(`less-than-3`);\n  }\n});\n\ntest(\"custom error with custom errormap\", () => {\n  try {\n    z.string()\n      .refine((val) => val.length > 12, {\n        params: { minimum: 13 },\n        message: \"override\",\n      })\n      .parse(\"asdf\", { errorMap });\n  } catch (err) {\n    const zerr: z.ZodError = err as any;\n    expect(zerr.issues[0].message).toEqual(\"override\");\n  }\n});\n\ntest(\"default error message\", () => {\n  try {\n    z.number()\n      .refine((x) => x > 3)\n      .parse(2);\n  } catch (err) {\n    const zerr: z.ZodError = err as any;\n    expect(zerr.issues.length).toEqual(1);\n    expect(zerr.issues[0].message).toEqual(\"Invalid input\");\n  }\n});\n\ntest(\"override error in refine\", () => {\n  try {\n    z.number()\n      .refine((x) => x > 3, \"override\")\n      .parse(2);\n  } catch (err) {\n    const zerr: z.ZodError = err as any;\n    expect(zerr.issues.length).toEqual(1);\n    expect(zerr.issues[0].message).toEqual(\"override\");\n  }\n});\n\ntest(\"override error in refinement\", () => {\n  try {\n    z.number()\n      .refine((x) => x > 3, {\n        message: \"override\",\n      })\n      .parse(2);\n  } catch (err) {\n    const zerr: z.ZodError = err as any;\n    expect(zerr.issues.length).toEqual(1);\n    expect(zerr.issues[0].message).toEqual(\"override\");\n  }\n});\n\ntest(\"array minimum\", () => {\n  try {\n    z.array(z.string()).min(3, \"tooshort\").parse([\"asdf\", \"qwer\"]);\n  } catch (err) {\n    const zerr: ZodError = err as any;\n    expect(zerr.issues[0].code).toEqual(ZodIssueCode.too_small);\n    expect(zerr.issues[0].message).toEqual(\"tooshort\");\n  }\n  try {\n    z.array(z.string()).min(3).parse([\"asdf\", \"qwer\"]);\n  } catch (err) {\n    const zerr: ZodError = err as any;\n    expect(zerr.issues[0].code).toEqual(ZodIssueCode.too_small);\n    expect(zerr.issues[0].message).toEqual(`Array must contain at least 3 element(s)`);\n  }\n});\n\n// implement test for semi-smart union logic that checks for type error on either left or right\n// test(\"union smart errors\", () => {\n//   // expect.assertions(2);\n\n//   const p1 = z\n//     .union([z.string(), z.number().refine((x) => x > 0)])\n//     .safeParse(-3.2);\n\n//   if (p1.success === true) throw new Error();\n//   expect(p1.success).toBe(false);\n//   expect(p1.error.issues[0].code).toEqual(ZodIssueCode.custom);\n\n//   const p2 = z.union([z.string(), z.number()]).safeParse(false);\n//   // .catch(err => expect(err.issues[0].code).toEqual(ZodIssueCode.invalid_union));\n//   if (p2.success === true) throw new Error();\n//   expect(p2.success).toBe(false);\n//   expect(p2.error.issues[0].code).toEqual(ZodIssueCode.invalid_union);\n// });\n\ntest(\"custom path in custom error map\", () => {\n  const schema = z.object({\n    items: z.array(z.string()).refine((data) => data.length > 3, {\n      path: [\"items-too-few\"],\n    }),\n  });\n\n  const errorMap: z.ZodErrorMap = (error) => {\n    expect(error.path.length).toBe(2);\n    return { message: \"doesnt matter\" };\n  };\n  const result = schema.safeParse({ items: [\"first\"] }, { errorMap });\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues[0].path).toEqual([\"items\", \"items-too-few\"]);\n  }\n});\n\ntest(\"error metadata from value\", () => {\n  const dynamicRefine = z.string().refine(\n    (val) => val === val.toUpperCase(),\n    (val) => ({ params: { val } })\n  );\n\n  const result = dynamicRefine.safeParse(\"asdf\");\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    const sub = result.error.issues[0];\n    expect(result.error.issues[0].code).toEqual(\"custom\");\n    if (sub.code === \"custom\") {\n      expect(sub.params!.val).toEqual(\"asdf\");\n    }\n  }\n});\n\n// test(\"don't call refine after validation failed\", () => {\n//   const asdf = z\n//     .union([\n//       z.number(),\n//       z.string().transform(z.number(), (val) => {\n//         return parseFloat(val);\n//       }),\n//     ])\n//     .refine((v) => v >= 1);\n\n//   expect(() => asdf.safeParse(\"foo\")).not.toThrow();\n// });\n\ntest(\"root level formatting\", () => {\n  const schema = z.string().email();\n  const result = schema.safeParse(\"asdfsdf\");\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.format()._errors).toEqual([\"Invalid email\"]);\n  }\n});\n\ntest(\"custom path\", () => {\n  const schema = z\n    .object({\n      password: z.string(),\n      confirm: z.string(),\n    })\n    .refine((val) => val.confirm === val.password, { path: [\"confirm\"] });\n\n  const result = schema.safeParse({\n    password: \"peanuts\",\n    confirm: \"qeanuts\",\n  });\n\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    // nested errors\n    const error = result.error.format();\n    expect(error._errors).toEqual([]);\n    expect(error.password?._errors).toEqual(undefined);\n    expect(error.confirm?._errors).toEqual([\"Invalid input\"]);\n  }\n});\n\ntest(\"custom path\", () => {\n  const schema = z\n    .object({\n      password: z.string().min(6),\n      confirm: z.string().min(6),\n    })\n    .refine((val) => val.confirm === val.password);\n\n  const result = schema.safeParse({\n    password: \"qwer\",\n    confirm: \"asdf\",\n  });\n\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues.length).toEqual(3);\n  }\n});\n\nconst schema = z.object({\n  inner: z.object({\n    name: z\n      .string()\n      .refine((val) => val.length > 5)\n      .array()\n      .refine((val) => val.length <= 1),\n  }),\n});\n\ntest(\"no abort early on refinements\", () => {\n  const invalidItem = {\n    inner: { name: [\"aasd\", \"asdfasdfasfd\"] },\n  };\n\n  const result1 = schema.safeParse(invalidItem);\n  expect(result1.success).toEqual(false);\n  if (!result1.success) {\n    expect(result1.error.issues.length).toEqual(2);\n  }\n});\ntest(\"formatting\", () => {\n  const invalidItem = {\n    inner: { name: [\"aasd\", \"asdfasdfasfd\"] },\n  };\n  const invalidArray = {\n    inner: { name: [\"asdfasdf\", \"asdfasdfasfd\"] },\n  };\n  const result1 = schema.safeParse(invalidItem);\n  const result2 = schema.safeParse(invalidArray);\n\n  expect(result1.success).toEqual(false);\n  expect(result2.success).toEqual(false);\n  if (!result1.success) {\n    const error = result1.error.format();\n\n    expect(error._errors).toEqual([]);\n    expect(error.inner?._errors).toEqual([]);\n    // expect(error.inner?.name?._errors).toEqual([\"Invalid input\"]);\n    // expect(error.inner?.name?.[0]._errors).toEqual([\"Invalid input\"]);\n    expect(error.inner?.name?.[1]).toEqual(undefined);\n  }\n  if (!result2.success) {\n    type FormattedError = z.inferFormattedError<typeof schema>;\n    const error: FormattedError = result2.error.format();\n    expect(error._errors).toEqual([]);\n    expect(error.inner?._errors).toEqual([]);\n    expect(error.inner?.name?._errors).toEqual([\"Invalid input\"]);\n    expect(error.inner?.name?.[0]).toEqual(undefined);\n    expect(error.inner?.name?.[1]).toEqual(undefined);\n    expect(error.inner?.name?.[2]).toEqual(undefined);\n  }\n\n  // test custom mapper\n  if (!result2.success) {\n    type FormattedError = z.inferFormattedError<typeof schema, number>;\n    const error: FormattedError = result2.error.format(() => 5);\n    expect(error._errors).toEqual([]);\n    expect(error.inner?._errors).toEqual([]);\n    expect(error.inner?.name?._errors).toEqual([5]);\n  }\n});\n\ntest(\"formatting with nullable and optional fields\", () => {\n  const nameSchema = z.string().refine((val) => val.length > 5);\n  const schema = z.object({\n    nullableObject: z.object({ name: nameSchema }).nullable(),\n    nullableArray: z.array(nameSchema).nullable(),\n    nullableTuple: z.tuple([nameSchema, nameSchema, z.number()]).nullable(),\n    optionalObject: z.object({ name: nameSchema }).optional(),\n    optionalArray: z.array(nameSchema).optional(),\n    optionalTuple: z.tuple([nameSchema, nameSchema, z.number()]).optional(),\n  });\n  const invalidItem = {\n    nullableObject: { name: \"abcd\" },\n    nullableArray: [\"abcd\"],\n    nullableTuple: [\"abcd\", \"abcd\", 1],\n    optionalObject: { name: \"abcd\" },\n    optionalArray: [\"abcd\"],\n    optionalTuple: [\"abcd\", \"abcd\", 1],\n  };\n  const result = schema.safeParse(invalidItem);\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    type FormattedError = z.inferFormattedError<typeof schema>;\n    const error: FormattedError = result.error.format();\n    expect(error._errors).toEqual([]);\n    expect(error.nullableObject?._errors).toEqual([]);\n    expect(error.nullableObject?.name?._errors).toEqual([\"Invalid input\"]);\n    expect(error.nullableArray?._errors).toEqual([]);\n    expect(error.nullableArray?.[0]?._errors).toEqual([\"Invalid input\"]);\n    expect(error.nullableTuple?._errors).toEqual([]);\n    expect(error.nullableTuple?.[0]?._errors).toEqual([\"Invalid input\"]);\n    expect(error.nullableTuple?.[1]?._errors).toEqual([\"Invalid input\"]);\n    expect(error.optionalObject?._errors).toEqual([]);\n    expect(error.optionalObject?.name?._errors).toEqual([\"Invalid input\"]);\n    expect(error.optionalArray?._errors).toEqual([]);\n    expect(error.optionalArray?.[0]?._errors).toEqual([\"Invalid input\"]);\n    expect(error.optionalTuple?._errors).toEqual([]);\n    expect(error.optionalTuple?.[0]?._errors).toEqual([\"Invalid input\"]);\n    expect(error.optionalTuple?.[1]?._errors).toEqual([\"Invalid input\"]);\n  }\n});\n\nconst stringWithCustomError = z.string({\n  errorMap: (issue, ctx) => ({\n    message: issue.code === \"invalid_type\" ? (ctx.data ? \"Invalid name\" : \"Name is required\") : ctx.defaultError,\n  }),\n});\n\ntest(\"schema-bound error map\", () => {\n  const result = stringWithCustomError.safeParse(1234);\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues[0].message).toEqual(\"Invalid name\");\n  }\n\n  const result2 = stringWithCustomError.safeParse(undefined);\n  expect(result2.success).toEqual(false);\n  if (!result2.success) {\n    expect(result2.error.issues[0].message).toEqual(\"Name is required\");\n  }\n\n  // support contextual override\n  const result3 = stringWithCustomError.safeParse(undefined, {\n    errorMap: () => ({ message: \"OVERRIDE\" }),\n  });\n  expect(result3.success).toEqual(false);\n  if (!result3.success) {\n    expect(result3.error.issues[0].message).toEqual(\"OVERRIDE\");\n  }\n});\n\ntest(\"overrideErrorMap\", () => {\n  // support overrideErrorMap\n  z.setErrorMap(() => ({ message: \"OVERRIDE\" }));\n  const result4 = stringWithCustomError.min(10).safeParse(\"tooshort\");\n  expect(result4.success).toEqual(false);\n  if (!result4.success) {\n    expect(result4.error.issues[0].message).toEqual(\"OVERRIDE\");\n  }\n  z.setErrorMap(z.defaultErrorMap);\n});\n\ntest(\"invalid and required\", () => {\n  const str = z.string({\n    invalid_type_error: \"Invalid name\",\n    required_error: \"Name is required\",\n  });\n  const result1 = str.safeParse(1234);\n  expect(result1.success).toEqual(false);\n  if (!result1.success) {\n    expect(result1.error.issues[0].message).toEqual(\"Invalid name\");\n  }\n  const result2 = str.safeParse(undefined);\n  expect(result2.success).toEqual(false);\n  if (!result2.success) {\n    expect(result2.error.issues[0].message).toEqual(\"Name is required\");\n  }\n});\n\ntest(\"Fallback to default required error\", () => {\n  const str = z.string({\n    invalid_type_error: \"Invalid name\",\n    // required_error: \"Name is required\",\n  });\n\n  const result2 = str.safeParse(undefined);\n  expect(result2.success).toEqual(false);\n  if (!result2.success) {\n    expect(result2.error.issues[0].message).toEqual(\"Required\");\n  }\n});\n\ntest(\"invalid and required and errorMap\", () => {\n  expect(() => {\n    return z.string({\n      invalid_type_error: \"Invalid name\",\n      required_error: \"Name is required\",\n      errorMap: () => ({ message: \"OVERRIDE\" }),\n    });\n  }).toThrow();\n});\n\ntest(\"strict error message\", () => {\n  const errorMsg = \"Invalid object\";\n  const obj = z.object({ x: z.string() }).strict(errorMsg);\n  const result = obj.safeParse({ x: \"a\", y: \"b\" });\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues[0].message).toEqual(errorMsg);\n  }\n});\n\ntest(\"enum error message, invalid enum elementstring\", () => {\n  try {\n    z.enum([\"Tuna\", \"Trout\"]).parse(\"Salmon\");\n  } catch (err) {\n    const zerr: z.ZodError = err as any;\n    expect(zerr.issues.length).toEqual(1);\n    expect(zerr.issues[0].message).toEqual(\"Invalid enum value. Expected 'Tuna' | 'Trout', received 'Salmon'\");\n  }\n});\n\ntest(\"enum error message, invalid type\", () => {\n  try {\n    z.enum([\"Tuna\", \"Trout\"]).parse(12);\n  } catch (err) {\n    const zerr: z.ZodError = err as any;\n    expect(zerr.issues.length).toEqual(1);\n    expect(zerr.issues[0].message).toEqual(\"Expected 'Tuna' | 'Trout', received number\");\n  }\n});\n\ntest(\"nativeEnum default error message\", () => {\n  enum Fish {\n    Tuna = \"Tuna\",\n    Trout = \"Trout\",\n  }\n  try {\n    z.nativeEnum(Fish).parse(\"Salmon\");\n  } catch (err) {\n    const zerr: z.ZodError = err as any;\n    expect(zerr.issues.length).toEqual(1);\n    expect(zerr.issues[0].message).toEqual(\"Invalid enum value. Expected 'Tuna' | 'Trout', received 'Salmon'\");\n  }\n});\n\ntest(\"literal default error message\", () => {\n  try {\n    z.literal(\"Tuna\").parse(\"Trout\");\n  } catch (err) {\n    const zerr: z.ZodError = err as any;\n    expect(zerr.issues.length).toEqual(1);\n    expect(zerr.issues[0].message).toEqual(`Invalid literal value, expected \"Tuna\"`);\n  }\n});\n\ntest(\"literal bigint default error message\", () => {\n  try {\n    z.literal(BigInt(12)).parse(BigInt(13));\n  } catch (err) {\n    const zerr: z.ZodError = err as any;\n    expect(zerr.issues.length).toEqual(1);\n    expect(zerr.issues[0].message).toEqual(`Invalid literal value, expected \"12\"`);\n  }\n});\n\ntest(\"enum with message returns the custom error message\", () => {\n  const schema = z.enum([\"apple\", \"banana\"], {\n    message: \"the value provided is invalid\",\n  });\n\n  const result1 = schema.safeParse(\"berries\");\n  expect(result1.success).toEqual(false);\n  if (!result1.success) {\n    expect(result1.error.issues[0].message).toEqual(\"the value provided is invalid\");\n  }\n\n  const result2 = schema.safeParse(undefined);\n  expect(result2.success).toEqual(false);\n  if (!result2.success) {\n    expect(result2.error.issues[0].message).toEqual(\"the value provided is invalid\");\n  }\n\n  const result3 = schema.safeParse(\"banana\");\n  expect(result3.success).toEqual(true);\n\n  const result4 = schema.safeParse(null);\n  expect(result4.success).toEqual(false);\n  if (!result4.success) {\n    expect(result4.error.issues[0].message).toEqual(\"the value provided is invalid\");\n  }\n});\n\ntest(\"when the message is falsy, it is used as is provided\", () => {\n  const schema = z.string().max(1, { message: \"\" });\n  const result = schema.safeParse(\"asdf\");\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues[0].message).toEqual(\"\");\n  }\n});\n\n// test(\"dont short circuit on continuable errors\", () => {\n//   const user = z\n//     .object({\n//       password: z.string().min(6),\n//       confirm: z.string(),\n//     })\n//     .refine((data) => data.password === data.confirm, {\n//       message: \"Passwords don't match\",\n//       path: [\"confirm\"],\n//     });\n//   const result = user.safeParse({ password: \"asdf\", confirm: \"qwer\" });\n//   if (!result.success) {\n//     expect(result.error.issues.length).toEqual(2);\n//   }\n// });",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/error.test.ts",
        "start": 1,
        "end": 551,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 551,
          "column": 7,
          "position": 5707
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/error.test.ts",
        "start": 1,
        "end": 551,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 551,
          "column": 7,
          "position": 5707
        }
      }
    },
    {
      "format": "typescript",
      "lines": 80,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\ntest(\"create enum\", () => {\n  const MyEnum = z.enum([\"Red\", \"Green\", \"Blue\"]);\n  expect(MyEnum.Values.Red).toEqual(\"Red\");\n  expect(MyEnum.Enum.Red).toEqual(\"Red\");\n  expect(MyEnum.enum.Red).toEqual(\"Red\");\n});\n\ntest(\"infer enum\", () => {\n  const MyEnum = z.enum([\"Red\", \"Green\", \"Blue\"]);\n  type MyEnum = z.infer<typeof MyEnum>;\n  util.assertEqual<MyEnum, \"Red\" | \"Green\" | \"Blue\">(true);\n});\n\ntest(\"get options\", () => {\n  expect(z.enum([\"tuna\", \"trout\"]).options).toEqual([\"tuna\", \"trout\"]);\n});\n\ntest(\"readonly enum\", () => {\n  const HTTP_SUCCESS = [\"200\", \"201\"] as const;\n  const arg = z.enum(HTTP_SUCCESS);\n  type arg = z.infer<typeof arg>;\n  util.assertEqual<arg, \"200\" | \"201\">(true);\n\n  arg.parse(\"201\");\n  expect(() => arg.parse(\"202\")).toThrow();\n});\n\ntest(\"error params\", () => {\n  const result = z.enum([\"test\"], { required_error: \"REQUIRED\" }).safeParse(undefined);\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues[0].message).toEqual(\"REQUIRED\");\n  }\n});\n\ntest(\"extract/exclude\", () => {\n  const foods = [\"Pasta\", \"Pizza\", \"Tacos\", \"Burgers\", \"Salad\"] as const;\n  const FoodEnum = z.enum(foods);\n  const ItalianEnum = FoodEnum.extract([\"Pasta\", \"Pizza\"]);\n  const UnhealthyEnum = FoodEnum.exclude([\"Salad\"]);\n  const EmptyFoodEnum = FoodEnum.exclude(foods);\n\n  util.assertEqual<z.infer<typeof ItalianEnum>, \"Pasta\" | \"Pizza\">(true);\n  util.assertEqual<z.infer<typeof UnhealthyEnum>, \"Pasta\" | \"Pizza\" | \"Tacos\" | \"Burgers\">(true);\n  // @ts-expect-error TS2344\n  util.assertEqual<typeof EmptyFoodEnum, z.ZodEnum<[]>>(true);\n  util.assertEqual<z.infer<typeof EmptyFoodEnum>, never>(true);\n});\n\ntest(\"error map in extract/exclude\", () => {\n  const foods = [\"Pasta\", \"Pizza\", \"Tacos\", \"Burgers\", \"Salad\"] as const;\n  const FoodEnum = z.enum(foods, {\n    errorMap: () => ({ message: \"This is not food!\" }),\n  });\n  const ItalianEnum = FoodEnum.extract([\"Pasta\", \"Pizza\"]);\n  const foodsError = FoodEnum.safeParse(\"Cucumbers\");\n  const italianError = ItalianEnum.safeParse(\"Tacos\");\n  if (!foodsError.success && !italianError.success) {\n    expect(foodsError.error.issues[0].message).toEqual(italianError.error.issues[0].message);\n  }\n\n  const UnhealthyEnum = FoodEnum.exclude([\"Salad\"], {\n    errorMap: () => ({ message: \"This is not healthy food!\" }),\n  });\n  const unhealthyError = UnhealthyEnum.safeParse(\"Salad\");\n  if (!unhealthyError.success) {\n    expect(unhealthyError.error.issues[0].message).toEqual(\"This is not healthy food!\");\n  }\n});\n\ntest(\"readonly in ZodEnumDef\", () => {\n  let _t!: z.ZodEnumDef<readonly [\"a\", \"b\"]>;\n  _t;\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/enum.test.ts",
        "start": 1,
        "end": 80,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 80,
          "column": 2,
          "position": 1022
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/enum.test.ts",
        "start": 1,
        "end": 80,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 80,
          "column": 2,
          "position": 1022
        }
      }
    },
    {
      "format": "typescript",
      "lines": 315,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\ntest(\"valid\", () => {\n  expect(\n    z\n      .discriminatedUnion(\"type\", [\n        z.object({ type: z.literal(\"a\"), a: z.string() }),\n        z.object({ type: z.literal(\"b\"), b: z.string() }),\n      ])\n      .parse({ type: \"a\", a: \"abc\" })\n  ).toEqual({ type: \"a\", a: \"abc\" });\n});\n\ntest(\"valid - discriminator value of various primitive types\", () => {\n  const schema = z.discriminatedUnion(\"type\", [\n    z.object({ type: z.literal(\"1\"), val: z.literal(1) }),\n    z.object({ type: z.literal(1), val: z.literal(2) }),\n    z.object({ type: z.literal(BigInt(1)), val: z.literal(3) }),\n    z.object({ type: z.literal(\"true\"), val: z.literal(4) }),\n    z.object({ type: z.literal(true), val: z.literal(5) }),\n    z.object({ type: z.literal(\"null\"), val: z.literal(6) }),\n    z.object({ type: z.literal(null), val: z.literal(7) }),\n    z.object({ type: z.literal(\"undefined\"), val: z.literal(8) }),\n    z.object({ type: z.literal(undefined), val: z.literal(9) }),\n    z.object({ type: z.literal(\"transform\"), val: z.literal(10) }),\n    z.object({ type: z.literal(\"refine\"), val: z.literal(11) }),\n    z.object({ type: z.literal(\"superRefine\"), val: z.literal(12) }),\n  ]);\n\n  expect(schema.parse({ type: \"1\", val: 1 })).toEqual({ type: \"1\", val: 1 });\n  expect(schema.parse({ type: 1, val: 2 })).toEqual({ type: 1, val: 2 });\n  expect(schema.parse({ type: BigInt(1), val: 3 })).toEqual({\n    type: BigInt(1),\n    val: 3,\n  });\n  expect(schema.parse({ type: \"true\", val: 4 })).toEqual({\n    type: \"true\",\n    val: 4,\n  });\n  expect(schema.parse({ type: true, val: 5 })).toEqual({\n    type: true,\n    val: 5,\n  });\n  expect(schema.parse({ type: \"null\", val: 6 })).toEqual({\n    type: \"null\",\n    val: 6,\n  });\n  expect(schema.parse({ type: null, val: 7 })).toEqual({\n    type: null,\n    val: 7,\n  });\n  expect(schema.parse({ type: \"undefined\", val: 8 })).toEqual({\n    type: \"undefined\",\n    val: 8,\n  });\n  expect(schema.parse({ type: undefined, val: 9 })).toEqual({\n    type: undefined,\n    val: 9,\n  });\n});\n\ntest(\"invalid - null\", () => {\n  try {\n    z.discriminatedUnion(\"type\", [\n      z.object({ type: z.literal(\"a\"), a: z.string() }),\n      z.object({ type: z.literal(\"b\"), b: z.string() }),\n    ]).parse(null);\n    throw new Error();\n  } catch (e: any) {\n    expect(JSON.parse(e.message)).toEqual([\n      {\n        code: z.ZodIssueCode.invalid_type,\n        expected: z.ZodParsedType.object,\n        message: \"Expected object, received null\",\n        received: z.ZodParsedType.null,\n        path: [],\n      },\n    ]);\n  }\n});\n\ntest(\"invalid discriminator value\", () => {\n  try {\n    z.discriminatedUnion(\"type\", [\n      z.object({ type: z.literal(\"a\"), a: z.string() }),\n      z.object({ type: z.literal(\"b\"), b: z.string() }),\n    ]).parse({ type: \"x\", a: \"abc\" });\n    throw new Error();\n  } catch (e: any) {\n    expect(JSON.parse(e.message)).toEqual([\n      {\n        code: z.ZodIssueCode.invalid_union_discriminator,\n        options: [\"a\", \"b\"],\n        message: \"Invalid discriminator value. Expected 'a' | 'b'\",\n        path: [\"type\"],\n      },\n    ]);\n  }\n});\n\ntest(\"valid discriminator value, invalid data\", () => {\n  try {\n    z.discriminatedUnion(\"type\", [\n      z.object({ type: z.literal(\"a\"), a: z.string() }),\n      z.object({ type: z.literal(\"b\"), b: z.string() }),\n    ]).parse({ type: \"a\", b: \"abc\" });\n    throw new Error();\n  } catch (e: any) {\n    expect(JSON.parse(e.message)).toEqual([\n      {\n        code: z.ZodIssueCode.invalid_type,\n        expected: z.ZodParsedType.string,\n        message: \"Required\",\n        path: [\"a\"],\n        received: z.ZodParsedType.undefined,\n      },\n    ]);\n  }\n});\n\ntest(\"wrong schema - missing discriminator\", () => {\n  try {\n    z.discriminatedUnion(\"type\", [\n      z.object({ type: z.literal(\"a\"), a: z.string() }),\n      z.object({ b: z.string() }) as any,\n    ]);\n    throw new Error();\n  } catch (e: any) {\n    expect(e.message.includes(\"could not be extracted\")).toBe(true);\n  }\n});\n\ntest(\"wrong schema - duplicate discriminator values\", () => {\n  try {\n    z.discriminatedUnion(\"type\", [\n      z.object({ type: z.literal(\"a\"), a: z.string() }),\n      z.object({ type: z.literal(\"a\"), b: z.string() }),\n    ]);\n    throw new Error();\n  } catch (e: any) {\n    expect(e.message.includes(\"has duplicate value\")).toEqual(true);\n  }\n});\n\ntest(\"async - valid\", async () => {\n  expect(\n    await z\n      .discriminatedUnion(\"type\", [\n        z.object({\n          type: z.literal(\"a\"),\n          a: z\n            .string()\n            .refine(async () => true)\n            .transform(async (val) => Number(val)),\n        }),\n        z.object({\n          type: z.literal(\"b\"),\n          b: z.string(),\n        }),\n      ])\n      .parseAsync({ type: \"a\", a: \"1\" })\n  ).toEqual({ type: \"a\", a: 1 });\n});\n\ntest(\"async - invalid\", async () => {\n  try {\n    await z\n      .discriminatedUnion(\"type\", [\n        z.object({\n          type: z.literal(\"a\"),\n          a: z\n            .string()\n            .refine(async () => true)\n            .transform(async (val) => val),\n        }),\n        z.object({\n          type: z.literal(\"b\"),\n          b: z.string(),\n        }),\n      ])\n      .parseAsync({ type: \"a\", a: 1 });\n    throw new Error();\n  } catch (e: any) {\n    expect(JSON.parse(e.message)).toEqual([\n      {\n        code: \"invalid_type\",\n        expected: \"string\",\n        received: \"number\",\n        path: [\"a\"],\n        message: \"Expected string, received number\",\n      },\n    ]);\n  }\n});\n\ntest(\"valid - literals with .default or .preprocess\", () => {\n  const schema = z.discriminatedUnion(\"type\", [\n    z.object({\n      type: z.literal(\"foo\").default(\"foo\"),\n      a: z.string(),\n    }),\n    z.object({\n      type: z.literal(\"custom\"),\n      method: z.string(),\n    }),\n    z.object({\n      type: z.preprocess((val) => String(val), z.literal(\"bar\")),\n      c: z.string(),\n    }),\n  ]);\n  expect(schema.parse({ type: \"foo\", a: \"foo\" })).toEqual({\n    type: \"foo\",\n    a: \"foo\",\n  });\n});\n\ntest(\"enum and nativeEnum\", () => {\n  enum MyEnum {\n    d = 0,\n    e = \"e\",\n  }\n\n  const schema = z.discriminatedUnion(\"key\", [\n    z.object({\n      key: z.literal(\"a\"),\n      // Add other properties specific to this option\n    }),\n    z.object({\n      key: z.enum([\"b\", \"c\"]),\n      // Add other properties specific to this option\n    }),\n    z.object({\n      key: z.nativeEnum(MyEnum),\n      // Add other properties specific to this option\n    }),\n  ]);\n\n  // type schema = z.infer<typeof schema>;\n\n  schema.parse({ key: \"a\" });\n  schema.parse({ key: \"b\" });\n  schema.parse({ key: \"c\" });\n  schema.parse({ key: MyEnum.d });\n  schema.parse({ key: MyEnum.e });\n  schema.parse({ key: \"e\" });\n});\n\ntest(\"branded\", () => {\n  const schema = z.discriminatedUnion(\"key\", [\n    z.object({\n      key: z.literal(\"a\"),\n      // Add other properties specific to this option\n    }),\n    z.object({\n      key: z.literal(\"b\").brand(\"asdfaf\"),\n      // Add other properties specific to this option\n    }),\n  ]);\n\n  // type schema = z.infer<typeof schema>;\n\n  schema.parse({ key: \"a\" });\n  schema.parse({ key: \"b\" });\n  expect(() => {\n    schema.parse({ key: \"c\" });\n  }).toThrow();\n});\n\ntest(\"optional and nullable\", () => {\n  const schema = z.discriminatedUnion(\"key\", [\n    z.object({\n      key: z.literal(\"a\").optional(),\n      a: z.literal(true),\n    }),\n    z.object({\n      key: z.literal(\"b\").nullable(),\n      b: z.literal(true),\n      // Add other properties specific to this option\n    }),\n  ]);\n\n  type schema = z.infer<typeof schema>;\n  z.util.assertEqual<schema, { key?: \"a\" | undefined; a: true } | { key: \"b\" | null; b: true }>(true);\n\n  schema.parse({ key: \"a\", a: true });\n  schema.parse({ key: undefined, a: true });\n  schema.parse({ key: \"b\", b: true });\n  schema.parse({ key: null, b: true });\n  expect(() => {\n    schema.parse({ key: null, a: true });\n  }).toThrow();\n  expect(() => {\n    schema.parse({ key: \"b\", a: true });\n  }).toThrow();\n\n  const value = schema.parse({ key: null, b: true });\n\n  if (!(\"key\" in value)) value.a;\n  if (value.key === undefined) value.a;\n  if (value.key === \"a\") value.a;\n  if (value.key === \"b\") value.b;\n  if (value.key === null) value.b;\n});\n\ntest(\"readonly array of options\", () => {\n  const options = [\n    z.object({ type: z.literal(\"x\"), val: z.literal(1) }),\n    z.object({ type: z.literal(\"y\"), val: z.literal(2) }),\n  ] as const;\n\n  expect(z.discriminatedUnion(\"type\", options).parse({ type: \"x\", val: 1 })).toEqual({ type: \"x\", val: 1 });\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/discriminated-unions.test.ts",
        "start": 1,
        "end": 315,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 315,
          "column": 2,
          "position": 3661
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/discriminated-unions.test.ts",
        "start": 1,
        "end": 315,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 315,
          "column": 2,
          "position": 3661
        }
      }
    },
    {
      "format": "typescript",
      "lines": 33,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\nconst description = \"a description\";\n\ntest(\"passing `description` to schema should add a description\", () => {\n  expect(z.string({ description }).description).toEqual(description);\n  expect(z.number({ description }).description).toEqual(description);\n  expect(z.boolean({ description }).description).toEqual(description);\n});\n\ntest(\"`.describe` should add a description\", () => {\n  expect(z.string().describe(description).description).toEqual(description);\n  expect(z.number().describe(description).description).toEqual(description);\n  expect(z.boolean().describe(description).description).toEqual(description);\n});\n\ntest(\"description should carry over to chained schemas\", () => {\n  const schema = z.string({ description });\n  expect(schema.description).toEqual(description);\n  expect(schema.optional().description).toEqual(description);\n  expect(schema.optional().nullable().default(\"default\").description).toEqual(description);\n});\n\ntest(\"description should not carry over to chained array schema\", () => {\n  const schema = z.string().describe(description);\n\n  expect(schema.description).toEqual(description);\n  expect(schema.array().description).toEqual(undefined);\n  expect(z.array(schema).description).toEqual(undefined);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/description.test.ts",
        "start": 1,
        "end": 33,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 33,
          "column": 2,
          "position": 395
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/description.test.ts",
        "start": 1,
        "end": 33,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 33,
          "column": 2,
          "position": 395
        }
      }
    },
    {
      "format": "typescript",
      "lines": 112,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport { z } from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\ntest(\"basic defaults\", () => {\n  expect(z.string().default(\"default\").parse(undefined)).toBe(\"default\");\n});\n\ntest(\"default with transform\", () => {\n  const stringWithDefault = z\n    .string()\n    .transform((val) => val.toUpperCase())\n    .default(\"default\");\n  expect(stringWithDefault.parse(undefined)).toBe(\"DEFAULT\");\n  expect(stringWithDefault).toBeInstanceOf(z.ZodDefault);\n  expect(stringWithDefault._def.innerType).toBeInstanceOf(z.ZodEffects);\n  expect(stringWithDefault._def.innerType._def.schema).toBeInstanceOf(z.ZodSchema);\n\n  type inp = z.input<typeof stringWithDefault>;\n  util.assertEqual<inp, string | undefined>(true);\n  type out = z.output<typeof stringWithDefault>;\n  util.assertEqual<out, string>(true);\n});\n\ntest(\"default on existing optional\", () => {\n  const stringWithDefault = z.string().optional().default(\"asdf\");\n  expect(stringWithDefault.parse(undefined)).toBe(\"asdf\");\n  expect(stringWithDefault).toBeInstanceOf(z.ZodDefault);\n  expect(stringWithDefault._def.innerType).toBeInstanceOf(z.ZodOptional);\n  expect(stringWithDefault._def.innerType._def.innerType).toBeInstanceOf(z.ZodString);\n\n  type inp = z.input<typeof stringWithDefault>;\n  util.assertEqual<inp, string | undefined>(true);\n  type out = z.output<typeof stringWithDefault>;\n  util.assertEqual<out, string>(true);\n});\n\ntest(\"optional on default\", () => {\n  const stringWithDefault = z.string().default(\"asdf\").optional();\n\n  type inp = z.input<typeof stringWithDefault>;\n  util.assertEqual<inp, string | undefined>(true);\n  type out = z.output<typeof stringWithDefault>;\n  util.assertEqual<out, string | undefined>(true);\n});\n\ntest(\"complex chain example\", () => {\n  const complex = z\n    .string()\n    .default(\"asdf\")\n    .transform((val) => val.toUpperCase())\n    .default(\"qwer\")\n    .removeDefault()\n    .optional()\n    .default(\"asdfasdf\");\n\n  expect(complex.parse(undefined)).toBe(\"ASDFASDF\");\n});\n\ntest(\"removeDefault\", () => {\n  const stringWithRemovedDefault = z.string().default(\"asdf\").removeDefault();\n\n  type out = z.output<typeof stringWithRemovedDefault>;\n  util.assertEqual<out, string>(true);\n});\n\ntest(\"nested\", () => {\n  const inner = z.string().default(\"asdf\");\n  const outer = z.object({ inner }).default({\n    inner: undefined,\n  });\n  type input = z.input<typeof outer>;\n  util.assertEqual<input, { inner?: string | undefined } | undefined>(true);\n  type out = z.output<typeof outer>;\n  util.assertEqual<out, { inner: string }>(true);\n  expect(outer.parse(undefined)).toEqual({ inner: \"asdf\" });\n  expect(outer.parse({})).toEqual({ inner: \"asdf\" });\n  expect(outer.parse({ inner: undefined })).toEqual({ inner: \"asdf\" });\n});\n\ntest(\"chained defaults\", () => {\n  const stringWithDefault = z.string().default(\"inner\").default(\"outer\");\n  const result = stringWithDefault.parse(undefined);\n  expect(result).toEqual(\"outer\");\n});\n\ntest(\"factory\", () => {\n  expect(z.ZodDefault.create(z.string(), { default: \"asdf\" }).parse(undefined)).toEqual(\"asdf\");\n});\n\ntest(\"native enum\", () => {\n  enum Fruits {\n    apple = \"apple\",\n    orange = \"orange\",\n  }\n\n  const schema = z.object({\n    fruit: z.nativeEnum(Fruits).default(Fruits.apple),\n  });\n\n  expect(schema.parse({})).toEqual({ fruit: Fruits.apple });\n});\n\ntest(\"enum\", () => {\n  const schema = z.object({\n    fruit: z.enum([\"apple\", \"orange\"]).default(\"apple\"),\n  });\n\n  expect(schema.parse({})).toEqual({ fruit: \"apple\" });\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/default.test.ts",
        "start": 1,
        "end": 112,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 112,
          "column": 2,
          "position": 1302
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/default.test.ts",
        "start": 1,
        "end": 112,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 112,
          "column": 2,
          "position": 1302
        }
      }
    },
    {
      "format": "typescript",
      "lines": 186,
      "fragment": "// @ts-ignore TS6133\nimport { test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\ntest(\"test\", () => {\n  z;\n});\n\n// const fish = z.object({\n//   name: z.string(),\n//   props: z.object({\n//     color: z.string(),\n//     numScales: z.number(),\n//   }),\n// });\n\n// const nonStrict = z\n//   .object({\n//     name: z.string(),\n//     color: z.string(),\n//   })\n//   .nonstrict();\n\n// test('object pick type', () => {\n//   const modNonStrictFish = nonStrict.omit({ name: true });\n//   modNonStrictFish.parse({ color: 'asdf' });\n\n//   const bad1 = () => fish.pick({ props: { unknown: true } } as any);\n//   const bad2 = () => fish.omit({ name: true, props: { unknown: true } } as any);\n\n//   expect(bad1).toThrow();\n//   expect(bad2).toThrow();\n// });\n\n// test('f1', () => {\n//   const f1 = fish.pick(true);\n//   f1.parse({ name: 'a', props: { color: 'b', numScales: 3 } });\n// });\n// test('f2', () => {\n//   const f2 = fish.pick({ props: true });\n//   f2.parse({ props: { color: 'asdf', numScales: 1 } });\n//   const badcheck2 = () => f2.parse({ name: 'a', props: { color: 'b', numScales: 3 } } as any);\n//   expect(badcheck2).toThrow();\n// });\n// test('f3', () => {\n//   const f3 = fish.pick({ props: { color: true } });\n//   f3.parse({ props: { color: 'b' } });\n//   const badcheck3 = () => f3.parse({ name: 'a', props: { color: 'b', numScales: 3 } } as any);\n//   expect(badcheck3).toThrow();\n// });\n// test('f4', () => {\n//   const badcheck4 = () => fish.pick({ props: { color: true, unknown: true } });\n//   expect(badcheck4).toThrow();\n// });\n// test('f6', () => {\n//   const f6 = fish.omit({ props: true });\n//   const badcheck6 = () => f6.parse({ name: 'a', props: { color: 'b', numScales: 3 } } as any);\n//   f6.parse({ name: 'adsf' });\n//   expect(badcheck6).toThrow();\n// });\n// test('f7', () => {\n//   const f7 = fish.omit({ props: { color: true } });\n//   f7.parse({ name: 'a', props: { numScales: 3 } });\n//   const badcheck7 = () => f7.parse({ name: 'a', props: { color: 'b', numScales: 3 } } as any);\n//   expect(badcheck7).toThrow();\n// });\n// test('f8', () => {\n//   const badcheck8 = () => fish.omit({ props: { color: true, unknown: true } });\n//   expect(badcheck8).toThrow();\n// });\n// test('f9', () => {\n//   const f9 = nonStrict.pick(true);\n//   f9.parse({ name: 'a', color: 'asdf' });\n// });\n// test('f10', () => {\n//   const f10 = nonStrict.pick({ name: true });\n//   f10.parse({ name: 'a' });\n//   const val = f10.parse({ name: 'a', color: 'b' });\n//   expect(val).toEqual({ name: 'a' });\n// });\n// test('f12', () => {\n//   const badfcheck12 = () => nonStrict.omit({ color: true, asdf: true });\n//   expect(badfcheck12).toThrow();\n// });\n\n// test('array masking', () => {\n//   const fishArray = z.array(fish);\n//   const modFishArray = fishArray.pick({\n//     name: true,\n//     props: {\n//       numScales: true,\n//     },\n//   });\n\n//   modFishArray.parse([{ name: 'fish', props: { numScales: 12 } }]);\n//   const bad1 = () => modFishArray.parse([{ name: 'fish', props: { numScales: 12, color: 'asdf' } }] as any);\n//   expect(bad1).toThrow();\n// });\n\n// test('array masking', () => {\n//   const fishArray = z.array(fish);\n//   const fail = () =>\n//     fishArray.pick({\n//       name: true,\n//       props: {\n//         whatever: true,\n//       },\n//     } as any);\n//   expect(fail).toThrow();\n// });\n\n// test('array masking', () => {\n//   const fishArray = z.array(fish);\n//   const fail = () =>\n//     fishArray.omit({\n//       whateve: true,\n//     } as any);\n//   expect(fail).toThrow();\n// });\n\n// test('array masking', () => {\n//   const fishArray = z.array(fish);\n//   const modFishList = fishArray.omit({\n//     name: true,\n//     props: {\n//       color: true,\n//     },\n//   });\n\n//   modFishList.parse([{ props: { numScales: 12 } }]);\n//   const fail = () => modFishList.parse([{ name: 'hello', props: { numScales: 12 } }] as any);\n//   expect(fail).toThrow();\n// });\n\n// test('primitive array masking', () => {\n//   const fishArray = z.array(z.number());\n//   const fail = () => fishArray.pick({} as any);\n//   expect(fail).toThrow();\n// });\n\n// test('other array masking', () => {\n//   const fishArray = z.array(z.array(z.number()));\n//   const fail = () => fishArray.pick({} as any);\n//   expect(fail).toThrow();\n// });\n\n// test('invalid mask #1', () => {\n//   const fail = () => fish.pick(1 as any);\n//   expect(fail).toThrow();\n// });\n\n// test('invalid mask #2', () => {\n//   const fail = () => fish.pick([] as any);\n//   expect(fail).toThrow();\n// });\n\n// test('invalid mask #3', () => {\n//   const fail = () => fish.pick(false as any);\n//   expect(fail).toThrow();\n// });\n\n// test('invalid mask #4', () => {\n//   const fail = () => fish.pick('asdf' as any);\n//   expect(fail).toThrow();\n// });\n\n// test('invalid mask #5', () => {\n//   const fail = () => fish.omit(1 as any);\n//   expect(fail).toThrow();\n// });\n\n// test('invalid mask #6', () => {\n//   const fail = () => fish.omit([] as any);\n//   expect(fail).toThrow();\n// });\n\n// test('invalid mask #7', () => {\n//   const fail = () => fish.omit(false as any);\n//   expect(fail).toThrow();\n// });\n\n// test('invalid mask #8', () => {\n//   const fail = () => fish.omit('asdf' as any);\n//   expect(fail).toThrow();\n// });",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/deepmasking.test.ts",
        "start": 1,
        "end": 186,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 186,
          "column": 7,
          "position": 382
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/deepmasking.test.ts",
        "start": 1,
        "end": 186,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 186,
          "column": 7,
          "position": 382
        }
      }
    },
    {
      "format": "typescript",
      "lines": 32,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\nconst beforeBenchmarkDate = new Date(2022, 10, 4);\nconst benchmarkDate = new Date(2022, 10, 5);\nconst afterBenchmarkDate = new Date(2022, 10, 6);\n\nconst minCheck = z.date().min(benchmarkDate);\nconst maxCheck = z.date().max(benchmarkDate);\n\ntest(\"passing validations\", () => {\n  minCheck.parse(benchmarkDate);\n  minCheck.parse(afterBenchmarkDate);\n\n  maxCheck.parse(benchmarkDate);\n  maxCheck.parse(beforeBenchmarkDate);\n});\n\ntest(\"failing validations\", () => {\n  expect(() => minCheck.parse(beforeBenchmarkDate)).toThrow();\n  expect(() => maxCheck.parse(afterBenchmarkDate)).toThrow();\n});\n\ntest(\"min max getters\", () => {\n  expect(minCheck.minDate).toEqual(benchmarkDate);\n  expect(minCheck.min(afterBenchmarkDate).minDate).toEqual(afterBenchmarkDate);\n\n  expect(maxCheck.maxDate).toEqual(benchmarkDate);\n  expect(maxCheck.max(beforeBenchmarkDate).maxDate).toEqual(beforeBenchmarkDate);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/date.test.ts",
        "start": 1,
        "end": 32,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 32,
          "column": 2,
          "position": 325
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/date.test.ts",
        "start": 1,
        "end": 31,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 31,
          "column": 2,
          "position": 323
        }
      }
    },
    {
      "format": "typescript",
      "lines": 31,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\ntest(\"passing validations\", () => {\n  const example1 = z.custom<number>((x) => typeof x === \"number\");\n  example1.parse(1234);\n  expect(() => example1.parse({})).toThrow();\n});\n\ntest(\"string params\", () => {\n  const example1 = z.custom<number>((x) => typeof x !== \"number\", \"customerr\");\n  const result = example1.safeParse(1234);\n  expect(result.success).toEqual(false);\n  // @ts-ignore\n  expect(JSON.stringify(result.error).includes(\"customerr\")).toEqual(true);\n});\n\ntest(\"async validations\", async () => {\n  const example1 = z.custom<number>(async (x) => {\n    return typeof x === \"number\";\n  });\n  const r1 = await example1.safeParseAsync(1234);\n  expect(r1.success).toEqual(true);\n  expect(r1.data).toEqual(1234);\n\n  const r2 = await example1.safeParseAsync(\"asdf\");\n  expect(r2.success).toEqual(false);\n  expect(r2.error!.issues.length).toEqual(1);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/custom.test.ts",
        "start": 1,
        "end": 31,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 31,
          "column": 2,
          "position": 370
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/custom.test.ts",
        "start": 1,
        "end": 31,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 31,
          "column": 2,
          "position": 370
        }
      }
    },
    {
      "format": "typescript",
      "lines": 56,
      "fragment": "import { test } from \"vitest\";\nimport * as z from \"zod/v3\";\n\nconst crazySchema = z.object({\n  tuple: z.tuple([\n    z.string().nullable().optional(),\n    z.number().nullable().optional(),\n    z.boolean().nullable().optional(),\n    z.null().nullable().optional(),\n    z.undefined().nullable().optional(),\n    z.literal(\"1234\").nullable().optional(),\n  ]),\n  merged: z\n    .object({\n      k1: z.string().optional(),\n    })\n    .merge(z.object({ k1: z.string().nullable(), k2: z.number() })),\n  union: z.array(z.union([z.literal(\"asdf\"), z.literal(12)])).nonempty(),\n  array: z.array(z.number()),\n  // sumTransformer: z.transformer(z.array(z.number()), z.number(), (arg) => {\n  //   return arg.reduce((a, b) => a + b, 0);\n  // }),\n  sumMinLength: z.array(z.number()).refine((arg) => arg.length > 5),\n  intersection: z.intersection(z.object({ p1: z.string().optional() }), z.object({ p1: z.number().optional() })),\n  enum: z.intersection(z.enum([\"zero\", \"one\"]), z.enum([\"one\", \"two\"])),\n  nonstrict: z.object({ points: z.number() }).nonstrict(),\n  numProm: z.promise(z.number()),\n  lenfun: z.function(z.tuple([z.string()]), z.boolean()),\n});\n\n// const asyncCrazySchema = crazySchema.extend({\n//   // async_transform: z.transformer(\n//   //   z.array(z.number()),\n//   //   z.number(),\n//   //   async (arg) => {\n//   //     return arg.reduce((a, b) => a + b, 0);\n//   //   }\n//   // ),\n//   async_refine: z.array(z.number()).refine(async (arg) => arg.length > 5),\n// });\n\ntest(\"parse\", () => {\n  crazySchema.parse({\n    tuple: [\"asdf\", 1234, true, null, undefined, \"1234\"],\n    merged: { k1: \"asdf\", k2: 12 },\n    union: [\"asdf\", 12, \"asdf\", 12, \"asdf\", 12],\n    array: [12, 15, 16],\n    // sumTransformer: [12, 15, 16],\n    sumMinLength: [12, 15, 16, 98, 24, 63],\n    intersection: {},\n    enum: \"one\",\n    nonstrict: { points: 1234 },\n    numProm: Promise.resolve(12),\n    lenfun: (x: string) => x.length,\n  });\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/complex.test.ts",
        "start": 1,
        "end": 56,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 56,
          "column": 2,
          "position": 698
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/complex.test.ts",
        "start": 1,
        "end": 56,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 56,
          "column": 2,
          "position": 698
        }
      }
    },
    {
      "format": "typescript",
      "lines": 133,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\ntest(\"string coercion\", () => {\n  const schema = z.coerce.string();\n  expect(schema.parse(\"sup\")).toEqual(\"sup\");\n  expect(schema.parse(\"\")).toEqual(\"\");\n  expect(schema.parse(12)).toEqual(\"12\");\n  expect(schema.parse(0)).toEqual(\"0\");\n  expect(schema.parse(-12)).toEqual(\"-12\");\n  expect(schema.parse(3.14)).toEqual(\"3.14\");\n  expect(schema.parse(BigInt(15))).toEqual(\"15\");\n  expect(schema.parse(Number.NaN)).toEqual(\"NaN\");\n  expect(schema.parse(Number.POSITIVE_INFINITY)).toEqual(\"Infinity\");\n  expect(schema.parse(Number.NEGATIVE_INFINITY)).toEqual(\"-Infinity\");\n  expect(schema.parse(true)).toEqual(\"true\");\n  expect(schema.parse(false)).toEqual(\"false\");\n  expect(schema.parse(null)).toEqual(\"null\");\n  expect(schema.parse(undefined)).toEqual(\"undefined\");\n  expect(schema.parse({ hello: \"world!\" })).toEqual(\"[object Object]\");\n  expect(schema.parse([\"item\", \"another_item\"])).toEqual(\"item,another_item\");\n  expect(schema.parse([])).toEqual(\"\");\n  expect(schema.parse(new Date(\"2022-01-01T00:00:00.000Z\"))).toEqual(new Date(\"2022-01-01T00:00:00.000Z\").toString());\n});\n\ntest(\"number coercion\", () => {\n  const schema = z.coerce.number();\n  expect(schema.parse(\"12\")).toEqual(12);\n  expect(schema.parse(\"0\")).toEqual(0);\n  expect(schema.parse(\"-12\")).toEqual(-12);\n  expect(schema.parse(\"3.14\")).toEqual(3.14);\n  expect(schema.parse(\"\")).toEqual(0);\n  expect(() => schema.parse(\"NOT_A_NUMBER\")).toThrow(); // z.ZodError\n  expect(schema.parse(12)).toEqual(12);\n  expect(schema.parse(0)).toEqual(0);\n  expect(schema.parse(-12)).toEqual(-12);\n  expect(schema.parse(3.14)).toEqual(3.14);\n  expect(schema.parse(BigInt(15))).toEqual(15);\n  expect(() => schema.parse(Number.NaN)).toThrow(); // z.ZodError\n  expect(schema.parse(Number.POSITIVE_INFINITY)).toEqual(Number.POSITIVE_INFINITY);\n  expect(schema.parse(Number.NEGATIVE_INFINITY)).toEqual(Number.NEGATIVE_INFINITY);\n  expect(schema.parse(true)).toEqual(1);\n  expect(schema.parse(false)).toEqual(0);\n  expect(schema.parse(null)).toEqual(0);\n  expect(() => schema.parse(undefined)).toThrow(); // z.ZodError\n  expect(() => schema.parse({ hello: \"world!\" })).toThrow(); // z.ZodError\n  expect(() => schema.parse([\"item\", \"another_item\"])).toThrow(); // z.ZodError\n  expect(schema.parse([])).toEqual(0);\n  expect(schema.parse(new Date(1670139203496))).toEqual(1670139203496);\n});\n\ntest(\"boolean coercion\", () => {\n  const schema = z.coerce.boolean();\n  expect(schema.parse(\"true\")).toEqual(true);\n  expect(schema.parse(\"false\")).toEqual(true);\n  expect(schema.parse(\"0\")).toEqual(true);\n  expect(schema.parse(\"1\")).toEqual(true);\n  expect(schema.parse(\"\")).toEqual(false);\n  expect(schema.parse(1)).toEqual(true);\n  expect(schema.parse(0)).toEqual(false);\n  expect(schema.parse(-1)).toEqual(true);\n  expect(schema.parse(3.14)).toEqual(true);\n  expect(schema.parse(BigInt(15))).toEqual(true);\n  expect(schema.parse(Number.NaN)).toEqual(false);\n  expect(schema.parse(Number.POSITIVE_INFINITY)).toEqual(true);\n  expect(schema.parse(Number.NEGATIVE_INFINITY)).toEqual(true);\n  expect(schema.parse(true)).toEqual(true);\n  expect(schema.parse(false)).toEqual(false);\n  expect(schema.parse(null)).toEqual(false);\n  expect(schema.parse(undefined)).toEqual(false);\n  expect(schema.parse({ hello: \"world!\" })).toEqual(true);\n  expect(schema.parse([\"item\", \"another_item\"])).toEqual(true);\n  expect(schema.parse([])).toEqual(true);\n  expect(schema.parse(new Date(1670139203496))).toEqual(true);\n});\n\ntest(\"bigint coercion\", () => {\n  const schema = z.coerce.bigint();\n  expect(schema.parse(\"5\")).toEqual(BigInt(5));\n  expect(schema.parse(\"0\")).toEqual(BigInt(0));\n  expect(schema.parse(\"-5\")).toEqual(BigInt(-5));\n  expect(() => schema.parse(\"3.14\")).toThrow(); // not a z.ZodError!\n  expect(schema.parse(\"\")).toEqual(BigInt(0));\n  expect(() => schema.parse(\"NOT_A_NUMBER\")).toThrow(); // not a z.ZodError!\n  expect(schema.parse(5)).toEqual(BigInt(5));\n  expect(schema.parse(0)).toEqual(BigInt(0));\n  expect(schema.parse(-5)).toEqual(BigInt(-5));\n  expect(() => schema.parse(3.14)).toThrow(); // not a z.ZodError!\n  expect(schema.parse(BigInt(5))).toEqual(BigInt(5));\n  expect(() => schema.parse(Number.NaN)).toThrow(); // not a z.ZodError!\n  expect(() => schema.parse(Number.POSITIVE_INFINITY)).toThrow(); // not a z.ZodError!\n  expect(() => schema.parse(Number.NEGATIVE_INFINITY)).toThrow(); // not a z.ZodError!\n  expect(schema.parse(true)).toEqual(BigInt(1));\n  expect(schema.parse(false)).toEqual(BigInt(0));\n  expect(() => schema.parse(null)).toThrow(); // not a z.ZodError!\n  expect(() => schema.parse(undefined)).toThrow(); // not a z.ZodError!\n  expect(() => schema.parse({ hello: \"world!\" })).toThrow(); // not a z.ZodError!\n  expect(() => schema.parse([\"item\", \"another_item\"])).toThrow(); // not a z.ZodError!\n  expect(schema.parse([])).toEqual(BigInt(0));\n  expect(schema.parse(new Date(1670139203496))).toEqual(BigInt(1670139203496));\n});\n\ntest(\"date coercion\", () => {\n  const schema = z.coerce.date();\n  expect(schema.parse(new Date().toDateString())).toBeInstanceOf(Date);\n  expect(schema.parse(new Date().toISOString())).toBeInstanceOf(Date);\n  expect(schema.parse(new Date().toUTCString())).toBeInstanceOf(Date);\n  expect(schema.parse(\"5\")).toBeInstanceOf(Date);\n  expect(schema.parse(\"2000-01-01\")).toBeInstanceOf(Date);\n  // expect(schema.parse(\"0\")).toBeInstanceOf(Date);\n  // expect(schema.parse(\"-5\")).toBeInstanceOf(Date);\n  // expect(schema.parse(\"3.14\")).toBeInstanceOf(Date);\n  expect(() => schema.parse(\"\")).toThrow(); // z.ZodError\n  expect(() => schema.parse(\"NOT_A_DATE\")).toThrow(); // z.ZodError\n  expect(schema.parse(5)).toBeInstanceOf(Date);\n  expect(schema.parse(0)).toBeInstanceOf(Date);\n  expect(schema.parse(-5)).toBeInstanceOf(Date);\n  expect(schema.parse(3.14)).toBeInstanceOf(Date);\n  expect(() => schema.parse(BigInt(5))).toThrow(); // not a z.ZodError!\n  expect(() => schema.parse(Number.NaN)).toThrow(); // z.ZodError\n  expect(() => schema.parse(Number.POSITIVE_INFINITY)).toThrow(); // z.ZodError\n  expect(() => schema.parse(Number.NEGATIVE_INFINITY)).toThrow(); // z.ZodError\n  expect(schema.parse(true)).toBeInstanceOf(Date);\n  expect(schema.parse(false)).toBeInstanceOf(Date);\n  expect(schema.parse(null)).toBeInstanceOf(Date);\n  expect(() => schema.parse(undefined)).toThrow(); // z.ZodError\n  expect(() => schema.parse({ hello: \"world!\" })).toThrow(); // z.ZodError\n  expect(() => schema.parse([\"item\", \"another_item\"])).toThrow(); // z.ZodError\n  expect(() => schema.parse([])).toThrow(); // z.ZodError\n  expect(schema.parse(new Date())).toBeInstanceOf(Date);\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/coerce.test.ts",
        "start": 1,
        "end": 133,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 133,
          "column": 2,
          "position": 2372
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/coerce.test.ts",
        "start": 1,
        "end": 132,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 132,
          "column": 2,
          "position": 2337
        }
      }
    },
    {
      "format": "typescript",
      "lines": 220,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport { z } from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\ntest(\"basic catch\", () => {\n  expect(z.string().catch(\"default\").parse(undefined)).toBe(\"default\");\n});\n\ntest(\"catch fn does not run when parsing succeeds\", () => {\n  let isCalled = false;\n  const cb = () => {\n    isCalled = true;\n    return \"asdf\";\n  };\n  expect(z.string().catch(cb).parse(\"test\")).toBe(\"test\");\n  expect(isCalled).toEqual(false);\n});\n\ntest(\"basic catch async\", async () => {\n  const result = await z.string().catch(\"default\").parseAsync(1243);\n  expect(result).toBe(\"default\");\n});\n\ntest(\"catch replace wrong types\", () => {\n  expect(z.string().catch(\"default\").parse(true)).toBe(\"default\");\n  expect(z.string().catch(\"default\").parse(true)).toBe(\"default\");\n  expect(z.string().catch(\"default\").parse(15)).toBe(\"default\");\n  expect(z.string().catch(\"default\").parse([])).toBe(\"default\");\n  expect(z.string().catch(\"default\").parse(new Map())).toBe(\"default\");\n  expect(z.string().catch(\"default\").parse(new Set())).toBe(\"default\");\n  expect(z.string().catch(\"default\").parse({})).toBe(\"default\");\n});\n\ntest(\"catch with transform\", () => {\n  const stringWithDefault = z\n    .string()\n    .transform((val) => val.toUpperCase())\n    .catch(\"default\");\n  expect(stringWithDefault.parse(undefined)).toBe(\"default\");\n  expect(stringWithDefault.parse(15)).toBe(\"default\");\n  expect(stringWithDefault).toBeInstanceOf(z.ZodCatch);\n  expect(stringWithDefault._def.innerType).toBeInstanceOf(z.ZodEffects);\n  expect(stringWithDefault._def.innerType._def.schema).toBeInstanceOf(z.ZodSchema);\n\n  type inp = z.input<typeof stringWithDefault>;\n  util.assertEqual<inp, unknown>(true);\n  type out = z.output<typeof stringWithDefault>;\n  util.assertEqual<out, string>(true);\n});\n\ntest(\"catch on existing optional\", () => {\n  const stringWithDefault = z.string().optional().catch(\"asdf\");\n  expect(stringWithDefault.parse(undefined)).toBe(undefined);\n  expect(stringWithDefault.parse(15)).toBe(\"asdf\");\n  expect(stringWithDefault).toBeInstanceOf(z.ZodCatch);\n  expect(stringWithDefault._def.innerType).toBeInstanceOf(z.ZodOptional);\n  expect(stringWithDefault._def.innerType._def.innerType).toBeInstanceOf(z.ZodString);\n\n  type inp = z.input<typeof stringWithDefault>;\n  util.assertEqual<inp, unknown>(true);\n  type out = z.output<typeof stringWithDefault>;\n  util.assertEqual<out, string | undefined>(true);\n});\n\ntest(\"optional on catch\", () => {\n  const stringWithDefault = z.string().catch(\"asdf\").optional();\n\n  type inp = z.input<typeof stringWithDefault>;\n  util.assertEqual<inp, unknown>(true);\n  type out = z.output<typeof stringWithDefault>;\n  util.assertEqual<out, string | undefined>(true);\n});\n\ntest(\"complex chain example\", () => {\n  const complex = z\n    .string()\n    .catch(\"asdf\")\n    .transform((val) => val + \"!\")\n    .transform((val) => val.toUpperCase())\n    .catch(\"qwer\")\n    .removeCatch()\n    .optional()\n    .catch(\"asdfasdf\");\n\n  expect(complex.parse(\"qwer\")).toBe(\"QWER!\");\n  expect(complex.parse(15)).toBe(\"ASDF!\");\n  expect(complex.parse(true)).toBe(\"ASDF!\");\n});\n\ntest(\"removeCatch\", () => {\n  const stringWithRemovedDefault = z.string().catch(\"asdf\").removeCatch();\n\n  type out = z.output<typeof stringWithRemovedDefault>;\n  util.assertEqual<out, string>(true);\n});\n\ntest(\"nested\", () => {\n  const inner = z.string().catch(\"asdf\");\n  const outer = z.object({ inner }).catch({\n    inner: \"asdf\",\n  });\n  type input = z.input<typeof outer>;\n  util.assertEqual<input, unknown>(true);\n  type out = z.output<typeof outer>;\n  util.assertEqual<out, { inner: string }>(true);\n  expect(outer.parse(undefined)).toEqual({ inner: \"asdf\" });\n  expect(outer.parse({})).toEqual({ inner: \"asdf\" });\n  expect(outer.parse({ inner: undefined })).toEqual({ inner: \"asdf\" });\n});\n\ntest(\"chained catch\", () => {\n  const stringWithDefault = z.string().catch(\"inner\").catch(\"outer\");\n  const result = stringWithDefault.parse(undefined);\n  expect(result).toEqual(\"inner\");\n  const resultDiff = stringWithDefault.parse(5);\n  expect(resultDiff).toEqual(\"inner\");\n});\n\ntest(\"factory\", () => {\n  z.ZodCatch.create(z.string(), {\n    catch: \"asdf\",\n  }).parse(undefined);\n});\n\ntest(\"native enum\", () => {\n  enum Fruits {\n    apple = \"apple\",\n    orange = \"orange\",\n  }\n\n  const schema = z.object({\n    fruit: z.nativeEnum(Fruits).catch(Fruits.apple),\n  });\n\n  expect(schema.parse({})).toEqual({ fruit: Fruits.apple });\n  expect(schema.parse({ fruit: 15 })).toEqual({ fruit: Fruits.apple });\n});\n\ntest(\"enum\", () => {\n  const schema = z.object({\n    fruit: z.enum([\"apple\", \"orange\"]).catch(\"apple\"),\n  });\n\n  expect(schema.parse({})).toEqual({ fruit: \"apple\" });\n  expect(schema.parse({ fruit: true })).toEqual({ fruit: \"apple\" });\n  expect(schema.parse({ fruit: 15 })).toEqual({ fruit: \"apple\" });\n});\n\ntest(\"reported issues with nested usage\", () => {\n  const schema = z.object({\n    string: z.string(),\n    obj: z.object({\n      sub: z.object({\n        lit: z.literal(\"a\"),\n        subCatch: z.number().catch(23),\n      }),\n      midCatch: z.number().catch(42),\n    }),\n    number: z.number().catch(0),\n    bool: z.boolean(),\n  });\n\n  try {\n    schema.parse({\n      string: {},\n      obj: {\n        sub: {\n          lit: \"b\",\n          subCatch: \"24\",\n        },\n        midCatch: 444,\n      },\n      number: \"\",\n      bool: \"yes\",\n    });\n  } catch (error) {\n    const issues = (error as z.ZodError).issues;\n\n    expect(issues.length).toEqual(3);\n    expect(issues[0].message).toMatch(\"string\");\n    expect(issues[1].message).toMatch(\"literal\");\n    expect(issues[2].message).toMatch(\"boolean\");\n  }\n});\n\ntest(\"catch error\", () => {\n  let catchError: z.ZodError | undefined = undefined;\n\n  const schema = z.object({\n    age: z.number(),\n    name: z.string().catch((ctx) => {\n      catchError = ctx.error;\n\n      return \"John Doe\";\n    }),\n  });\n\n  const result = schema.safeParse({\n    age: null,\n    name: null,\n  });\n\n  expect(result.success).toEqual(false);\n  expect(!result.success && result.error.issues.length).toEqual(1);\n  expect(!result.success && result.error.issues[0].message).toMatch(\"number\");\n\n  expect(catchError).toBeInstanceOf(z.ZodError);\n  expect(catchError !== undefined && (catchError as z.ZodError).issues.length).toEqual(1);\n  expect(catchError !== undefined && (catchError as z.ZodError).issues[0].message).toMatch(\"string\");\n});\n\ntest(\"ctx.input\", () => {\n  const schema = z.string().catch((ctx) => {\n    return String(ctx.input);\n  });\n\n  expect(schema.parse(123)).toEqual(\"123\");\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/catch.test.ts",
        "start": 1,
        "end": 220,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 220,
          "column": 2,
          "position": 2536
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/catch.test.ts",
        "start": 1,
        "end": 252,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 252,
          "column": 2,
          "position": 2387
        }
      }
    },
    {
      "format": "typescript",
      "lines": 53,
      "fragment": "// @ts-ignore TS6133\nimport { test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\ntest(\"branded types\", () => {\n  const mySchema = z\n    .object({\n      name: z.string(),\n    })\n    .brand<\"superschema\">();\n\n  // simple branding\n  type MySchema = z.infer<typeof mySchema>;\n  util.assertEqual<MySchema, { name: string } & { [z.BRAND]: { superschema: true } }>(true);\n\n  const doStuff = (arg: MySchema) => arg;\n  doStuff(mySchema.parse({ name: \"hello there\" }));\n\n  // inheritance\n  const extendedSchema = mySchema.brand<\"subschema\">();\n  type ExtendedSchema = z.infer<typeof extendedSchema>;\n  util.assertEqual<ExtendedSchema, { name: string } & z.BRAND<\"superschema\"> & z.BRAND<\"subschema\">>(true);\n\n  doStuff(extendedSchema.parse({ name: \"hello again\" }));\n\n  // number branding\n  const numberSchema = z.number().brand<42>();\n  type NumberSchema = z.infer<typeof numberSchema>;\n  util.assertEqual<NumberSchema, number & { [z.BRAND]: { 42: true } }>(true);\n\n  // symbol branding\n  const MyBrand: unique symbol = Symbol(\"hello\");\n  type MyBrand = typeof MyBrand;\n  const symbolBrand = z.number().brand<\"sup\">().brand<typeof MyBrand>();\n  type SymbolBrand = z.infer<typeof symbolBrand>;\n  // number & { [z.BRAND]: { sup: true, [MyBrand]: true } }\n  util.assertEqual<SymbolBrand, number & z.BRAND<\"sup\"> & z.BRAND<MyBrand>>(true);\n\n  // keeping brands out of input types\n  const age = z.number().brand<\"age\">();\n\n  type Age = z.infer<typeof age>;\n  type AgeInput = z.input<typeof age>;\n\n  util.assertEqual<AgeInput, Age>(false);\n  util.assertEqual<number, AgeInput>(true);\n  util.assertEqual<number & z.BRAND<\"age\">, Age>(true);\n\n  // @ts-expect-error\n  doStuff({ name: \"hello there!\" });\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/branded.test.ts",
        "start": 1,
        "end": 53,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 53,
          "column": 2,
          "position": 626
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/branded.test.ts",
        "start": 1,
        "end": 53,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 53,
          "column": 2,
          "position": 626
        }
      }
    },
    {
      "format": "typescript",
      "lines": 55,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\nconst gtFive = z.bigint().gt(BigInt(5));\nconst gteFive = z.bigint().gte(BigInt(5));\nconst ltFive = z.bigint().lt(BigInt(5));\nconst lteFive = z.bigint().lte(BigInt(5));\nconst positive = z.bigint().positive();\nconst negative = z.bigint().negative();\nconst nonnegative = z.bigint().nonnegative();\nconst nonpositive = z.bigint().nonpositive();\nconst multipleOfFive = z.bigint().multipleOf(BigInt(5));\n\ntest(\"passing validations\", () => {\n  z.bigint().parse(BigInt(1));\n  z.bigint().parse(BigInt(0));\n  z.bigint().parse(BigInt(-1));\n  gtFive.parse(BigInt(6));\n  gteFive.parse(BigInt(5));\n  gteFive.parse(BigInt(6));\n  ltFive.parse(BigInt(4));\n  lteFive.parse(BigInt(5));\n  lteFive.parse(BigInt(4));\n  positive.parse(BigInt(3));\n  negative.parse(BigInt(-2));\n  nonnegative.parse(BigInt(0));\n  nonnegative.parse(BigInt(7));\n  nonpositive.parse(BigInt(0));\n  nonpositive.parse(BigInt(-12));\n  multipleOfFive.parse(BigInt(15));\n});\n\ntest(\"failing validations\", () => {\n  expect(() => gtFive.parse(BigInt(5))).toThrow();\n  expect(() => gteFive.parse(BigInt(4))).toThrow();\n  expect(() => ltFive.parse(BigInt(5))).toThrow();\n  expect(() => lteFive.parse(BigInt(6))).toThrow();\n  expect(() => positive.parse(BigInt(0))).toThrow();\n  expect(() => positive.parse(BigInt(-2))).toThrow();\n  expect(() => negative.parse(BigInt(0))).toThrow();\n  expect(() => negative.parse(BigInt(3))).toThrow();\n  expect(() => nonnegative.parse(BigInt(-1))).toThrow();\n  expect(() => nonpositive.parse(BigInt(1))).toThrow();\n  expect(() => multipleOfFive.parse(BigInt(13))).toThrow();\n});\n\ntest(\"min max getters\", () => {\n  expect(z.bigint().min(BigInt(5)).minValue).toEqual(BigInt(5));\n  expect(z.bigint().min(BigInt(5)).min(BigInt(10)).minValue).toEqual(BigInt(10));\n\n  expect(z.bigint().max(BigInt(5)).maxValue).toEqual(BigInt(5));\n  expect(z.bigint().max(BigInt(5)).max(BigInt(1)).maxValue).toEqual(BigInt(1));\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/bigint.test.ts",
        "start": 1,
        "end": 55,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 55,
          "column": 2,
          "position": 861
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/bigint.test.ts",
        "start": 1,
        "end": 54,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 54,
          "column": 2,
          "position": 859
        }
      }
    },
    {
      "format": "typescript",
      "lines": 29,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\ntest(\"type guard\", () => {\n  const stringToNumber = z.string().transform((arg) => arg.length);\n\n  const s1 = z.object({\n    stringToNumber,\n  });\n  type t1 = z.input<typeof s1>;\n\n  const data = { stringToNumber: \"asdf\" };\n  const parsed = s1.safeParse(data);\n  if (parsed.success) {\n    util.assertEqual<typeof data, t1>(true);\n  }\n});\n\ntest(\"test this binding\", () => {\n  const callback = (predicate: (val: string) => boolean) => {\n    return predicate(\"hello\");\n  };\n\n  expect(callback((value) => z.string().safeParse(value).success)).toBe(true); // true\n  expect(callback((value) => z.string().safeParse(value).success)).toBe(true); // true\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/base.test.ts",
        "start": 1,
        "end": 29,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 29,
          "column": 2,
          "position": 317
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/base.test.ts",
        "start": 1,
        "end": 29,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 29,
          "column": 2,
          "position": 317
        }
      }
    },
    {
      "format": "typescript",
      "lines": 46,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\ntest(\"parse async test\", async () => {\n  const schema1 = z.string().refine(async (_val) => false);\n  expect(() => schema1.parse(\"asdf\")).toThrow();\n\n  const schema2 = z.string().refine((_val) => Promise.resolve(true));\n  return await expect(() => schema2.parse(\"asdf\")).toThrow();\n});\n\ntest(\"parseAsync async test\", async () => {\n  const schema1 = z.string().refine(async (_val) => true);\n  await schema1.parseAsync(\"asdf\");\n\n  const schema2 = z.string().refine(async (_val) => false);\n  return await expect(schema2.parseAsync(\"asdf\")).rejects.toBeDefined();\n  // expect(async () => await schema2.parseAsync('asdf')).toThrow();\n});\n\ntest(\"parseAsync async test\", async () => {\n  // expect.assertions(2);\n\n  const schema1 = z.string().refine((_val) => Promise.resolve(true));\n  const v1 = await schema1.parseAsync(\"asdf\");\n  expect(v1).toEqual(\"asdf\");\n\n  const schema2 = z.string().refine((_val) => Promise.resolve(false));\n  await expect(schema2.parseAsync(\"asdf\")).rejects.toBeDefined();\n\n  const schema3 = z.string().refine((_val) => Promise.resolve(true));\n  await expect(schema3.parseAsync(\"asdf\")).resolves.toEqual(\"asdf\");\n  return await expect(schema3.parseAsync(\"qwer\")).resolves.toEqual(\"qwer\");\n});\n\ntest(\"parseAsync async with value\", async () => {\n  const schema1 = z.string().refine(async (val) => {\n    return val.length > 5;\n  });\n  await expect(schema1.parseAsync(\"asdf\")).rejects.toBeDefined();\n\n  const v = await schema1.parseAsync(\"asdf123\");\n  return await expect(v).toEqual(\"asdf123\");\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/async-refinements.test.ts",
        "start": 1,
        "end": 46,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 46,
          "column": 2,
          "position": 586
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/async-refinements.test.ts",
        "start": 1,
        "end": 46,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 46,
          "column": 2,
          "position": 586
        }
      }
    },
    {
      "format": "typescript",
      "lines": 388,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\n/// string\nconst stringSchema = z.string();\n\ntest(\"string async parse\", async () => {\n  const goodData = \"XXX\";\n  const badData = 12;\n\n  const goodResult = await stringSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await stringSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// number\nconst numberSchema = z.number();\ntest(\"number async parse\", async () => {\n  const goodData = 1234.2353;\n  const badData = \"1234\";\n\n  const goodResult = await numberSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await numberSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// bigInt\nconst bigIntSchema = z.bigint();\ntest(\"bigInt async parse\", async () => {\n  const goodData = BigInt(145);\n  const badData = 134;\n\n  const goodResult = await bigIntSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await bigIntSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// boolean\nconst booleanSchema = z.boolean();\ntest(\"boolean async parse\", async () => {\n  const goodData = true;\n  const badData = 1;\n\n  const goodResult = await booleanSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await booleanSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// date\nconst dateSchema = z.date();\ntest(\"date async parse\", async () => {\n  const goodData = new Date();\n  const badData = new Date().toISOString();\n\n  const goodResult = await dateSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await dateSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// undefined\nconst undefinedSchema = z.undefined();\ntest(\"undefined async parse\", async () => {\n  const goodData = undefined;\n  const badData = \"XXX\";\n\n  const goodResult = await undefinedSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(undefined);\n\n  const badResult = await undefinedSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// null\nconst nullSchema = z.null();\ntest(\"null async parse\", async () => {\n  const goodData = null;\n  const badData = undefined;\n\n  const goodResult = await nullSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await nullSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// any\nconst anySchema = z.any();\ntest(\"any async parse\", async () => {\n  const goodData = [{}];\n  // const badData = 'XXX';\n\n  const goodResult = await anySchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  // const badResult = await anySchema.safeParseAsync(badData);\n  // expect(badResult.success).toBe(false);\n  // if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// unknown\nconst unknownSchema = z.unknown();\ntest(\"unknown async parse\", async () => {\n  const goodData = [\"asdf\", 124, () => {}];\n  // const badData = 'XXX';\n\n  const goodResult = await unknownSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  // const badResult = await unknownSchema.safeParseAsync(badData);\n  // expect(badResult.success).toBe(false);\n  // if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// void\nconst voidSchema = z.void();\ntest(\"void async parse\", async () => {\n  const goodData = undefined;\n  const badData = 0;\n\n  const goodResult = await voidSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await voidSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// array\nconst arraySchema = z.array(z.string());\ntest(\"array async parse\", async () => {\n  const goodData = [\"XXX\"];\n  const badData = \"XXX\";\n\n  const goodResult = await arraySchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await arraySchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// object\nconst objectSchema = z.object({ string: z.string() });\ntest(\"object async parse\", async () => {\n  const goodData = { string: \"XXX\" };\n  const badData = { string: 12 };\n\n  const goodResult = await objectSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await objectSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// union\nconst unionSchema = z.union([z.string(), z.undefined()]);\ntest(\"union async parse\", async () => {\n  const goodData = undefined;\n  const badData = null;\n\n  const goodResult = await unionSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await unionSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// record\nconst recordSchema = z.record(z.object({}));\ntest(\"record async parse\", async () => {\n  const goodData = { adsf: {}, asdf: {} };\n  const badData = [{}];\n\n  const goodResult = await recordSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await recordSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// function\nconst functionSchema = z.function();\ntest(\"function async parse\", async () => {\n  const goodData = () => {};\n  const badData = \"XXX\";\n\n  const goodResult = await functionSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(typeof goodResult.data).toEqual(\"function\");\n\n  const badResult = await functionSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// literal\nconst literalSchema = z.literal(\"asdf\");\ntest(\"literal async parse\", async () => {\n  const goodData = \"asdf\";\n  const badData = \"asdff\";\n\n  const goodResult = await literalSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await literalSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// enum\nconst enumSchema = z.enum([\"fish\", \"whale\"]);\ntest(\"enum async parse\", async () => {\n  const goodData = \"whale\";\n  const badData = \"leopard\";\n\n  const goodResult = await enumSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await enumSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// nativeEnum\nenum nativeEnumTest {\n  asdf = \"qwer\",\n}\n// @ts-ignore\nconst nativeEnumSchema = z.nativeEnum(nativeEnumTest);\ntest(\"nativeEnum async parse\", async () => {\n  const goodData = nativeEnumTest.asdf;\n  const badData = \"asdf\";\n\n  const goodResult = await nativeEnumSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await nativeEnumSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// promise\nconst promiseSchema = z.promise(z.number());\ntest(\"promise async parse good\", async () => {\n  const goodData = Promise.resolve(123);\n\n  const goodResult = await promiseSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) {\n    expect(goodResult.data).toBeInstanceOf(Promise);\n    const data = await goodResult.data;\n    expect(data).toEqual(123);\n    // expect(goodResult.data).resolves.toEqual(124);\n    // return goodResult.data;\n  } else {\n    throw new Error(\"success should be true\");\n  }\n});\n\ntest(\"promise async parse bad\", async () => {\n  const badData = Promise.resolve(\"XXX\");\n  const badResult = await promiseSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(true);\n  if (badResult.success) {\n    await expect(badResult.data).rejects.toBeInstanceOf(z.ZodError);\n  } else {\n    throw new Error(\"success should be true\");\n  }\n});\n\ntest(\"async validation non-empty strings\", async () => {\n  const base = z.object({\n    hello: z.string().refine((x) => x && x.length > 0),\n    foo: z.string().refine((x) => x && x.length > 0),\n  });\n\n  const testval = { hello: \"\", foo: \"\" };\n  const result1 = base.safeParse(testval);\n  const result2 = base.safeParseAsync(testval);\n\n  const r1 = result1;\n  await result2.then((r2) => {\n    if (r1.success === false && r2.success === false) expect(r1.error.issues.length).toBe(r2.error.issues.length); // <--- r1 has length 2, r2 has length 1\n  });\n});\n\ntest(\"async validation multiple errors 1\", async () => {\n  const base = z.object({\n    hello: z.string(),\n    foo: z.number(),\n  });\n\n  const testval = { hello: 3, foo: \"hello\" };\n  const result1 = base.safeParse(testval);\n  const result2 = base.safeParseAsync(testval);\n\n  const r1 = result1;\n  await result2.then((r2) => {\n    if (r1.success === false && r2.success === false) expect(r2.error.issues.length).toBe(r1.error.issues.length);\n  });\n});\n\ntest(\"async validation multiple errors 2\", async () => {\n  const base = (is_async?: boolean) =>\n    z.object({\n      hello: z.string(),\n      foo: z.object({\n        bar: z.number().refine(is_async ? async () => false : () => false),\n      }),\n    });\n\n  const testval = { hello: 3, foo: { bar: 4 } };\n  const result1 = base().safeParse(testval);\n  const result2 = base(true).safeParseAsync(testval);\n\n  const r1 = result1;\n  await result2.then((r2) => {\n    if (r1.success === false && r2.success === false) expect(r2.error.issues.length).toBe(r1.error.issues.length);\n  });\n});\n\ntest(\"ensure early async failure prevents follow-up refinement checks\", async () => {\n  let count = 0;\n  const base = z.object({\n    hello: z.string(),\n    foo: z\n      .number()\n      .refine(async () => {\n        count++;\n        return true;\n      })\n      .refine(async () => {\n        count++;\n        return true;\n      }, \"Good\"),\n  });\n\n  const testval = { hello: \"bye\", foo: 3 };\n  const result = await base.safeParseAsync(testval);\n  if (result.success === false) {\n    expect(result.error.issues.length).toBe(1);\n    expect(count).toBe(1);\n  }\n\n  // await result.then((r) => {\n  //   if (r.success === false) expect(r.error.issues.length).toBe(1);\n  //   expect(count).toBe(2);\n  // });\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/async-parsing.test.ts",
        "start": 1,
        "end": 388,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 388,
          "column": 2,
          "position": 4223
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/async-parsing.test.ts",
        "start": 1,
        "end": 381,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 381,
          "column": 2,
          "position": 3955
        }
      }
    },
    {
      "format": "typescript",
      "lines": 71,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\nconst minTwo = z.string().array().min(2);\nconst maxTwo = z.string().array().max(2);\nconst justTwo = z.string().array().length(2);\nconst intNum = z.string().array().nonempty();\nconst nonEmptyMax = z.string().array().nonempty().max(2);\n\ntype t1 = z.infer<typeof nonEmptyMax>;\nutil.assertEqual<[string, ...string[]], t1>(true);\n\ntype t2 = z.infer<typeof minTwo>;\nutil.assertEqual<string[], t2>(true);\n\ntest(\"passing validations\", () => {\n  minTwo.parse([\"a\", \"a\"]);\n  minTwo.parse([\"a\", \"a\", \"a\"]);\n  maxTwo.parse([\"a\", \"a\"]);\n  maxTwo.parse([\"a\"]);\n  justTwo.parse([\"a\", \"a\"]);\n  intNum.parse([\"a\"]);\n  nonEmptyMax.parse([\"a\"]);\n});\n\ntest(\"failing validations\", () => {\n  expect(() => minTwo.parse([\"a\"])).toThrow();\n  expect(() => maxTwo.parse([\"a\", \"a\", \"a\"])).toThrow();\n  expect(() => justTwo.parse([\"a\"])).toThrow();\n  expect(() => justTwo.parse([\"a\", \"a\", \"a\"])).toThrow();\n  expect(() => intNum.parse([])).toThrow();\n  expect(() => nonEmptyMax.parse([])).toThrow();\n  expect(() => nonEmptyMax.parse([\"a\", \"a\", \"a\"])).toThrow();\n});\n\ntest(\"parse empty array in nonempty\", () => {\n  expect(() =>\n    z\n      .array(z.string())\n      .nonempty()\n      .parse([] as any)\n  ).toThrow();\n});\n\ntest(\"get element\", () => {\n  justTwo.element.parse(\"asdf\");\n  expect(() => justTwo.element.parse(12)).toThrow();\n});\n\ntest(\"continue parsing despite array size error\", () => {\n  const schema = z.object({\n    people: z.string().array().min(2),\n  });\n\n  const result = schema.safeParse({\n    people: [123],\n  });\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues.length).toEqual(2);\n  }\n});\n\ntest(\"parse should fail given sparse array\", () => {\n  const schema = z.array(z.string()).nonempty().min(1).max(3);\n\n  expect(() => schema.parse(new Array(3))).toThrow();\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/array.test.ts",
        "start": 1,
        "end": 71,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 71,
          "column": 2,
          "position": 855
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/array.test.ts",
        "start": 1,
        "end": 71,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 71,
          "column": 2,
          "position": 855
        }
      }
    },
    {
      "format": "typescript",
      "lines": 28,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\ntest(\"check any inference\", () => {\n  const t1 = z.any();\n  t1.optional();\n  t1.nullable();\n  type t1 = z.infer<typeof t1>;\n  util.assertEqual<t1, any>(true);\n});\n\ntest(\"check unknown inference\", () => {\n  const t1 = z.unknown();\n  t1.optional();\n  t1.nullable();\n  type t1 = z.infer<typeof t1>;\n  util.assertEqual<t1, unknown>(true);\n});\n\ntest(\"check never inference\", () => {\n  const t1 = z.never();\n  expect(() => t1.parse(undefined)).toThrow();\n  expect(() => t1.parse(\"asdf\")).toThrow();\n  expect(() => t1.parse(null)).toThrow();\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/anyunknown.test.ts",
        "start": 1,
        "end": 28,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 28,
          "column": 2,
          "position": 295
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/anyunknown.test.ts",
        "start": 1,
        "end": 26,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 26,
          "column": 2,
          "position": 285
        }
      }
    },
    {
      "format": "typescript",
      "lines": 157,
      "fragment": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\nconst Test = z.object({\n  f1: z.number(),\n  f2: z.string().optional(),\n  f3: z.string().nullable(),\n  f4: z.array(z.object({ t: z.union([z.string(), z.boolean()]) })),\n});\ntype TestFlattenedErrors = z.inferFlattenedErrors<typeof Test, { message: string; code: number }>;\ntype TestFormErrors = z.inferFlattenedErrors<typeof Test>;\n\ntest(\"default flattened errors type inference\", () => {\n  type TestTypeErrors = {\n    formErrors: string[];\n    fieldErrors: { [P in keyof z.TypeOf<typeof Test>]?: string[] | undefined };\n  };\n\n  util.assertEqual<z.inferFlattenedErrors<typeof Test>, TestTypeErrors>(true);\n  util.assertEqual<z.inferFlattenedErrors<typeof Test, { message: string }>, TestTypeErrors>(false);\n});\n\ntest(\"custom flattened errors type inference\", () => {\n  type ErrorType = { message: string; code: number };\n  type TestTypeErrors = {\n    formErrors: ErrorType[];\n    fieldErrors: {\n      [P in keyof z.TypeOf<typeof Test>]?: ErrorType[] | undefined;\n    };\n  };\n\n  util.assertEqual<z.inferFlattenedErrors<typeof Test>, TestTypeErrors>(false);\n  util.assertEqual<z.inferFlattenedErrors<typeof Test, { message: string; code: number }>, TestTypeErrors>(true);\n  util.assertEqual<z.inferFlattenedErrors<typeof Test, { message: string }>, TestTypeErrors>(false);\n});\n\ntest(\"form errors type inference\", () => {\n  type TestTypeErrors = {\n    formErrors: string[];\n    fieldErrors: { [P in keyof z.TypeOf<typeof Test>]?: string[] | undefined };\n  };\n\n  util.assertEqual<z.inferFlattenedErrors<typeof Test>, TestTypeErrors>(true);\n});\n\ntest(\".flatten() type assertion\", () => {\n  const parsed = Test.safeParse({}) as z.SafeParseError<void>;\n  const validFlattenedErrors: TestFlattenedErrors = parsed.error.flatten(() => ({ message: \"\", code: 0 }));\n  // @ts-expect-error should fail assertion between `TestFlattenedErrors` and unmapped `flatten()`.\n  const invalidFlattenedErrors: TestFlattenedErrors = parsed.error.flatten();\n  const validFormErrors: TestFormErrors = parsed.error.flatten();\n  // @ts-expect-error should fail assertion between `TestFormErrors` and mapped `flatten()`.\n  const invalidFormErrors: TestFormErrors = parsed.error.flatten(() => ({\n    message: \"string\",\n    code: 0,\n  }));\n\n  [validFlattenedErrors, invalidFlattenedErrors, validFormErrors, invalidFormErrors];\n});\n\ntest(\".formErrors type assertion\", () => {\n  const parsed = Test.safeParse({}) as z.SafeParseError<void>;\n  const validFormErrors: TestFormErrors = parsed.error.formErrors;\n  // @ts-expect-error should fail assertion between `TestFlattenedErrors` and `.formErrors`.\n  const invalidFlattenedErrors: TestFlattenedErrors = parsed.error.formErrors;\n\n  [validFormErrors, invalidFlattenedErrors];\n});\n\ntest(\"all errors\", () => {\n  const propertySchema = z.string();\n  const schema = z\n    .object({\n      a: propertySchema,\n      b: propertySchema,\n    })\n    .refine(\n      (val) => {\n        return val.a === val.b;\n      },\n      { message: \"Must be equal\" }\n    );\n\n  try {\n    schema.parse({\n      a: \"asdf\",\n      b: \"qwer\",\n    });\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      expect(error.flatten()).toEqual({\n        formErrors: [\"Must be equal\"],\n        fieldErrors: {},\n      });\n    }\n  }\n\n  try {\n    schema.parse({\n      a: null,\n      b: null,\n    });\n  } catch (_error) {\n    const error = _error as z.ZodError;\n    expect(error.flatten()).toEqual({\n      formErrors: [],\n      fieldErrors: {\n        a: [\"Expected string, received null\"],\n        b: [\"Expected string, received null\"],\n      },\n    });\n\n    expect(error.flatten((iss) => iss.message.toUpperCase())).toEqual({\n      formErrors: [],\n      fieldErrors: {\n        a: [\"EXPECTED STRING, RECEIVED NULL\"],\n        b: [\"EXPECTED STRING, RECEIVED NULL\"],\n      },\n    });\n    // Test identity\n\n    expect(error.flatten((i: z.ZodIssue) => i)).toEqual({\n      formErrors: [],\n      fieldErrors: {\n        a: [\n          {\n            code: \"invalid_type\",\n            expected: \"string\",\n            message: \"Expected string, received null\",\n            path: [\"a\"],\n            received: \"null\",\n          },\n        ],\n        b: [\n          {\n            code: \"invalid_type\",\n            expected: \"string\",\n            message: \"Expected string, received null\",\n            path: [\"b\"],\n            received: \"null\",\n          },\n        ],\n      },\n    });\n    // Test mapping\n    expect(error.flatten((i: z.ZodIssue) => i.message.length)).toEqual({\n      formErrors: [],\n      fieldErrors: {\n        a: [\"Expected string, received null\".length],\n        b: [\"Expected string, received null\".length],\n      },\n    });\n  }\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/all-errors.test.ts",
        "start": 1,
        "end": 157,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 157,
          "column": 2,
          "position": 1523
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/object.test.ts",
        "start": 1,
        "end": 157,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 157,
          "column": 2,
          "position": 1523
        }
      }
    },
    {
      "format": "typescript",
      "lines": 54,
      "fragment": "function getRandomInt(max: number) {\n  return Math.floor(Math.random() * Math.floor(max));\n}\n\nconst testSymbol = Symbol(\"test\");\n\nexport class Mocker {\n  pick = (...args: any[]): any => {\n    return args[getRandomInt(args.length)];\n  };\n\n  get string(): string {\n    return Math.random().toString(36).substring(7);\n  }\n  get number(): number {\n    return Math.random() * 100;\n  }\n  get bigint(): bigint {\n    return BigInt(Math.floor(Math.random() * 10000));\n  }\n  get boolean(): boolean {\n    return Math.random() < 0.5;\n  }\n  get date(): Date {\n    return new Date(Math.floor(Date.now() * Math.random()));\n  }\n  get symbol(): symbol {\n    return testSymbol;\n  }\n  get null(): null {\n    return null;\n  }\n  get undefined(): undefined {\n    return undefined;\n  }\n  get stringOptional(): string | undefined {\n    return this.pick(this.string, this.undefined);\n  }\n  get stringNullable(): string | null {\n    return this.pick(this.string, this.null);\n  }\n  get numberOptional(): number | undefined {\n    return this.pick(this.number, this.undefined);\n  }\n  get numberNullable(): number | null {\n    return this.pick(this.number, this.null);\n  }\n  get booleanOptional(): boolean | undefined {\n    return this.pick(this.boolean, this.undefined);\n  }\n  get booleanNullable(): boolean | null {\n    return this.pick(this.boolean, this.null);\n  }\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/tests/Mocker.ts",
        "start": 1,
        "end": 54,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 54,
          "column": 2,
          "position": 559
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/tests/Mocker.ts",
        "start": 1,
        "end": 54,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 54,
          "column": 2,
          "position": 559
        }
      }
    },
    {
      "format": "typescript",
      "lines": 124,
      "fragment": "import { type ZodErrorMap, ZodIssueCode } from \"../ZodError.js\";\nimport { util, ZodParsedType } from \"../helpers/util.js\";\n\nconst errorMap: ZodErrorMap = (issue, _ctx) => {\n  let message: string;\n  switch (issue.code) {\n    case ZodIssueCode.invalid_type:\n      if (issue.received === ZodParsedType.undefined) {\n        message = \"Required\";\n      } else {\n        message = `Expected ${issue.expected}, received ${issue.received}`;\n      }\n      break;\n    case ZodIssueCode.invalid_literal:\n      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n      break;\n    case ZodIssueCode.unrecognized_keys:\n      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n      break;\n    case ZodIssueCode.invalid_union:\n      message = `Invalid input`;\n      break;\n    case ZodIssueCode.invalid_union_discriminator:\n      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n      break;\n    case ZodIssueCode.invalid_enum_value:\n      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n      break;\n    case ZodIssueCode.invalid_arguments:\n      message = `Invalid function arguments`;\n      break;\n    case ZodIssueCode.invalid_return_type:\n      message = `Invalid function return type`;\n      break;\n    case ZodIssueCode.invalid_date:\n      message = `Invalid date`;\n      break;\n    case ZodIssueCode.invalid_string:\n      if (typeof issue.validation === \"object\") {\n        if (\"includes\" in issue.validation) {\n          message = `Invalid input: must include \"${issue.validation.includes}\"`;\n\n          if (typeof issue.validation.position === \"number\") {\n            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n          }\n        } else if (\"startsWith\" in issue.validation) {\n          message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n        } else if (\"endsWith\" in issue.validation) {\n          message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n        } else {\n          util.assertNever(issue.validation);\n        }\n      } else if (issue.validation !== \"regex\") {\n        message = `Invalid ${issue.validation}`;\n      } else {\n        message = \"Invalid\";\n      }\n      break;\n    case ZodIssueCode.too_small:\n      if (issue.type === \"array\")\n        message = `Array must contain ${\n          issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`\n        } ${issue.minimum} element(s)`;\n      else if (issue.type === \"string\")\n        message = `String must contain ${\n          issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`\n        } ${issue.minimum} character(s)`;\n      else if (issue.type === \"number\")\n        message = `Number must be ${\n          issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `\n        }${issue.minimum}`;\n      else if (issue.type === \"bigint\")\n        message = `Number must be ${\n          issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `\n        }${issue.minimum}`;\n      else if (issue.type === \"date\")\n        message = `Date must be ${\n          issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `\n        }${new Date(Number(issue.minimum))}`;\n      else message = \"Invalid input\";\n      break;\n    case ZodIssueCode.too_big:\n      if (issue.type === \"array\")\n        message = `Array must contain ${\n          issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`\n        } ${issue.maximum} element(s)`;\n      else if (issue.type === \"string\")\n        message = `String must contain ${\n          issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`\n        } ${issue.maximum} character(s)`;\n      else if (issue.type === \"number\")\n        message = `Number must be ${\n          issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`\n        } ${issue.maximum}`;\n      else if (issue.type === \"bigint\")\n        message = `BigInt must be ${\n          issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`\n        } ${issue.maximum}`;\n      else if (issue.type === \"date\")\n        message = `Date must be ${\n          issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`\n        } ${new Date(Number(issue.maximum))}`;\n      else message = \"Invalid input\";\n      break;\n    case ZodIssueCode.custom:\n      message = `Invalid input`;\n      break;\n    case ZodIssueCode.invalid_intersection_types:\n      message = `Intersection results could not be merged`;\n      break;\n    case ZodIssueCode.not_multiple_of:\n      message = `Number must be a multiple of ${issue.multipleOf}`;\n      break;\n    case ZodIssueCode.not_finite:\n      message = \"Number must be finite\";\n      break;\n    default:\n      message = _ctx.defaultError;\n      util.assertNever(issue);\n  }\n  return { message };\n};\n\nexport default errorMap;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/locales/en.ts",
        "start": 1,
        "end": 124,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 124,
          "column": 2,
          "position": 1230
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/locales/en.ts",
        "start": 1,
        "end": 124,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 124,
          "column": 2,
          "position": 1230
        }
      }
    },
    {
      "format": "typescript",
      "lines": 224,
      "fragment": "export namespace util {\n  type AssertEqual<T, U> = (<V>() => V extends T ? 1 : 2) extends <V>() => V extends U ? 1 : 2 ? true : false;\n\n  export type isAny<T> = 0 extends 1 & T ? true : false;\n  export const assertEqual = <A, B>(_: AssertEqual<A, B>): void => {};\n  export function assertIs<T>(_arg: T): void {}\n  export function assertNever(_x: never): never {\n    throw new Error();\n  }\n\n  export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n  export type OmitKeys<T, K extends string> = Pick<T, Exclude<keyof T, K>>;\n  export type MakePartial<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n  export type Exactly<T, X> = T & Record<Exclude<keyof X, keyof T>, never>;\n  export type InexactPartial<T> = { [k in keyof T]?: T[k] | undefined };\n  export const arrayToEnum = <T extends string, U extends [T, ...T[]]>(items: U): { [k in U[number]]: k } => {\n    const obj: any = {};\n    for (const item of items) {\n      obj[item] = item;\n    }\n    return obj;\n  };\n\n  export const getValidEnumValues = (obj: any): any[] => {\n    const validKeys = objectKeys(obj).filter((k: any) => typeof obj[obj[k]] !== \"number\");\n    const filtered: any = {};\n    for (const k of validKeys) {\n      filtered[k] = obj[k];\n    }\n    return objectValues(filtered);\n  };\n\n  export const objectValues = (obj: any): any[] => {\n    return objectKeys(obj).map(function (e) {\n      return obj[e];\n    });\n  };\n\n  export const objectKeys: ObjectConstructor[\"keys\"] =\n    typeof Object.keys === \"function\" // eslint-disable-line ban/ban\n      ? (obj: any) => Object.keys(obj) // eslint-disable-line ban/ban\n      : (object: any) => {\n          const keys = [];\n          for (const key in object) {\n            if (Object.prototype.hasOwnProperty.call(object, key)) {\n              keys.push(key);\n            }\n          }\n          return keys;\n        };\n\n  export const find = <T>(arr: T[], checker: (arg: T) => any): T | undefined => {\n    for (const item of arr) {\n      if (checker(item)) return item;\n    }\n    return undefined;\n  };\n\n  export type identity<T> = objectUtil.identity<T>;\n  export type flatten<T> = objectUtil.flatten<T>;\n\n  export type noUndefined<T> = T extends undefined ? never : T;\n\n  export const isInteger: NumberConstructor[\"isInteger\"] =\n    typeof Number.isInteger === \"function\"\n      ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban\n      : (val) => typeof val === \"number\" && Number.isFinite(val) && Math.floor(val) === val;\n\n  export function joinValues<T extends any[]>(array: T, separator = \" | \"): string {\n    return array.map((val) => (typeof val === \"string\" ? `'${val}'` : val)).join(separator);\n  }\n\n  export const jsonStringifyReplacer = (_: string, value: any): any => {\n    if (typeof value === \"bigint\") {\n      return value.toString();\n    }\n    return value;\n  };\n}\n\nexport namespace objectUtil {\n  export type MergeShapes<U, V> =\n    // fast path when there is no keys overlap\n    keyof U & keyof V extends never\n      ? U & V\n      : {\n          [k in Exclude<keyof U, keyof V>]: U[k];\n        } & V;\n\n  type optionalKeys<T extends object> = {\n    [k in keyof T]: undefined extends T[k] ? k : never;\n  }[keyof T];\n  type requiredKeys<T extends object> = {\n    [k in keyof T]: undefined extends T[k] ? never : k;\n  }[keyof T];\n  export type addQuestionMarks<T extends object, _O = any> = {\n    [K in requiredKeys<T>]: T[K];\n  } & {\n    [K in optionalKeys<T>]?: T[K];\n  } & { [k in keyof T]?: unknown };\n\n  export type identity<T> = T;\n  export type flatten<T> = identity<{ [k in keyof T]: T[k] }>;\n\n  export type noNeverKeys<T> = {\n    [k in keyof T]: [T[k]] extends [never] ? never : k;\n  }[keyof T];\n\n  export type noNever<T> = identity<{\n    [k in noNeverKeys<T>]: k extends keyof T ? T[k] : never;\n  }>;\n\n  export const mergeShapes = <U, T>(first: U, second: T): T & U => {\n    return {\n      ...first,\n      ...second, // second overwrites first\n    };\n  };\n\n  export type extendShape<A extends object, B extends object> = keyof A & keyof B extends never // fast path when there is no keys overlap\n    ? A & B\n    : {\n        [K in keyof A as K extends keyof B ? never : K]: A[K];\n      } & {\n        [K in keyof B]: B[K];\n      };\n}\n\nexport const ZodParsedType: {\n  string: \"string\";\n  nan: \"nan\";\n  number: \"number\";\n  integer: \"integer\";\n  float: \"float\";\n  boolean: \"boolean\";\n  date: \"date\";\n  bigint: \"bigint\";\n  symbol: \"symbol\";\n  function: \"function\";\n  undefined: \"undefined\";\n  null: \"null\";\n  array: \"array\";\n  object: \"object\";\n  unknown: \"unknown\";\n  promise: \"promise\";\n  void: \"void\";\n  never: \"never\";\n  map: \"map\";\n  set: \"set\";\n} = util.arrayToEnum([\n  \"string\",\n  \"nan\",\n  \"number\",\n  \"integer\",\n  \"float\",\n  \"boolean\",\n  \"date\",\n  \"bigint\",\n  \"symbol\",\n  \"function\",\n  \"undefined\",\n  \"null\",\n  \"array\",\n  \"object\",\n  \"unknown\",\n  \"promise\",\n  \"void\",\n  \"never\",\n  \"map\",\n  \"set\",\n]);\n\nexport type ZodParsedType = keyof typeof ZodParsedType;\n\nexport const getParsedType = (data: any): ZodParsedType => {\n  const t = typeof data;\n\n  switch (t) {\n    case \"undefined\":\n      return ZodParsedType.undefined;\n\n    case \"string\":\n      return ZodParsedType.string;\n\n    case \"number\":\n      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n\n    case \"boolean\":\n      return ZodParsedType.boolean;\n\n    case \"function\":\n      return ZodParsedType.function;\n\n    case \"bigint\":\n      return ZodParsedType.bigint;\n\n    case \"symbol\":\n      return ZodParsedType.symbol;\n\n    case \"object\":\n      if (Array.isArray(data)) {\n        return ZodParsedType.array;\n      }\n      if (data === null) {\n        return ZodParsedType.null;\n      }\n      if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n        return ZodParsedType.promise;\n      }\n      if (typeof Map !== \"undefined\" && data instanceof Map) {\n        return ZodParsedType.map;\n      }\n      if (typeof Set !== \"undefined\" && data instanceof Set) {\n        return ZodParsedType.set;\n      }\n      if (typeof Date !== \"undefined\" && data instanceof Date) {\n        return ZodParsedType.date;\n      }\n      return ZodParsedType.object;\n\n    default:\n      return ZodParsedType.unknown;\n  }\n};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/helpers/util.ts",
        "start": 1,
        "end": 224,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 224,
          "column": 2,
          "position": 2528
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/helpers/util.ts",
        "start": 1,
        "end": 224,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 224,
          "column": 2,
          "position": 2528
        }
      }
    },
    {
      "format": "typescript",
      "lines": 34,
      "fragment": "import type {\n  ZodArray,\n  ZodNullable,\n  ZodObject,\n  ZodOptional,\n  ZodRawShape,\n  ZodTuple,\n  ZodTupleItems,\n  ZodTypeAny,\n} from \"../types.js\";\n\nexport namespace partialUtil {\n  export type DeepPartial<T extends ZodTypeAny> = T extends ZodObject<ZodRawShape>\n    ? ZodObject<\n        { [k in keyof T[\"shape\"]]: ZodOptional<DeepPartial<T[\"shape\"][k]>> },\n        T[\"_def\"][\"unknownKeys\"],\n        T[\"_def\"][\"catchall\"]\n      >\n    : T extends ZodArray<infer Type, infer Card>\n      ? ZodArray<DeepPartial<Type>, Card>\n      : T extends ZodOptional<infer Type>\n        ? ZodOptional<DeepPartial<Type>>\n        : T extends ZodNullable<infer Type>\n          ? ZodNullable<DeepPartial<Type>>\n          : T extends ZodTuple<infer Items>\n            ? {\n                [k in keyof Items]: Items[k] extends ZodTypeAny ? DeepPartial<Items[k]> : never;\n              } extends infer PI\n              ? PI extends ZodTupleItems\n                ? ZodTuple<PI>\n                : never\n              : never\n            : T;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/helpers/partialUtil.ts",
        "start": 1,
        "end": 34,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 34,
          "column": 2,
          "position": 318
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/helpers/partialUtil.ts",
        "start": 1,
        "end": 34,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 34,
          "column": 2,
          "position": 318
        }
      }
    },
    {
      "format": "typescript",
      "lines": 176,
      "fragment": "import type { IssueData, ZodErrorMap, ZodIssue } from \"../ZodError.js\";\nimport { getErrorMap } from \"../errors.js\";\nimport defaultErrorMap from \"../locales/en.js\";\nimport type { ZodParsedType } from \"./util.js\";\n\nexport const makeIssue = (params: {\n  data: any;\n  path: (string | number)[];\n  errorMaps: ZodErrorMap[];\n  issueData: IssueData;\n}): ZodIssue => {\n  const { data, path, errorMaps, issueData } = params;\n  const fullPath = [...path, ...(issueData.path || [])];\n  const fullIssue = {\n    ...issueData,\n    path: fullPath,\n  };\n\n  if (issueData.message !== undefined) {\n    return {\n      ...issueData,\n      path: fullPath,\n      message: issueData.message,\n    };\n  }\n\n  let errorMessage = \"\";\n  const maps = errorMaps\n    .filter((m) => !!m)\n    .slice()\n    .reverse();\n  for (const map of maps) {\n    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n  }\n\n  return {\n    ...issueData,\n    path: fullPath,\n    message: errorMessage,\n  };\n};\n\nexport type ParseParams = {\n  path: (string | number)[];\n  errorMap: ZodErrorMap;\n  async: boolean;\n};\n\nexport type ParsePathComponent = string | number;\nexport type ParsePath = ParsePathComponent[];\nexport const EMPTY_PATH: ParsePath = [];\n\nexport interface ParseContext {\n  readonly common: {\n    readonly issues: ZodIssue[];\n    readonly contextualErrorMap?: ZodErrorMap | undefined;\n    readonly async: boolean;\n  };\n  readonly path: ParsePath;\n  readonly schemaErrorMap?: ZodErrorMap | undefined;\n  readonly parent: ParseContext | null;\n  readonly data: any;\n  readonly parsedType: ZodParsedType;\n}\n\nexport type ParseInput = {\n  data: any;\n  path: (string | number)[];\n  parent: ParseContext;\n};\n\nexport function addIssueToContext(ctx: ParseContext, issueData: IssueData): void {\n  const overrideMap = getErrorMap();\n  const issue = makeIssue({\n    issueData: issueData,\n    data: ctx.data,\n    path: ctx.path,\n    errorMaps: [\n      ctx.common.contextualErrorMap, // contextual error map is first priority\n      ctx.schemaErrorMap, // then schema-bound map if available\n      overrideMap, // then global override map\n      overrideMap === defaultErrorMap ? undefined : defaultErrorMap, // then global default map\n    ].filter((x) => !!x),\n  });\n  ctx.common.issues.push(issue);\n}\n\nexport type ObjectPair = {\n  key: SyncParseReturnType<any>;\n  value: SyncParseReturnType<any>;\n};\nexport class ParseStatus {\n  value: \"aborted\" | \"dirty\" | \"valid\" = \"valid\";\n  dirty(): void {\n    if (this.value === \"valid\") this.value = \"dirty\";\n  }\n  abort(): void {\n    if (this.value !== \"aborted\") this.value = \"aborted\";\n  }\n\n  static mergeArray(status: ParseStatus, results: SyncParseReturnType<any>[]): SyncParseReturnType {\n    const arrayValue: any[] = [];\n    for (const s of results) {\n      if (s.status === \"aborted\") return INVALID;\n      if (s.status === \"dirty\") status.dirty();\n      arrayValue.push(s.value);\n    }\n\n    return { status: status.value, value: arrayValue };\n  }\n\n  static async mergeObjectAsync(\n    status: ParseStatus,\n    pairs: { key: ParseReturnType<any>; value: ParseReturnType<any> }[]\n  ): Promise<SyncParseReturnType<any>> {\n    const syncPairs: ObjectPair[] = [];\n    for (const pair of pairs) {\n      const key = await pair.key;\n      const value = await pair.value;\n      syncPairs.push({\n        key,\n        value,\n      });\n    }\n    return ParseStatus.mergeObjectSync(status, syncPairs);\n  }\n\n  static mergeObjectSync(\n    status: ParseStatus,\n    pairs: {\n      key: SyncParseReturnType<any>;\n      value: SyncParseReturnType<any>;\n      alwaysSet?: boolean;\n    }[]\n  ): SyncParseReturnType {\n    const finalObject: any = {};\n    for (const pair of pairs) {\n      const { key, value } = pair;\n      if (key.status === \"aborted\") return INVALID;\n      if (value.status === \"aborted\") return INVALID;\n      if (key.status === \"dirty\") status.dirty();\n      if (value.status === \"dirty\") status.dirty();\n\n      if (key.value !== \"__proto__\" && (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n        finalObject[key.value] = value.value;\n      }\n    }\n\n    return { status: status.value, value: finalObject };\n  }\n}\nexport interface ParseResult {\n  status: \"aborted\" | \"dirty\" | \"valid\";\n  data: any;\n}\n\nexport type INVALID = { status: \"aborted\" };\nexport const INVALID: INVALID = Object.freeze({\n  status: \"aborted\",\n});\n\nexport type DIRTY<T> = { status: \"dirty\"; value: T };\nexport const DIRTY = <T>(value: T): DIRTY<T> => ({ status: \"dirty\", value });\n\nexport type OK<T> = { status: \"valid\"; value: T };\nexport const OK = <T>(value: T): OK<T> => ({ status: \"valid\", value });\n\nexport type SyncParseReturnType<T = any> = OK<T> | DIRTY<T> | INVALID;\nexport type AsyncParseReturnType<T> = Promise<SyncParseReturnType<T>>;\nexport type ParseReturnType<T> = SyncParseReturnType<T> | AsyncParseReturnType<T>;\n\nexport const isAborted = (x: ParseReturnType<any>): x is INVALID => (x as any).status === \"aborted\";\nexport const isDirty = <T>(x: ParseReturnType<T>): x is OK<T> | DIRTY<T> => (x as any).status === \"dirty\";\nexport const isValid = <T>(x: ParseReturnType<T>): x is OK<T> => (x as any).status === \"valid\";\nexport const isAsync = <T>(x: ParseReturnType<T>): x is AsyncParseReturnType<T> =>\n  typeof Promise !== \"undefined\" && x instanceof Promise;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/helpers/parseUtil.ts",
        "start": 1,
        "end": 176,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 176,
          "column": 2,
          "position": 1943
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/helpers/parseUtil.ts",
        "start": 1,
        "end": 176,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 176,
          "column": 2,
          "position": 1943
        }
      }
    },
    {
      "format": "typescript",
      "lines": 17,
      "fragment": "export namespace enumUtil {\n  type UnionToIntersectionFn<T> = (T extends unknown ? (k: () => T) => void : never) extends (\n    k: infer Intersection\n  ) => void\n    ? Intersection\n    : never;\n\n  type GetUnionLast<T> = UnionToIntersectionFn<T> extends () => infer Last ? Last : never;\n\n  type UnionToTuple<T, Tuple extends unknown[] = []> = [T] extends [never]\n    ? Tuple\n    : UnionToTuple<Exclude<T, GetUnionLast<T>>, [GetUnionLast<T>, ...Tuple]>;\n\n  type CastToStringTuple<T> = T extends [string, ...string[]] ? T : never;\n\n  export type UnionToTupleString<T> = CastToStringTuple<UnionToTuple<T>>;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/helpers/enumUtil.ts",
        "start": 1,
        "end": 17,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 17,
          "column": 2,
          "position": 238
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/helpers/enumUtil.ts",
        "start": 1,
        "end": 17,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 17,
          "column": 2,
          "position": 238
        }
      }
    },
    {
      "format": "typescript",
      "lines": 80,
      "fragment": "import Benchmark from \"benchmark\";\n\nimport { z } from \"zod/v3\";\n\nconst doubleSuite = new Benchmark.Suite(\"z.union: double\");\nconst manySuite = new Benchmark.Suite(\"z.union: many\");\n\nconst aSchema = z.object({\n  type: z.literal(\"a\"),\n});\nconst objA = {\n  type: \"a\",\n};\n\nconst bSchema = z.object({\n  type: z.literal(\"b\"),\n});\nconst objB = {\n  type: \"b\",\n};\n\nconst cSchema = z.object({\n  type: z.literal(\"c\"),\n});\nconst objC = {\n  type: \"c\",\n};\n\nconst dSchema = z.object({\n  type: z.literal(\"d\"),\n});\n\nconst double = z.union([aSchema, bSchema]);\nconst many = z.union([aSchema, bSchema, cSchema, dSchema]);\n\ndoubleSuite\n  .add(\"valid: a\", () => {\n    double.parse(objA);\n  })\n  .add(\"valid: b\", () => {\n    double.parse(objB);\n  })\n  .add(\"invalid: null\", () => {\n    try {\n      double.parse(null);\n    } catch (_err) {}\n  })\n  .add(\"invalid: wrong shape\", () => {\n    try {\n      double.parse(objC);\n    } catch (_err) {}\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`${(doubleSuite as any).name}: ${e.target}`);\n  });\n\nmanySuite\n  .add(\"valid: a\", () => {\n    many.parse(objA);\n  })\n  .add(\"valid: c\", () => {\n    many.parse(objC);\n  })\n  .add(\"invalid: null\", () => {\n    try {\n      many.parse(null);\n    } catch (_err) {}\n  })\n  .add(\"invalid: wrong shape\", () => {\n    try {\n      many.parse({ type: \"unknown\" });\n    } catch (_err) {}\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`${(manySuite as any).name}: ${e.target}`);\n  });\n\nexport default {\n  suites: [doubleSuite, manySuite],\n};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/benchmarks/union.ts",
        "start": 1,
        "end": 80,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 80,
          "column": 2,
          "position": 688
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/benchmarks/union.ts",
        "start": 1,
        "end": 80,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 80,
          "column": 2,
          "position": 688
        }
      }
    },
    {
      "format": "typescript",
      "lines": 55,
      "fragment": "import Benchmark from \"benchmark\";\n\nimport { z } from \"zod/v3\";\n\nconst SUITE_NAME = \"z.string\";\nconst suite = new Benchmark.Suite(SUITE_NAME);\n\nconst empty = \"\";\nconst short = \"short\";\nconst long = \"long\".repeat(256);\nconst manual = (str: unknown) => {\n  if (typeof str !== \"string\") {\n    throw new Error(\"Not a string\");\n  }\n\n  return str;\n};\nconst stringSchema = z.string();\nconst optionalStringSchema = z.string().optional();\nconst optionalNullableStringSchema = z.string().optional().nullable();\n\nsuite\n  .add(\"empty string\", () => {\n    stringSchema.parse(empty);\n  })\n  .add(\"short string\", () => {\n    stringSchema.parse(short);\n  })\n  .add(\"long string\", () => {\n    stringSchema.parse(long);\n  })\n  .add(\"optional string\", () => {\n    optionalStringSchema.parse(long);\n  })\n  .add(\"nullable string\", () => {\n    optionalNullableStringSchema.parse(long);\n  })\n  .add(\"nullable (null) string\", () => {\n    optionalNullableStringSchema.parse(null);\n  })\n  .add(\"invalid: null\", () => {\n    try {\n      stringSchema.parse(null);\n    } catch (_err) {}\n  })\n  .add(\"manual parser: long\", () => {\n    manual(long);\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`${SUITE_NAME}: ${e.target}`);\n  });\n\nexport default {\n  suites: [suite],\n};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/benchmarks/string.ts",
        "start": 1,
        "end": 55,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 55,
          "column": 2,
          "position": 484
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/benchmarks/string.ts",
        "start": 1,
        "end": 55,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 55,
          "column": 2,
          "position": 484
        }
      }
    },
    {
      "format": "typescript",
      "lines": 63,
      "fragment": "import Benchmark from \"benchmark\";\n\nimport { z } from \"zod/v3\";\n\nconst shortSuite = new Benchmark.Suite(\"realworld\");\n\nconst People = z.array(\n  z.object({\n    type: z.literal(\"person\"),\n    hair: z.enum([\"blue\", \"brown\"]),\n    active: z.boolean(),\n    name: z.string(),\n    age: z.number().int(),\n    hobbies: z.array(z.string()),\n    address: z.object({\n      street: z.string(),\n      zip: z.string(),\n      country: z.string(),\n    }),\n  })\n);\n\nlet i = 0;\n\nfunction num() {\n  return ++i;\n}\n\nfunction str() {\n  return (++i % 100).toString(16);\n}\n\nfunction array<T>(fn: () => T): T[] {\n  return Array.from({ length: ++i % 10 }, () => fn());\n}\n\nconst people = Array.from({ length: 100 }, () => {\n  return {\n    type: \"person\",\n    hair: i % 2 ? \"blue\" : \"brown\",\n    active: !!(i % 2),\n    name: str(),\n    age: num(),\n    hobbies: array(str),\n    address: {\n      street: str(),\n      zip: str(),\n      country: str(),\n    },\n  };\n});\n\nshortSuite\n  .add(\"valid\", () => {\n    People.parse(people);\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`${(shortSuite as any).name}: ${e.target}`);\n  });\n\nexport default {\n  suites: [shortSuite],\n};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/benchmarks/realworld.ts",
        "start": 1,
        "end": 63,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 63,
          "column": 2,
          "position": 558
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/benchmarks/realworld.ts",
        "start": 1,
        "end": 63,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 63,
          "column": 2,
          "position": 558
        }
      }
    },
    {
      "format": "typescript",
      "lines": 162,
      "fragment": "import Benchmark from \"benchmark\";\n\nimport { z } from \"zod/v3\";\nimport { Mocker } from \"../tests/Mocker.js\";\n\nconst val = new Mocker();\n\nconst enumSuite = new Benchmark.Suite(\"z.enum\");\nconst enumSchema = z.enum([\"a\", \"b\", \"c\"]);\n\nenumSuite\n  .add(\"valid\", () => {\n    enumSchema.parse(\"a\");\n  })\n  .add(\"invalid\", () => {\n    try {\n      enumSchema.parse(\"x\");\n    } catch (_e: any) {}\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`z.enum: ${e.target}`);\n  });\n\nconst longEnumSuite = new Benchmark.Suite(\"long z.enum\");\nconst longEnumSchema = z.enum([\n  \"one\",\n  \"two\",\n  \"three\",\n  \"four\",\n  \"five\",\n  \"six\",\n  \"seven\",\n  \"eight\",\n  \"nine\",\n  \"ten\",\n  \"eleven\",\n  \"twelve\",\n  \"thirteen\",\n  \"fourteen\",\n  \"fifteen\",\n  \"sixteen\",\n  \"seventeen\",\n]);\n\nlongEnumSuite\n  .add(\"valid\", () => {\n    longEnumSchema.parse(\"five\");\n  })\n  .add(\"invalid\", () => {\n    try {\n      longEnumSchema.parse(\"invalid\");\n    } catch (_e: any) {}\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`long z.enum: ${e.target}`);\n  });\n\nconst undefinedSuite = new Benchmark.Suite(\"z.undefined\");\nconst undefinedSchema = z.undefined();\n\nundefinedSuite\n  .add(\"valid\", () => {\n    undefinedSchema.parse(undefined);\n  })\n  .add(\"invalid\", () => {\n    try {\n      undefinedSchema.parse(1);\n    } catch (_e: any) {}\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`z.undefined: ${e.target}`);\n  });\n\nconst literalSuite = new Benchmark.Suite(\"z.literal\");\nconst short = \"short\";\nconst bad = \"bad\";\nconst literalSchema = z.literal(\"short\");\n\nliteralSuite\n  .add(\"valid\", () => {\n    literalSchema.parse(short);\n  })\n  .add(\"invalid\", () => {\n    try {\n      literalSchema.parse(bad);\n    } catch (_e: any) {}\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`z.literal: ${e.target}`);\n  });\n\nconst numberSuite = new Benchmark.Suite(\"z.number\");\nconst numberSchema = z.number().int();\n\nnumberSuite\n  .add(\"valid\", () => {\n    numberSchema.parse(1);\n  })\n  .add(\"invalid type\", () => {\n    try {\n      numberSchema.parse(\"bad\");\n    } catch (_e: any) {}\n  })\n  .add(\"invalid number\", () => {\n    try {\n      numberSchema.parse(0.5);\n    } catch (_e: any) {}\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`z.number: ${e.target}`);\n  });\n\nconst dateSuite = new Benchmark.Suite(\"z.date\");\n\nconst plainDate = z.date();\nconst minMaxDate = z.date().min(new Date(\"2021-01-01\")).max(new Date(\"2030-01-01\"));\n\ndateSuite\n  .add(\"valid\", () => {\n    plainDate.parse(new Date());\n  })\n  .add(\"invalid\", () => {\n    try {\n      plainDate.parse(1);\n    } catch (_e: any) {}\n  })\n  .add(\"valid min and max\", () => {\n    minMaxDate.parse(new Date(\"2023-01-01\"));\n  })\n  .add(\"invalid min\", () => {\n    try {\n      minMaxDate.parse(new Date(\"2019-01-01\"));\n    } catch (_e: any) {}\n  })\n  .add(\"invalid max\", () => {\n    try {\n      minMaxDate.parse(new Date(\"2031-01-01\"));\n    } catch (_e: any) {}\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`z.date: ${e.target}`);\n  });\n\nconst symbolSuite = new Benchmark.Suite(\"z.symbol\");\nconst symbolSchema = z.symbol();\n\nsymbolSuite\n  .add(\"valid\", () => {\n    symbolSchema.parse(val.symbol);\n  })\n  .add(\"invalid\", () => {\n    try {\n      symbolSchema.parse(1);\n    } catch (_e: any) {}\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`z.symbol: ${e.target}`);\n  });\n\nexport default {\n  suites: [enumSuite, longEnumSuite, undefinedSuite, literalSuite, numberSuite, dateSuite, symbolSuite],\n};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/benchmarks/primitives.ts",
        "start": 1,
        "end": 162,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 162,
          "column": 2,
          "position": 1440
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/benchmarks/primitives.ts",
        "start": 1,
        "end": 162,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 162,
          "column": 2,
          "position": 1440
        }
      }
    },
    {
      "format": "typescript",
      "lines": 69,
      "fragment": "import Benchmark from \"benchmark\";\n\nimport { z } from \"zod/v3\";\n\nconst emptySuite = new Benchmark.Suite(\"z.object: empty\");\nconst shortSuite = new Benchmark.Suite(\"z.object: short\");\nconst longSuite = new Benchmark.Suite(\"z.object: long\");\n\nconst empty = z.object({});\nconst short = z.object({\n  string: z.string(),\n});\nconst long = z.object({\n  string: z.string(),\n  number: z.number(),\n  boolean: z.boolean(),\n});\n\nemptySuite\n  .add(\"valid\", () => {\n    empty.parse({});\n  })\n  .add(\"valid: extra keys\", () => {\n    empty.parse({ string: \"string\" });\n  })\n  .add(\"invalid: null\", () => {\n    try {\n      empty.parse(null);\n    } catch (_err) {}\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`${(emptySuite as any).name}: ${e.target}`);\n  });\n\nshortSuite\n  .add(\"valid\", () => {\n    short.parse({ string: \"string\" });\n  })\n  .add(\"valid: extra keys\", () => {\n    short.parse({ string: \"string\", number: 42 });\n  })\n  .add(\"invalid: null\", () => {\n    try {\n      short.parse(null);\n    } catch (_err) {}\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`${(shortSuite as any).name}: ${e.target}`);\n  });\n\nlongSuite\n  .add(\"valid\", () => {\n    long.parse({ string: \"string\", number: 42, boolean: true });\n  })\n  .add(\"valid: extra keys\", () => {\n    long.parse({ string: \"string\", number: 42, boolean: true, list: [] });\n  })\n  .add(\"invalid: null\", () => {\n    try {\n      long.parse(null);\n    } catch (_err) {}\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`${(longSuite as any).name}: ${e.target}`);\n  });\n\nexport default {\n  suites: [emptySuite, shortSuite, longSuite],\n};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/benchmarks/object.ts",
        "start": 1,
        "end": 69,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 69,
          "column": 2,
          "position": 713
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/benchmarks/object.ts",
        "start": 1,
        "end": 69,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 69,
          "column": 2,
          "position": 713
        }
      }
    },
    {
      "format": "typescript",
      "lines": 57,
      "fragment": "import Benchmark from \"benchmark\";\n\nconst suite = new Benchmark.Suite(\"ipv4\");\n\nconst DATA = \"127.0.0.1\";\nconst ipv4RegexA =\n  /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;\nconst ipv4RegexB =\n  /^(?:(?:(?=(25[0-5]))\\1|(?=(2[0-4][0-9]))\\2|(?=(1[0-9]{2}))\\3|(?=([0-9]{1,2}))\\4)\\.){3}(?:(?=(25[0-5]))\\5|(?=(2[0-4][0-9]))\\6|(?=(1[0-9]{2}))\\7|(?=([0-9]{1,2}))\\8)$/;\nconst ipv4RegexC = /^(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)$/;\nconst ipv4RegexD = /^(\\b25[0-5]|\\b2[0-4][0-9]|\\b[01]?[0-9][0-9]?)(\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/;\nconst ipv4RegexE = /^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)\\.){3}(25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)$/;\nconst ipv4RegexF = /^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)\\.?\\b){4}$/;\nconst ipv4RegexG = /^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)(\\.(?!$)|$)){4}$/;\nconst ipv4RegexH = /^((25[0-5]|(2[0-4]|1[0-9]|[1-9]|)[0-9])(\\.(?!$)|$)){4}$/;\nconst ipv4RegexI =\n  /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\n\nsuite\n  .add(\"A\", () => {\n    return ipv4RegexA.test(DATA);\n  })\n  .add(\"B\", () => {\n    return ipv4RegexB.test(DATA);\n  })\n  .add(\"C\", () => {\n    return ipv4RegexC.test(DATA);\n  })\n  .add(\"D\", () => {\n    return ipv4RegexD.test(DATA);\n  })\n  .add(\"E\", () => {\n    return ipv4RegexE.test(DATA);\n  })\n  .add(\"F\", () => {\n    return ipv4RegexF.test(DATA);\n  })\n  .add(\"G\", () => {\n    return ipv4RegexG.test(DATA);\n  })\n  .add(\"H\", () => {\n    return ipv4RegexH.test(DATA);\n  })\n  .add(\"I\", () => {\n    return ipv4RegexI.test(DATA);\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`${suite.name!}: ${e.target}`);\n  });\n\nexport default {\n  suites: [suite],\n};\n\nif (require.main === module) {\n  suite.run();\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/benchmarks/ipv4.ts",
        "start": 1,
        "end": 57,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 57,
          "column": 2,
          "position": 473
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/benchmarks/ipv4.ts",
        "start": 1,
        "end": 57,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 57,
          "column": 2,
          "position": 473
        }
      }
    },
    {
      "format": "typescript",
      "lines": 59,
      "fragment": "import type Benchmark from \"benchmark\";\n\nimport datetimeBenchmarks from \"./datetime.js\";\nimport discriminatedUnionBenchmarks from \"./discriminatedUnion.js\";\nimport ipv4Benchmarks from \"./ipv4.js\";\nimport objectBenchmarks from \"./object.js\";\nimport primitiveBenchmarks from \"./primitives.js\";\nimport realworld from \"./realworld.js\";\nimport stringBenchmarks from \"./string.js\";\nimport unionBenchmarks from \"./union.js\";\n\nconst argv = process.argv.slice(2);\nlet suites: Benchmark.Suite[] = [];\n\nif (!argv.length) {\n  suites = [\n    ...realworld.suites,\n    ...primitiveBenchmarks.suites,\n    ...stringBenchmarks.suites,\n    ...objectBenchmarks.suites,\n    ...unionBenchmarks.suites,\n    ...discriminatedUnionBenchmarks.suites,\n  ];\n} else {\n  if (argv.includes(\"--realworld\")) {\n    suites.push(...realworld.suites);\n  }\n  if (argv.includes(\"--primitives\")) {\n    suites.push(...primitiveBenchmarks.suites);\n  }\n  if (argv.includes(\"--string\")) {\n    suites.push(...stringBenchmarks.suites);\n  }\n  if (argv.includes(\"--object\")) {\n    suites.push(...objectBenchmarks.suites);\n  }\n  if (argv.includes(\"--union\")) {\n    suites.push(...unionBenchmarks.suites);\n  }\n  if (argv.includes(\"--discriminatedUnion\")) {\n    suites.push(...datetimeBenchmarks.suites);\n  }\n  if (argv.includes(\"--datetime\")) {\n    suites.push(...datetimeBenchmarks.suites);\n  }\n  if (argv.includes(\"--ipv4\")) {\n    suites.push(...ipv4Benchmarks.suites);\n  }\n}\n\nfor (const suite of suites) {\n  suite.run({});\n}\n\n// exit on Ctrl-C\nprocess.on(\"SIGINT\", function () {\n  console.log(\"Exiting...\");\n  process.exit();\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/benchmarks/index.ts",
        "start": 1,
        "end": 59,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 59,
          "column": 2,
          "position": 486
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/benchmarks/index.ts",
        "start": 1,
        "end": 59,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 59,
          "column": 2,
          "position": 486
        }
      }
    },
    {
      "format": "typescript",
      "lines": 80,
      "fragment": "import Benchmark from \"benchmark\";\n\nimport { z } from \"zod/v3\";\n\nconst doubleSuite = new Benchmark.Suite(\"z.discriminatedUnion: double\");\nconst manySuite = new Benchmark.Suite(\"z.discriminatedUnion: many\");\n\nconst aSchema = z.object({\n  type: z.literal(\"a\"),\n});\nconst objA = {\n  type: \"a\",\n};\n\nconst bSchema = z.object({\n  type: z.literal(\"b\"),\n});\nconst objB = {\n  type: \"b\",\n};\n\nconst cSchema = z.object({\n  type: z.literal(\"c\"),\n});\nconst objC = {\n  type: \"c\",\n};\n\nconst dSchema = z.object({\n  type: z.literal(\"d\"),\n});\n\nconst double = z.discriminatedUnion(\"type\", [aSchema, bSchema]);\nconst many = z.discriminatedUnion(\"type\", [aSchema, bSchema, cSchema, dSchema]);\n\ndoubleSuite\n  .add(\"valid: a\", () => {\n    double.parse(objA);\n  })\n  .add(\"valid: b\", () => {\n    double.parse(objB);\n  })\n  .add(\"invalid: null\", () => {\n    try {\n      double.parse(null);\n    } catch (_err) {}\n  })\n  .add(\"invalid: wrong shape\", () => {\n    try {\n      double.parse(objC);\n    } catch (_err) {}\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`${(doubleSuite as any).name}: ${e.target}`);\n  });\n\nmanySuite\n  .add(\"valid: a\", () => {\n    many.parse(objA);\n  })\n  .add(\"valid: c\", () => {\n    many.parse(objC);\n  })\n  .add(\"invalid: null\", () => {\n    try {\n      many.parse(null);\n    } catch (_err) {}\n  })\n  .add(\"invalid: wrong shape\", () => {\n    try {\n      many.parse({ type: \"unknown\" });\n    } catch (_err) {}\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`${(manySuite as any).name}: ${e.target}`);\n  });\n\nexport default {\n  suites: [doubleSuite, manySuite],\n};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/benchmarks/discriminatedUnion.ts",
        "start": 1,
        "end": 80,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 80,
          "column": 2,
          "position": 694
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/benchmarks/discriminatedUnion.ts",
        "start": 1,
        "end": 80,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 80,
          "column": 2,
          "position": 688
        }
      }
    },
    {
      "format": "typescript",
      "lines": 58,
      "fragment": "import Benchmark from \"benchmark\";\n\nconst datetimeValidationSuite = new Benchmark.Suite(\"datetime\");\n\nconst DATA = \"2021-01-01\";\nconst MONTHS_31 = new Set([1, 3, 5, 7, 8, 10, 12]);\nconst MONTHS_30 = new Set([4, 6, 9, 11]);\n\nconst simpleDatetimeRegex = /^(\\d{4})-(\\d{2})-(\\d{2})$/;\nconst datetimeRegexNoLeapYearValidation =\n  /^\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\d|2\\d))$/;\nconst datetimeRegexWithLeapYearValidation =\n  /^((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))$/;\n\ndatetimeValidationSuite\n  .add(\"new Date()\", () => {\n    return !Number.isNaN(new Date(DATA).getTime());\n  })\n  .add(\"regex (no validation)\", () => {\n    return simpleDatetimeRegex.test(DATA);\n  })\n  .add(\"regex (no leap year)\", () => {\n    return datetimeRegexNoLeapYearValidation.test(DATA);\n  })\n  .add(\"regex (w/ leap year)\", () => {\n    return datetimeRegexWithLeapYearValidation.test(DATA);\n  })\n  .add(\"capture groups + code\", () => {\n    const match = DATA.match(simpleDatetimeRegex);\n    if (!match) return false;\n\n    // Extract year, month, and day from the capture groups\n    const year = Number.parseInt(match[1], 10);\n    const month = Number.parseInt(match[2], 10); // month is 0-indexed in JavaScript Date, so subtract 1\n    const day = Number.parseInt(match[3], 10);\n\n    if (month === 2) {\n      if ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0) {\n        return day <= 29;\n      }\n      return day <= 28;\n    }\n    if (MONTHS_30.has(month)) {\n      return day <= 30;\n    }\n    if (MONTHS_31.has(month)) {\n      return day <= 31;\n    }\n    return false;\n  })\n\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`${datetimeValidationSuite.name!}: ${e.target}`);\n  });\n\nexport default {\n  suites: [datetimeValidationSuite],\n};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/benchmarks/datetime.ts",
        "start": 1,
        "end": 58,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 58,
          "column": 2,
          "position": 577
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/benchmarks/datetime.ts",
        "start": 1,
        "end": 58,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 58,
          "column": 2,
          "position": 577
        }
      }
    },
    {
      "format": "typescript",
      "lines": 28,
      "fragment": "import { Pair } from '../../nodes/Pair';\nimport type { Scalar } from '../../nodes/Scalar';\nimport type { ToJSContext } from '../../nodes/toJS';\nimport { YAMLMap } from '../../nodes/YAMLMap';\nimport type { Schema } from '../../schema/Schema';\nimport type { StringifyContext } from '../../stringify/stringify';\nimport type { CreateNodeContext } from '../../util';\nimport type { CollectionTag } from '../types';\nexport declare class YAMLSet<T = unknown> extends YAMLMap<T, Scalar<null> | null> {\n    static tag: string;\n    constructor(schema?: Schema);\n    add(key: T | Pair<T, Scalar<null> | null> | {\n        key: T;\n        value: Scalar<null> | null;\n    }): void;\n    /**\n     * If `keepPair` is `true`, returns the Pair matching `key`.\n     * Otherwise, returns the value of that Pair's key.\n     */\n    get(key: unknown, keepPair?: boolean): any;\n    set(key: T, value: boolean): void;\n    /** @deprecated Will throw; `value` must be boolean */\n    set(key: T, value: null): void;\n    toJSON(_?: unknown, ctx?: ToJSContext): any;\n    toString(ctx?: StringifyContext, onComment?: () => void, onChompKeep?: () => void): string;\n    static from(schema: Schema, iterable: unknown, ctx: CreateNodeContext): YAMLSet;\n}\nexport declare const set: CollectionTag;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/schema/yaml-1.1/set.d.ts",
        "start": 1,
        "end": 28,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 28,
          "column": 2,
          "position": 390
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/schema/yaml-1.1/set.d.ts",
        "start": 1,
        "end": 28,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 28,
          "column": 2,
          "position": 390
        }
      }
    },
    {
      "format": "typescript",
      "lines": 22,
      "fragment": "import type { ToJSContext } from '../../nodes/toJS';\nimport { YAMLMap } from '../../nodes/YAMLMap';\nimport { YAMLSeq } from '../../nodes/YAMLSeq';\nimport type { CreateNodeContext } from '../../util';\nimport type { Schema } from '../Schema';\nimport type { CollectionTag } from '../types';\nexport declare class YAMLOMap extends YAMLSeq {\n    static tag: string;\n    constructor();\n    add: typeof YAMLMap.prototype.add;\n    delete: typeof YAMLMap.prototype.delete;\n    get: typeof YAMLMap.prototype.get;\n    has: typeof YAMLMap.prototype.has;\n    set: typeof YAMLMap.prototype.set;\n    /**\n     * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,\n     * but TypeScript won't allow widening the signature of a child method.\n     */\n    toJSON(_?: unknown, ctx?: ToJSContext): unknown[];\n    static from(schema: Schema, iterable: unknown, ctx: CreateNodeContext): YAMLOMap;\n}\nexport declare const omap: CollectionTag;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/schema/yaml-1.1/omap.d.ts",
        "start": 1,
        "end": 22,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 22,
          "column": 2,
          "position": 245
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/schema/yaml-1.1/omap.d.ts",
        "start": 1,
        "end": 22,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 22,
          "column": 2,
          "position": 245
        }
      }
    },
    {
      "format": "typescript",
      "lines": 35,
      "fragment": "import { MessagePort } from 'node:worker_threads';\nimport { R as RequiredProperty } from '../../types-Cxp8y2TL.js';\n\ntype ScopedImport = (specifier: string, parent: string) => Promise<any>;\n\ntype TsconfigOptions = false | string;\ntype InitializationOptions = {\n    namespace?: string;\n    port?: MessagePort;\n    tsconfig?: TsconfigOptions;\n};\ntype RegisterOptions = {\n    namespace?: string;\n    onImport?: (url: string) => void;\n    tsconfig?: TsconfigOptions;\n};\ntype Unregister = () => Promise<void>;\ntype NamespacedUnregister = Unregister & {\n    import: ScopedImport;\n    unregister: Unregister;\n};\ntype Register = {\n    (options: RequiredProperty<RegisterOptions, 'namespace'>): NamespacedUnregister;\n    (options?: RegisterOptions): Unregister;\n};\ndeclare const register: Register;\n\ntype Options = {\n    parentURL: string;\n    onImport?: (url: string) => void;\n    tsconfig?: TsconfigOptions;\n};\ndeclare const tsImport: (specifier: string, options: string | Options) => Promise<any>;\n\nexport { type InitializationOptions, type NamespacedUnregister, type Register, type RegisterOptions, type ScopedImport, type Unregister, register, tsImport };",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/tsx/dist/esm/api/index.d.mts",
        "start": 1,
        "end": 35,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 35,
          "column": 2,
          "position": 366
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/tsx/dist/esm/api/index.d.mts",
        "start": 1,
        "end": 35,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 35,
          "column": 2,
          "position": 366
        }
      }
    },
    {
      "format": "typescript",
      "lines": 35,
      "fragment": "import { MessagePort } from 'node:worker_threads';\nimport { R as RequiredProperty } from '../../types-Cxp8y2TL.js';\n\ntype ScopedImport = (specifier: string, parent: string) => Promise<any>;\n\ntype TsconfigOptions = false | string;\ntype InitializationOptions = {\n    namespace?: string;\n    port?: MessagePort;\n    tsconfig?: TsconfigOptions;\n};\ntype RegisterOptions = {\n    namespace?: string;\n    onImport?: (url: string) => void;\n    tsconfig?: TsconfigOptions;\n};\ntype Unregister = () => Promise<void>;\ntype NamespacedUnregister = Unregister & {\n    import: ScopedImport;\n    unregister: Unregister;\n};\ntype Register = {\n    (options: RequiredProperty<RegisterOptions, 'namespace'>): NamespacedUnregister;\n    (options?: RegisterOptions): Unregister;\n};\ndeclare const register: Register;\n\ntype Options = {\n    parentURL: string;\n    onImport?: (url: string) => void;\n    tsconfig?: TsconfigOptions;\n};\ndeclare const tsImport: (specifier: string, options: string | Options) => Promise<any>;\n\nexport { type InitializationOptions, type NamespacedUnregister, type Register, type RegisterOptions, type ScopedImport, type Unregister, register, tsImport };",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/tsx/dist/esm/api/index.d.cts",
        "start": 1,
        "end": 35,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 35,
          "column": 2,
          "position": 366
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/tsx/dist/esm/api/index.d.mts",
        "start": 1,
        "end": 35,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 35,
          "column": 2,
          "position": 366
        }
      }
    },
    {
      "format": "typescript",
      "lines": 35,
      "fragment": "import { R as RequiredProperty } from '../../types-Cxp8y2TL.js';\n\ntype RegisterOptions = {\n    namespace?: string;\n};\ntype Unregister = () => void;\ntype ScopedRequire = (id: string, fromFile: string | URL) => any;\ntype ScopedResolve = (id: string, fromFile: string | URL, resolveOptions?: {\n    paths?: string[] | undefined;\n}) => string;\ntype NamespacedUnregister = Unregister & {\n    require: ScopedRequire;\n    resolve: ScopedResolve;\n    unregister: Unregister;\n};\ntype Register = {\n    (options: RequiredProperty<RegisterOptions, 'namespace'>): NamespacedUnregister;\n    (options?: RegisterOptions): Unregister;\n};\ndeclare const register: Register;\n\ndeclare const tsxRequire: {\n    (id: string, fromFile: string | URL): any;\n    resolve: {\n        (id: string, fromFile: string | URL, options?: {\n            paths?: string[] | undefined;\n        }): string;\n        paths: (request: string) => string[] | null;\n    };\n    main: NodeJS.Module | undefined;\n    extensions: NodeJS.RequireExtensions;\n    cache: NodeJS.Dict<NodeJS.Module>;\n};\n\nexport { register, tsxRequire as require };",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/tsx/dist/cjs/api/index.d.mts",
        "start": 1,
        "end": 35,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 35,
          "column": 2,
          "position": 382
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/tsx/dist/cjs/api/index.d.mts",
        "start": 1,
        "end": 35,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 35,
          "column": 2,
          "position": 382
        }
      }
    },
    {
      "format": "typescript",
      "lines": 35,
      "fragment": "import { R as RequiredProperty } from '../../types-Cxp8y2TL.js';\n\ntype RegisterOptions = {\n    namespace?: string;\n};\ntype Unregister = () => void;\ntype ScopedRequire = (id: string, fromFile: string | URL) => any;\ntype ScopedResolve = (id: string, fromFile: string | URL, resolveOptions?: {\n    paths?: string[] | undefined;\n}) => string;\ntype NamespacedUnregister = Unregister & {\n    require: ScopedRequire;\n    resolve: ScopedResolve;\n    unregister: Unregister;\n};\ntype Register = {\n    (options: RequiredProperty<RegisterOptions, 'namespace'>): NamespacedUnregister;\n    (options?: RegisterOptions): Unregister;\n};\ndeclare const register: Register;\n\ndeclare const tsxRequire: {\n    (id: string, fromFile: string | URL): any;\n    resolve: {\n        (id: string, fromFile: string | URL, options?: {\n            paths?: string[] | undefined;\n        }): string;\n        paths: (request: string) => string[] | null;\n    };\n    main: NodeJS.Module | undefined;\n    extensions: NodeJS.RequireExtensions;\n    cache: NodeJS.Dict<NodeJS.Module>;\n};\n\nexport { register, tsxRequire as require };",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/tsx/dist/cjs/api/index.d.cts",
        "start": 1,
        "end": 35,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 35,
          "column": 2,
          "position": 382
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/tsx/dist/cjs/api/index.d.mts",
        "start": 1,
        "end": 35,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 35,
          "column": 2,
          "position": 382
        }
      }
    },
    {
      "format": "typescript",
      "lines": 34,
      "fragment": "import { JsonSchema7AnyType } from \"./parsers/any.js\";\nimport { JsonSchema7ArrayType } from \"./parsers/array.js\";\nimport { JsonSchema7BigintType } from \"./parsers/bigint.js\";\nimport { JsonSchema7BooleanType } from \"./parsers/boolean.js\";\nimport { JsonSchema7DateType } from \"./parsers/date.js\";\nimport { JsonSchema7EnumType } from \"./parsers/enum.js\";\nimport { JsonSchema7AllOfType } from \"./parsers/intersection.js\";\nimport { JsonSchema7LiteralType } from \"./parsers/literal.js\";\nimport { JsonSchema7MapType } from \"./parsers/map.js\";\nimport { JsonSchema7NativeEnumType } from \"./parsers/nativeEnum.js\";\nimport { JsonSchema7NeverType } from \"./parsers/never.js\";\nimport { JsonSchema7NullType } from \"./parsers/null.js\";\nimport { JsonSchema7NullableType } from \"./parsers/nullable.js\";\nimport { JsonSchema7NumberType } from \"./parsers/number.js\";\nimport { JsonSchema7ObjectType } from \"./parsers/object.js\";\nimport { JsonSchema7RecordType } from \"./parsers/record.js\";\nimport { JsonSchema7SetType } from \"./parsers/set.js\";\nimport { JsonSchema7StringType } from \"./parsers/string.js\";\nimport { JsonSchema7TupleType } from \"./parsers/tuple.js\";\nimport { JsonSchema7UndefinedType } from \"./parsers/undefined.js\";\nimport { JsonSchema7UnionType } from \"./parsers/union.js\";\nimport { JsonSchema7UnknownType } from \"./parsers/unknown.js\";\ntype JsonSchema7RefType = {\n    $ref: string;\n};\ntype JsonSchema7Meta = {\n    title?: string;\n    default?: any;\n    description?: string;\n    markdownDescription?: string;\n};\nexport type JsonSchema7TypeUnion = JsonSchema7StringType | JsonSchema7ArrayType | JsonSchema7NumberType | JsonSchema7BigintType | JsonSchema7BooleanType | JsonSchema7DateType | JsonSchema7EnumType | JsonSchema7LiteralType | JsonSchema7NativeEnumType | JsonSchema7NullType | JsonSchema7NumberType | JsonSchema7ObjectType | JsonSchema7RecordType | JsonSchema7TupleType | JsonSchema7UnionType | JsonSchema7UndefinedType | JsonSchema7RefType | JsonSchema7NeverType | JsonSchema7MapType | JsonSchema7AnyType | JsonSchema7NullableType | JsonSchema7AllOfType | JsonSchema7UnknownType | JsonSchema7SetType;\nexport type JsonSchema7Type = JsonSchema7TypeUnion & JsonSchema7Meta;\nexport {};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod-to-json-schema/dist/types/parseTypes.d.ts",
        "start": 1,
        "end": 34,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 34,
          "column": 2,
          "position": 469
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod-to-json-schema/dist/types/parseTypes.d.ts",
        "start": 1,
        "end": 34,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 34,
          "column": 2,
          "position": 469
        }
      }
    },
    {
      "format": "typescript",
      "lines": 40,
      "fragment": "export * from \"./Options.js\";\nexport * from \"./Refs.js\";\nexport * from \"./errorMessages.js\";\nexport * from \"./getRelativePath.js\";\nexport * from \"./parseDef.js\";\nexport * from \"./parseTypes.js\";\nexport * from \"./parsers/any.js\";\nexport * from \"./parsers/array.js\";\nexport * from \"./parsers/bigint.js\";\nexport * from \"./parsers/boolean.js\";\nexport * from \"./parsers/branded.js\";\nexport * from \"./parsers/catch.js\";\nexport * from \"./parsers/date.js\";\nexport * from \"./parsers/default.js\";\nexport * from \"./parsers/effects.js\";\nexport * from \"./parsers/enum.js\";\nexport * from \"./parsers/intersection.js\";\nexport * from \"./parsers/literal.js\";\nexport * from \"./parsers/map.js\";\nexport * from \"./parsers/nativeEnum.js\";\nexport * from \"./parsers/never.js\";\nexport * from \"./parsers/null.js\";\nexport * from \"./parsers/nullable.js\";\nexport * from \"./parsers/number.js\";\nexport * from \"./parsers/object.js\";\nexport * from \"./parsers/optional.js\";\nexport * from \"./parsers/pipeline.js\";\nexport * from \"./parsers/promise.js\";\nexport * from \"./parsers/readonly.js\";\nexport * from \"./parsers/record.js\";\nexport * from \"./parsers/set.js\";\nexport * from \"./parsers/string.js\";\nexport * from \"./parsers/tuple.js\";\nexport * from \"./parsers/undefined.js\";\nexport * from \"./parsers/union.js\";\nexport * from \"./parsers/unknown.js\";\nexport * from \"./selectParser.js\";\nexport * from \"./zodToJsonSchema.js\";\nimport { zodToJsonSchema } from \"./zodToJsonSchema.js\";\nexport default zodToJsonSchema;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod-to-json-schema/dist/types/index.d.ts",
        "start": 1,
        "end": 40,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 40,
          "column": 2,
          "position": 360
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod-to-json-schema/dist/types/index.d.ts",
        "start": 1,
        "end": 40,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 40,
          "column": 2,
          "position": 360
        }
      }
    },
    {
      "format": "typescript",
      "lines": 15,
      "fragment": "import { JsonSchema7TypeUnion } from \"./parseTypes.js\";\nimport { Refs } from \"./Refs.js\";\nexport type ErrorMessages<T extends JsonSchema7TypeUnion | {\n    format: string;\n} | {\n    pattern: string;\n}, OmitProperties extends string = \"\"> = Partial<Omit<{\n    [key in keyof T]: string;\n}, OmitProperties | \"type\" | \"errorMessages\">>;\nexport declare function addErrorMessage<T extends {\n    errorMessage?: ErrorMessages<any>;\n}>(res: T, key: keyof T, errorMessage: string | undefined, refs: Refs): void;\nexport declare function setResponseValueAndErrors<Json7Type extends JsonSchema7TypeUnion & {\n    errorMessage?: ErrorMessages<Json7Type>;\n}, Key extends keyof Omit<Json7Type, \"errorMessage\">>(res: Json7Type, key: Key, value: Json7Type[Key], errorMessage: string | undefined, refs: Refs): void;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod-to-json-schema/dist/types/errorMessages.d.ts",
        "start": 1,
        "end": 15,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 15,
          "column": 2,
          "position": 261
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod-to-json-schema/dist/types/errorMessages.d.ts",
        "start": 1,
        "end": 15,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 15,
          "column": 2,
          "position": 261
        }
      }
    },
    {
      "format": "typescript",
      "lines": 17,
      "fragment": "import { ZodTypeDef } from \"zod\";\nimport { Options, Targets } from \"./Options.js\";\nimport { JsonSchema7Type } from \"./parseTypes.js\";\nexport type Refs = {\n    seen: Map<ZodTypeDef, Seen>;\n    currentPath: string[];\n    propertyPath: string[] | undefined;\n    flags: {\n        hasReferencedOpenAiAnyType: boolean;\n    };\n} & Options<Targets>;\nexport type Seen = {\n    def: ZodTypeDef;\n    path: string[];\n    jsonSchema: JsonSchema7Type | undefined;\n};\nexport declare const getRefs: (options?: string | Partial<Options<Targets>>) => Refs;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod-to-json-schema/dist/types/Refs.d.ts",
        "start": 1,
        "end": 17,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 17,
          "column": 2,
          "position": 183
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod-to-json-schema/dist/types/Refs.d.ts",
        "start": 1,
        "end": 17,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 17,
          "column": 2,
          "position": 183
        }
      }
    },
    {
      "format": "typescript",
      "lines": 37,
      "fragment": "import { ZodSchema, ZodTypeDef } from \"zod\";\nimport { Refs, Seen } from \"./Refs\";\nimport { JsonSchema7Type } from \"./parseTypes\";\nexport type Targets = \"jsonSchema7\" | \"jsonSchema2019-09\" | \"openApi3\" | \"openAi\";\nexport type DateStrategy = \"format:date-time\" | \"format:date\" | \"string\" | \"integer\";\nexport declare const ignoreOverride: unique symbol;\nexport type OverrideCallback = (def: ZodTypeDef, refs: Refs, seen: Seen | undefined, forceResolution?: boolean) => JsonSchema7Type | undefined | typeof ignoreOverride;\nexport type PostProcessCallback = (jsonSchema: JsonSchema7Type | undefined, def: ZodTypeDef, refs: Refs) => JsonSchema7Type | undefined;\nexport declare const jsonDescription: PostProcessCallback;\nexport type Options<Target extends Targets = \"jsonSchema7\"> = {\n    name: string | undefined;\n    $refStrategy: \"root\" | \"relative\" | \"none\" | \"seen\";\n    basePath: string[];\n    effectStrategy: \"input\" | \"any\";\n    pipeStrategy: \"input\" | \"output\" | \"all\";\n    dateStrategy: DateStrategy | DateStrategy[];\n    mapStrategy: \"entries\" | \"record\";\n    removeAdditionalStrategy: \"passthrough\" | \"strict\";\n    allowedAdditionalProperties: true | undefined;\n    rejectedAdditionalProperties: false | undefined;\n    target: Target;\n    strictUnions: boolean;\n    definitionPath: string;\n    definitions: Record<string, ZodSchema>;\n    errorMessages: boolean;\n    markdownDescription: boolean;\n    patternStrategy: \"escape\" | \"preserve\";\n    applyRegexFlags: boolean;\n    emailStrategy: \"format:email\" | \"format:idn-email\" | \"pattern:zod\";\n    base64Strategy: \"format:binary\" | \"contentEncoding:base64\" | \"pattern:zod\";\n    nameStrategy: \"ref\" | \"title\";\n    override?: OverrideCallback;\n    postProcess?: PostProcessCallback;\n    openAiAnyTypeName: string;\n};\nexport declare const defaultOptions: Options;\nexport declare const getDefaultOptions: <Target extends Targets>(options: string | Partial<Options<Target>> | undefined) => Options<Target>;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod-to-json-schema/dist/types/Options.d.ts",
        "start": 1,
        "end": 37,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 37,
          "column": 2,
          "position": 540
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod-to-json-schema/dist/types/Options.d.ts",
        "start": 1,
        "end": 37,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 37,
          "column": 2,
          "position": 540
        }
      }
    },
    {
      "format": "typescript",
      "lines": 356,
      "fragment": "import * as core from \"../core/index.js\";\nimport { util } from \"../core/index.js\";\ntype SomeType = core.SomeType;\nexport interface ZodMiniType<out Output = unknown, out Input = unknown, out Internals extends core.$ZodTypeInternals<Output, Input> = core.$ZodTypeInternals<Output, Input>> extends core.$ZodType<Output, Input, Internals> {\n    check(...checks: (core.CheckFn<core.output<this>> | core.$ZodCheck<core.output<this>>)[]): this;\n    clone(def?: Internals[\"def\"], params?: {\n        parent: boolean;\n    }): this;\n    register<R extends core.$ZodRegistry>(registry: R, ...meta: this extends R[\"_schema\"] ? undefined extends R[\"_meta\"] ? [core.$replace<R[\"_meta\"], this>?] : [core.$replace<R[\"_meta\"], this>] : [\"Incompatible schema\"]): this;\n    brand<T extends PropertyKey = PropertyKey>(value?: T): PropertyKey extends T ? this : this & Record<\"_zod\", Record<\"output\", core.output<this> & core.$brand<T>>>;\n    def: Internals[\"def\"];\n    parse(data: unknown, params?: core.ParseContext<core.$ZodIssue>): core.output<this>;\n    safeParse(data: unknown, params?: core.ParseContext<core.$ZodIssue>): util.SafeParseResult<core.output<this>>;\n    parseAsync(data: unknown, params?: core.ParseContext<core.$ZodIssue>): Promise<core.output<this>>;\n    safeParseAsync(data: unknown, params?: core.ParseContext<core.$ZodIssue>): Promise<util.SafeParseResult<core.output<this>>>;\n}\ninterface _ZodMiniType<out Internals extends core.$ZodTypeInternals = core.$ZodTypeInternals> extends ZodMiniType<any, any, Internals> {\n}\nexport declare const ZodMiniType: core.$constructor<ZodMiniType>;\nexport interface _ZodMiniString<T extends core.$ZodStringInternals<unknown> = core.$ZodStringInternals<unknown>> extends _ZodMiniType<T>, core.$ZodString<T[\"input\"]> {\n    _zod: T;\n}\nexport interface ZodMiniString<Input = unknown> extends _ZodMiniString<core.$ZodStringInternals<Input>>, core.$ZodString<Input> {\n}\nexport declare const ZodMiniString: core.$constructor<ZodMiniString>;\nexport declare function string(params?: string | core.$ZodStringParams): ZodMiniString<string>;\nexport interface ZodMiniStringFormat<Format extends string = string> extends _ZodMiniString<core.$ZodStringFormatInternals<Format>>, core.$ZodStringFormat<Format> {\n}\nexport declare const ZodMiniStringFormat: core.$constructor<ZodMiniStringFormat>;\nexport interface ZodMiniEmail extends _ZodMiniString<core.$ZodEmailInternals> {\n}\nexport declare const ZodMiniEmail: core.$constructor<ZodMiniEmail>;\nexport declare function email(params?: string | core.$ZodEmailParams): ZodMiniEmail;\nexport interface ZodMiniGUID extends _ZodMiniString<core.$ZodGUIDInternals> {\n}\nexport declare const ZodMiniGUID: core.$constructor<ZodMiniGUID>;\nexport declare function guid(params?: string | core.$ZodGUIDParams): ZodMiniGUID;\nexport interface ZodMiniUUID extends _ZodMiniString<core.$ZodUUIDInternals> {\n}\nexport declare const ZodMiniUUID: core.$constructor<ZodMiniUUID>;\nexport declare function uuid(params?: string | core.$ZodUUIDParams): ZodMiniUUID;\nexport declare function uuidv4(params?: string | core.$ZodUUIDv4Params): ZodMiniUUID;\nexport declare function uuidv6(params?: string | core.$ZodUUIDv6Params): ZodMiniUUID;\nexport declare function uuidv7(params?: string | core.$ZodUUIDv7Params): ZodMiniUUID;\nexport interface ZodMiniURL extends _ZodMiniString<core.$ZodURLInternals> {\n}\nexport declare const ZodMiniURL: core.$constructor<ZodMiniURL>;\nexport declare function url(params?: string | core.$ZodURLParams): ZodMiniURL;\nexport interface ZodMiniEmoji extends _ZodMiniString<core.$ZodEmojiInternals> {\n}\nexport declare const ZodMiniEmoji: core.$constructor<ZodMiniEmoji>;\nexport declare function emoji(params?: string | core.$ZodEmojiParams): ZodMiniEmoji;\nexport interface ZodMiniNanoID extends _ZodMiniString<core.$ZodNanoIDInternals> {\n}\nexport declare const ZodMiniNanoID: core.$constructor<ZodMiniNanoID>;\nexport declare function nanoid(params?: string | core.$ZodNanoIDParams): ZodMiniNanoID;\nexport interface ZodMiniCUID extends _ZodMiniString<core.$ZodCUIDInternals> {\n}\nexport declare const ZodMiniCUID: core.$constructor<ZodMiniCUID>;\nexport declare function cuid(params?: string | core.$ZodCUIDParams): ZodMiniCUID;\nexport interface ZodMiniCUID2 extends _ZodMiniString<core.$ZodCUID2Internals> {\n}\nexport declare const ZodMiniCUID2: core.$constructor<ZodMiniCUID2>;\nexport declare function cuid2(params?: string | core.$ZodCUID2Params): ZodMiniCUID2;\nexport interface ZodMiniULID extends _ZodMiniString<core.$ZodULIDInternals> {\n}\nexport declare const ZodMiniULID: core.$constructor<ZodMiniULID>;\nexport declare function ulid(params?: string | core.$ZodULIDParams): ZodMiniULID;\nexport interface ZodMiniXID extends _ZodMiniString<core.$ZodXIDInternals> {\n}\nexport declare const ZodMiniXID: core.$constructor<ZodMiniXID>;\nexport declare function xid(params?: string | core.$ZodXIDParams): ZodMiniXID;\nexport interface ZodMiniKSUID extends _ZodMiniString<core.$ZodKSUIDInternals> {\n}\nexport declare const ZodMiniKSUID: core.$constructor<ZodMiniKSUID>;\nexport declare function ksuid(params?: string | core.$ZodKSUIDParams): ZodMiniKSUID;\nexport interface ZodMiniIPv4 extends _ZodMiniString<core.$ZodIPv4Internals> {\n}\nexport declare const ZodMiniIPv4: core.$constructor<ZodMiniIPv4>;\nexport declare function ipv4(params?: string | core.$ZodIPv4Params): ZodMiniIPv4;\nexport interface ZodMiniIPv6 extends _ZodMiniString<core.$ZodIPv6Internals> {\n}\nexport declare const ZodMiniIPv6: core.$constructor<ZodMiniIPv6>;\nexport declare function ipv6(params?: string | core.$ZodIPv6Params): ZodMiniIPv6;\nexport interface ZodMiniCIDRv4 extends _ZodMiniString<core.$ZodCIDRv4Internals> {\n}\nexport declare const ZodMiniCIDRv4: core.$constructor<ZodMiniCIDRv4>;\nexport declare function cidrv4(params?: string | core.$ZodCIDRv4Params): ZodMiniCIDRv4;\nexport interface ZodMiniCIDRv6 extends _ZodMiniString<core.$ZodCIDRv6Internals> {\n}\nexport declare const ZodMiniCIDRv6: core.$constructor<ZodMiniCIDRv6>;\nexport declare function cidrv6(params?: string | core.$ZodCIDRv6Params): ZodMiniCIDRv6;\nexport interface ZodMiniBase64 extends _ZodMiniString<core.$ZodBase64Internals> {\n}\nexport declare const ZodMiniBase64: core.$constructor<ZodMiniBase64>;\nexport declare function base64(params?: string | core.$ZodBase64Params): ZodMiniBase64;\nexport interface ZodMiniBase64URL extends _ZodMiniString<core.$ZodBase64URLInternals> {\n}\nexport declare const ZodMiniBase64URL: core.$constructor<ZodMiniBase64URL>;\nexport declare function base64url(params?: string | core.$ZodBase64URLParams): ZodMiniBase64URL;\nexport interface ZodMiniE164 extends _ZodMiniString<core.$ZodE164Internals> {\n}\nexport declare const ZodMiniE164: core.$constructor<ZodMiniE164>;\nexport declare function e164(params?: string | core.$ZodE164Params): ZodMiniE164;\nexport interface ZodMiniJWT extends _ZodMiniString<core.$ZodJWTInternals> {\n}\nexport declare const ZodMiniJWT: core.$constructor<ZodMiniJWT>;\nexport declare function jwt(params?: string | core.$ZodJWTParams): ZodMiniJWT;\nexport interface ZodMiniCustomStringFormat<Format extends string = string> extends ZodMiniStringFormat<Format>, core.$ZodCustomStringFormat<Format> {\n    _zod: core.$ZodCustomStringFormatInternals<Format>;\n}\nexport declare const ZodMiniCustomStringFormat: core.$constructor<ZodMiniCustomStringFormat>;\nexport declare function stringFormat<Format extends string>(format: Format, fnOrRegex: ((arg: string) => util.MaybeAsync<unknown>) | RegExp, _params?: string | core.$ZodStringFormatParams): ZodMiniCustomStringFormat<Format>;\ninterface _ZodMiniNumber<T extends core.$ZodNumberInternals<unknown> = core.$ZodNumberInternals<unknown>> extends _ZodMiniType<T>, core.$ZodNumber<T[\"input\"]> {\n    _zod: T;\n}\nexport interface ZodMiniNumber<Input = unknown> extends _ZodMiniNumber<core.$ZodNumberInternals<Input>>, core.$ZodNumber<Input> {\n}\nexport declare const ZodMiniNumber: core.$constructor<ZodMiniNumber>;\nexport declare function number(params?: string | core.$ZodNumberParams): ZodMiniNumber<number>;\nexport interface ZodMiniNumberFormat extends _ZodMiniNumber<core.$ZodNumberFormatInternals>, core.$ZodNumberFormat {\n}\nexport declare const ZodMiniNumberFormat: core.$constructor<ZodMiniNumberFormat>;\nexport declare function int(params?: string | core.$ZodCheckNumberFormatParams): ZodMiniNumberFormat;\nexport declare function float32(params?: string | core.$ZodCheckNumberFormatParams): ZodMiniNumberFormat;\nexport declare function float64(params?: string | core.$ZodCheckNumberFormatParams): ZodMiniNumberFormat;\nexport declare function int32(params?: string | core.$ZodCheckNumberFormatParams): ZodMiniNumberFormat;\nexport declare function uint32(params?: string | core.$ZodCheckNumberFormatParams): ZodMiniNumberFormat;\nexport interface ZodMiniBoolean<T = unknown> extends _ZodMiniType<core.$ZodBooleanInternals<T>> {\n}\nexport declare const ZodMiniBoolean: core.$constructor<ZodMiniBoolean>;\nexport declare function boolean(params?: string | core.$ZodBooleanParams): ZodMiniBoolean<boolean>;\nexport interface ZodMiniBigInt<T = unknown> extends _ZodMiniType<core.$ZodBigIntInternals<T>>, core.$ZodBigInt<T> {\n}\nexport declare const ZodMiniBigInt: core.$constructor<ZodMiniBigInt>;\nexport declare function bigint(params?: string | core.$ZodBigIntParams): ZodMiniBigInt<bigint>;\nexport interface ZodMiniBigIntFormat extends _ZodMiniType<core.$ZodBigIntFormatInternals> {\n}\nexport declare const ZodMiniBigIntFormat: core.$constructor<ZodMiniBigIntFormat>;\nexport declare function int64(params?: string | core.$ZodBigIntFormatParams): ZodMiniBigIntFormat;\nexport declare function uint64(params?: string | core.$ZodBigIntFormatParams): ZodMiniBigIntFormat;\nexport interface ZodMiniSymbol extends _ZodMiniType<core.$ZodSymbolInternals> {\n}\nexport declare const ZodMiniSymbol: core.$constructor<ZodMiniSymbol>;\nexport declare function symbol(params?: string | core.$ZodSymbolParams): ZodMiniSymbol;\nexport interface ZodMiniUndefined extends _ZodMiniType<core.$ZodUndefinedInternals> {\n}\nexport declare const ZodMiniUndefined: core.$constructor<ZodMiniUndefined>;\ndeclare function _undefined(params?: string | core.$ZodUndefinedParams): ZodMiniUndefined;\nexport { _undefined as undefined };\nexport interface ZodMiniNull extends _ZodMiniType<core.$ZodNullInternals> {\n}\nexport declare const ZodMiniNull: core.$constructor<ZodMiniNull>;\ndeclare function _null(params?: string | core.$ZodNullParams): ZodMiniNull;\nexport { _null as null };\nexport interface ZodMiniAny extends _ZodMiniType<core.$ZodAnyInternals> {\n}\nexport declare const ZodMiniAny: core.$constructor<ZodMiniAny>;\nexport declare function any(): ZodMiniAny;\nexport interface ZodMiniUnknown extends _ZodMiniType<core.$ZodUnknownInternals> {\n}\nexport declare const ZodMiniUnknown: core.$constructor<ZodMiniUnknown>;\nexport declare function unknown(): ZodMiniUnknown;\nexport interface ZodMiniNever extends _ZodMiniType<core.$ZodNeverInternals> {\n}\nexport declare const ZodMiniNever: core.$constructor<ZodMiniNever>;\nexport declare function never(params?: string | core.$ZodNeverParams): ZodMiniNever;\nexport interface ZodMiniVoid extends _ZodMiniType<core.$ZodVoidInternals> {\n}\nexport declare const ZodMiniVoid: core.$constructor<ZodMiniVoid>;\ndeclare function _void(params?: string | core.$ZodVoidParams): ZodMiniVoid;\nexport { _void as void };\nexport interface ZodMiniDate<T = unknown> extends _ZodMiniType<core.$ZodDateInternals<T>> {\n}\nexport declare const ZodMiniDate: core.$constructor<ZodMiniDate>;\nexport declare function date(params?: string | core.$ZodDateParams): ZodMiniDate<Date>;\nexport interface ZodMiniArray<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodArrayInternals<T>>, core.$ZodArray<T> {\n}\nexport declare const ZodMiniArray: core.$constructor<ZodMiniArray>;\nexport declare function array<T extends SomeType>(element: T, params?: string | core.$ZodArrayParams): ZodMiniArray<T>;\nexport declare function keyof<T extends ZodMiniObject>(schema: T): ZodMiniLiteral<Exclude<keyof T[\"shape\"], symbol>>;\nexport interface ZodMiniObject<\n/** @ts-ignore Cast variance */\nout Shape extends core.$ZodShape = core.$ZodShape, out Config extends core.$ZodObjectConfig = core.$strip> extends ZodMiniType<any, any, core.$ZodObjectInternals<Shape, Config>>, core.$ZodObject<Shape, Config> {\n    shape: Shape;\n}\nexport declare const ZodMiniObject: core.$constructor<ZodMiniObject>;\nexport declare function object<T extends core.$ZodLooseShape = Record<never, SomeType>>(shape?: T, params?: string | core.$ZodObjectParams): ZodMiniObject<T, core.$strip>;\nexport declare function strictObject<T extends core.$ZodLooseShape>(shape: T, params?: string | core.$ZodObjectParams): ZodMiniObject<T, core.$strict>;\nexport declare function looseObject<T extends core.$ZodLooseShape>(shape: T, params?: string | core.$ZodObjectParams): ZodMiniObject<T, core.$loose>;\nexport declare function extend<T extends ZodMiniObject, U extends core.$ZodLooseShape>(schema: T, shape: U): ZodMiniObject<util.Extend<T[\"shape\"], U>, T[\"_zod\"][\"config\"]>;\n/** @deprecated Identical to `z.extend(A, B)` */\nexport declare function merge<T extends ZodMiniObject, U extends ZodMiniObject>(a: T, b: U): ZodMiniObject<util.Extend<T[\"shape\"], U[\"shape\"]>, T[\"_zod\"][\"config\"]>;\nexport declare function pick<T extends ZodMiniObject, M extends util.Mask<keyof T[\"shape\"]>>(schema: T, mask: M): ZodMiniObject<util.Flatten<Pick<T[\"shape\"], keyof T[\"shape\"] & keyof M>>, T[\"_zod\"][\"config\"]>;\nexport declare function omit<T extends ZodMiniObject, const M extends util.Mask<keyof T[\"shape\"]>>(schema: T, mask: M): ZodMiniObject<util.Flatten<Omit<T[\"shape\"], keyof M>>, T[\"_zod\"][\"config\"]>;\nexport declare function partial<T extends ZodMiniObject>(schema: T): ZodMiniObject<{\n    [k in keyof T[\"shape\"]]: ZodMiniOptional<T[\"shape\"][k]>;\n}, T[\"_zod\"][\"config\"]>;\nexport declare function partial<T extends ZodMiniObject, M extends util.Mask<keyof T[\"shape\"]>>(schema: T, mask: M): ZodMiniObject<{\n    [k in keyof T[\"shape\"]]: k extends keyof M ? ZodMiniOptional<T[\"shape\"][k]> : T[\"shape\"][k];\n}, T[\"_zod\"][\"config\"]>;\nexport type RequiredInterfaceShape<Shape extends core.$ZodLooseShape, Keys extends PropertyKey = keyof Shape> = util.Identity<{\n    [k in keyof Shape as k extends Keys ? k : never]: ZodMiniNonOptional<Shape[k]>;\n} & {\n    [k in keyof Shape as k extends Keys ? never : k]: Shape[k];\n}>;\nexport declare function required<T extends ZodMiniObject>(schema: T): ZodMiniObject<{\n    [k in keyof T[\"shape\"]]: ZodMiniNonOptional<T[\"shape\"][k]>;\n}, T[\"_zod\"][\"config\"]>;\nexport declare function required<T extends ZodMiniObject, M extends util.Mask<keyof T[\"shape\"]>>(schema: T, mask: M): ZodMiniObject<util.Extend<T[\"shape\"], {\n    [k in keyof M & keyof T[\"shape\"]]: ZodMiniNonOptional<T[\"shape\"][k]>;\n}>, T[\"_zod\"][\"config\"]>;\nexport declare function catchall<T extends ZodMiniObject, U extends SomeType>(inst: T, catchall: U): ZodMiniObject<T[\"shape\"], core.$catchall<U>>;\nexport interface ZodMiniUnion<T extends readonly SomeType[] = readonly core.$ZodType[]> extends _ZodMiniType<core.$ZodUnionInternals<T>> {\n}\nexport declare const ZodMiniUnion: core.$constructor<ZodMiniUnion>;\nexport declare function union<const T extends readonly SomeType[]>(options: T, params?: string | core.$ZodUnionParams): ZodMiniUnion<T>;\nexport interface ZodMiniDiscriminatedUnion<Options extends readonly SomeType[] = readonly core.$ZodType[]> extends ZodMiniUnion<Options> {\n    _zod: core.$ZodDiscriminatedUnionInternals<Options>;\n}\nexport declare const ZodMiniDiscriminatedUnion: core.$constructor<ZodMiniDiscriminatedUnion>;\nexport declare function discriminatedUnion<Types extends readonly [core.$ZodTypeDiscriminable, ...core.$ZodTypeDiscriminable[]]>(discriminator: string, options: Types, params?: string | core.$ZodDiscriminatedUnionParams): ZodMiniDiscriminatedUnion<Types>;\nexport interface ZodMiniIntersection<A extends SomeType = core.$ZodType, B extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodIntersectionInternals<A, B>> {\n}\nexport declare const ZodMiniIntersection: core.$constructor<ZodMiniIntersection>;\nexport declare function intersection<T extends SomeType, U extends SomeType>(left: T, right: U): ZodMiniIntersection<T, U>;\nexport interface ZodMiniTuple<T extends util.TupleItems = readonly core.$ZodType[], Rest extends SomeType | null = core.$ZodType | null> extends _ZodMiniType<core.$ZodTupleInternals<T, Rest>> {\n}\nexport declare const ZodMiniTuple: core.$constructor<ZodMiniTuple>;\nexport declare function tuple<const T extends readonly [SomeType, ...SomeType[]]>(items: T, params?: string | core.$ZodTupleParams): ZodMiniTuple<T, null>;\nexport declare function tuple<const T extends readonly [SomeType, ...SomeType[]], Rest extends SomeType>(items: T, rest: Rest, params?: string | core.$ZodTupleParams): ZodMiniTuple<T, Rest>;\nexport declare function tuple(items: [], params?: string | core.$ZodTupleParams): ZodMiniTuple<[], null>;\nexport interface ZodMiniRecord<Key extends core.$ZodRecordKey = core.$ZodRecordKey, Value extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodRecordInternals<Key, Value>> {\n}\nexport declare const ZodMiniRecord: core.$constructor<ZodMiniRecord>;\nexport declare function record<Key extends core.$ZodRecordKey, Value extends SomeType>(keyType: Key, valueType: Value, params?: string | core.$ZodRecordParams): ZodMiniRecord<Key, Value>;\nexport declare function partialRecord<Key extends core.$ZodRecordKey, Value extends SomeType>(keyType: Key, valueType: Value, params?: string | core.$ZodRecordParams): ZodMiniRecord<Key & core.$partial, Value>;\nexport interface ZodMiniMap<Key extends SomeType = core.$ZodType, Value extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodMapInternals<Key, Value>> {\n}\nexport declare const ZodMiniMap: core.$constructor<ZodMiniMap>;\nexport declare function map<Key extends SomeType, Value extends SomeType>(keyType: Key, valueType: Value, params?: string | core.$ZodMapParams): ZodMiniMap<Key, Value>;\nexport interface ZodMiniSet<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodSetInternals<T>> {\n}\nexport declare const ZodMiniSet: core.$constructor<ZodMiniSet>;\nexport declare function set<Value extends SomeType>(valueType: Value, params?: string | core.$ZodSetParams): ZodMiniSet<Value>;\nexport interface ZodMiniEnum<T extends util.EnumLike = util.EnumLike> extends _ZodMiniType<core.$ZodEnumInternals<T>> {\n}\nexport declare const ZodMiniEnum: core.$constructor<ZodMiniEnum>;\ndeclare function _enum<const T extends readonly string[]>(values: T, params?: string | core.$ZodEnumParams): ZodMiniEnum<util.ToEnum<T[number]>>;\ndeclare function _enum<T extends util.EnumLike>(entries: T, params?: string | core.$ZodEnumParams): ZodMiniEnum<T>;\nexport { _enum as enum };\n/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.\n *\n * ```ts\n * enum Colors { red, green, blue }\n * z.enum(Colors);\n * ```\n */\nexport declare function nativeEnum<T extends util.EnumLike>(entries: T, params?: string | core.$ZodEnumParams): ZodMiniEnum<T>;\nexport interface ZodMiniLiteral<T extends util.Literal = util.Literal> extends _ZodMiniType<core.$ZodLiteralInternals<T>> {\n}\nexport declare const ZodMiniLiteral: core.$constructor<ZodMiniLiteral>;\nexport declare function literal<const T extends ReadonlyArray<util.Literal>>(value: T, params?: string | core.$ZodLiteralParams): ZodMiniLiteral<T[number]>;\nexport declare function literal<const T extends util.Literal>(value: T, params?: string | core.$ZodLiteralParams): ZodMiniLiteral<T>;\nexport interface ZodMiniFile extends _ZodMiniType<core.$ZodFileInternals> {\n}\nexport declare const ZodMiniFile: core.$constructor<ZodMiniFile>;\nexport declare function file(params?: string | core.$ZodFileParams): ZodMiniFile;\nexport interface ZodMiniTransform<O = unknown, I = unknown> extends _ZodMiniType<core.$ZodTransformInternals<O, I>> {\n}\nexport declare const ZodMiniTransform: core.$constructor<ZodMiniTransform>;\nexport declare function transform<I = unknown, O = I>(fn: (input: I, ctx: core.ParsePayload) => O): ZodMiniTransform<Awaited<O>, I>;\nexport interface ZodMiniOptional<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodOptionalInternals<T>>, core.$ZodOptional<T> {\n}\nexport declare const ZodMiniOptional: core.$constructor<ZodMiniOptional>;\nexport declare function optional<T extends SomeType>(innerType: T): ZodMiniOptional<T>;\nexport interface ZodMiniNullable<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodNullableInternals<T>> {\n}\nexport declare const ZodMiniNullable: core.$constructor<ZodMiniNullable>;\nexport declare function nullable<T extends SomeType>(innerType: T): ZodMiniNullable<T>;\nexport declare function nullish<T extends SomeType>(innerType: T): ZodMiniOptional<ZodMiniNullable<T>>;\nexport interface ZodMiniDefault<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodDefaultInternals<T>> {\n}\nexport declare const ZodMiniDefault: core.$constructor<ZodMiniDefault>;\nexport declare function _default<T extends SomeType>(innerType: T, defaultValue: util.NoUndefined<core.output<T>> | (() => util.NoUndefined<core.output<T>>)): ZodMiniDefault<T>;\nexport interface ZodMiniPrefault<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodPrefaultInternals<T>> {\n}\nexport declare const ZodMiniPrefault: core.$constructor<ZodMiniPrefault>;\nexport declare function prefault<T extends SomeType>(innerType: T, defaultValue: util.NoUndefined<core.input<T>> | (() => util.NoUndefined<core.input<T>>)): ZodMiniPrefault<T>;\nexport interface ZodMiniNonOptional<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodNonOptionalInternals<T>> {\n}\nexport declare const ZodMiniNonOptional: core.$constructor<ZodMiniNonOptional>;\nexport declare function nonoptional<T extends SomeType>(innerType: T, params?: string | core.$ZodNonOptionalParams): ZodMiniNonOptional<T>;\nexport interface ZodMiniSuccess<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodSuccessInternals<T>> {\n}\nexport declare const ZodMiniSuccess: core.$constructor<ZodMiniSuccess>;\nexport declare function success<T extends SomeType>(innerType: T): ZodMiniSuccess<T>;\nexport interface ZodMiniCatch<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodCatchInternals<T>> {\n}\nexport declare const ZodMiniCatch: core.$constructor<ZodMiniCatch>;\ndeclare function _catch<T extends SomeType>(innerType: T, catchValue: core.output<T> | ((ctx: core.$ZodCatchCtx) => core.output<T>)): ZodMiniCatch<T>;\nexport { _catch as catch };\nexport interface ZodMiniNaN extends _ZodMiniType<core.$ZodNaNInternals> {\n}\nexport declare const ZodMiniNaN: core.$constructor<ZodMiniNaN>;\nexport declare function nan(params?: string | core.$ZodNaNParams): ZodMiniNaN;\nexport interface ZodMiniPipe<A extends SomeType = core.$ZodType, B extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodPipeInternals<A, B>> {\n}\nexport declare const ZodMiniPipe: core.$constructor<ZodMiniPipe>;\nexport declare function pipe<const A extends SomeType, B extends core.$ZodType<unknown, core.output<A>> = core.$ZodType<unknown, core.output<A>>>(in_: A, out: B | core.$ZodType<unknown, core.output<A>>): ZodMiniPipe<A, B>;\nexport interface ZodMiniReadonly<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodReadonlyInternals<T>> {\n}\nexport declare const ZodMiniReadonly: core.$constructor<ZodMiniReadonly>;\nexport declare function readonly<T extends SomeType>(innerType: T): ZodMiniReadonly<T>;\nexport interface ZodMiniTemplateLiteral<Template extends string = string> extends _ZodMiniType<core.$ZodTemplateLiteralInternals<Template>> {\n}\nexport declare const ZodMiniTemplateLiteral: core.$constructor<ZodMiniTemplateLiteral>;\nexport declare function templateLiteral<const Parts extends core.$ZodTemplateLiteralPart[]>(parts: Parts, params?: string | core.$ZodTemplateLiteralParams): ZodMiniTemplateLiteral<core.$PartsToTemplateLiteral<Parts>>;\nexport interface ZodMiniLazy<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodLazyInternals<T>> {\n}\nexport declare const ZodMiniLazy: core.$constructor<ZodMiniLazy>;\ndeclare function _lazy<T extends SomeType>(getter: () => T): ZodMiniLazy<T>;\nexport { _lazy as lazy };\nexport interface ZodMiniPromise<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodPromiseInternals<T>> {\n}\nexport declare const ZodMiniPromise: core.$constructor<ZodMiniPromise>;\nexport declare function promise<T extends SomeType>(innerType: T): ZodMiniPromise<T>;\nexport interface ZodMiniCustom<O = unknown, I = unknown> extends _ZodMiniType<core.$ZodCustomInternals<O, I>> {\n}\nexport declare const ZodMiniCustom: core.$constructor<ZodMiniCustom>;\nexport declare function check<O = unknown>(fn: core.CheckFn<O>, params?: string | core.$ZodCustomParams): core.$ZodCheck<O>;\nexport declare function custom<O = unknown, I = O>(fn?: (data: O) => unknown, _params?: string | core.$ZodCustomParams | undefined): ZodMiniCustom<O, I>;\nexport declare function refine<T>(fn: (arg: NoInfer<T>) => util.MaybeAsync<unknown>, _params?: string | core.$ZodCustomParams): core.$ZodCheck<T>;\ndeclare abstract class Class {\n    constructor(..._args: any[]);\n}\ndeclare function _instanceof<T extends typeof Class>(cls: T, params?: core.$ZodCustomParams): ZodMiniCustom<InstanceType<T>, InstanceType<T>>;\nexport { _instanceof as instanceof };\nexport declare const stringbool: (_params?: string | core.$ZodStringBoolParams) => ZodMiniPipe<ZodMiniPipe<ZodMiniString, ZodMiniTransform<boolean, string>>, ZodMiniBoolean>;\ntype _ZodMiniJSONSchema = ZodMiniUnion<[\n    ZodMiniString,\n    ZodMiniNumber,\n    ZodMiniBoolean,\n    ZodMiniNull,\n    ZodMiniArray<ZodMiniJSONSchema>,\n    ZodMiniRecord<ZodMiniString<string>, ZodMiniJSONSchema>\n]>;\ntype _ZodMiniJSONSchemaInternals = _ZodMiniJSONSchema[\"_zod\"];\nexport interface ZodMiniJSONSchemaInternals extends _ZodMiniJSONSchemaInternals {\n    output: util.JSONType;\n    input: util.JSONType;\n}\nexport interface ZodMiniJSONSchema extends _ZodMiniJSONSchema {\n    _zod: ZodMiniJSONSchemaInternals;\n}\nexport declare function json(): ZodMiniJSONSchema;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/mini/schemas.d.ts",
        "start": 1,
        "end": 356,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 356,
          "column": 2,
          "position": 7699
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/mini/schemas.d.ts",
        "start": 1,
        "end": 356,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 356,
          "column": 2,
          "position": 7699
        }
      }
    },
    {
      "format": "typescript",
      "lines": 356,
      "fragment": "import * as core from \"../core/index.cjs\";\nimport { util } from \"../core/index.cjs\";\ntype SomeType = core.SomeType;\nexport interface ZodMiniType<out Output = unknown, out Input = unknown, out Internals extends core.$ZodTypeInternals<Output, Input> = core.$ZodTypeInternals<Output, Input>> extends core.$ZodType<Output, Input, Internals> {\n    check(...checks: (core.CheckFn<core.output<this>> | core.$ZodCheck<core.output<this>>)[]): this;\n    clone(def?: Internals[\"def\"], params?: {\n        parent: boolean;\n    }): this;\n    register<R extends core.$ZodRegistry>(registry: R, ...meta: this extends R[\"_schema\"] ? undefined extends R[\"_meta\"] ? [core.$replace<R[\"_meta\"], this>?] : [core.$replace<R[\"_meta\"], this>] : [\"Incompatible schema\"]): this;\n    brand<T extends PropertyKey = PropertyKey>(value?: T): PropertyKey extends T ? this : this & Record<\"_zod\", Record<\"output\", core.output<this> & core.$brand<T>>>;\n    def: Internals[\"def\"];\n    parse(data: unknown, params?: core.ParseContext<core.$ZodIssue>): core.output<this>;\n    safeParse(data: unknown, params?: core.ParseContext<core.$ZodIssue>): util.SafeParseResult<core.output<this>>;\n    parseAsync(data: unknown, params?: core.ParseContext<core.$ZodIssue>): Promise<core.output<this>>;\n    safeParseAsync(data: unknown, params?: core.ParseContext<core.$ZodIssue>): Promise<util.SafeParseResult<core.output<this>>>;\n}\ninterface _ZodMiniType<out Internals extends core.$ZodTypeInternals = core.$ZodTypeInternals> extends ZodMiniType<any, any, Internals> {\n}\nexport declare const ZodMiniType: core.$constructor<ZodMiniType>;\nexport interface _ZodMiniString<T extends core.$ZodStringInternals<unknown> = core.$ZodStringInternals<unknown>> extends _ZodMiniType<T>, core.$ZodString<T[\"input\"]> {\n    _zod: T;\n}\nexport interface ZodMiniString<Input = unknown> extends _ZodMiniString<core.$ZodStringInternals<Input>>, core.$ZodString<Input> {\n}\nexport declare const ZodMiniString: core.$constructor<ZodMiniString>;\nexport declare function string(params?: string | core.$ZodStringParams): ZodMiniString<string>;\nexport interface ZodMiniStringFormat<Format extends string = string> extends _ZodMiniString<core.$ZodStringFormatInternals<Format>>, core.$ZodStringFormat<Format> {\n}\nexport declare const ZodMiniStringFormat: core.$constructor<ZodMiniStringFormat>;\nexport interface ZodMiniEmail extends _ZodMiniString<core.$ZodEmailInternals> {\n}\nexport declare const ZodMiniEmail: core.$constructor<ZodMiniEmail>;\nexport declare function email(params?: string | core.$ZodEmailParams): ZodMiniEmail;\nexport interface ZodMiniGUID extends _ZodMiniString<core.$ZodGUIDInternals> {\n}\nexport declare const ZodMiniGUID: core.$constructor<ZodMiniGUID>;\nexport declare function guid(params?: string | core.$ZodGUIDParams): ZodMiniGUID;\nexport interface ZodMiniUUID extends _ZodMiniString<core.$ZodUUIDInternals> {\n}\nexport declare const ZodMiniUUID: core.$constructor<ZodMiniUUID>;\nexport declare function uuid(params?: string | core.$ZodUUIDParams): ZodMiniUUID;\nexport declare function uuidv4(params?: string | core.$ZodUUIDv4Params): ZodMiniUUID;\nexport declare function uuidv6(params?: string | core.$ZodUUIDv6Params): ZodMiniUUID;\nexport declare function uuidv7(params?: string | core.$ZodUUIDv7Params): ZodMiniUUID;\nexport interface ZodMiniURL extends _ZodMiniString<core.$ZodURLInternals> {\n}\nexport declare const ZodMiniURL: core.$constructor<ZodMiniURL>;\nexport declare function url(params?: string | core.$ZodURLParams): ZodMiniURL;\nexport interface ZodMiniEmoji extends _ZodMiniString<core.$ZodEmojiInternals> {\n}\nexport declare const ZodMiniEmoji: core.$constructor<ZodMiniEmoji>;\nexport declare function emoji(params?: string | core.$ZodEmojiParams): ZodMiniEmoji;\nexport interface ZodMiniNanoID extends _ZodMiniString<core.$ZodNanoIDInternals> {\n}\nexport declare const ZodMiniNanoID: core.$constructor<ZodMiniNanoID>;\nexport declare function nanoid(params?: string | core.$ZodNanoIDParams): ZodMiniNanoID;\nexport interface ZodMiniCUID extends _ZodMiniString<core.$ZodCUIDInternals> {\n}\nexport declare const ZodMiniCUID: core.$constructor<ZodMiniCUID>;\nexport declare function cuid(params?: string | core.$ZodCUIDParams): ZodMiniCUID;\nexport interface ZodMiniCUID2 extends _ZodMiniString<core.$ZodCUID2Internals> {\n}\nexport declare const ZodMiniCUID2: core.$constructor<ZodMiniCUID2>;\nexport declare function cuid2(params?: string | core.$ZodCUID2Params): ZodMiniCUID2;\nexport interface ZodMiniULID extends _ZodMiniString<core.$ZodULIDInternals> {\n}\nexport declare const ZodMiniULID: core.$constructor<ZodMiniULID>;\nexport declare function ulid(params?: string | core.$ZodULIDParams): ZodMiniULID;\nexport interface ZodMiniXID extends _ZodMiniString<core.$ZodXIDInternals> {\n}\nexport declare const ZodMiniXID: core.$constructor<ZodMiniXID>;\nexport declare function xid(params?: string | core.$ZodXIDParams): ZodMiniXID;\nexport interface ZodMiniKSUID extends _ZodMiniString<core.$ZodKSUIDInternals> {\n}\nexport declare const ZodMiniKSUID: core.$constructor<ZodMiniKSUID>;\nexport declare function ksuid(params?: string | core.$ZodKSUIDParams): ZodMiniKSUID;\nexport interface ZodMiniIPv4 extends _ZodMiniString<core.$ZodIPv4Internals> {\n}\nexport declare const ZodMiniIPv4: core.$constructor<ZodMiniIPv4>;\nexport declare function ipv4(params?: string | core.$ZodIPv4Params): ZodMiniIPv4;\nexport interface ZodMiniIPv6 extends _ZodMiniString<core.$ZodIPv6Internals> {\n}\nexport declare const ZodMiniIPv6: core.$constructor<ZodMiniIPv6>;\nexport declare function ipv6(params?: string | core.$ZodIPv6Params): ZodMiniIPv6;\nexport interface ZodMiniCIDRv4 extends _ZodMiniString<core.$ZodCIDRv4Internals> {\n}\nexport declare const ZodMiniCIDRv4: core.$constructor<ZodMiniCIDRv4>;\nexport declare function cidrv4(params?: string | core.$ZodCIDRv4Params): ZodMiniCIDRv4;\nexport interface ZodMiniCIDRv6 extends _ZodMiniString<core.$ZodCIDRv6Internals> {\n}\nexport declare const ZodMiniCIDRv6: core.$constructor<ZodMiniCIDRv6>;\nexport declare function cidrv6(params?: string | core.$ZodCIDRv6Params): ZodMiniCIDRv6;\nexport interface ZodMiniBase64 extends _ZodMiniString<core.$ZodBase64Internals> {\n}\nexport declare const ZodMiniBase64: core.$constructor<ZodMiniBase64>;\nexport declare function base64(params?: string | core.$ZodBase64Params): ZodMiniBase64;\nexport interface ZodMiniBase64URL extends _ZodMiniString<core.$ZodBase64URLInternals> {\n}\nexport declare const ZodMiniBase64URL: core.$constructor<ZodMiniBase64URL>;\nexport declare function base64url(params?: string | core.$ZodBase64URLParams): ZodMiniBase64URL;\nexport interface ZodMiniE164 extends _ZodMiniString<core.$ZodE164Internals> {\n}\nexport declare const ZodMiniE164: core.$constructor<ZodMiniE164>;\nexport declare function e164(params?: string | core.$ZodE164Params): ZodMiniE164;\nexport interface ZodMiniJWT extends _ZodMiniString<core.$ZodJWTInternals> {\n}\nexport declare const ZodMiniJWT: core.$constructor<ZodMiniJWT>;\nexport declare function jwt(params?: string | core.$ZodJWTParams): ZodMiniJWT;\nexport interface ZodMiniCustomStringFormat<Format extends string = string> extends ZodMiniStringFormat<Format>, core.$ZodCustomStringFormat<Format> {\n    _zod: core.$ZodCustomStringFormatInternals<Format>;\n}\nexport declare const ZodMiniCustomStringFormat: core.$constructor<ZodMiniCustomStringFormat>;\nexport declare function stringFormat<Format extends string>(format: Format, fnOrRegex: ((arg: string) => util.MaybeAsync<unknown>) | RegExp, _params?: string | core.$ZodStringFormatParams): ZodMiniCustomStringFormat<Format>;\ninterface _ZodMiniNumber<T extends core.$ZodNumberInternals<unknown> = core.$ZodNumberInternals<unknown>> extends _ZodMiniType<T>, core.$ZodNumber<T[\"input\"]> {\n    _zod: T;\n}\nexport interface ZodMiniNumber<Input = unknown> extends _ZodMiniNumber<core.$ZodNumberInternals<Input>>, core.$ZodNumber<Input> {\n}\nexport declare const ZodMiniNumber: core.$constructor<ZodMiniNumber>;\nexport declare function number(params?: string | core.$ZodNumberParams): ZodMiniNumber<number>;\nexport interface ZodMiniNumberFormat extends _ZodMiniNumber<core.$ZodNumberFormatInternals>, core.$ZodNumberFormat {\n}\nexport declare const ZodMiniNumberFormat: core.$constructor<ZodMiniNumberFormat>;\nexport declare function int(params?: string | core.$ZodCheckNumberFormatParams): ZodMiniNumberFormat;\nexport declare function float32(params?: string | core.$ZodCheckNumberFormatParams): ZodMiniNumberFormat;\nexport declare function float64(params?: string | core.$ZodCheckNumberFormatParams): ZodMiniNumberFormat;\nexport declare function int32(params?: string | core.$ZodCheckNumberFormatParams): ZodMiniNumberFormat;\nexport declare function uint32(params?: string | core.$ZodCheckNumberFormatParams): ZodMiniNumberFormat;\nexport interface ZodMiniBoolean<T = unknown> extends _ZodMiniType<core.$ZodBooleanInternals<T>> {\n}\nexport declare const ZodMiniBoolean: core.$constructor<ZodMiniBoolean>;\nexport declare function boolean(params?: string | core.$ZodBooleanParams): ZodMiniBoolean<boolean>;\nexport interface ZodMiniBigInt<T = unknown> extends _ZodMiniType<core.$ZodBigIntInternals<T>>, core.$ZodBigInt<T> {\n}\nexport declare const ZodMiniBigInt: core.$constructor<ZodMiniBigInt>;\nexport declare function bigint(params?: string | core.$ZodBigIntParams): ZodMiniBigInt<bigint>;\nexport interface ZodMiniBigIntFormat extends _ZodMiniType<core.$ZodBigIntFormatInternals> {\n}\nexport declare const ZodMiniBigIntFormat: core.$constructor<ZodMiniBigIntFormat>;\nexport declare function int64(params?: string | core.$ZodBigIntFormatParams): ZodMiniBigIntFormat;\nexport declare function uint64(params?: string | core.$ZodBigIntFormatParams): ZodMiniBigIntFormat;\nexport interface ZodMiniSymbol extends _ZodMiniType<core.$ZodSymbolInternals> {\n}\nexport declare const ZodMiniSymbol: core.$constructor<ZodMiniSymbol>;\nexport declare function symbol(params?: string | core.$ZodSymbolParams): ZodMiniSymbol;\nexport interface ZodMiniUndefined extends _ZodMiniType<core.$ZodUndefinedInternals> {\n}\nexport declare const ZodMiniUndefined: core.$constructor<ZodMiniUndefined>;\ndeclare function _undefined(params?: string | core.$ZodUndefinedParams): ZodMiniUndefined;\nexport { _undefined as undefined };\nexport interface ZodMiniNull extends _ZodMiniType<core.$ZodNullInternals> {\n}\nexport declare const ZodMiniNull: core.$constructor<ZodMiniNull>;\ndeclare function _null(params?: string | core.$ZodNullParams): ZodMiniNull;\nexport { _null as null };\nexport interface ZodMiniAny extends _ZodMiniType<core.$ZodAnyInternals> {\n}\nexport declare const ZodMiniAny: core.$constructor<ZodMiniAny>;\nexport declare function any(): ZodMiniAny;\nexport interface ZodMiniUnknown extends _ZodMiniType<core.$ZodUnknownInternals> {\n}\nexport declare const ZodMiniUnknown: core.$constructor<ZodMiniUnknown>;\nexport declare function unknown(): ZodMiniUnknown;\nexport interface ZodMiniNever extends _ZodMiniType<core.$ZodNeverInternals> {\n}\nexport declare const ZodMiniNever: core.$constructor<ZodMiniNever>;\nexport declare function never(params?: string | core.$ZodNeverParams): ZodMiniNever;\nexport interface ZodMiniVoid extends _ZodMiniType<core.$ZodVoidInternals> {\n}\nexport declare const ZodMiniVoid: core.$constructor<ZodMiniVoid>;\ndeclare function _void(params?: string | core.$ZodVoidParams): ZodMiniVoid;\nexport { _void as void };\nexport interface ZodMiniDate<T = unknown> extends _ZodMiniType<core.$ZodDateInternals<T>> {\n}\nexport declare const ZodMiniDate: core.$constructor<ZodMiniDate>;\nexport declare function date(params?: string | core.$ZodDateParams): ZodMiniDate<Date>;\nexport interface ZodMiniArray<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodArrayInternals<T>>, core.$ZodArray<T> {\n}\nexport declare const ZodMiniArray: core.$constructor<ZodMiniArray>;\nexport declare function array<T extends SomeType>(element: T, params?: string | core.$ZodArrayParams): ZodMiniArray<T>;\nexport declare function keyof<T extends ZodMiniObject>(schema: T): ZodMiniLiteral<Exclude<keyof T[\"shape\"], symbol>>;\nexport interface ZodMiniObject<\n/** @ts-ignore Cast variance */\nout Shape extends core.$ZodShape = core.$ZodShape, out Config extends core.$ZodObjectConfig = core.$strip> extends ZodMiniType<any, any, core.$ZodObjectInternals<Shape, Config>>, core.$ZodObject<Shape, Config> {\n    shape: Shape;\n}\nexport declare const ZodMiniObject: core.$constructor<ZodMiniObject>;\nexport declare function object<T extends core.$ZodLooseShape = Record<never, SomeType>>(shape?: T, params?: string | core.$ZodObjectParams): ZodMiniObject<T, core.$strip>;\nexport declare function strictObject<T extends core.$ZodLooseShape>(shape: T, params?: string | core.$ZodObjectParams): ZodMiniObject<T, core.$strict>;\nexport declare function looseObject<T extends core.$ZodLooseShape>(shape: T, params?: string | core.$ZodObjectParams): ZodMiniObject<T, core.$loose>;\nexport declare function extend<T extends ZodMiniObject, U extends core.$ZodLooseShape>(schema: T, shape: U): ZodMiniObject<util.Extend<T[\"shape\"], U>, T[\"_zod\"][\"config\"]>;\n/** @deprecated Identical to `z.extend(A, B)` */\nexport declare function merge<T extends ZodMiniObject, U extends ZodMiniObject>(a: T, b: U): ZodMiniObject<util.Extend<T[\"shape\"], U[\"shape\"]>, T[\"_zod\"][\"config\"]>;\nexport declare function pick<T extends ZodMiniObject, M extends util.Mask<keyof T[\"shape\"]>>(schema: T, mask: M): ZodMiniObject<util.Flatten<Pick<T[\"shape\"], keyof T[\"shape\"] & keyof M>>, T[\"_zod\"][\"config\"]>;\nexport declare function omit<T extends ZodMiniObject, const M extends util.Mask<keyof T[\"shape\"]>>(schema: T, mask: M): ZodMiniObject<util.Flatten<Omit<T[\"shape\"], keyof M>>, T[\"_zod\"][\"config\"]>;\nexport declare function partial<T extends ZodMiniObject>(schema: T): ZodMiniObject<{\n    [k in keyof T[\"shape\"]]: ZodMiniOptional<T[\"shape\"][k]>;\n}, T[\"_zod\"][\"config\"]>;\nexport declare function partial<T extends ZodMiniObject, M extends util.Mask<keyof T[\"shape\"]>>(schema: T, mask: M): ZodMiniObject<{\n    [k in keyof T[\"shape\"]]: k extends keyof M ? ZodMiniOptional<T[\"shape\"][k]> : T[\"shape\"][k];\n}, T[\"_zod\"][\"config\"]>;\nexport type RequiredInterfaceShape<Shape extends core.$ZodLooseShape, Keys extends PropertyKey = keyof Shape> = util.Identity<{\n    [k in keyof Shape as k extends Keys ? k : never]: ZodMiniNonOptional<Shape[k]>;\n} & {\n    [k in keyof Shape as k extends Keys ? never : k]: Shape[k];\n}>;\nexport declare function required<T extends ZodMiniObject>(schema: T): ZodMiniObject<{\n    [k in keyof T[\"shape\"]]: ZodMiniNonOptional<T[\"shape\"][k]>;\n}, T[\"_zod\"][\"config\"]>;\nexport declare function required<T extends ZodMiniObject, M extends util.Mask<keyof T[\"shape\"]>>(schema: T, mask: M): ZodMiniObject<util.Extend<T[\"shape\"], {\n    [k in keyof M & keyof T[\"shape\"]]: ZodMiniNonOptional<T[\"shape\"][k]>;\n}>, T[\"_zod\"][\"config\"]>;\nexport declare function catchall<T extends ZodMiniObject, U extends SomeType>(inst: T, catchall: U): ZodMiniObject<T[\"shape\"], core.$catchall<U>>;\nexport interface ZodMiniUnion<T extends readonly SomeType[] = readonly core.$ZodType[]> extends _ZodMiniType<core.$ZodUnionInternals<T>> {\n}\nexport declare const ZodMiniUnion: core.$constructor<ZodMiniUnion>;\nexport declare function union<const T extends readonly SomeType[]>(options: T, params?: string | core.$ZodUnionParams): ZodMiniUnion<T>;\nexport interface ZodMiniDiscriminatedUnion<Options extends readonly SomeType[] = readonly core.$ZodType[]> extends ZodMiniUnion<Options> {\n    _zod: core.$ZodDiscriminatedUnionInternals<Options>;\n}\nexport declare const ZodMiniDiscriminatedUnion: core.$constructor<ZodMiniDiscriminatedUnion>;\nexport declare function discriminatedUnion<Types extends readonly [core.$ZodTypeDiscriminable, ...core.$ZodTypeDiscriminable[]]>(discriminator: string, options: Types, params?: string | core.$ZodDiscriminatedUnionParams): ZodMiniDiscriminatedUnion<Types>;\nexport interface ZodMiniIntersection<A extends SomeType = core.$ZodType, B extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodIntersectionInternals<A, B>> {\n}\nexport declare const ZodMiniIntersection: core.$constructor<ZodMiniIntersection>;\nexport declare function intersection<T extends SomeType, U extends SomeType>(left: T, right: U): ZodMiniIntersection<T, U>;\nexport interface ZodMiniTuple<T extends util.TupleItems = readonly core.$ZodType[], Rest extends SomeType | null = core.$ZodType | null> extends _ZodMiniType<core.$ZodTupleInternals<T, Rest>> {\n}\nexport declare const ZodMiniTuple: core.$constructor<ZodMiniTuple>;\nexport declare function tuple<const T extends readonly [SomeType, ...SomeType[]]>(items: T, params?: string | core.$ZodTupleParams): ZodMiniTuple<T, null>;\nexport declare function tuple<const T extends readonly [SomeType, ...SomeType[]], Rest extends SomeType>(items: T, rest: Rest, params?: string | core.$ZodTupleParams): ZodMiniTuple<T, Rest>;\nexport declare function tuple(items: [], params?: string | core.$ZodTupleParams): ZodMiniTuple<[], null>;\nexport interface ZodMiniRecord<Key extends core.$ZodRecordKey = core.$ZodRecordKey, Value extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodRecordInternals<Key, Value>> {\n}\nexport declare const ZodMiniRecord: core.$constructor<ZodMiniRecord>;\nexport declare function record<Key extends core.$ZodRecordKey, Value extends SomeType>(keyType: Key, valueType: Value, params?: string | core.$ZodRecordParams): ZodMiniRecord<Key, Value>;\nexport declare function partialRecord<Key extends core.$ZodRecordKey, Value extends SomeType>(keyType: Key, valueType: Value, params?: string | core.$ZodRecordParams): ZodMiniRecord<Key & core.$partial, Value>;\nexport interface ZodMiniMap<Key extends SomeType = core.$ZodType, Value extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodMapInternals<Key, Value>> {\n}\nexport declare const ZodMiniMap: core.$constructor<ZodMiniMap>;\nexport declare function map<Key extends SomeType, Value extends SomeType>(keyType: Key, valueType: Value, params?: string | core.$ZodMapParams): ZodMiniMap<Key, Value>;\nexport interface ZodMiniSet<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodSetInternals<T>> {\n}\nexport declare const ZodMiniSet: core.$constructor<ZodMiniSet>;\nexport declare function set<Value extends SomeType>(valueType: Value, params?: string | core.$ZodSetParams): ZodMiniSet<Value>;\nexport interface ZodMiniEnum<T extends util.EnumLike = util.EnumLike> extends _ZodMiniType<core.$ZodEnumInternals<T>> {\n}\nexport declare const ZodMiniEnum: core.$constructor<ZodMiniEnum>;\ndeclare function _enum<const T extends readonly string[]>(values: T, params?: string | core.$ZodEnumParams): ZodMiniEnum<util.ToEnum<T[number]>>;\ndeclare function _enum<T extends util.EnumLike>(entries: T, params?: string | core.$ZodEnumParams): ZodMiniEnum<T>;\nexport { _enum as enum };\n/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.\n *\n * ```ts\n * enum Colors { red, green, blue }\n * z.enum(Colors);\n * ```\n */\nexport declare function nativeEnum<T extends util.EnumLike>(entries: T, params?: string | core.$ZodEnumParams): ZodMiniEnum<T>;\nexport interface ZodMiniLiteral<T extends util.Literal = util.Literal> extends _ZodMiniType<core.$ZodLiteralInternals<T>> {\n}\nexport declare const ZodMiniLiteral: core.$constructor<ZodMiniLiteral>;\nexport declare function literal<const T extends ReadonlyArray<util.Literal>>(value: T, params?: string | core.$ZodLiteralParams): ZodMiniLiteral<T[number]>;\nexport declare function literal<const T extends util.Literal>(value: T, params?: string | core.$ZodLiteralParams): ZodMiniLiteral<T>;\nexport interface ZodMiniFile extends _ZodMiniType<core.$ZodFileInternals> {\n}\nexport declare const ZodMiniFile: core.$constructor<ZodMiniFile>;\nexport declare function file(params?: string | core.$ZodFileParams): ZodMiniFile;\nexport interface ZodMiniTransform<O = unknown, I = unknown> extends _ZodMiniType<core.$ZodTransformInternals<O, I>> {\n}\nexport declare const ZodMiniTransform: core.$constructor<ZodMiniTransform>;\nexport declare function transform<I = unknown, O = I>(fn: (input: I, ctx: core.ParsePayload) => O): ZodMiniTransform<Awaited<O>, I>;\nexport interface ZodMiniOptional<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodOptionalInternals<T>>, core.$ZodOptional<T> {\n}\nexport declare const ZodMiniOptional: core.$constructor<ZodMiniOptional>;\nexport declare function optional<T extends SomeType>(innerType: T): ZodMiniOptional<T>;\nexport interface ZodMiniNullable<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodNullableInternals<T>> {\n}\nexport declare const ZodMiniNullable: core.$constructor<ZodMiniNullable>;\nexport declare function nullable<T extends SomeType>(innerType: T): ZodMiniNullable<T>;\nexport declare function nullish<T extends SomeType>(innerType: T): ZodMiniOptional<ZodMiniNullable<T>>;\nexport interface ZodMiniDefault<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodDefaultInternals<T>> {\n}\nexport declare const ZodMiniDefault: core.$constructor<ZodMiniDefault>;\nexport declare function _default<T extends SomeType>(innerType: T, defaultValue: util.NoUndefined<core.output<T>> | (() => util.NoUndefined<core.output<T>>)): ZodMiniDefault<T>;\nexport interface ZodMiniPrefault<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodPrefaultInternals<T>> {\n}\nexport declare const ZodMiniPrefault: core.$constructor<ZodMiniPrefault>;\nexport declare function prefault<T extends SomeType>(innerType: T, defaultValue: util.NoUndefined<core.input<T>> | (() => util.NoUndefined<core.input<T>>)): ZodMiniPrefault<T>;\nexport interface ZodMiniNonOptional<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodNonOptionalInternals<T>> {\n}\nexport declare const ZodMiniNonOptional: core.$constructor<ZodMiniNonOptional>;\nexport declare function nonoptional<T extends SomeType>(innerType: T, params?: string | core.$ZodNonOptionalParams): ZodMiniNonOptional<T>;\nexport interface ZodMiniSuccess<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodSuccessInternals<T>> {\n}\nexport declare const ZodMiniSuccess: core.$constructor<ZodMiniSuccess>;\nexport declare function success<T extends SomeType>(innerType: T): ZodMiniSuccess<T>;\nexport interface ZodMiniCatch<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodCatchInternals<T>> {\n}\nexport declare const ZodMiniCatch: core.$constructor<ZodMiniCatch>;\ndeclare function _catch<T extends SomeType>(innerType: T, catchValue: core.output<T> | ((ctx: core.$ZodCatchCtx) => core.output<T>)): ZodMiniCatch<T>;\nexport { _catch as catch };\nexport interface ZodMiniNaN extends _ZodMiniType<core.$ZodNaNInternals> {\n}\nexport declare const ZodMiniNaN: core.$constructor<ZodMiniNaN>;\nexport declare function nan(params?: string | core.$ZodNaNParams): ZodMiniNaN;\nexport interface ZodMiniPipe<A extends SomeType = core.$ZodType, B extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodPipeInternals<A, B>> {\n}\nexport declare const ZodMiniPipe: core.$constructor<ZodMiniPipe>;\nexport declare function pipe<const A extends SomeType, B extends core.$ZodType<unknown, core.output<A>> = core.$ZodType<unknown, core.output<A>>>(in_: A, out: B | core.$ZodType<unknown, core.output<A>>): ZodMiniPipe<A, B>;\nexport interface ZodMiniReadonly<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodReadonlyInternals<T>> {\n}\nexport declare const ZodMiniReadonly: core.$constructor<ZodMiniReadonly>;\nexport declare function readonly<T extends SomeType>(innerType: T): ZodMiniReadonly<T>;\nexport interface ZodMiniTemplateLiteral<Template extends string = string> extends _ZodMiniType<core.$ZodTemplateLiteralInternals<Template>> {\n}\nexport declare const ZodMiniTemplateLiteral: core.$constructor<ZodMiniTemplateLiteral>;\nexport declare function templateLiteral<const Parts extends core.$ZodTemplateLiteralPart[]>(parts: Parts, params?: string | core.$ZodTemplateLiteralParams): ZodMiniTemplateLiteral<core.$PartsToTemplateLiteral<Parts>>;\nexport interface ZodMiniLazy<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodLazyInternals<T>> {\n}\nexport declare const ZodMiniLazy: core.$constructor<ZodMiniLazy>;\ndeclare function _lazy<T extends SomeType>(getter: () => T): ZodMiniLazy<T>;\nexport { _lazy as lazy };\nexport interface ZodMiniPromise<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodPromiseInternals<T>> {\n}\nexport declare const ZodMiniPromise: core.$constructor<ZodMiniPromise>;\nexport declare function promise<T extends SomeType>(innerType: T): ZodMiniPromise<T>;\nexport interface ZodMiniCustom<O = unknown, I = unknown> extends _ZodMiniType<core.$ZodCustomInternals<O, I>> {\n}\nexport declare const ZodMiniCustom: core.$constructor<ZodMiniCustom>;\nexport declare function check<O = unknown>(fn: core.CheckFn<O>, params?: string | core.$ZodCustomParams): core.$ZodCheck<O>;\nexport declare function custom<O = unknown, I = O>(fn?: (data: O) => unknown, _params?: string | core.$ZodCustomParams | undefined): ZodMiniCustom<O, I>;\nexport declare function refine<T>(fn: (arg: NoInfer<T>) => util.MaybeAsync<unknown>, _params?: string | core.$ZodCustomParams): core.$ZodCheck<T>;\ndeclare abstract class Class {\n    constructor(..._args: any[]);\n}\ndeclare function _instanceof<T extends typeof Class>(cls: T, params?: core.$ZodCustomParams): ZodMiniCustom<InstanceType<T>, InstanceType<T>>;\nexport { _instanceof as instanceof };\nexport declare const stringbool: (_params?: string | core.$ZodStringBoolParams) => ZodMiniPipe<ZodMiniPipe<ZodMiniString, ZodMiniTransform<boolean, string>>, ZodMiniBoolean>;\ntype _ZodMiniJSONSchema = ZodMiniUnion<[\n    ZodMiniString,\n    ZodMiniNumber,\n    ZodMiniBoolean,\n    ZodMiniNull,\n    ZodMiniArray<ZodMiniJSONSchema>,\n    ZodMiniRecord<ZodMiniString<string>, ZodMiniJSONSchema>\n]>;\ntype _ZodMiniJSONSchemaInternals = _ZodMiniJSONSchema[\"_zod\"];\nexport interface ZodMiniJSONSchemaInternals extends _ZodMiniJSONSchemaInternals {\n    output: util.JSONType;\n    input: util.JSONType;\n}\nexport interface ZodMiniJSONSchema extends _ZodMiniJSONSchema {\n    _zod: ZodMiniJSONSchemaInternals;\n}\nexport declare function json(): ZodMiniJSONSchema;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/mini/schemas.d.cts",
        "start": 1,
        "end": 356,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 356,
          "column": 2,
          "position": 7699
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/mini/schemas.d.cts",
        "start": 1,
        "end": 356,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 356,
          "column": 2,
          "position": 7699
        }
      }
    },
    {
      "format": "typescript",
      "lines": 22,
      "fragment": "import * as core from \"../core/index.js\";\nimport * as schemas from \"./schemas.js\";\nexport interface ZodMiniISODateTime extends schemas.ZodMiniStringFormat<\"datetime\"> {\n    _zod: core.$ZodISODateTimeInternals;\n}\nexport declare const ZodMiniISODateTime: core.$constructor<ZodMiniISODateTime>;\nexport declare function datetime(params?: string | core.$ZodISODateTimeParams): ZodMiniISODateTime;\nexport interface ZodMiniISODate extends schemas.ZodMiniStringFormat<\"date\"> {\n    _zod: core.$ZodISODateInternals;\n}\nexport declare const ZodMiniISODate: core.$constructor<ZodMiniISODate>;\nexport declare function date(params?: string | core.$ZodISODateParams): ZodMiniISODate;\nexport interface ZodMiniISOTime extends schemas.ZodMiniStringFormat<\"time\"> {\n    _zod: core.$ZodISOTimeInternals;\n}\nexport declare const ZodMiniISOTime: core.$constructor<ZodMiniISOTime>;\nexport declare function time(params?: string | core.$ZodISOTimeParams): ZodMiniISOTime;\nexport interface ZodMiniISODuration extends schemas.ZodMiniStringFormat<\"duration\"> {\n    _zod: core.$ZodISODurationInternals;\n}\nexport declare const ZodMiniISODuration: core.$constructor<ZodMiniISODuration>;\nexport declare function duration(params?: string | core.$ZodISODurationParams): ZodMiniISODuration;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/mini/iso.d.ts",
        "start": 1,
        "end": 22,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 22,
          "column": 2,
          "position": 308
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/mini/iso.d.ts",
        "start": 1,
        "end": 22,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 22,
          "column": 2,
          "position": 308
        }
      }
    },
    {
      "format": "typescript",
      "lines": 22,
      "fragment": "import * as core from \"../core/index.cjs\";\nimport * as schemas from \"./schemas.cjs\";\nexport interface ZodMiniISODateTime extends schemas.ZodMiniStringFormat<\"datetime\"> {\n    _zod: core.$ZodISODateTimeInternals;\n}\nexport declare const ZodMiniISODateTime: core.$constructor<ZodMiniISODateTime>;\nexport declare function datetime(params?: string | core.$ZodISODateTimeParams): ZodMiniISODateTime;\nexport interface ZodMiniISODate extends schemas.ZodMiniStringFormat<\"date\"> {\n    _zod: core.$ZodISODateInternals;\n}\nexport declare const ZodMiniISODate: core.$constructor<ZodMiniISODate>;\nexport declare function date(params?: string | core.$ZodISODateParams): ZodMiniISODate;\nexport interface ZodMiniISOTime extends schemas.ZodMiniStringFormat<\"time\"> {\n    _zod: core.$ZodISOTimeInternals;\n}\nexport declare const ZodMiniISOTime: core.$constructor<ZodMiniISOTime>;\nexport declare function time(params?: string | core.$ZodISOTimeParams): ZodMiniISOTime;\nexport interface ZodMiniISODuration extends schemas.ZodMiniStringFormat<\"duration\"> {\n    _zod: core.$ZodISODurationInternals;\n}\nexport declare const ZodMiniISODuration: core.$constructor<ZodMiniISODuration>;\nexport declare function duration(params?: string | core.$ZodISODurationParams): ZodMiniISODuration;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/mini/iso.d.cts",
        "start": 1,
        "end": 22,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 22,
          "column": 2,
          "position": 308
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/mini/iso.d.cts",
        "start": 1,
        "end": 22,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 22,
          "column": 2,
          "position": 308
        }
      }
    },
    {
      "format": "typescript",
      "lines": 11,
      "fragment": "export * as core from \"../core/index.js\";\nexport * from \"./parse.js\";\nexport * from \"./schemas.js\";\nexport * from \"./checks.js\";\nexport type { infer, output, input } from \"../core/index.js\";\nexport { globalRegistry, registry, config, $output, $input, $brand, function, clone, regexes, treeifyError, prettifyError, formatError, flattenError, toJSONSchema, TimePrecision, NEVER, } from \"../core/index.js\";\nexport * as locales from \"../locales/index.js\";\n/** A special constant with type `never` */\nexport * as iso from \"./iso.js\";\nexport { ZodMiniISODateTime, ZodMiniISODate, ZodMiniISOTime, ZodMiniISODuration, } from \"./iso.js\";\nexport * as coerce from \"./coerce.js\";",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/mini/external.d.ts",
        "start": 1,
        "end": 11,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 11,
          "column": 2,
          "position": 182
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/mini/external.ts",
        "start": 1,
        "end": 11,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 11,
          "column": 2,
          "position": 182
        }
      }
    },
    {
      "format": "typescript",
      "lines": 11,
      "fragment": "export * as core from \"../core/index.cjs\";\nexport * from \"./parse.cjs\";\nexport * from \"./schemas.cjs\";\nexport * from \"./checks.cjs\";\nexport type { infer, output, input } from \"../core/index.cjs\";\nexport { globalRegistry, registry, config, $output, $input, $brand, function, clone, regexes, treeifyError, prettifyError, formatError, flattenError, toJSONSchema, TimePrecision, NEVER, } from \"../core/index.cjs\";\nexport * as locales from \"../locales/index.cjs\";\n/** A special constant with type `never` */\nexport * as iso from \"./iso.cjs\";\nexport { ZodMiniISODateTime, ZodMiniISODate, ZodMiniISOTime, ZodMiniISODuration, } from \"./iso.cjs\";\nexport * as coerce from \"./coerce.cjs\";",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/mini/external.d.cts",
        "start": 1,
        "end": 11,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 11,
          "column": 2,
          "position": 182
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/mini/external.d.cts",
        "start": 1,
        "end": 11,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 11,
          "column": 2,
          "position": 182
        }
      }
    },
    {
      "format": "typescript",
      "lines": 39,
      "fragment": "export { default as ar } from \"./ar.js\";\nexport { default as az } from \"./az.js\";\nexport { default as be } from \"./be.js\";\nexport { default as ca } from \"./ca.js\";\nexport { default as cs } from \"./cs.js\";\nexport { default as de } from \"./de.js\";\nexport { default as en } from \"./en.js\";\nexport { default as eo } from \"./eo.js\";\nexport { default as es } from \"./es.js\";\nexport { default as fa } from \"./fa.js\";\nexport { default as fi } from \"./fi.js\";\nexport { default as fr } from \"./fr.js\";\nexport { default as frCA } from \"./fr-CA.js\";\nexport { default as he } from \"./he.js\";\nexport { default as hu } from \"./hu.js\";\nexport { default as id } from \"./id.js\";\nexport { default as it } from \"./it.js\";\nexport { default as ja } from \"./ja.js\";\nexport { default as kh } from \"./kh.js\";\nexport { default as ko } from \"./ko.js\";\nexport { default as mk } from \"./mk.js\";\nexport { default as ms } from \"./ms.js\";\nexport { default as nl } from \"./nl.js\";\nexport { default as no } from \"./no.js\";\nexport { default as ota } from \"./ota.js\";\nexport { default as ps } from \"./ps.js\";\nexport { default as pl } from \"./pl.js\";\nexport { default as pt } from \"./pt.js\";\nexport { default as ru } from \"./ru.js\";\nexport { default as sl } from \"./sl.js\";\nexport { default as sv } from \"./sv.js\";\nexport { default as ta } from \"./ta.js\";\nexport { default as th } from \"./th.js\";\nexport { default as tr } from \"./tr.js\";\nexport { default as ua } from \"./ua.js\";\nexport { default as ur } from \"./ur.js\";\nexport { default as vi } from \"./vi.js\";\nexport { default as zhCN } from \"./zh-CN.js\";\nexport { default as zhTW } from \"./zh-TW.js\";",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/locales/index.d.ts",
        "start": 1,
        "end": 39,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 39,
          "column": 2,
          "position": 661
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/locales/index.ts",
        "start": 1,
        "end": 39,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 39,
          "column": 2,
          "position": 661
        }
      }
    },
    {
      "format": "typescript",
      "lines": 39,
      "fragment": "export { default as ar } from \"./ar.cjs\";\nexport { default as az } from \"./az.cjs\";\nexport { default as be } from \"./be.cjs\";\nexport { default as ca } from \"./ca.cjs\";\nexport { default as cs } from \"./cs.cjs\";\nexport { default as de } from \"./de.cjs\";\nexport { default as en } from \"./en.cjs\";\nexport { default as eo } from \"./eo.cjs\";\nexport { default as es } from \"./es.cjs\";\nexport { default as fa } from \"./fa.cjs\";\nexport { default as fi } from \"./fi.cjs\";\nexport { default as fr } from \"./fr.cjs\";\nexport { default as frCA } from \"./fr-CA.cjs\";\nexport { default as he } from \"./he.cjs\";\nexport { default as hu } from \"./hu.cjs\";\nexport { default as id } from \"./id.cjs\";\nexport { default as it } from \"./it.cjs\";\nexport { default as ja } from \"./ja.cjs\";\nexport { default as kh } from \"./kh.cjs\";\nexport { default as ko } from \"./ko.cjs\";\nexport { default as mk } from \"./mk.cjs\";\nexport { default as ms } from \"./ms.cjs\";\nexport { default as nl } from \"./nl.cjs\";\nexport { default as no } from \"./no.cjs\";\nexport { default as ota } from \"./ota.cjs\";\nexport { default as ps } from \"./ps.cjs\";\nexport { default as pl } from \"./pl.cjs\";\nexport { default as pt } from \"./pt.cjs\";\nexport { default as ru } from \"./ru.cjs\";\nexport { default as sl } from \"./sl.cjs\";\nexport { default as sv } from \"./sv.cjs\";\nexport { default as ta } from \"./ta.cjs\";\nexport { default as th } from \"./th.cjs\";\nexport { default as tr } from \"./tr.cjs\";\nexport { default as ua } from \"./ua.cjs\";\nexport { default as ur } from \"./ur.cjs\";\nexport { default as vi } from \"./vi.cjs\";\nexport { default as zhCN } from \"./zh-CN.cjs\";\nexport { default as zhTW } from \"./zh-TW.cjs\";",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/locales/index.d.cts",
        "start": 1,
        "end": 39,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 39,
          "column": 2,
          "position": 661
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/locales/index.d.cts",
        "start": 1,
        "end": 39,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 39,
          "column": 2,
          "position": 661
        }
      }
    },
    {
      "format": "typescript",
      "lines": 183,
      "fragment": "import type * as checks from \"./checks.js\";\nimport type { $ZodConfig } from \"./core.js\";\nimport type * as errors from \"./errors.js\";\nimport type * as schemas from \"./schemas.js\";\nexport type JSONType = string | number | boolean | null | JSONType[] | {\n    [key: string]: JSONType;\n};\nexport type JWTAlgorithm = \"HS256\" | \"HS384\" | \"HS512\" | \"RS256\" | \"RS384\" | \"RS512\" | \"ES256\" | \"ES384\" | \"ES512\" | \"PS256\" | \"PS384\" | \"PS512\" | \"EdDSA\" | (string & {});\nexport type IPVersion = \"v4\" | \"v6\";\nexport type MimeTypes = \"application/json\" | \"application/xml\" | \"application/x-www-form-urlencoded\" | \"application/javascript\" | \"application/pdf\" | \"application/zip\" | \"application/vnd.ms-excel\" | \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\" | \"application/msword\" | \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\" | \"application/vnd.ms-powerpoint\" | \"application/vnd.openxmlformats-officedocument.presentationml.presentation\" | \"application/octet-stream\" | \"application/graphql\" | \"text/html\" | \"text/plain\" | \"text/css\" | \"text/javascript\" | \"text/csv\" | \"image/png\" | \"image/jpeg\" | \"image/gif\" | \"image/svg+xml\" | \"image/webp\" | \"audio/mpeg\" | \"audio/ogg\" | \"audio/wav\" | \"audio/webm\" | \"video/mp4\" | \"video/webm\" | \"video/ogg\" | \"font/woff\" | \"font/woff2\" | \"font/ttf\" | \"font/otf\" | \"multipart/form-data\" | (string & {});\nexport type ParsedTypes = \"string\" | \"number\" | \"bigint\" | \"boolean\" | \"symbol\" | \"undefined\" | \"object\" | \"function\" | \"file\" | \"date\" | \"array\" | \"map\" | \"set\" | \"nan\" | \"null\" | \"promise\";\nexport type AssertEqual<T, U> = (<V>() => V extends T ? 1 : 2) extends <V>() => V extends U ? 1 : 2 ? true : false;\nexport type AssertNotEqual<T, U> = (<V>() => V extends T ? 1 : 2) extends <V>() => V extends U ? 1 : 2 ? false : true;\nexport type AssertExtends<T, U> = T extends U ? T : never;\nexport type IsAny<T> = 0 extends 1 & T ? true : false;\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\nexport type OmitKeys<T, K extends string> = Pick<T, Exclude<keyof T, K>>;\nexport type MakePartial<T, K extends keyof T> = Omit<T, K> & InexactPartial<Pick<T, K>>;\nexport type MakeRequired<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;\nexport type Exactly<T, X> = T & Record<Exclude<keyof X, keyof T>, never>;\nexport type NoUndefined<T> = T extends undefined ? never : T;\nexport type Whatever = {} | undefined | null;\nexport type LoosePartial<T extends object> = InexactPartial<T> & {\n    [k: string]: unknown;\n};\nexport type Mask<Keys extends PropertyKey> = {\n    [K in Keys]?: true;\n};\nexport type Writeable<T> = {\n    -readonly [P in keyof T]: T[P];\n} & {};\nexport type InexactPartial<T> = {\n    [P in keyof T]?: T[P] | undefined;\n};\nexport type EmptyObject = Record<string, never>;\nexport type BuiltIn = (((...args: any[]) => any) | (new (...args: any[]) => any)) | {\n    readonly [Symbol.toStringTag]: string;\n} | Date | Error | Generator | Promise<unknown> | RegExp;\nexport type MakeReadonly<T> = T extends Map<infer K, infer V> ? ReadonlyMap<K, V> : T extends Set<infer V> ? ReadonlySet<V> : T extends [infer Head, ...infer Tail] ? readonly [Head, ...Tail] : T extends Array<infer V> ? ReadonlyArray<V> : T extends BuiltIn ? T : Readonly<T>;\nexport type SomeObject = Record<PropertyKey, any>;\nexport type Identity<T> = T;\nexport type Flatten<T> = Identity<{\n    [k in keyof T]: T[k];\n}>;\nexport type Mapped<T> = {\n    [k in keyof T]: T[k];\n};\nexport type Prettify<T> = {\n    [K in keyof T]: T[K];\n} & {};\nexport type NoNeverKeys<T> = {\n    [k in keyof T]: [T[k]] extends [never] ? never : k;\n}[keyof T];\nexport type NoNever<T> = Identity<{\n    [k in NoNeverKeys<T>]: k extends keyof T ? T[k] : never;\n}>;\nexport type Extend<A extends SomeObject, B extends SomeObject> = Flatten<keyof A & keyof B extends never ? A & B : {\n    [K in keyof A as K extends keyof B ? never : K]: A[K];\n} & {\n    [K in keyof B]: B[K];\n}>;\nexport type TupleItems = ReadonlyArray<schemas.SomeType>;\nexport type AnyFunc = (...args: any[]) => any;\nexport type IsProp<T, K extends keyof T> = T[K] extends AnyFunc ? never : K;\nexport type MaybeAsync<T> = T | Promise<T>;\nexport type KeyOf<T> = keyof OmitIndexSignature<T>;\nexport type OmitIndexSignature<T> = {\n    [K in keyof T as string extends K ? never : K extends string ? K : never]: T[K];\n};\nexport type ExtractIndexSignature<T> = {\n    [K in keyof T as string extends K ? K : K extends string ? never : K]: T[K];\n};\nexport type Keys<T extends object> = keyof OmitIndexSignature<T>;\nexport type SchemaClass<T extends schemas.SomeType> = {\n    new (def: T[\"_zod\"][\"def\"]): T;\n};\nexport type EnumValue = string | number;\nexport type EnumLike = Readonly<Record<string, EnumValue>>;\nexport type ToEnum<T extends EnumValue> = Flatten<{\n    [k in T]: k;\n}>;\nexport type KeysEnum<T extends object> = ToEnum<Exclude<keyof T, symbol>>;\nexport type KeysArray<T extends object> = Flatten<(keyof T & string)[]>;\nexport type Literal = string | number | bigint | boolean | null | undefined;\nexport type LiteralArray = Array<Literal>;\nexport type Primitive = string | number | symbol | bigint | boolean | null | undefined;\nexport type PrimitiveArray = Array<Primitive>;\nexport type HasSize = {\n    size: number;\n};\nexport type HasLength = {\n    length: number;\n};\nexport type Numeric = number | bigint | Date;\nexport type SafeParseResult<T> = SafeParseSuccess<T> | SafeParseError<T>;\nexport type SafeParseSuccess<T> = {\n    success: true;\n    data: T;\n    error?: never;\n};\nexport type SafeParseError<T> = {\n    success: false;\n    data?: never;\n    error: errors.$ZodError<T>;\n};\nexport type PropValues = Record<string, Set<Primitive>>;\nexport type PrimitiveSet = Set<Primitive>;\nexport declare function assertEqual<A, B>(val: AssertEqual<A, B>): AssertEqual<A, B>;\nexport declare function assertNotEqual<A, B>(val: AssertNotEqual<A, B>): AssertNotEqual<A, B>;\nexport declare function assertIs<T>(_arg: T): void;\nexport declare function assertNever(_x: never): never;\nexport declare function assert<T>(_: any): asserts _ is T;\nexport declare function getEnumValues(entries: EnumLike): EnumValue[];\nexport declare function joinValues<T extends Primitive[]>(array: T, separator?: string): string;\nexport declare function jsonStringifyReplacer(_: string, value: any): any;\nexport declare function cached<T>(getter: () => T): {\n    value: T;\n};\nexport declare function nullish(input: any): boolean;\nexport declare function cleanRegex(source: string): string;\nexport declare function floatSafeRemainder(val: number, step: number): number;\nexport declare function defineLazy<T, K extends keyof T>(object: T, key: K, getter: () => T[K]): void;\nexport declare function assignProp<T extends object, K extends PropertyKey>(target: T, prop: K, value: K extends keyof T ? T[K] : any): void;\nexport declare function getElementAtPath(obj: any, path: (string | number)[] | null | undefined): any;\nexport declare function promiseAllObject<T extends object>(promisesObj: T): Promise<{\n    [k in keyof T]: Awaited<T[k]>;\n}>;\nexport declare function randomString(length?: number): string;\nexport declare function esc(str: string): string;\nexport declare const captureStackTrace: (targetObject: object, constructorOpt?: Function) => void;\nexport declare function isObject(data: any): data is Record<PropertyKey, unknown>;\nexport declare const allowsEval: {\n    value: boolean;\n};\nexport declare function isPlainObject(o: any): o is Record<PropertyKey, unknown>;\nexport declare function numKeys(data: any): number;\nexport declare const getParsedType: (data: any) => ParsedTypes;\nexport declare const propertyKeyTypes: Set<string>;\nexport declare const primitiveTypes: Set<string>;\nexport declare function escapeRegex(str: string): string;\nexport declare function clone<T extends schemas.$ZodType>(inst: T, def?: T[\"_zod\"][\"def\"], params?: {\n    parent: boolean;\n}): T;\nexport type EmptyToNever<T> = keyof T extends never ? never : T;\nexport type Normalize<T> = T extends undefined ? never : T extends Record<any, any> ? Flatten<{\n    [k in keyof Omit<T, \"error\" | \"message\">]: T[k];\n} & (\"error\" extends keyof T ? {\n    error?: Exclude<T[\"error\"], string>;\n} : unknown)> : never;\nexport declare function normalizeParams<T>(_params: T): Normalize<T>;\nexport declare function createTransparentProxy<T extends object>(getter: () => T): T;\nexport declare function stringifyPrimitive(value: any): string;\nexport declare function optionalKeys(shape: schemas.$ZodShape): string[];\nexport type CleanKey<T extends PropertyKey> = T extends `?${infer K}` ? K : T extends `${infer K}?` ? K : T;\nexport type ToCleanMap<T extends schemas.$ZodLooseShape> = {\n    [k in keyof T]: k extends `?${infer K}` ? K : k extends `${infer K}?` ? K : k;\n};\nexport type FromCleanMap<T extends schemas.$ZodLooseShape> = {\n    [k in keyof T as k extends `?${infer K}` ? K : k extends `${infer K}?` ? K : k]: k;\n};\nexport declare const NUMBER_FORMAT_RANGES: Record<checks.$ZodNumberFormats, [number, number]>;\nexport declare const BIGINT_FORMAT_RANGES: Record<checks.$ZodBigIntFormats, [bigint, bigint]>;\nexport declare function pick(schema: schemas.$ZodObject, mask: Record<string, unknown>): any;\nexport declare function omit(schema: schemas.$ZodObject, mask: object): any;\nexport declare function extend(schema: schemas.$ZodObject, shape: schemas.$ZodShape): any;\nexport declare function merge(a: schemas.$ZodObject, b: schemas.$ZodObject): any;\nexport declare function partial(Class: SchemaClass<schemas.$ZodOptional> | null, schema: schemas.$ZodObject, mask: object | undefined): any;\nexport declare function required(Class: SchemaClass<schemas.$ZodNonOptional>, schema: schemas.$ZodObject, mask: object | undefined): any;\nexport type Constructor<T, Def extends any[] = any[]> = new (...args: Def) => T;\nexport declare function aborted(x: schemas.ParsePayload, startIndex?: number): boolean;\nexport declare function prefixIssues(path: PropertyKey, issues: errors.$ZodRawIssue[]): errors.$ZodRawIssue[];\nexport declare function unwrapMessage(message: string | {\n    message: string;\n} | undefined | null): string | undefined;\nexport declare function finalizeIssue(iss: errors.$ZodRawIssue, ctx: schemas.ParseContextInternal | undefined, config: $ZodConfig): errors.$ZodIssue;\nexport declare function getSizableOrigin(input: any): \"set\" | \"map\" | \"file\" | \"unknown\";\nexport declare function getLengthableOrigin(input: any): \"array\" | \"string\" | \"unknown\";\nexport declare function issue(_iss: string, input: any, inst: any): errors.$ZodRawIssue;\nexport declare function issue(_iss: errors.$ZodRawIssue): errors.$ZodRawIssue;\nexport declare function cleanEnum(obj: Record<string, EnumValue>): EnumValue[];\nexport declare abstract class Class {\n    constructor(..._args: any[]);\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/core/util.d.ts",
        "start": 1,
        "end": 183,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 183,
          "column": 2,
          "position": 4164
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/util.d.ts",
        "start": 1,
        "end": 183,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 183,
          "column": 2,
          "position": 4164
        }
      }
    },
    {
      "format": "typescript",
      "lines": 183,
      "fragment": "import type * as checks from \"./checks.cjs\";\nimport type { $ZodConfig } from \"./core.cjs\";\nimport type * as errors from \"./errors.cjs\";\nimport type * as schemas from \"./schemas.cjs\";\nexport type JSONType = string | number | boolean | null | JSONType[] | {\n    [key: string]: JSONType;\n};\nexport type JWTAlgorithm = \"HS256\" | \"HS384\" | \"HS512\" | \"RS256\" | \"RS384\" | \"RS512\" | \"ES256\" | \"ES384\" | \"ES512\" | \"PS256\" | \"PS384\" | \"PS512\" | \"EdDSA\" | (string & {});\nexport type IPVersion = \"v4\" | \"v6\";\nexport type MimeTypes = \"application/json\" | \"application/xml\" | \"application/x-www-form-urlencoded\" | \"application/javascript\" | \"application/pdf\" | \"application/zip\" | \"application/vnd.ms-excel\" | \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\" | \"application/msword\" | \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\" | \"application/vnd.ms-powerpoint\" | \"application/vnd.openxmlformats-officedocument.presentationml.presentation\" | \"application/octet-stream\" | \"application/graphql\" | \"text/html\" | \"text/plain\" | \"text/css\" | \"text/javascript\" | \"text/csv\" | \"image/png\" | \"image/jpeg\" | \"image/gif\" | \"image/svg+xml\" | \"image/webp\" | \"audio/mpeg\" | \"audio/ogg\" | \"audio/wav\" | \"audio/webm\" | \"video/mp4\" | \"video/webm\" | \"video/ogg\" | \"font/woff\" | \"font/woff2\" | \"font/ttf\" | \"font/otf\" | \"multipart/form-data\" | (string & {});\nexport type ParsedTypes = \"string\" | \"number\" | \"bigint\" | \"boolean\" | \"symbol\" | \"undefined\" | \"object\" | \"function\" | \"file\" | \"date\" | \"array\" | \"map\" | \"set\" | \"nan\" | \"null\" | \"promise\";\nexport type AssertEqual<T, U> = (<V>() => V extends T ? 1 : 2) extends <V>() => V extends U ? 1 : 2 ? true : false;\nexport type AssertNotEqual<T, U> = (<V>() => V extends T ? 1 : 2) extends <V>() => V extends U ? 1 : 2 ? false : true;\nexport type AssertExtends<T, U> = T extends U ? T : never;\nexport type IsAny<T> = 0 extends 1 & T ? true : false;\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\nexport type OmitKeys<T, K extends string> = Pick<T, Exclude<keyof T, K>>;\nexport type MakePartial<T, K extends keyof T> = Omit<T, K> & InexactPartial<Pick<T, K>>;\nexport type MakeRequired<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;\nexport type Exactly<T, X> = T & Record<Exclude<keyof X, keyof T>, never>;\nexport type NoUndefined<T> = T extends undefined ? never : T;\nexport type Whatever = {} | undefined | null;\nexport type LoosePartial<T extends object> = InexactPartial<T> & {\n    [k: string]: unknown;\n};\nexport type Mask<Keys extends PropertyKey> = {\n    [K in Keys]?: true;\n};\nexport type Writeable<T> = {\n    -readonly [P in keyof T]: T[P];\n} & {};\nexport type InexactPartial<T> = {\n    [P in keyof T]?: T[P] | undefined;\n};\nexport type EmptyObject = Record<string, never>;\nexport type BuiltIn = (((...args: any[]) => any) | (new (...args: any[]) => any)) | {\n    readonly [Symbol.toStringTag]: string;\n} | Date | Error | Generator | Promise<unknown> | RegExp;\nexport type MakeReadonly<T> = T extends Map<infer K, infer V> ? ReadonlyMap<K, V> : T extends Set<infer V> ? ReadonlySet<V> : T extends [infer Head, ...infer Tail] ? readonly [Head, ...Tail] : T extends Array<infer V> ? ReadonlyArray<V> : T extends BuiltIn ? T : Readonly<T>;\nexport type SomeObject = Record<PropertyKey, any>;\nexport type Identity<T> = T;\nexport type Flatten<T> = Identity<{\n    [k in keyof T]: T[k];\n}>;\nexport type Mapped<T> = {\n    [k in keyof T]: T[k];\n};\nexport type Prettify<T> = {\n    [K in keyof T]: T[K];\n} & {};\nexport type NoNeverKeys<T> = {\n    [k in keyof T]: [T[k]] extends [never] ? never : k;\n}[keyof T];\nexport type NoNever<T> = Identity<{\n    [k in NoNeverKeys<T>]: k extends keyof T ? T[k] : never;\n}>;\nexport type Extend<A extends SomeObject, B extends SomeObject> = Flatten<keyof A & keyof B extends never ? A & B : {\n    [K in keyof A as K extends keyof B ? never : K]: A[K];\n} & {\n    [K in keyof B]: B[K];\n}>;\nexport type TupleItems = ReadonlyArray<schemas.SomeType>;\nexport type AnyFunc = (...args: any[]) => any;\nexport type IsProp<T, K extends keyof T> = T[K] extends AnyFunc ? never : K;\nexport type MaybeAsync<T> = T | Promise<T>;\nexport type KeyOf<T> = keyof OmitIndexSignature<T>;\nexport type OmitIndexSignature<T> = {\n    [K in keyof T as string extends K ? never : K extends string ? K : never]: T[K];\n};\nexport type ExtractIndexSignature<T> = {\n    [K in keyof T as string extends K ? K : K extends string ? never : K]: T[K];\n};\nexport type Keys<T extends object> = keyof OmitIndexSignature<T>;\nexport type SchemaClass<T extends schemas.SomeType> = {\n    new (def: T[\"_zod\"][\"def\"]): T;\n};\nexport type EnumValue = string | number;\nexport type EnumLike = Readonly<Record<string, EnumValue>>;\nexport type ToEnum<T extends EnumValue> = Flatten<{\n    [k in T]: k;\n}>;\nexport type KeysEnum<T extends object> = ToEnum<Exclude<keyof T, symbol>>;\nexport type KeysArray<T extends object> = Flatten<(keyof T & string)[]>;\nexport type Literal = string | number | bigint | boolean | null | undefined;\nexport type LiteralArray = Array<Literal>;\nexport type Primitive = string | number | symbol | bigint | boolean | null | undefined;\nexport type PrimitiveArray = Array<Primitive>;\nexport type HasSize = {\n    size: number;\n};\nexport type HasLength = {\n    length: number;\n};\nexport type Numeric = number | bigint | Date;\nexport type SafeParseResult<T> = SafeParseSuccess<T> | SafeParseError<T>;\nexport type SafeParseSuccess<T> = {\n    success: true;\n    data: T;\n    error?: never;\n};\nexport type SafeParseError<T> = {\n    success: false;\n    data?: never;\n    error: errors.$ZodError<T>;\n};\nexport type PropValues = Record<string, Set<Primitive>>;\nexport type PrimitiveSet = Set<Primitive>;\nexport declare function assertEqual<A, B>(val: AssertEqual<A, B>): AssertEqual<A, B>;\nexport declare function assertNotEqual<A, B>(val: AssertNotEqual<A, B>): AssertNotEqual<A, B>;\nexport declare function assertIs<T>(_arg: T): void;\nexport declare function assertNever(_x: never): never;\nexport declare function assert<T>(_: any): asserts _ is T;\nexport declare function getEnumValues(entries: EnumLike): EnumValue[];\nexport declare function joinValues<T extends Primitive[]>(array: T, separator?: string): string;\nexport declare function jsonStringifyReplacer(_: string, value: any): any;\nexport declare function cached<T>(getter: () => T): {\n    value: T;\n};\nexport declare function nullish(input: any): boolean;\nexport declare function cleanRegex(source: string): string;\nexport declare function floatSafeRemainder(val: number, step: number): number;\nexport declare function defineLazy<T, K extends keyof T>(object: T, key: K, getter: () => T[K]): void;\nexport declare function assignProp<T extends object, K extends PropertyKey>(target: T, prop: K, value: K extends keyof T ? T[K] : any): void;\nexport declare function getElementAtPath(obj: any, path: (string | number)[] | null | undefined): any;\nexport declare function promiseAllObject<T extends object>(promisesObj: T): Promise<{\n    [k in keyof T]: Awaited<T[k]>;\n}>;\nexport declare function randomString(length?: number): string;\nexport declare function esc(str: string): string;\nexport declare const captureStackTrace: (targetObject: object, constructorOpt?: Function) => void;\nexport declare function isObject(data: any): data is Record<PropertyKey, unknown>;\nexport declare const allowsEval: {\n    value: boolean;\n};\nexport declare function isPlainObject(o: any): o is Record<PropertyKey, unknown>;\nexport declare function numKeys(data: any): number;\nexport declare const getParsedType: (data: any) => ParsedTypes;\nexport declare const propertyKeyTypes: Set<string>;\nexport declare const primitiveTypes: Set<string>;\nexport declare function escapeRegex(str: string): string;\nexport declare function clone<T extends schemas.$ZodType>(inst: T, def?: T[\"_zod\"][\"def\"], params?: {\n    parent: boolean;\n}): T;\nexport type EmptyToNever<T> = keyof T extends never ? never : T;\nexport type Normalize<T> = T extends undefined ? never : T extends Record<any, any> ? Flatten<{\n    [k in keyof Omit<T, \"error\" | \"message\">]: T[k];\n} & (\"error\" extends keyof T ? {\n    error?: Exclude<T[\"error\"], string>;\n} : unknown)> : never;\nexport declare function normalizeParams<T>(_params: T): Normalize<T>;\nexport declare function createTransparentProxy<T extends object>(getter: () => T): T;\nexport declare function stringifyPrimitive(value: any): string;\nexport declare function optionalKeys(shape: schemas.$ZodShape): string[];\nexport type CleanKey<T extends PropertyKey> = T extends `?${infer K}` ? K : T extends `${infer K}?` ? K : T;\nexport type ToCleanMap<T extends schemas.$ZodLooseShape> = {\n    [k in keyof T]: k extends `?${infer K}` ? K : k extends `${infer K}?` ? K : k;\n};\nexport type FromCleanMap<T extends schemas.$ZodLooseShape> = {\n    [k in keyof T as k extends `?${infer K}` ? K : k extends `${infer K}?` ? K : k]: k;\n};\nexport declare const NUMBER_FORMAT_RANGES: Record<checks.$ZodNumberFormats, [number, number]>;\nexport declare const BIGINT_FORMAT_RANGES: Record<checks.$ZodBigIntFormats, [bigint, bigint]>;\nexport declare function pick(schema: schemas.$ZodObject, mask: Record<string, unknown>): any;\nexport declare function omit(schema: schemas.$ZodObject, mask: object): any;\nexport declare function extend(schema: schemas.$ZodObject, shape: schemas.$ZodShape): any;\nexport declare function merge(a: schemas.$ZodObject, b: schemas.$ZodObject): any;\nexport declare function partial(Class: SchemaClass<schemas.$ZodOptional> | null, schema: schemas.$ZodObject, mask: object | undefined): any;\nexport declare function required(Class: SchemaClass<schemas.$ZodNonOptional>, schema: schemas.$ZodObject, mask: object | undefined): any;\nexport type Constructor<T, Def extends any[] = any[]> = new (...args: Def) => T;\nexport declare function aborted(x: schemas.ParsePayload, startIndex?: number): boolean;\nexport declare function prefixIssues(path: PropertyKey, issues: errors.$ZodRawIssue[]): errors.$ZodRawIssue[];\nexport declare function unwrapMessage(message: string | {\n    message: string;\n} | undefined | null): string | undefined;\nexport declare function finalizeIssue(iss: errors.$ZodRawIssue, ctx: schemas.ParseContextInternal | undefined, config: $ZodConfig): errors.$ZodIssue;\nexport declare function getSizableOrigin(input: any): \"set\" | \"map\" | \"file\" | \"unknown\";\nexport declare function getLengthableOrigin(input: any): \"array\" | \"string\" | \"unknown\";\nexport declare function issue(_iss: string, input: any, inst: any): errors.$ZodRawIssue;\nexport declare function issue(_iss: errors.$ZodRawIssue): errors.$ZodRawIssue;\nexport declare function cleanEnum(obj: Record<string, EnumValue>): EnumValue[];\nexport declare abstract class Class {\n    constructor(..._args: any[]);\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/core/util.d.cts",
        "start": 1,
        "end": 183,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 183,
          "column": 2,
          "position": 4164
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/util.d.cts",
        "start": 1,
        "end": 183,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 183,
          "column": 2,
          "position": 4164
        }
      }
    },
    {
      "format": "typescript",
      "lines": 88,
      "fragment": "import type * as JSONSchema from \"./json-schema.js\";\nimport { $ZodRegistry } from \"./registries.js\";\nimport type * as schemas from \"./schemas.js\";\ninterface JSONSchemaGeneratorParams {\n    /** A registry used to look up metadata for each schema. Any schema with an `id` property will be extracted as a $def.\n     *  @default globalRegistry */\n    metadata?: $ZodRegistry<Record<string, any>>;\n    /** The JSON Schema version to target.\n     * - `\"draft-2020-12\"`  Default. JSON Schema Draft 2020-12\n     * - `\"draft-7\"`  JSON Schema Draft 7 */\n    target?: \"draft-7\" | \"draft-2020-12\";\n    /** How to handle unrepresentable types.\n     * - `\"throw\"`  Default. Unrepresentable types throw an error\n     * - `\"any\"`  Unrepresentable types become `{}` */\n    unrepresentable?: \"throw\" | \"any\";\n    /** Arbitrary custom logic that can be used to modify the generated JSON Schema. */\n    override?: (ctx: {\n        zodSchema: schemas.$ZodTypes;\n        jsonSchema: JSONSchema.BaseSchema;\n        path: (string | number)[];\n    }) => void;\n    /** Whether to extract the `\"input\"` or `\"output\"` type. Relevant to transforms, Error converting schema to JSONz, defaults, coerced primitives, etc.\n     * - `\"output\"`  Default. Convert the output schema.\n     * - `\"input\"`  Convert the input schema. */\n    io?: \"input\" | \"output\";\n}\ninterface ProcessParams {\n    schemaPath: schemas.$ZodType[];\n    path: (string | number)[];\n}\ninterface EmitParams {\n    /** How to handle cycles.\n     * - `\"ref\"`  Default. Cycles will be broken using $defs\n     * - `\"throw\"`  Cycles will throw an error if encountered */\n    cycles?: \"ref\" | \"throw\";\n    reused?: \"ref\" | \"inline\";\n    external?: {\n        /**  */\n        registry: $ZodRegistry<{\n            id?: string | undefined;\n        }>;\n        uri?: ((id: string) => string) | undefined;\n        defs: Record<string, JSONSchema.BaseSchema>;\n    } | undefined;\n}\ninterface Seen {\n    /** JSON Schema result for this Zod schema */\n    schema: JSONSchema.BaseSchema;\n    /** A cached version of the schema that doesn't get overwritten during ref resolution */\n    def?: JSONSchema.BaseSchema;\n    defId?: string | undefined;\n    /** Number of times this schema was encountered during traversal */\n    count: number;\n    /** Cycle path */\n    cycle?: (string | number)[] | undefined;\n    isParent?: boolean | undefined;\n    ref?: schemas.$ZodType | undefined | null;\n    /** JSON Schema property path for this schema */\n    path?: (string | number)[] | undefined;\n}\nexport declare class JSONSchemaGenerator {\n    metadataRegistry: $ZodRegistry<Record<string, any>>;\n    target: \"draft-7\" | \"draft-2020-12\";\n    unrepresentable: \"throw\" | \"any\";\n    override: (ctx: {\n        zodSchema: schemas.$ZodTypes;\n        jsonSchema: JSONSchema.BaseSchema;\n        path: (string | number)[];\n    }) => void;\n    io: \"input\" | \"output\";\n    counter: number;\n    seen: Map<schemas.$ZodType, Seen>;\n    constructor(params?: JSONSchemaGeneratorParams);\n    process(schema: schemas.$ZodType, _params?: ProcessParams): JSONSchema.BaseSchema;\n    emit(schema: schemas.$ZodType, _params?: EmitParams): JSONSchema.BaseSchema;\n}\ninterface ToJSONSchemaParams extends Omit<JSONSchemaGeneratorParams & EmitParams, \"external\"> {\n}\ninterface RegistryToJSONSchemaParams extends Omit<JSONSchemaGeneratorParams & EmitParams, \"external\"> {\n    uri?: (id: string) => string;\n}\nexport declare function toJSONSchema(schema: schemas.$ZodType, _params?: ToJSONSchemaParams): JSONSchema.BaseSchema;\nexport declare function toJSONSchema(registry: $ZodRegistry<{\n    id?: string | undefined;\n}>, _params?: RegistryToJSONSchemaParams): {\n    schemas: Record<string, JSONSchema.BaseSchema>;\n};\nexport {};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/core/to-json-schema.d.ts",
        "start": 1,
        "end": 88,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 88,
          "column": 2,
          "position": 798
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/to-json-schema.d.ts",
        "start": 1,
        "end": 88,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 88,
          "column": 2,
          "position": 798
        }
      }
    },
    {
      "format": "typescript",
      "lines": 88,
      "fragment": "import type * as JSONSchema from \"./json-schema.cjs\";\nimport { $ZodRegistry } from \"./registries.cjs\";\nimport type * as schemas from \"./schemas.cjs\";\ninterface JSONSchemaGeneratorParams {\n    /** A registry used to look up metadata for each schema. Any schema with an `id` property will be extracted as a $def.\n     *  @default globalRegistry */\n    metadata?: $ZodRegistry<Record<string, any>>;\n    /** The JSON Schema version to target.\n     * - `\"draft-2020-12\"`  Default. JSON Schema Draft 2020-12\n     * - `\"draft-7\"`  JSON Schema Draft 7 */\n    target?: \"draft-7\" | \"draft-2020-12\";\n    /** How to handle unrepresentable types.\n     * - `\"throw\"`  Default. Unrepresentable types throw an error\n     * - `\"any\"`  Unrepresentable types become `{}` */\n    unrepresentable?: \"throw\" | \"any\";\n    /** Arbitrary custom logic that can be used to modify the generated JSON Schema. */\n    override?: (ctx: {\n        zodSchema: schemas.$ZodTypes;\n        jsonSchema: JSONSchema.BaseSchema;\n        path: (string | number)[];\n    }) => void;\n    /** Whether to extract the `\"input\"` or `\"output\"` type. Relevant to transforms, Error converting schema to JSONz, defaults, coerced primitives, etc.\n     * - `\"output\"`  Default. Convert the output schema.\n     * - `\"input\"`  Convert the input schema. */\n    io?: \"input\" | \"output\";\n}\ninterface ProcessParams {\n    schemaPath: schemas.$ZodType[];\n    path: (string | number)[];\n}\ninterface EmitParams {\n    /** How to handle cycles.\n     * - `\"ref\"`  Default. Cycles will be broken using $defs\n     * - `\"throw\"`  Cycles will throw an error if encountered */\n    cycles?: \"ref\" | \"throw\";\n    reused?: \"ref\" | \"inline\";\n    external?: {\n        /**  */\n        registry: $ZodRegistry<{\n            id?: string | undefined;\n        }>;\n        uri?: ((id: string) => string) | undefined;\n        defs: Record<string, JSONSchema.BaseSchema>;\n    } | undefined;\n}\ninterface Seen {\n    /** JSON Schema result for this Zod schema */\n    schema: JSONSchema.BaseSchema;\n    /** A cached version of the schema that doesn't get overwritten during ref resolution */\n    def?: JSONSchema.BaseSchema;\n    defId?: string | undefined;\n    /** Number of times this schema was encountered during traversal */\n    count: number;\n    /** Cycle path */\n    cycle?: (string | number)[] | undefined;\n    isParent?: boolean | undefined;\n    ref?: schemas.$ZodType | undefined | null;\n    /** JSON Schema property path for this schema */\n    path?: (string | number)[] | undefined;\n}\nexport declare class JSONSchemaGenerator {\n    metadataRegistry: $ZodRegistry<Record<string, any>>;\n    target: \"draft-7\" | \"draft-2020-12\";\n    unrepresentable: \"throw\" | \"any\";\n    override: (ctx: {\n        zodSchema: schemas.$ZodTypes;\n        jsonSchema: JSONSchema.BaseSchema;\n        path: (string | number)[];\n    }) => void;\n    io: \"input\" | \"output\";\n    counter: number;\n    seen: Map<schemas.$ZodType, Seen>;\n    constructor(params?: JSONSchemaGeneratorParams);\n    process(schema: schemas.$ZodType, _params?: ProcessParams): JSONSchema.BaseSchema;\n    emit(schema: schemas.$ZodType, _params?: EmitParams): JSONSchema.BaseSchema;\n}\ninterface ToJSONSchemaParams extends Omit<JSONSchemaGeneratorParams & EmitParams, \"external\"> {\n}\ninterface RegistryToJSONSchemaParams extends Omit<JSONSchemaGeneratorParams & EmitParams, \"external\"> {\n    uri?: (id: string) => string;\n}\nexport declare function toJSONSchema(schema: schemas.$ZodType, _params?: ToJSONSchemaParams): JSONSchema.BaseSchema;\nexport declare function toJSONSchema(registry: $ZodRegistry<{\n    id?: string | undefined;\n}>, _params?: RegistryToJSONSchemaParams): {\n    schemas: Record<string, JSONSchema.BaseSchema>;\n};\nexport {};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/core/to-json-schema.d.cts",
        "start": 1,
        "end": 88,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 88,
          "column": 2,
          "position": 798
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/to-json-schema.d.cts",
        "start": 1,
        "end": 88,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 88,
          "column": 2,
          "position": 798
        }
      }
    },
    {
      "format": "typescript",
      "lines": 55,
      "fragment": "/** The Standard Schema interface. */\nexport interface StandardSchemaV1<Input = unknown, Output = Input> {\n    /** The Standard Schema properties. */\n    readonly \"~standard\": StandardSchemaV1.Props<Input, Output>;\n}\nexport declare namespace StandardSchemaV1 {\n    /** The Standard Schema properties interface. */\n    interface Props<Input = unknown, Output = Input> {\n        /** The version number of the standard. */\n        readonly version: 1;\n        /** The vendor name of the schema library. */\n        readonly vendor: string;\n        /** Validates unknown input values. */\n        readonly validate: (value: unknown) => Result<Output> | Promise<Result<Output>>;\n        /** Inferred types associated with the schema. */\n        readonly types?: Types<Input, Output> | undefined;\n    }\n    /** The result interface of the validate function. */\n    type Result<Output> = SuccessResult<Output> | FailureResult;\n    /** The result interface if validation succeeds. */\n    interface SuccessResult<Output> {\n        /** The typed output value. */\n        readonly value: Output;\n        /** The non-existent issues. */\n        readonly issues?: undefined;\n    }\n    /** The result interface if validation fails. */\n    interface FailureResult {\n        /** The issues of failed validation. */\n        readonly issues: ReadonlyArray<Issue>;\n    }\n    /** The issue interface of the failure output. */\n    interface Issue {\n        /** The error message of the issue. */\n        readonly message: string;\n        /** The path of the issue, if any. */\n        readonly path?: ReadonlyArray<PropertyKey | PathSegment> | undefined;\n    }\n    /** The path segment interface of the issue. */\n    interface PathSegment {\n        /** The key representing a path segment. */\n        readonly key: PropertyKey;\n    }\n    /** The Standard Schema types interface. */\n    interface Types<Input = unknown, Output = Input> {\n        /** The input type of the schema. */\n        readonly input: Input;\n        /** The output type of the schema. */\n        readonly output: Output;\n    }\n    /** Infers the input type of a Standard Schema. */\n    type InferInput<Schema extends StandardSchemaV1> = NonNullable<Schema[\"~standard\"][\"types\"]>[\"input\"];\n    /** Infers the output type of a Standard Schema. */\n    type InferOutput<Schema extends StandardSchemaV1> = NonNullable<Schema[\"~standard\"][\"types\"]>[\"output\"];\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/core/standard-schema.d.ts",
        "start": 1,
        "end": 55,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 55,
          "column": 2,
          "position": 444
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/standard-schema.d.ts",
        "start": 1,
        "end": 55,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 55,
          "column": 2,
          "position": 444
        }
      }
    },
    {
      "format": "typescript",
      "lines": 55,
      "fragment": "/** The Standard Schema interface. */\nexport interface StandardSchemaV1<Input = unknown, Output = Input> {\n    /** The Standard Schema properties. */\n    readonly \"~standard\": StandardSchemaV1.Props<Input, Output>;\n}\nexport declare namespace StandardSchemaV1 {\n    /** The Standard Schema properties interface. */\n    interface Props<Input = unknown, Output = Input> {\n        /** The version number of the standard. */\n        readonly version: 1;\n        /** The vendor name of the schema library. */\n        readonly vendor: string;\n        /** Validates unknown input values. */\n        readonly validate: (value: unknown) => Result<Output> | Promise<Result<Output>>;\n        /** Inferred types associated with the schema. */\n        readonly types?: Types<Input, Output> | undefined;\n    }\n    /** The result interface of the validate function. */\n    type Result<Output> = SuccessResult<Output> | FailureResult;\n    /** The result interface if validation succeeds. */\n    interface SuccessResult<Output> {\n        /** The typed output value. */\n        readonly value: Output;\n        /** The non-existent issues. */\n        readonly issues?: undefined;\n    }\n    /** The result interface if validation fails. */\n    interface FailureResult {\n        /** The issues of failed validation. */\n        readonly issues: ReadonlyArray<Issue>;\n    }\n    /** The issue interface of the failure output. */\n    interface Issue {\n        /** The error message of the issue. */\n        readonly message: string;\n        /** The path of the issue, if any. */\n        readonly path?: ReadonlyArray<PropertyKey | PathSegment> | undefined;\n    }\n    /** The path segment interface of the issue. */\n    interface PathSegment {\n        /** The key representing a path segment. */\n        readonly key: PropertyKey;\n    }\n    /** The Standard Schema types interface. */\n    interface Types<Input = unknown, Output = Input> {\n        /** The input type of the schema. */\n        readonly input: Input;\n        /** The output type of the schema. */\n        readonly output: Output;\n    }\n    /** Infers the input type of a Standard Schema. */\n    type InferInput<Schema extends StandardSchemaV1> = NonNullable<Schema[\"~standard\"][\"types\"]>[\"input\"];\n    /** Infers the output type of a Standard Schema. */\n    type InferOutput<Schema extends StandardSchemaV1> = NonNullable<Schema[\"~standard\"][\"types\"]>[\"output\"];\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/core/standard-schema.d.cts",
        "start": 1,
        "end": 55,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 55,
          "column": 2,
          "position": 444
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/standard-schema.d.ts",
        "start": 1,
        "end": 55,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 55,
          "column": 2,
          "position": 444
        }
      }
    },
    {
      "format": "typescript",
      "lines": 35,
      "fragment": "import type * as core from \"./core.js\";\nimport type { $ZodType } from \"./schemas.js\";\nexport declare const $output: unique symbol;\nexport type $output = typeof $output;\nexport declare const $input: unique symbol;\nexport type $input = typeof $input;\nexport type $replace<Meta, S extends $ZodType> = Meta extends $output ? core.output<S> : Meta extends $input ? core.input<S> : Meta extends (infer M)[] ? $replace<M, S>[] : Meta extends (...args: infer P) => infer R ? (...args: {\n    [K in keyof P]: $replace<P[K], S>;\n}) => $replace<R, S> : Meta extends object ? {\n    [K in keyof Meta]: $replace<Meta[K], S>;\n} : Meta;\ntype MetadataType = Record<string, unknown> | undefined;\nexport declare class $ZodRegistry<Meta extends MetadataType = MetadataType, Schema extends $ZodType = $ZodType> {\n    _meta: Meta;\n    _schema: Schema;\n    _map: Map<Schema, $replace<Meta, Schema>>;\n    _idmap: Map<string, Schema>;\n    add<S extends Schema>(schema: S, ..._meta: undefined extends Meta ? [$replace<Meta, S>?] : [$replace<Meta, S>]): this;\n    clear(): this;\n    remove(schema: Schema): this;\n    get<S extends Schema>(schema: S): $replace<Meta, S> | undefined;\n    has(schema: Schema): boolean;\n}\nexport interface JSONSchemaMeta {\n    id?: string | undefined;\n    title?: string | undefined;\n    description?: string | undefined;\n    deprecated?: boolean | undefined;\n    [k: string]: unknown;\n}\nexport interface GlobalMeta extends JSONSchemaMeta {\n}\nexport declare function registry<T extends MetadataType = MetadataType, S extends $ZodType = $ZodType>(): $ZodRegistry<T, S>;\nexport declare const globalRegistry: $ZodRegistry<GlobalMeta>;\nexport {};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/core/registries.d.ts",
        "start": 1,
        "end": 35,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 35,
          "column": 2,
          "position": 635
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/registries.d.ts",
        "start": 1,
        "end": 35,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 35,
          "column": 2,
          "position": 635
        }
      }
    },
    {
      "format": "typescript",
      "lines": 35,
      "fragment": "import type * as core from \"./core.cjs\";\nimport type { $ZodType } from \"./schemas.cjs\";\nexport declare const $output: unique symbol;\nexport type $output = typeof $output;\nexport declare const $input: unique symbol;\nexport type $input = typeof $input;\nexport type $replace<Meta, S extends $ZodType> = Meta extends $output ? core.output<S> : Meta extends $input ? core.input<S> : Meta extends (infer M)[] ? $replace<M, S>[] : Meta extends (...args: infer P) => infer R ? (...args: {\n    [K in keyof P]: $replace<P[K], S>;\n}) => $replace<R, S> : Meta extends object ? {\n    [K in keyof Meta]: $replace<Meta[K], S>;\n} : Meta;\ntype MetadataType = Record<string, unknown> | undefined;\nexport declare class $ZodRegistry<Meta extends MetadataType = MetadataType, Schema extends $ZodType = $ZodType> {\n    _meta: Meta;\n    _schema: Schema;\n    _map: Map<Schema, $replace<Meta, Schema>>;\n    _idmap: Map<string, Schema>;\n    add<S extends Schema>(schema: S, ..._meta: undefined extends Meta ? [$replace<Meta, S>?] : [$replace<Meta, S>]): this;\n    clear(): this;\n    remove(schema: Schema): this;\n    get<S extends Schema>(schema: S): $replace<Meta, S> | undefined;\n    has(schema: Schema): boolean;\n}\nexport interface JSONSchemaMeta {\n    id?: string | undefined;\n    title?: string | undefined;\n    description?: string | undefined;\n    deprecated?: boolean | undefined;\n    [k: string]: unknown;\n}\nexport interface GlobalMeta extends JSONSchemaMeta {\n}\nexport declare function registry<T extends MetadataType = MetadataType, S extends $ZodType = $ZodType>(): $ZodRegistry<T, S>;\nexport declare const globalRegistry: $ZodRegistry<GlobalMeta>;\nexport {};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/core/registries.d.cts",
        "start": 1,
        "end": 35,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 35,
          "column": 2,
          "position": 635
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/registries.d.cts",
        "start": 1,
        "end": 35,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 35,
          "column": 2,
          "position": 635
        }
      }
    },
    {
      "format": "typescript",
      "lines": 62,
      "fragment": "export declare const cuid: RegExp;\nexport declare const cuid2: RegExp;\nexport declare const ulid: RegExp;\nexport declare const xid: RegExp;\nexport declare const ksuid: RegExp;\nexport declare const nanoid: RegExp;\n/** ISO 8601-1 duration regex. Does not support the 8601-2 extensions like negative durations or fractional/negative components. */\nexport declare const duration: RegExp;\n/** Implements ISO 8601-2 extensions like explicit +- prefixes, mixing weeks with other units, and fractional/negative components. */\nexport declare const extendedDuration: RegExp;\n/** A regex for any UUID-like identifier: 8-4-4-4-12 hex pattern */\nexport declare const guid: RegExp;\n/** Returns a regex for validating an RFC 4122 UUID.\n *\n * @param version Optionally specify a version 1-8. If no version is specified, all versions are supported. */\nexport declare const uuid: (version?: number | undefined) => RegExp;\nexport declare const uuid4: RegExp;\nexport declare const uuid6: RegExp;\nexport declare const uuid7: RegExp;\n/** Practical email validation */\nexport declare const email: RegExp;\n/** Equivalent to the HTML5 input[type=email] validation implemented by browsers. Source: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email */\nexport declare const html5Email: RegExp;\n/** The classic emailregex.com regex for RFC 5322-compliant emails */\nexport declare const rfc5322Email: RegExp;\n/** A loose regex that allows Unicode characters, enforces length limits, and that's about it. */\nexport declare const unicodeEmail: RegExp;\nexport declare const browserEmail: RegExp;\nexport declare const _emoji = \"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\";\nexport declare function emoji(): RegExp;\nexport declare const ipv4: RegExp;\nexport declare const ipv6: RegExp;\nexport declare const cidrv4: RegExp;\nexport declare const cidrv6: RegExp;\nexport declare const base64: RegExp;\nexport declare const base64url: RegExp;\nexport declare const hostname: RegExp;\nexport declare const domain: RegExp;\nexport declare const e164: RegExp;\nexport declare const date: RegExp;\nexport declare function time(args: {\n    precision?: number | null;\n}): RegExp;\nexport declare function datetime(args: {\n    precision?: number | null;\n    offset?: boolean;\n    local?: boolean;\n}): RegExp;\nexport declare const string: (params?: {\n    minimum?: number | undefined;\n    maximum?: number | undefined;\n}) => RegExp;\nexport declare const bigint: RegExp;\nexport declare const integer: RegExp;\nexport declare const number: RegExp;\nexport declare const boolean: RegExp;\ndeclare const _null: RegExp;\nexport { _null as null };\ndeclare const _undefined: RegExp;\nexport { _undefined as undefined };\nexport declare const lowercase: RegExp;\nexport declare const uppercase: RegExp;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/core/regexes.d.ts",
        "start": 1,
        "end": 62,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 62,
          "column": 2,
          "position": 637
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/regexes.d.ts",
        "start": 1,
        "end": 62,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 62,
          "column": 2,
          "position": 637
        }
      }
    },
    {
      "format": "typescript",
      "lines": 62,
      "fragment": "export declare const cuid: RegExp;\nexport declare const cuid2: RegExp;\nexport declare const ulid: RegExp;\nexport declare const xid: RegExp;\nexport declare const ksuid: RegExp;\nexport declare const nanoid: RegExp;\n/** ISO 8601-1 duration regex. Does not support the 8601-2 extensions like negative durations or fractional/negative components. */\nexport declare const duration: RegExp;\n/** Implements ISO 8601-2 extensions like explicit +- prefixes, mixing weeks with other units, and fractional/negative components. */\nexport declare const extendedDuration: RegExp;\n/** A regex for any UUID-like identifier: 8-4-4-4-12 hex pattern */\nexport declare const guid: RegExp;\n/** Returns a regex for validating an RFC 4122 UUID.\n *\n * @param version Optionally specify a version 1-8. If no version is specified, all versions are supported. */\nexport declare const uuid: (version?: number | undefined) => RegExp;\nexport declare const uuid4: RegExp;\nexport declare const uuid6: RegExp;\nexport declare const uuid7: RegExp;\n/** Practical email validation */\nexport declare const email: RegExp;\n/** Equivalent to the HTML5 input[type=email] validation implemented by browsers. Source: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email */\nexport declare const html5Email: RegExp;\n/** The classic emailregex.com regex for RFC 5322-compliant emails */\nexport declare const rfc5322Email: RegExp;\n/** A loose regex that allows Unicode characters, enforces length limits, and that's about it. */\nexport declare const unicodeEmail: RegExp;\nexport declare const browserEmail: RegExp;\nexport declare const _emoji = \"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\";\nexport declare function emoji(): RegExp;\nexport declare const ipv4: RegExp;\nexport declare const ipv6: RegExp;\nexport declare const cidrv4: RegExp;\nexport declare const cidrv6: RegExp;\nexport declare const base64: RegExp;\nexport declare const base64url: RegExp;\nexport declare const hostname: RegExp;\nexport declare const domain: RegExp;\nexport declare const e164: RegExp;\nexport declare const date: RegExp;\nexport declare function time(args: {\n    precision?: number | null;\n}): RegExp;\nexport declare function datetime(args: {\n    precision?: number | null;\n    offset?: boolean;\n    local?: boolean;\n}): RegExp;\nexport declare const string: (params?: {\n    minimum?: number | undefined;\n    maximum?: number | undefined;\n}) => RegExp;\nexport declare const bigint: RegExp;\nexport declare const integer: RegExp;\nexport declare const number: RegExp;\nexport declare const boolean: RegExp;\ndeclare const _null: RegExp;\nexport { _null as null };\ndeclare const _undefined: RegExp;\nexport { _undefined as undefined };\nexport declare const lowercase: RegExp;\nexport declare const uppercase: RegExp;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/core/regexes.d.cts",
        "start": 1,
        "end": 62,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 62,
          "column": 2,
          "position": 637
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/regexes.d.ts",
        "start": 1,
        "end": 62,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 62,
          "column": 2,
          "position": 637
        }
      }
    },
    {
      "format": "typescript",
      "lines": 25,
      "fragment": "import * as core from \"./core.js\";\nimport * as errors from \"./errors.js\";\nimport type * as schemas from \"./schemas.js\";\nimport * as util from \"./util.js\";\nexport type $ZodErrorClass = {\n    new (issues: errors.$ZodIssue[]): errors.$ZodError;\n};\nexport type $Parse = <T extends schemas.$ZodType>(schema: T, value: unknown, _ctx?: schemas.ParseContext<errors.$ZodIssue>, _params?: {\n    callee?: util.AnyFunc;\n    Err?: $ZodErrorClass;\n}) => core.output<T>;\nexport declare const _parse: (_Err: $ZodErrorClass) => $Parse;\nexport declare const parse: $Parse;\nexport type $ParseAsync = <T extends schemas.$ZodType>(schema: T, value: unknown, _ctx?: schemas.ParseContext<errors.$ZodIssue>, _params?: {\n    callee?: util.AnyFunc;\n    Err?: $ZodErrorClass;\n}) => Promise<core.output<T>>;\nexport declare const _parseAsync: (_Err: $ZodErrorClass) => $ParseAsync;\nexport declare const parseAsync: $ParseAsync;\nexport type $SafeParse = <T extends schemas.$ZodType>(schema: T, value: unknown, _ctx?: schemas.ParseContext<errors.$ZodIssue>) => util.SafeParseResult<core.output<T>>;\nexport declare const _safeParse: (_Err: $ZodErrorClass) => $SafeParse;\nexport declare const safeParse: $SafeParse;\nexport type $SafeParseAsync = <T extends schemas.$ZodType>(schema: T, value: unknown, _ctx?: schemas.ParseContext<errors.$ZodIssue>) => Promise<util.SafeParseResult<core.output<T>>>;\nexport declare const _safeParseAsync: (_Err: $ZodErrorClass) => $SafeParseAsync;\nexport declare const safeParseAsync: $SafeParseAsync;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/core/parse.d.ts",
        "start": 1,
        "end": 25,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 25,
          "column": 2,
          "position": 499
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/parse.d.ts",
        "start": 1,
        "end": 25,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 25,
          "column": 2,
          "position": 499
        }
      }
    },
    {
      "format": "typescript",
      "lines": 25,
      "fragment": "import * as core from \"./core.cjs\";\nimport * as errors from \"./errors.cjs\";\nimport type * as schemas from \"./schemas.cjs\";\nimport * as util from \"./util.cjs\";\nexport type $ZodErrorClass = {\n    new (issues: errors.$ZodIssue[]): errors.$ZodError;\n};\nexport type $Parse = <T extends schemas.$ZodType>(schema: T, value: unknown, _ctx?: schemas.ParseContext<errors.$ZodIssue>, _params?: {\n    callee?: util.AnyFunc;\n    Err?: $ZodErrorClass;\n}) => core.output<T>;\nexport declare const _parse: (_Err: $ZodErrorClass) => $Parse;\nexport declare const parse: $Parse;\nexport type $ParseAsync = <T extends schemas.$ZodType>(schema: T, value: unknown, _ctx?: schemas.ParseContext<errors.$ZodIssue>, _params?: {\n    callee?: util.AnyFunc;\n    Err?: $ZodErrorClass;\n}) => Promise<core.output<T>>;\nexport declare const _parseAsync: (_Err: $ZodErrorClass) => $ParseAsync;\nexport declare const parseAsync: $ParseAsync;\nexport type $SafeParse = <T extends schemas.$ZodType>(schema: T, value: unknown, _ctx?: schemas.ParseContext<errors.$ZodIssue>) => util.SafeParseResult<core.output<T>>;\nexport declare const _safeParse: (_Err: $ZodErrorClass) => $SafeParse;\nexport declare const safeParse: $SafeParse;\nexport type $SafeParseAsync = <T extends schemas.$ZodType>(schema: T, value: unknown, _ctx?: schemas.ParseContext<errors.$ZodIssue>) => Promise<util.SafeParseResult<core.output<T>>>;\nexport declare const _safeParseAsync: (_Err: $ZodErrorClass) => $SafeParseAsync;\nexport declare const safeParseAsync: $SafeParseAsync;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/core/parse.d.cts",
        "start": 1,
        "end": 25,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 25,
          "column": 2,
          "position": 499
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/parse.d.cts",
        "start": 1,
        "end": 25,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 25,
          "column": 2,
          "position": 499
        }
      }
    },
    {
      "format": "typescript",
      "lines": 87,
      "fragment": "export type Schema = ObjectSchema | ArraySchema | StringSchema | NumberSchema | IntegerSchema | BooleanSchema | NullSchema;\nexport type _JSONSchema = boolean | JSONSchema;\nexport type JSONSchema = {\n    [k: string]: unknown;\n    $schema?: \"https://json-schema.org/draft/2020-12/schema\" | \"http://json-schema.org/draft-07/schema#\";\n    $id?: string;\n    $anchor?: string;\n    $ref?: string;\n    $dynamicRef?: string;\n    $dynamicAnchor?: string;\n    $vocabulary?: Record<string, boolean>;\n    $comment?: string;\n    $defs?: Record<string, JSONSchema>;\n    type?: \"object\" | \"array\" | \"string\" | \"number\" | \"boolean\" | \"null\" | \"integer\";\n    additionalItems?: _JSONSchema;\n    unevaluatedItems?: _JSONSchema;\n    prefixItems?: _JSONSchema[];\n    items?: _JSONSchema | _JSONSchema[];\n    contains?: _JSONSchema;\n    additionalProperties?: _JSONSchema;\n    unevaluatedProperties?: _JSONSchema;\n    properties?: Record<string, _JSONSchema>;\n    patternProperties?: Record<string, _JSONSchema>;\n    dependentSchemas?: Record<string, _JSONSchema>;\n    propertyNames?: _JSONSchema;\n    if?: _JSONSchema;\n    then?: _JSONSchema;\n    else?: _JSONSchema;\n    allOf?: JSONSchema[];\n    anyOf?: JSONSchema[];\n    oneOf?: JSONSchema[];\n    not?: _JSONSchema;\n    multipleOf?: number;\n    maximum?: number;\n    exclusiveMaximum?: number;\n    minimum?: number;\n    exclusiveMinimum?: number;\n    maxLength?: number;\n    minLength?: number;\n    pattern?: string;\n    maxItems?: number;\n    minItems?: number;\n    uniqueItems?: boolean;\n    maxContains?: number;\n    minContains?: number;\n    maxProperties?: number;\n    minProperties?: number;\n    required?: string[];\n    dependentRequired?: Record<string, string[]>;\n    enum?: Array<string | number | boolean | null>;\n    const?: string | number | boolean | null;\n    id?: string;\n    title?: string;\n    description?: string;\n    default?: unknown;\n    deprecated?: boolean;\n    readOnly?: boolean;\n    writeOnly?: boolean;\n    examples?: unknown[];\n    format?: string;\n    contentMediaType?: string;\n    contentEncoding?: string;\n    contentSchema?: JSONSchema;\n    _prefault?: unknown;\n};\nexport type BaseSchema = JSONSchema;\nexport interface ObjectSchema extends JSONSchema {\n    type: \"object\";\n}\nexport interface ArraySchema extends JSONSchema {\n    type: \"array\";\n}\nexport interface StringSchema extends JSONSchema {\n    type: \"string\";\n}\nexport interface NumberSchema extends JSONSchema {\n    type: \"number\";\n}\nexport interface IntegerSchema extends JSONSchema {\n    type: \"integer\";\n}\nexport interface BooleanSchema extends JSONSchema {\n    type: \"boolean\";\n}\nexport interface NullSchema extends JSONSchema {\n    type: \"null\";\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/core/json-schema.d.ts",
        "start": 1,
        "end": 87,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 87,
          "column": 2,
          "position": 822
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/json-schema.d.ts",
        "start": 1,
        "end": 143,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 143,
          "column": 2,
          "position": 920
        }
      }
    },
    {
      "format": "typescript",
      "lines": 87,
      "fragment": "export type Schema = ObjectSchema | ArraySchema | StringSchema | NumberSchema | IntegerSchema | BooleanSchema | NullSchema;\nexport type _JSONSchema = boolean | JSONSchema;\nexport type JSONSchema = {\n    [k: string]: unknown;\n    $schema?: \"https://json-schema.org/draft/2020-12/schema\" | \"http://json-schema.org/draft-07/schema#\";\n    $id?: string;\n    $anchor?: string;\n    $ref?: string;\n    $dynamicRef?: string;\n    $dynamicAnchor?: string;\n    $vocabulary?: Record<string, boolean>;\n    $comment?: string;\n    $defs?: Record<string, JSONSchema>;\n    type?: \"object\" | \"array\" | \"string\" | \"number\" | \"boolean\" | \"null\" | \"integer\";\n    additionalItems?: _JSONSchema;\n    unevaluatedItems?: _JSONSchema;\n    prefixItems?: _JSONSchema[];\n    items?: _JSONSchema | _JSONSchema[];\n    contains?: _JSONSchema;\n    additionalProperties?: _JSONSchema;\n    unevaluatedProperties?: _JSONSchema;\n    properties?: Record<string, _JSONSchema>;\n    patternProperties?: Record<string, _JSONSchema>;\n    dependentSchemas?: Record<string, _JSONSchema>;\n    propertyNames?: _JSONSchema;\n    if?: _JSONSchema;\n    then?: _JSONSchema;\n    else?: _JSONSchema;\n    allOf?: JSONSchema[];\n    anyOf?: JSONSchema[];\n    oneOf?: JSONSchema[];\n    not?: _JSONSchema;\n    multipleOf?: number;\n    maximum?: number;\n    exclusiveMaximum?: number;\n    minimum?: number;\n    exclusiveMinimum?: number;\n    maxLength?: number;\n    minLength?: number;\n    pattern?: string;\n    maxItems?: number;\n    minItems?: number;\n    uniqueItems?: boolean;\n    maxContains?: number;\n    minContains?: number;\n    maxProperties?: number;\n    minProperties?: number;\n    required?: string[];\n    dependentRequired?: Record<string, string[]>;\n    enum?: Array<string | number | boolean | null>;\n    const?: string | number | boolean | null;\n    id?: string;\n    title?: string;\n    description?: string;\n    default?: unknown;\n    deprecated?: boolean;\n    readOnly?: boolean;\n    writeOnly?: boolean;\n    examples?: unknown[];\n    format?: string;\n    contentMediaType?: string;\n    contentEncoding?: string;\n    contentSchema?: JSONSchema;\n    _prefault?: unknown;\n};\nexport type BaseSchema = JSONSchema;\nexport interface ObjectSchema extends JSONSchema {\n    type: \"object\";\n}\nexport interface ArraySchema extends JSONSchema {\n    type: \"array\";\n}\nexport interface StringSchema extends JSONSchema {\n    type: \"string\";\n}\nexport interface NumberSchema extends JSONSchema {\n    type: \"number\";\n}\nexport interface IntegerSchema extends JSONSchema {\n    type: \"integer\";\n}\nexport interface BooleanSchema extends JSONSchema {\n    type: \"boolean\";\n}\nexport interface NullSchema extends JSONSchema {\n    type: \"null\";\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/core/json-schema.d.cts",
        "start": 1,
        "end": 87,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 87,
          "column": 2,
          "position": 822
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/json-schema.d.ts",
        "start": 1,
        "end": 143,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 143,
          "column": 2,
          "position": 920
        }
      }
    },
    {
      "format": "typescript",
      "lines": 15,
      "fragment": "export * from \"./core.js\";\nexport * from \"./parse.js\";\nexport * from \"./errors.js\";\nexport * from \"./schemas.js\";\nexport * from \"./checks.js\";\nexport * from \"./versions.js\";\nexport * as util from \"./util.js\";\nexport * as regexes from \"./regexes.js\";\nexport * as locales from \"../locales/index.js\";\nexport * from \"./registries.js\";\nexport * from \"./doc.js\";\nexport * from \"./function.js\";\nexport * from \"./api.js\";\nexport * from \"./to-json-schema.js\";\nexport * as JSONSchema from \"./json-schema.js\";",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/core/index.d.ts",
        "start": 1,
        "end": 15,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 15,
          "column": 2,
          "position": 149
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/core/index.ts",
        "start": 1,
        "end": 15,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 15,
          "column": 2,
          "position": 149
        }
      }
    },
    {
      "format": "typescript",
      "lines": 15,
      "fragment": "export * from \"./core.cjs\";\nexport * from \"./parse.cjs\";\nexport * from \"./errors.cjs\";\nexport * from \"./schemas.cjs\";\nexport * from \"./checks.cjs\";\nexport * from \"./versions.cjs\";\nexport * as util from \"./util.cjs\";\nexport * as regexes from \"./regexes.cjs\";\nexport * as locales from \"../locales/index.cjs\";\nexport * from \"./registries.cjs\";\nexport * from \"./doc.cjs\";\nexport * from \"./function.cjs\";\nexport * from \"./api.cjs\";\nexport * from \"./to-json-schema.cjs\";\nexport * as JSONSchema from \"./json-schema.cjs\";",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/core/index.d.cts",
        "start": 1,
        "end": 15,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 15,
          "column": 2,
          "position": 149
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/index.d.cts",
        "start": 1,
        "end": 15,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 15,
          "column": 2,
          "position": 149
        }
      }
    },
    {
      "format": "typescript",
      "lines": 52,
      "fragment": "import type * as core from \"./core.js\";\nimport * as schemas from \"./schemas.js\";\nimport { $ZodTuple } from \"./schemas.js\";\nimport type * as util from \"./util.js\";\nexport interface $ZodFunctionDef<In extends $ZodFunctionIn = $ZodFunctionIn, Out extends $ZodFunctionOut = $ZodFunctionOut> {\n    type: \"function\";\n    input: In;\n    output: Out;\n}\nexport type $ZodFunctionArgs = schemas.$ZodType<unknown[], unknown[]>;\nexport type $ZodFunctionIn = $ZodFunctionArgs;\nexport type $ZodFunctionOut = schemas.$ZodType;\nexport type $InferInnerFunctionType<Args extends $ZodFunctionIn, Returns extends $ZodFunctionOut> = (...args: $ZodFunctionIn extends Args ? never[] : core.output<Args>) => core.input<Returns>;\nexport type $InferInnerFunctionTypeAsync<Args extends $ZodFunctionIn, Returns extends $ZodFunctionOut> = (...args: $ZodFunctionIn extends Args ? never[] : core.output<Args>) => util.MaybeAsync<core.input<Returns>>;\nexport type $InferOuterFunctionType<Args extends $ZodFunctionIn, Returns extends $ZodFunctionOut> = (...args: $ZodFunctionIn extends Args ? never[] : core.input<Args>) => core.output<Returns>;\nexport type $InferOuterFunctionTypeAsync<Args extends $ZodFunctionIn, Returns extends $ZodFunctionOut> = (...args: $ZodFunctionIn extends Args ? never[] : core.input<Args>) => util.MaybeAsync<core.output<Returns>>;\nexport declare class $ZodFunction<Args extends $ZodFunctionIn = $ZodFunctionIn, Returns extends $ZodFunctionOut = $ZodFunctionOut> {\n    def: $ZodFunctionDef<Args, Returns>;\n    /** @deprecated */\n    _def: $ZodFunctionDef<Args, Returns>;\n    _input: $InferInnerFunctionType<Args, Returns>;\n    _output: $InferOuterFunctionType<Args, Returns>;\n    constructor(def: $ZodFunctionDef<Args, Returns>);\n    implement<F extends $InferInnerFunctionType<Args, Returns>>(func: F): (...args: Parameters<this[\"_output\"]>) => ReturnType<F> extends ReturnType<this[\"_output\"]> ? ReturnType<F> : ReturnType<this[\"_output\"]>;\n    implementAsync<F extends $InferInnerFunctionTypeAsync<Args, Returns>>(func: F): F extends $InferOuterFunctionTypeAsync<Args, Returns> ? F : $InferOuterFunctionTypeAsync<Args, Returns>;\n    input<const Items extends util.TupleItems, const Rest extends $ZodFunctionOut = $ZodFunctionOut>(args: Items, rest?: Rest): $ZodFunction<schemas.$ZodTuple<Items, Rest>, Returns>;\n    input<NewArgs extends $ZodFunctionIn>(args: NewArgs): $ZodFunction<NewArgs, Returns>;\n    output<NewReturns extends schemas.$ZodType>(output: NewReturns): $ZodFunction<Args, NewReturns>;\n}\nexport interface $ZodFunctionParams<I extends $ZodFunctionIn, O extends schemas.$ZodType> {\n    input?: I;\n    output?: O;\n}\ndeclare function _function(): $ZodFunction;\ndeclare function _function<const In extends Array<schemas.$ZodType> = Array<schemas.$ZodType>>(params: {\n    input: In;\n}): $ZodFunction<$ZodTuple<In, null>, $ZodFunctionOut>;\ndeclare function _function<const In extends Array<schemas.$ZodType> = Array<schemas.$ZodType>, const Out extends $ZodFunctionOut = $ZodFunctionOut>(params: {\n    input: In;\n    output: Out;\n}): $ZodFunction<$ZodTuple<In, null>, Out>;\ndeclare function _function<const In extends $ZodFunctionIn = $ZodFunctionIn>(params: {\n    input: In;\n}): $ZodFunction<In, $ZodFunctionOut>;\ndeclare function _function<const Out extends $ZodFunctionOut = $ZodFunctionOut>(params: {\n    output: Out;\n}): $ZodFunction<$ZodFunctionIn, Out>;\ndeclare function _function<In extends $ZodFunctionIn = $ZodFunctionIn, Out extends schemas.$ZodType = schemas.$ZodType>(params?: {\n    input: In;\n    output: Out;\n}): $ZodFunction<In, Out>;\nexport { _function as function };",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/core/function.d.ts",
        "start": 1,
        "end": 52,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 52,
          "column": 2,
          "position": 1094
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/function.d.ts",
        "start": 1,
        "end": 52,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 52,
          "column": 2,
          "position": 1094
        }
      }
    },
    {
      "format": "typescript",
      "lines": 52,
      "fragment": "import type * as core from \"./core.cjs\";\nimport * as schemas from \"./schemas.cjs\";\nimport { $ZodTuple } from \"./schemas.cjs\";\nimport type * as util from \"./util.cjs\";\nexport interface $ZodFunctionDef<In extends $ZodFunctionIn = $ZodFunctionIn, Out extends $ZodFunctionOut = $ZodFunctionOut> {\n    type: \"function\";\n    input: In;\n    output: Out;\n}\nexport type $ZodFunctionArgs = schemas.$ZodType<unknown[], unknown[]>;\nexport type $ZodFunctionIn = $ZodFunctionArgs;\nexport type $ZodFunctionOut = schemas.$ZodType;\nexport type $InferInnerFunctionType<Args extends $ZodFunctionIn, Returns extends $ZodFunctionOut> = (...args: $ZodFunctionIn extends Args ? never[] : core.output<Args>) => core.input<Returns>;\nexport type $InferInnerFunctionTypeAsync<Args extends $ZodFunctionIn, Returns extends $ZodFunctionOut> = (...args: $ZodFunctionIn extends Args ? never[] : core.output<Args>) => util.MaybeAsync<core.input<Returns>>;\nexport type $InferOuterFunctionType<Args extends $ZodFunctionIn, Returns extends $ZodFunctionOut> = (...args: $ZodFunctionIn extends Args ? never[] : core.input<Args>) => core.output<Returns>;\nexport type $InferOuterFunctionTypeAsync<Args extends $ZodFunctionIn, Returns extends $ZodFunctionOut> = (...args: $ZodFunctionIn extends Args ? never[] : core.input<Args>) => util.MaybeAsync<core.output<Returns>>;\nexport declare class $ZodFunction<Args extends $ZodFunctionIn = $ZodFunctionIn, Returns extends $ZodFunctionOut = $ZodFunctionOut> {\n    def: $ZodFunctionDef<Args, Returns>;\n    /** @deprecated */\n    _def: $ZodFunctionDef<Args, Returns>;\n    _input: $InferInnerFunctionType<Args, Returns>;\n    _output: $InferOuterFunctionType<Args, Returns>;\n    constructor(def: $ZodFunctionDef<Args, Returns>);\n    implement<F extends $InferInnerFunctionType<Args, Returns>>(func: F): (...args: Parameters<this[\"_output\"]>) => ReturnType<F> extends ReturnType<this[\"_output\"]> ? ReturnType<F> : ReturnType<this[\"_output\"]>;\n    implementAsync<F extends $InferInnerFunctionTypeAsync<Args, Returns>>(func: F): F extends $InferOuterFunctionTypeAsync<Args, Returns> ? F : $InferOuterFunctionTypeAsync<Args, Returns>;\n    input<const Items extends util.TupleItems, const Rest extends $ZodFunctionOut = $ZodFunctionOut>(args: Items, rest?: Rest): $ZodFunction<schemas.$ZodTuple<Items, Rest>, Returns>;\n    input<NewArgs extends $ZodFunctionIn>(args: NewArgs): $ZodFunction<NewArgs, Returns>;\n    output<NewReturns extends schemas.$ZodType>(output: NewReturns): $ZodFunction<Args, NewReturns>;\n}\nexport interface $ZodFunctionParams<I extends $ZodFunctionIn, O extends schemas.$ZodType> {\n    input?: I;\n    output?: O;\n}\ndeclare function _function(): $ZodFunction;\ndeclare function _function<const In extends Array<schemas.$ZodType> = Array<schemas.$ZodType>>(params: {\n    input: In;\n}): $ZodFunction<$ZodTuple<In, null>, $ZodFunctionOut>;\ndeclare function _function<const In extends Array<schemas.$ZodType> = Array<schemas.$ZodType>, const Out extends $ZodFunctionOut = $ZodFunctionOut>(params: {\n    input: In;\n    output: Out;\n}): $ZodFunction<$ZodTuple<In, null>, Out>;\ndeclare function _function<const In extends $ZodFunctionIn = $ZodFunctionIn>(params: {\n    input: In;\n}): $ZodFunction<In, $ZodFunctionOut>;\ndeclare function _function<const Out extends $ZodFunctionOut = $ZodFunctionOut>(params: {\n    output: Out;\n}): $ZodFunction<$ZodFunctionIn, Out>;\ndeclare function _function<In extends $ZodFunctionIn = $ZodFunctionIn, Out extends schemas.$ZodType = schemas.$ZodType>(params?: {\n    input: In;\n    output: Out;\n}): $ZodFunction<In, Out>;\nexport { _function as function };",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/core/function.d.cts",
        "start": 1,
        "end": 52,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 52,
          "column": 2,
          "position": 1094
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/function.d.cts",
        "start": 1,
        "end": 52,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 52,
          "column": 2,
          "position": 1094
        }
      }
    },
    {
      "format": "typescript",
      "lines": 208,
      "fragment": "import type { $ZodCheck, $ZodStringFormats } from \"./checks.js\";\nimport { $constructor } from \"./core.js\";\nimport type { $ZodType } from \"./schemas.js\";\nimport * as util from \"./util.js\";\nexport interface $ZodIssueBase {\n    readonly code?: string;\n    readonly input?: unknown;\n    readonly path: PropertyKey[];\n    readonly message: string;\n}\nexport interface $ZodIssueInvalidType<Input = unknown> extends $ZodIssueBase {\n    readonly code: \"invalid_type\";\n    readonly expected: $ZodType[\"_zod\"][\"def\"][\"type\"];\n    readonly input: Input;\n}\nexport interface $ZodIssueTooBig<Input = unknown> extends $ZodIssueBase {\n    readonly code: \"too_big\";\n    readonly origin: \"number\" | \"int\" | \"bigint\" | \"date\" | \"string\" | \"array\" | \"set\" | \"file\" | (string & {});\n    readonly maximum: number | bigint;\n    readonly inclusive?: boolean;\n    readonly exact?: boolean;\n    readonly input: Input;\n}\nexport interface $ZodIssueTooSmall<Input = unknown> extends $ZodIssueBase {\n    readonly code: \"too_small\";\n    readonly origin: \"number\" | \"int\" | \"bigint\" | \"date\" | \"string\" | \"array\" | \"set\" | \"file\" | (string & {});\n    readonly minimum: number | bigint;\n    /** True if the allowable range includes the minimum */\n    readonly inclusive?: boolean;\n    /** True if the allowed value is fixed (e.g.` z.length(5)`), not a range (`z.minLength(5)`) */\n    readonly exact?: boolean;\n    readonly input: Input;\n}\nexport interface $ZodIssueInvalidStringFormat extends $ZodIssueBase {\n    readonly code: \"invalid_format\";\n    readonly format: $ZodStringFormats | (string & {});\n    readonly pattern?: string;\n    readonly input: string;\n}\nexport interface $ZodIssueNotMultipleOf<Input extends number | bigint = number | bigint> extends $ZodIssueBase {\n    readonly code: \"not_multiple_of\";\n    readonly divisor: number;\n    readonly input: Input;\n}\nexport interface $ZodIssueUnrecognizedKeys extends $ZodIssueBase {\n    readonly code: \"unrecognized_keys\";\n    readonly keys: string[];\n    readonly input: Record<string, unknown>;\n}\nexport interface $ZodIssueInvalidUnion extends $ZodIssueBase {\n    readonly code: \"invalid_union\";\n    readonly errors: $ZodIssue[][];\n    readonly input: unknown;\n}\nexport interface $ZodIssueInvalidKey<Input = unknown> extends $ZodIssueBase {\n    readonly code: \"invalid_key\";\n    readonly origin: \"map\" | \"record\";\n    readonly issues: $ZodIssue[];\n    readonly input: Input;\n}\nexport interface $ZodIssueInvalidElement<Input = unknown> extends $ZodIssueBase {\n    readonly code: \"invalid_element\";\n    readonly origin: \"map\" | \"set\";\n    readonly key: unknown;\n    readonly issues: $ZodIssue[];\n    readonly input: Input;\n}\nexport interface $ZodIssueInvalidValue<Input = unknown> extends $ZodIssueBase {\n    readonly code: \"invalid_value\";\n    readonly values: util.Primitive[];\n    readonly input: Input;\n}\nexport interface $ZodIssueCustom extends $ZodIssueBase {\n    readonly code: \"custom\";\n    readonly params?: Record<string, any> | undefined;\n    readonly input: unknown;\n}\nexport interface $ZodIssueStringCommonFormats extends $ZodIssueInvalidStringFormat {\n    format: Exclude<$ZodStringFormats, \"regex\" | \"jwt\" | \"starts_with\" | \"ends_with\" | \"includes\">;\n}\nexport interface $ZodIssueStringInvalidRegex extends $ZodIssueInvalidStringFormat {\n    format: \"regex\";\n    pattern: string;\n}\nexport interface $ZodIssueStringInvalidJWT extends $ZodIssueInvalidStringFormat {\n    format: \"jwt\";\n    algorithm?: string;\n}\nexport interface $ZodIssueStringStartsWith extends $ZodIssueInvalidStringFormat {\n    format: \"starts_with\";\n    prefix: string;\n}\nexport interface $ZodIssueStringEndsWith extends $ZodIssueInvalidStringFormat {\n    format: \"ends_with\";\n    suffix: string;\n}\nexport interface $ZodIssueStringIncludes extends $ZodIssueInvalidStringFormat {\n    format: \"includes\";\n    includes: string;\n}\nexport type $ZodStringFormatIssues = $ZodIssueStringCommonFormats | $ZodIssueStringInvalidRegex | $ZodIssueStringInvalidJWT | $ZodIssueStringStartsWith | $ZodIssueStringEndsWith | $ZodIssueStringIncludes;\nexport type $ZodIssue = $ZodIssueInvalidType | $ZodIssueTooBig | $ZodIssueTooSmall | $ZodIssueInvalidStringFormat | $ZodIssueNotMultipleOf | $ZodIssueUnrecognizedKeys | $ZodIssueInvalidUnion | $ZodIssueInvalidKey | $ZodIssueInvalidElement | $ZodIssueInvalidValue | $ZodIssueCustom;\nexport type $ZodIssueCode = $ZodIssue[\"code\"];\nexport type $ZodRawIssue<T extends $ZodIssueBase = $ZodIssue> = T extends any ? RawIssue<T> : never;\ntype RawIssue<T extends $ZodIssueBase> = util.Flatten<util.MakePartial<T, \"message\" | \"path\"> & {\n    /** The input data */\n    readonly input?: unknown;\n    /** The schema or check that originated this issue. */\n    readonly inst?: $ZodType | $ZodCheck;\n    /** @deprecated Internal use only. If `true`, Zod will continue executing validation despite this issue. */\n    readonly continue?: boolean | undefined;\n} & Record<string, any>>;\nexport interface $ZodErrorMap<T extends $ZodIssueBase = $ZodIssue> {\n    (issue: $ZodRawIssue<T>): {\n        message: string;\n    } | string | undefined | null;\n}\nexport interface $ZodError<T = unknown> extends Error {\n    type: T;\n    issues: $ZodIssue[];\n    _zod: {\n        output: T;\n        def: $ZodIssue[];\n    };\n    stack?: string;\n    name: string;\n}\nexport declare const $ZodError: $constructor<$ZodError>;\ninterface $ZodRealError<T = any> extends $ZodError<T> {\n}\nexport declare const $ZodRealError: $constructor<$ZodRealError>;\nexport type $ZodFlattenedError<T, U = string> = _FlattenedError<T, U>;\ntype _FlattenedError<T, U = string> = {\n    formErrors: U[];\n    fieldErrors: {\n        [P in keyof T]?: U[];\n    };\n};\nexport declare function flattenError<T>(error: $ZodError<T>): _FlattenedError<T>;\nexport declare function flattenError<T, U>(error: $ZodError<T>, mapper?: (issue: $ZodIssue) => U): _FlattenedError<T, U>;\ntype _ZodFormattedError<T, U = string> = T extends [any, ...any[]] ? {\n    [K in keyof T]?: $ZodFormattedError<T[K], U>;\n} : T extends any[] ? {\n    [k: number]: $ZodFormattedError<T[number], U>;\n} : T extends object ? util.Flatten<{\n    [K in keyof T]?: $ZodFormattedError<T[K], U>;\n}> : any;\nexport type $ZodFormattedError<T, U = string> = {\n    _errors: U[];\n} & util.Flatten<_ZodFormattedError<T, U>>;\nexport declare function formatError<T>(error: $ZodError<T>): $ZodFormattedError<T>;\nexport declare function formatError<T, U>(error: $ZodError<T>, mapper?: (issue: $ZodIssue) => U): $ZodFormattedError<T, U>;\nexport type $ZodErrorTree<T, U = string> = T extends [any, ...any[]] ? {\n    errors: U[];\n    items?: {\n        [K in keyof T]?: $ZodErrorTree<T[K], U>;\n    };\n} : T extends any[] ? {\n    errors: U[];\n    items?: Array<$ZodErrorTree<T[number], U>>;\n} : T extends object ? {\n    errors: U[];\n    properties?: {\n        [K in keyof T]?: $ZodErrorTree<T[K], U>;\n    };\n} : {\n    errors: U[];\n};\nexport declare function treeifyError<T>(error: $ZodError<T>): $ZodErrorTree<T>;\nexport declare function treeifyError<T, U>(error: $ZodError<T>, mapper?: (issue: $ZodIssue) => U): $ZodErrorTree<T, U>;\n/** Format a ZodError as a human-readable string in the following form.\n *\n * From\n *\n * ```ts\n * ZodError {\n *   issues: [\n *     {\n *       expected: 'string',\n *       code: 'invalid_type',\n *       path: [ 'username' ],\n *       message: 'Invalid input: expected string'\n *     },\n *     {\n *       expected: 'number',\n *       code: 'invalid_type',\n *       path: [ 'favoriteNumbers', 1 ],\n *       message: 'Invalid input: expected number'\n *     }\n *   ];\n * }\n * ```\n *\n * to\n *\n * ```\n * username\n *    Expected number, received string at \"username\n * favoriteNumbers[0]\n *    Invalid input: expected number\n * ```\n */\nexport declare function toDotPath(path: (string | number | symbol)[]): string;\ninterface BaseError {\n    issues: $ZodIssueBase[];\n}\nexport declare function prettifyError(error: BaseError): string;\nexport {};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/core/errors.d.ts",
        "start": 1,
        "end": 208,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 208,
          "column": 2,
          "position": 2249
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/errors.d.ts",
        "start": 1,
        "end": 208,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 208,
          "column": 2,
          "position": 2249
        }
      }
    },
    {
      "format": "typescript",
      "lines": 208,
      "fragment": "import type { $ZodCheck, $ZodStringFormats } from \"./checks.cjs\";\nimport { $constructor } from \"./core.cjs\";\nimport type { $ZodType } from \"./schemas.cjs\";\nimport * as util from \"./util.cjs\";\nexport interface $ZodIssueBase {\n    readonly code?: string;\n    readonly input?: unknown;\n    readonly path: PropertyKey[];\n    readonly message: string;\n}\nexport interface $ZodIssueInvalidType<Input = unknown> extends $ZodIssueBase {\n    readonly code: \"invalid_type\";\n    readonly expected: $ZodType[\"_zod\"][\"def\"][\"type\"];\n    readonly input: Input;\n}\nexport interface $ZodIssueTooBig<Input = unknown> extends $ZodIssueBase {\n    readonly code: \"too_big\";\n    readonly origin: \"number\" | \"int\" | \"bigint\" | \"date\" | \"string\" | \"array\" | \"set\" | \"file\" | (string & {});\n    readonly maximum: number | bigint;\n    readonly inclusive?: boolean;\n    readonly exact?: boolean;\n    readonly input: Input;\n}\nexport interface $ZodIssueTooSmall<Input = unknown> extends $ZodIssueBase {\n    readonly code: \"too_small\";\n    readonly origin: \"number\" | \"int\" | \"bigint\" | \"date\" | \"string\" | \"array\" | \"set\" | \"file\" | (string & {});\n    readonly minimum: number | bigint;\n    /** True if the allowable range includes the minimum */\n    readonly inclusive?: boolean;\n    /** True if the allowed value is fixed (e.g.` z.length(5)`), not a range (`z.minLength(5)`) */\n    readonly exact?: boolean;\n    readonly input: Input;\n}\nexport interface $ZodIssueInvalidStringFormat extends $ZodIssueBase {\n    readonly code: \"invalid_format\";\n    readonly format: $ZodStringFormats | (string & {});\n    readonly pattern?: string;\n    readonly input: string;\n}\nexport interface $ZodIssueNotMultipleOf<Input extends number | bigint = number | bigint> extends $ZodIssueBase {\n    readonly code: \"not_multiple_of\";\n    readonly divisor: number;\n    readonly input: Input;\n}\nexport interface $ZodIssueUnrecognizedKeys extends $ZodIssueBase {\n    readonly code: \"unrecognized_keys\";\n    readonly keys: string[];\n    readonly input: Record<string, unknown>;\n}\nexport interface $ZodIssueInvalidUnion extends $ZodIssueBase {\n    readonly code: \"invalid_union\";\n    readonly errors: $ZodIssue[][];\n    readonly input: unknown;\n}\nexport interface $ZodIssueInvalidKey<Input = unknown> extends $ZodIssueBase {\n    readonly code: \"invalid_key\";\n    readonly origin: \"map\" | \"record\";\n    readonly issues: $ZodIssue[];\n    readonly input: Input;\n}\nexport interface $ZodIssueInvalidElement<Input = unknown> extends $ZodIssueBase {\n    readonly code: \"invalid_element\";\n    readonly origin: \"map\" | \"set\";\n    readonly key: unknown;\n    readonly issues: $ZodIssue[];\n    readonly input: Input;\n}\nexport interface $ZodIssueInvalidValue<Input = unknown> extends $ZodIssueBase {\n    readonly code: \"invalid_value\";\n    readonly values: util.Primitive[];\n    readonly input: Input;\n}\nexport interface $ZodIssueCustom extends $ZodIssueBase {\n    readonly code: \"custom\";\n    readonly params?: Record<string, any> | undefined;\n    readonly input: unknown;\n}\nexport interface $ZodIssueStringCommonFormats extends $ZodIssueInvalidStringFormat {\n    format: Exclude<$ZodStringFormats, \"regex\" | \"jwt\" | \"starts_with\" | \"ends_with\" | \"includes\">;\n}\nexport interface $ZodIssueStringInvalidRegex extends $ZodIssueInvalidStringFormat {\n    format: \"regex\";\n    pattern: string;\n}\nexport interface $ZodIssueStringInvalidJWT extends $ZodIssueInvalidStringFormat {\n    format: \"jwt\";\n    algorithm?: string;\n}\nexport interface $ZodIssueStringStartsWith extends $ZodIssueInvalidStringFormat {\n    format: \"starts_with\";\n    prefix: string;\n}\nexport interface $ZodIssueStringEndsWith extends $ZodIssueInvalidStringFormat {\n    format: \"ends_with\";\n    suffix: string;\n}\nexport interface $ZodIssueStringIncludes extends $ZodIssueInvalidStringFormat {\n    format: \"includes\";\n    includes: string;\n}\nexport type $ZodStringFormatIssues = $ZodIssueStringCommonFormats | $ZodIssueStringInvalidRegex | $ZodIssueStringInvalidJWT | $ZodIssueStringStartsWith | $ZodIssueStringEndsWith | $ZodIssueStringIncludes;\nexport type $ZodIssue = $ZodIssueInvalidType | $ZodIssueTooBig | $ZodIssueTooSmall | $ZodIssueInvalidStringFormat | $ZodIssueNotMultipleOf | $ZodIssueUnrecognizedKeys | $ZodIssueInvalidUnion | $ZodIssueInvalidKey | $ZodIssueInvalidElement | $ZodIssueInvalidValue | $ZodIssueCustom;\nexport type $ZodIssueCode = $ZodIssue[\"code\"];\nexport type $ZodRawIssue<T extends $ZodIssueBase = $ZodIssue> = T extends any ? RawIssue<T> : never;\ntype RawIssue<T extends $ZodIssueBase> = util.Flatten<util.MakePartial<T, \"message\" | \"path\"> & {\n    /** The input data */\n    readonly input?: unknown;\n    /** The schema or check that originated this issue. */\n    readonly inst?: $ZodType | $ZodCheck;\n    /** @deprecated Internal use only. If `true`, Zod will continue executing validation despite this issue. */\n    readonly continue?: boolean | undefined;\n} & Record<string, any>>;\nexport interface $ZodErrorMap<T extends $ZodIssueBase = $ZodIssue> {\n    (issue: $ZodRawIssue<T>): {\n        message: string;\n    } | string | undefined | null;\n}\nexport interface $ZodError<T = unknown> extends Error {\n    type: T;\n    issues: $ZodIssue[];\n    _zod: {\n        output: T;\n        def: $ZodIssue[];\n    };\n    stack?: string;\n    name: string;\n}\nexport declare const $ZodError: $constructor<$ZodError>;\ninterface $ZodRealError<T = any> extends $ZodError<T> {\n}\nexport declare const $ZodRealError: $constructor<$ZodRealError>;\nexport type $ZodFlattenedError<T, U = string> = _FlattenedError<T, U>;\ntype _FlattenedError<T, U = string> = {\n    formErrors: U[];\n    fieldErrors: {\n        [P in keyof T]?: U[];\n    };\n};\nexport declare function flattenError<T>(error: $ZodError<T>): _FlattenedError<T>;\nexport declare function flattenError<T, U>(error: $ZodError<T>, mapper?: (issue: $ZodIssue) => U): _FlattenedError<T, U>;\ntype _ZodFormattedError<T, U = string> = T extends [any, ...any[]] ? {\n    [K in keyof T]?: $ZodFormattedError<T[K], U>;\n} : T extends any[] ? {\n    [k: number]: $ZodFormattedError<T[number], U>;\n} : T extends object ? util.Flatten<{\n    [K in keyof T]?: $ZodFormattedError<T[K], U>;\n}> : any;\nexport type $ZodFormattedError<T, U = string> = {\n    _errors: U[];\n} & util.Flatten<_ZodFormattedError<T, U>>;\nexport declare function formatError<T>(error: $ZodError<T>): $ZodFormattedError<T>;\nexport declare function formatError<T, U>(error: $ZodError<T>, mapper?: (issue: $ZodIssue) => U): $ZodFormattedError<T, U>;\nexport type $ZodErrorTree<T, U = string> = T extends [any, ...any[]] ? {\n    errors: U[];\n    items?: {\n        [K in keyof T]?: $ZodErrorTree<T[K], U>;\n    };\n} : T extends any[] ? {\n    errors: U[];\n    items?: Array<$ZodErrorTree<T[number], U>>;\n} : T extends object ? {\n    errors: U[];\n    properties?: {\n        [K in keyof T]?: $ZodErrorTree<T[K], U>;\n    };\n} : {\n    errors: U[];\n};\nexport declare function treeifyError<T>(error: $ZodError<T>): $ZodErrorTree<T>;\nexport declare function treeifyError<T, U>(error: $ZodError<T>, mapper?: (issue: $ZodIssue) => U): $ZodErrorTree<T, U>;\n/** Format a ZodError as a human-readable string in the following form.\n *\n * From\n *\n * ```ts\n * ZodError {\n *   issues: [\n *     {\n *       expected: 'string',\n *       code: 'invalid_type',\n *       path: [ 'username' ],\n *       message: 'Invalid input: expected string'\n *     },\n *     {\n *       expected: 'number',\n *       code: 'invalid_type',\n *       path: [ 'favoriteNumbers', 1 ],\n *       message: 'Invalid input: expected number'\n *     }\n *   ];\n * }\n * ```\n *\n * to\n *\n * ```\n * username\n *    Expected number, received string at \"username\n * favoriteNumbers[0]\n *    Invalid input: expected number\n * ```\n */\nexport declare function toDotPath(path: (string | number | symbol)[]): string;\ninterface BaseError {\n    issues: $ZodIssueBase[];\n}\nexport declare function prettifyError(error: BaseError): string;\nexport {};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/core/errors.d.cts",
        "start": 1,
        "end": 208,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 208,
          "column": 2,
          "position": 2249
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/errors.d.cts",
        "start": 1,
        "end": 208,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 208,
          "column": 2,
          "position": 2249
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": "type ModeWriter = (doc: Doc, modes: {\n    execution: \"sync\" | \"async\";\n}) => void;\nexport declare class Doc {\n    args: string[];\n    content: string[];\n    indent: number;\n    constructor(args?: string[]);\n    indented(fn: (doc: Doc) => void): void;\n    write(fn: ModeWriter): void;\n    write(line: string): void;\n    compile(): Function;\n}\nexport {};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/core/doc.d.ts",
        "start": 1,
        "end": 14,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 14,
          "column": 2,
          "position": 148
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/doc.d.ts",
        "start": 1,
        "end": 14,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 14,
          "column": 2,
          "position": 148
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": "type ModeWriter = (doc: Doc, modes: {\n    execution: \"sync\" | \"async\";\n}) => void;\nexport declare class Doc {\n    args: string[];\n    content: string[];\n    indent: number;\n    constructor(args?: string[]);\n    indented(fn: (doc: Doc) => void): void;\n    write(fn: ModeWriter): void;\n    write(line: string): void;\n    compile(): Function;\n}\nexport {};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/core/doc.d.cts",
        "start": 1,
        "end": 14,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 14,
          "column": 2,
          "position": 148
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/doc.d.ts",
        "start": 1,
        "end": 14,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 14,
          "column": 2,
          "position": 148
        }
      }
    },
    {
      "format": "typescript",
      "lines": 49,
      "fragment": "import type * as errors from \"./errors.js\";\nimport type * as schemas from \"./schemas.js\";\nimport type { Class } from \"./util.js\";\ntype ZodTrait = {\n    _zod: {\n        def: any;\n        [k: string]: any;\n    };\n};\nexport interface $constructor<T extends ZodTrait, D = T[\"_zod\"][\"def\"]> {\n    new (def: D): T;\n    init(inst: T, def: D): asserts inst is T;\n}\n/** A special constant with type `never` */\nexport declare const NEVER: never;\nexport declare function $constructor<T extends ZodTrait, D = T[\"_zod\"][\"def\"]>(name: string, initializer: (inst: T, def: D) => void, params?: {\n    Parent?: typeof Class;\n}): $constructor<T, D>;\nexport declare const $brand: unique symbol;\nexport type $brand<T extends string | number | symbol = string | number | symbol> = {\n    [$brand]: {\n        [k in T]: true;\n    };\n};\nexport type $ZodBranded<T extends schemas.SomeType, Brand extends string | number | symbol> = T & Record<\"_zod\", Record<\"output\", output<T> & $brand<Brand>>>;\nexport declare class $ZodAsyncError extends Error {\n    constructor();\n}\nexport type input<T> = T extends {\n    _zod: {\n        input: any;\n    };\n} ? Required<T[\"_zod\"]>[\"input\"] : unknown;\nexport type output<T> = T extends {\n    _zod: {\n        output: any;\n    };\n} ? Required<T[\"_zod\"]>[\"output\"] : unknown;\nexport type { output as infer };\nexport interface $ZodConfig {\n    /** Custom error map. Overrides `config().localeError`. */\n    customError?: errors.$ZodErrorMap | undefined;\n    /** Localized error map. Lowest priority. */\n    localeError?: errors.$ZodErrorMap | undefined;\n    /** Disable JIT schema compilation. Useful in environments that disallow `eval`. */\n    jitless?: boolean | undefined;\n}\nexport declare const globalConfig: $ZodConfig;\nexport declare function config(newConfig?: Partial<$ZodConfig>): $ZodConfig;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/core/core.d.ts",
        "start": 1,
        "end": 49,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 49,
          "column": 2,
          "position": 629
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/core.d.ts",
        "start": 1,
        "end": 49,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 49,
          "column": 2,
          "position": 629
        }
      }
    },
    {
      "format": "typescript",
      "lines": 49,
      "fragment": "import type * as errors from \"./errors.cjs\";\nimport type * as schemas from \"./schemas.cjs\";\nimport type { Class } from \"./util.cjs\";\ntype ZodTrait = {\n    _zod: {\n        def: any;\n        [k: string]: any;\n    };\n};\nexport interface $constructor<T extends ZodTrait, D = T[\"_zod\"][\"def\"]> {\n    new (def: D): T;\n    init(inst: T, def: D): asserts inst is T;\n}\n/** A special constant with type `never` */\nexport declare const NEVER: never;\nexport declare function $constructor<T extends ZodTrait, D = T[\"_zod\"][\"def\"]>(name: string, initializer: (inst: T, def: D) => void, params?: {\n    Parent?: typeof Class;\n}): $constructor<T, D>;\nexport declare const $brand: unique symbol;\nexport type $brand<T extends string | number | symbol = string | number | symbol> = {\n    [$brand]: {\n        [k in T]: true;\n    };\n};\nexport type $ZodBranded<T extends schemas.SomeType, Brand extends string | number | symbol> = T & Record<\"_zod\", Record<\"output\", output<T> & $brand<Brand>>>;\nexport declare class $ZodAsyncError extends Error {\n    constructor();\n}\nexport type input<T> = T extends {\n    _zod: {\n        input: any;\n    };\n} ? Required<T[\"_zod\"]>[\"input\"] : unknown;\nexport type output<T> = T extends {\n    _zod: {\n        output: any;\n    };\n} ? Required<T[\"_zod\"]>[\"output\"] : unknown;\nexport type { output as infer };\nexport interface $ZodConfig {\n    /** Custom error map. Overrides `config().localeError`. */\n    customError?: errors.$ZodErrorMap | undefined;\n    /** Localized error map. Lowest priority. */\n    localeError?: errors.$ZodErrorMap | undefined;\n    /** Disable JIT schema compilation. Useful in environments that disallow `eval`. */\n    jitless?: boolean | undefined;\n}\nexport declare const globalConfig: $ZodConfig;\nexport declare function config(newConfig?: Partial<$ZodConfig>): $ZodConfig;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/core/core.d.cts",
        "start": 1,
        "end": 49,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 49,
          "column": 2,
          "position": 629
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/core.d.cts",
        "start": 1,
        "end": 49,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 49,
          "column": 2,
          "position": 629
        }
      }
    },
    {
      "format": "typescript",
      "lines": 278,
      "fragment": "import * as core from \"./core.js\";\nimport type * as errors from \"./errors.js\";\nimport type * as schemas from \"./schemas.js\";\nimport * as util from \"./util.js\";\nexport interface $ZodCheckDef {\n    check: string;\n    error?: errors.$ZodErrorMap<never> | undefined;\n    /** If true, no later checks will be executed if this check fails. Default `false`. */\n    abort?: boolean | undefined;\n    /** If provided, this check will only be executed if the function returns `true`. Defaults to `payload => z.util.isAborted(payload)`. */\n    when?: ((payload: schemas.ParsePayload) => boolean) | undefined;\n}\nexport interface $ZodCheckInternals<T> {\n    def: $ZodCheckDef;\n    /** The set of issues this check might throw. */\n    issc?: errors.$ZodIssueBase;\n    check(payload: schemas.ParsePayload<T>): util.MaybeAsync<void>;\n    onattach: ((schema: schemas.$ZodType) => void)[];\n}\nexport interface $ZodCheck<in T = never> {\n    _zod: $ZodCheckInternals<T>;\n}\nexport declare const $ZodCheck: core.$constructor<$ZodCheck<any>>;\nexport interface $ZodCheckLessThanDef extends $ZodCheckDef {\n    check: \"less_than\";\n    value: util.Numeric;\n    inclusive: boolean;\n}\nexport interface $ZodCheckLessThanInternals<T extends util.Numeric = util.Numeric> extends $ZodCheckInternals<T> {\n    def: $ZodCheckLessThanDef;\n    issc: errors.$ZodIssueTooBig<T>;\n}\nexport interface $ZodCheckLessThan<T extends util.Numeric = util.Numeric> extends $ZodCheck<T> {\n    _zod: $ZodCheckLessThanInternals<T>;\n}\nexport declare const $ZodCheckLessThan: core.$constructor<$ZodCheckLessThan>;\nexport interface $ZodCheckGreaterThanDef extends $ZodCheckDef {\n    check: \"greater_than\";\n    value: util.Numeric;\n    inclusive: boolean;\n}\nexport interface $ZodCheckGreaterThanInternals<T extends util.Numeric = util.Numeric> extends $ZodCheckInternals<T> {\n    def: $ZodCheckGreaterThanDef;\n    issc: errors.$ZodIssueTooSmall<T>;\n}\nexport interface $ZodCheckGreaterThan<T extends util.Numeric = util.Numeric> extends $ZodCheck<T> {\n    _zod: $ZodCheckGreaterThanInternals<T>;\n}\nexport declare const $ZodCheckGreaterThan: core.$constructor<$ZodCheckGreaterThan>;\nexport interface $ZodCheckMultipleOfDef<T extends number | bigint = number | bigint> extends $ZodCheckDef {\n    check: \"multiple_of\";\n    value: T;\n}\nexport interface $ZodCheckMultipleOfInternals<T extends number | bigint = number | bigint> extends $ZodCheckInternals<T> {\n    def: $ZodCheckMultipleOfDef<T>;\n    issc: errors.$ZodIssueNotMultipleOf;\n}\nexport interface $ZodCheckMultipleOf<T extends number | bigint = number | bigint> extends $ZodCheck<T> {\n    _zod: $ZodCheckMultipleOfInternals<T>;\n}\nexport declare const $ZodCheckMultipleOf: core.$constructor<$ZodCheckMultipleOf<number | bigint>>;\nexport type $ZodNumberFormats = \"int32\" | \"uint32\" | \"float32\" | \"float64\" | \"safeint\";\nexport interface $ZodCheckNumberFormatDef extends $ZodCheckDef {\n    check: \"number_format\";\n    format: $ZodNumberFormats;\n}\nexport interface $ZodCheckNumberFormatInternals extends $ZodCheckInternals<number> {\n    def: $ZodCheckNumberFormatDef;\n    issc: errors.$ZodIssueInvalidType | errors.$ZodIssueTooBig<\"number\"> | errors.$ZodIssueTooSmall<\"number\">;\n}\nexport interface $ZodCheckNumberFormat extends $ZodCheck<number> {\n    _zod: $ZodCheckNumberFormatInternals;\n}\nexport declare const $ZodCheckNumberFormat: core.$constructor<$ZodCheckNumberFormat>;\nexport type $ZodBigIntFormats = \"int64\" | \"uint64\";\nexport interface $ZodCheckBigIntFormatDef extends $ZodCheckDef {\n    check: \"bigint_format\";\n    format: $ZodBigIntFormats | undefined;\n}\nexport interface $ZodCheckBigIntFormatInternals extends $ZodCheckInternals<bigint> {\n    def: $ZodCheckBigIntFormatDef;\n    issc: errors.$ZodIssueTooBig<\"bigint\"> | errors.$ZodIssueTooSmall<\"bigint\">;\n}\nexport interface $ZodCheckBigIntFormat extends $ZodCheck<bigint> {\n    _zod: $ZodCheckBigIntFormatInternals;\n}\nexport declare const $ZodCheckBigIntFormat: core.$constructor<$ZodCheckBigIntFormat>;\nexport interface $ZodCheckMaxSizeDef extends $ZodCheckDef {\n    check: \"max_size\";\n    maximum: number;\n}\nexport interface $ZodCheckMaxSizeInternals<T extends util.HasSize = util.HasSize> extends $ZodCheckInternals<T> {\n    def: $ZodCheckMaxSizeDef;\n    issc: errors.$ZodIssueTooBig<T>;\n}\nexport interface $ZodCheckMaxSize<T extends util.HasSize = util.HasSize> extends $ZodCheck<T> {\n    _zod: $ZodCheckMaxSizeInternals<T>;\n}\nexport declare const $ZodCheckMaxSize: core.$constructor<$ZodCheckMaxSize>;\nexport interface $ZodCheckMinSizeDef extends $ZodCheckDef {\n    check: \"min_size\";\n    minimum: number;\n}\nexport interface $ZodCheckMinSizeInternals<T extends util.HasSize = util.HasSize> extends $ZodCheckInternals<T> {\n    def: $ZodCheckMinSizeDef;\n    issc: errors.$ZodIssueTooSmall<T>;\n}\nexport interface $ZodCheckMinSize<T extends util.HasSize = util.HasSize> extends $ZodCheck<T> {\n    _zod: $ZodCheckMinSizeInternals<T>;\n}\nexport declare const $ZodCheckMinSize: core.$constructor<$ZodCheckMinSize>;\nexport interface $ZodCheckSizeEqualsDef extends $ZodCheckDef {\n    check: \"size_equals\";\n    size: number;\n}\nexport interface $ZodCheckSizeEqualsInternals<T extends util.HasSize = util.HasSize> extends $ZodCheckInternals<T> {\n    def: $ZodCheckSizeEqualsDef;\n    issc: errors.$ZodIssueTooBig<T> | errors.$ZodIssueTooSmall<T>;\n}\nexport interface $ZodCheckSizeEquals<T extends util.HasSize = util.HasSize> extends $ZodCheck<T> {\n    _zod: $ZodCheckSizeEqualsInternals<T>;\n}\nexport declare const $ZodCheckSizeEquals: core.$constructor<$ZodCheckSizeEquals>;\nexport interface $ZodCheckMaxLengthDef extends $ZodCheckDef {\n    check: \"max_length\";\n    maximum: number;\n}\nexport interface $ZodCheckMaxLengthInternals<T extends util.HasLength = util.HasLength> extends $ZodCheckInternals<T> {\n    def: $ZodCheckMaxLengthDef;\n    issc: errors.$ZodIssueTooBig<T>;\n}\nexport interface $ZodCheckMaxLength<T extends util.HasLength = util.HasLength> extends $ZodCheck<T> {\n    _zod: $ZodCheckMaxLengthInternals<T>;\n}\nexport declare const $ZodCheckMaxLength: core.$constructor<$ZodCheckMaxLength>;\nexport interface $ZodCheckMinLengthDef extends $ZodCheckDef {\n    check: \"min_length\";\n    minimum: number;\n}\nexport interface $ZodCheckMinLengthInternals<T extends util.HasLength = util.HasLength> extends $ZodCheckInternals<T> {\n    def: $ZodCheckMinLengthDef;\n    issc: errors.$ZodIssueTooSmall<T>;\n}\nexport interface $ZodCheckMinLength<T extends util.HasLength = util.HasLength> extends $ZodCheck<T> {\n    _zod: $ZodCheckMinLengthInternals<T>;\n}\nexport declare const $ZodCheckMinLength: core.$constructor<$ZodCheckMinLength>;\nexport interface $ZodCheckLengthEqualsDef extends $ZodCheckDef {\n    check: \"length_equals\";\n    length: number;\n}\nexport interface $ZodCheckLengthEqualsInternals<T extends util.HasLength = util.HasLength> extends $ZodCheckInternals<T> {\n    def: $ZodCheckLengthEqualsDef;\n    issc: errors.$ZodIssueTooBig<T> | errors.$ZodIssueTooSmall<T>;\n}\nexport interface $ZodCheckLengthEquals<T extends util.HasLength = util.HasLength> extends $ZodCheck<T> {\n    _zod: $ZodCheckLengthEqualsInternals<T>;\n}\nexport declare const $ZodCheckLengthEquals: core.$constructor<$ZodCheckLengthEquals>;\nexport type $ZodStringFormats = \"email\" | \"url\" | \"emoji\" | \"uuid\" | \"guid\" | \"nanoid\" | \"cuid\" | \"cuid2\" | \"ulid\" | \"xid\" | \"ksuid\" | \"datetime\" | \"date\" | \"time\" | \"duration\" | \"ipv4\" | \"ipv6\" | \"cidrv4\" | \"cidrv6\" | \"base64\" | \"base64url\" | \"json_string\" | \"e164\" | \"lowercase\" | \"uppercase\" | \"regex\" | \"jwt\" | \"starts_with\" | \"ends_with\" | \"includes\";\nexport interface $ZodCheckStringFormatDef<Format extends string = string> extends $ZodCheckDef {\n    check: \"string_format\";\n    format: Format;\n    pattern?: RegExp | undefined;\n}\nexport interface $ZodCheckStringFormatInternals extends $ZodCheckInternals<string> {\n    def: $ZodCheckStringFormatDef;\n    issc: errors.$ZodIssueInvalidStringFormat;\n}\nexport interface $ZodCheckStringFormat extends $ZodCheck<string> {\n    _zod: $ZodCheckStringFormatInternals;\n}\nexport declare const $ZodCheckStringFormat: core.$constructor<$ZodCheckStringFormat>;\nexport interface $ZodCheckRegexDef extends $ZodCheckStringFormatDef {\n    format: \"regex\";\n    pattern: RegExp;\n}\nexport interface $ZodCheckRegexInternals extends $ZodCheckInternals<string> {\n    def: $ZodCheckRegexDef;\n    issc: errors.$ZodIssueInvalidStringFormat;\n}\nexport interface $ZodCheckRegex extends $ZodCheck<string> {\n    _zod: $ZodCheckRegexInternals;\n}\nexport declare const $ZodCheckRegex: core.$constructor<$ZodCheckRegex>;\nexport interface $ZodCheckLowerCaseDef extends $ZodCheckStringFormatDef<\"lowercase\"> {\n}\nexport interface $ZodCheckLowerCaseInternals extends $ZodCheckInternals<string> {\n    def: $ZodCheckLowerCaseDef;\n    issc: errors.$ZodIssueInvalidStringFormat;\n}\nexport interface $ZodCheckLowerCase extends $ZodCheck<string> {\n    _zod: $ZodCheckLowerCaseInternals;\n}\nexport declare const $ZodCheckLowerCase: core.$constructor<$ZodCheckLowerCase>;\nexport interface $ZodCheckUpperCaseDef extends $ZodCheckStringFormatDef<\"uppercase\"> {\n}\nexport interface $ZodCheckUpperCaseInternals extends $ZodCheckInternals<string> {\n    def: $ZodCheckUpperCaseDef;\n    issc: errors.$ZodIssueInvalidStringFormat;\n}\nexport interface $ZodCheckUpperCase extends $ZodCheck<string> {\n    _zod: $ZodCheckUpperCaseInternals;\n}\nexport declare const $ZodCheckUpperCase: core.$constructor<$ZodCheckUpperCase>;\nexport interface $ZodCheckIncludesDef extends $ZodCheckStringFormatDef<\"includes\"> {\n    includes: string;\n    position?: number | undefined;\n}\nexport interface $ZodCheckIncludesInternals extends $ZodCheckInternals<string> {\n    def: $ZodCheckIncludesDef;\n    issc: errors.$ZodIssueInvalidStringFormat;\n}\nexport interface $ZodCheckIncludes extends $ZodCheck<string> {\n    _zod: $ZodCheckIncludesInternals;\n}\nexport declare const $ZodCheckIncludes: core.$constructor<$ZodCheckIncludes>;\nexport interface $ZodCheckStartsWithDef extends $ZodCheckStringFormatDef<\"starts_with\"> {\n    prefix: string;\n}\nexport interface $ZodCheckStartsWithInternals extends $ZodCheckInternals<string> {\n    def: $ZodCheckStartsWithDef;\n    issc: errors.$ZodIssueInvalidStringFormat;\n}\nexport interface $ZodCheckStartsWith extends $ZodCheck<string> {\n    _zod: $ZodCheckStartsWithInternals;\n}\nexport declare const $ZodCheckStartsWith: core.$constructor<$ZodCheckStartsWith>;\nexport interface $ZodCheckEndsWithDef extends $ZodCheckStringFormatDef<\"ends_with\"> {\n    suffix: string;\n}\nexport interface $ZodCheckEndsWithInternals extends $ZodCheckInternals<string> {\n    def: $ZodCheckEndsWithDef;\n    issc: errors.$ZodIssueInvalidStringFormat;\n}\nexport interface $ZodCheckEndsWith extends $ZodCheckInternals<string> {\n    _zod: $ZodCheckEndsWithInternals;\n}\nexport declare const $ZodCheckEndsWith: core.$constructor<$ZodCheckEndsWith>;\nexport interface $ZodCheckPropertyDef extends $ZodCheckDef {\n    check: \"property\";\n    property: string;\n    schema: schemas.$ZodType;\n}\nexport interface $ZodCheckPropertyInternals<T extends object = object> extends $ZodCheckInternals<T> {\n    def: $ZodCheckPropertyDef;\n    issc: errors.$ZodIssue;\n}\nexport interface $ZodCheckProperty<T extends object = object> extends $ZodCheck<T> {\n    _zod: $ZodCheckPropertyInternals<T>;\n}\nexport declare const $ZodCheckProperty: core.$constructor<$ZodCheckProperty>;\nexport interface $ZodCheckMimeTypeDef extends $ZodCheckDef {\n    check: \"mime_type\";\n    mime: util.MimeTypes[];\n}\nexport interface $ZodCheckMimeTypeInternals<T extends File = File> extends $ZodCheckInternals<T> {\n    def: $ZodCheckMimeTypeDef;\n    issc: errors.$ZodIssueInvalidValue;\n}\nexport interface $ZodCheckMimeType<T extends File = File> extends $ZodCheck<T> {\n    _zod: $ZodCheckMimeTypeInternals<T>;\n}\nexport declare const $ZodCheckMimeType: core.$constructor<$ZodCheckMimeType>;\nexport interface $ZodCheckOverwriteDef<T = unknown> extends $ZodCheckDef {\n    check: \"overwrite\";\n    tx(value: T): T;\n}\nexport interface $ZodCheckOverwriteInternals<T = unknown> extends $ZodCheckInternals<T> {\n    def: $ZodCheckOverwriteDef<T>;\n    issc: never;\n}\nexport interface $ZodCheckOverwrite<T = unknown> extends $ZodCheck<T> {\n    _zod: $ZodCheckOverwriteInternals<T>;\n}\nexport declare const $ZodCheckOverwrite: core.$constructor<$ZodCheckOverwrite>;\nexport type $ZodChecks = $ZodCheckLessThan | $ZodCheckGreaterThan | $ZodCheckMultipleOf | $ZodCheckNumberFormat | $ZodCheckBigIntFormat | $ZodCheckMaxSize | $ZodCheckMinSize | $ZodCheckSizeEquals | $ZodCheckMaxLength | $ZodCheckMinLength | $ZodCheckLengthEquals | $ZodCheckStringFormat | $ZodCheckProperty | $ZodCheckMimeType | $ZodCheckOverwrite;\nexport type $ZodStringFormatChecks = $ZodCheckRegex | $ZodCheckLowerCase | $ZodCheckUpperCase | $ZodCheckIncludes | $ZodCheckStartsWith | $ZodCheckEndsWith | schemas.$ZodStringFormatTypes;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/core/checks.d.ts",
        "start": 1,
        "end": 278,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 278,
          "column": 2,
          "position": 3216
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/checks.d.ts",
        "start": 1,
        "end": 278,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 278,
          "column": 2,
          "position": 3216
        }
      }
    },
    {
      "format": "typescript",
      "lines": 278,
      "fragment": "import * as core from \"./core.cjs\";\nimport type * as errors from \"./errors.cjs\";\nimport type * as schemas from \"./schemas.cjs\";\nimport * as util from \"./util.cjs\";\nexport interface $ZodCheckDef {\n    check: string;\n    error?: errors.$ZodErrorMap<never> | undefined;\n    /** If true, no later checks will be executed if this check fails. Default `false`. */\n    abort?: boolean | undefined;\n    /** If provided, this check will only be executed if the function returns `true`. Defaults to `payload => z.util.isAborted(payload)`. */\n    when?: ((payload: schemas.ParsePayload) => boolean) | undefined;\n}\nexport interface $ZodCheckInternals<T> {\n    def: $ZodCheckDef;\n    /** The set of issues this check might throw. */\n    issc?: errors.$ZodIssueBase;\n    check(payload: schemas.ParsePayload<T>): util.MaybeAsync<void>;\n    onattach: ((schema: schemas.$ZodType) => void)[];\n}\nexport interface $ZodCheck<in T = never> {\n    _zod: $ZodCheckInternals<T>;\n}\nexport declare const $ZodCheck: core.$constructor<$ZodCheck<any>>;\nexport interface $ZodCheckLessThanDef extends $ZodCheckDef {\n    check: \"less_than\";\n    value: util.Numeric;\n    inclusive: boolean;\n}\nexport interface $ZodCheckLessThanInternals<T extends util.Numeric = util.Numeric> extends $ZodCheckInternals<T> {\n    def: $ZodCheckLessThanDef;\n    issc: errors.$ZodIssueTooBig<T>;\n}\nexport interface $ZodCheckLessThan<T extends util.Numeric = util.Numeric> extends $ZodCheck<T> {\n    _zod: $ZodCheckLessThanInternals<T>;\n}\nexport declare const $ZodCheckLessThan: core.$constructor<$ZodCheckLessThan>;\nexport interface $ZodCheckGreaterThanDef extends $ZodCheckDef {\n    check: \"greater_than\";\n    value: util.Numeric;\n    inclusive: boolean;\n}\nexport interface $ZodCheckGreaterThanInternals<T extends util.Numeric = util.Numeric> extends $ZodCheckInternals<T> {\n    def: $ZodCheckGreaterThanDef;\n    issc: errors.$ZodIssueTooSmall<T>;\n}\nexport interface $ZodCheckGreaterThan<T extends util.Numeric = util.Numeric> extends $ZodCheck<T> {\n    _zod: $ZodCheckGreaterThanInternals<T>;\n}\nexport declare const $ZodCheckGreaterThan: core.$constructor<$ZodCheckGreaterThan>;\nexport interface $ZodCheckMultipleOfDef<T extends number | bigint = number | bigint> extends $ZodCheckDef {\n    check: \"multiple_of\";\n    value: T;\n}\nexport interface $ZodCheckMultipleOfInternals<T extends number | bigint = number | bigint> extends $ZodCheckInternals<T> {\n    def: $ZodCheckMultipleOfDef<T>;\n    issc: errors.$ZodIssueNotMultipleOf;\n}\nexport interface $ZodCheckMultipleOf<T extends number | bigint = number | bigint> extends $ZodCheck<T> {\n    _zod: $ZodCheckMultipleOfInternals<T>;\n}\nexport declare const $ZodCheckMultipleOf: core.$constructor<$ZodCheckMultipleOf<number | bigint>>;\nexport type $ZodNumberFormats = \"int32\" | \"uint32\" | \"float32\" | \"float64\" | \"safeint\";\nexport interface $ZodCheckNumberFormatDef extends $ZodCheckDef {\n    check: \"number_format\";\n    format: $ZodNumberFormats;\n}\nexport interface $ZodCheckNumberFormatInternals extends $ZodCheckInternals<number> {\n    def: $ZodCheckNumberFormatDef;\n    issc: errors.$ZodIssueInvalidType | errors.$ZodIssueTooBig<\"number\"> | errors.$ZodIssueTooSmall<\"number\">;\n}\nexport interface $ZodCheckNumberFormat extends $ZodCheck<number> {\n    _zod: $ZodCheckNumberFormatInternals;\n}\nexport declare const $ZodCheckNumberFormat: core.$constructor<$ZodCheckNumberFormat>;\nexport type $ZodBigIntFormats = \"int64\" | \"uint64\";\nexport interface $ZodCheckBigIntFormatDef extends $ZodCheckDef {\n    check: \"bigint_format\";\n    format: $ZodBigIntFormats | undefined;\n}\nexport interface $ZodCheckBigIntFormatInternals extends $ZodCheckInternals<bigint> {\n    def: $ZodCheckBigIntFormatDef;\n    issc: errors.$ZodIssueTooBig<\"bigint\"> | errors.$ZodIssueTooSmall<\"bigint\">;\n}\nexport interface $ZodCheckBigIntFormat extends $ZodCheck<bigint> {\n    _zod: $ZodCheckBigIntFormatInternals;\n}\nexport declare const $ZodCheckBigIntFormat: core.$constructor<$ZodCheckBigIntFormat>;\nexport interface $ZodCheckMaxSizeDef extends $ZodCheckDef {\n    check: \"max_size\";\n    maximum: number;\n}\nexport interface $ZodCheckMaxSizeInternals<T extends util.HasSize = util.HasSize> extends $ZodCheckInternals<T> {\n    def: $ZodCheckMaxSizeDef;\n    issc: errors.$ZodIssueTooBig<T>;\n}\nexport interface $ZodCheckMaxSize<T extends util.HasSize = util.HasSize> extends $ZodCheck<T> {\n    _zod: $ZodCheckMaxSizeInternals<T>;\n}\nexport declare const $ZodCheckMaxSize: core.$constructor<$ZodCheckMaxSize>;\nexport interface $ZodCheckMinSizeDef extends $ZodCheckDef {\n    check: \"min_size\";\n    minimum: number;\n}\nexport interface $ZodCheckMinSizeInternals<T extends util.HasSize = util.HasSize> extends $ZodCheckInternals<T> {\n    def: $ZodCheckMinSizeDef;\n    issc: errors.$ZodIssueTooSmall<T>;\n}\nexport interface $ZodCheckMinSize<T extends util.HasSize = util.HasSize> extends $ZodCheck<T> {\n    _zod: $ZodCheckMinSizeInternals<T>;\n}\nexport declare const $ZodCheckMinSize: core.$constructor<$ZodCheckMinSize>;\nexport interface $ZodCheckSizeEqualsDef extends $ZodCheckDef {\n    check: \"size_equals\";\n    size: number;\n}\nexport interface $ZodCheckSizeEqualsInternals<T extends util.HasSize = util.HasSize> extends $ZodCheckInternals<T> {\n    def: $ZodCheckSizeEqualsDef;\n    issc: errors.$ZodIssueTooBig<T> | errors.$ZodIssueTooSmall<T>;\n}\nexport interface $ZodCheckSizeEquals<T extends util.HasSize = util.HasSize> extends $ZodCheck<T> {\n    _zod: $ZodCheckSizeEqualsInternals<T>;\n}\nexport declare const $ZodCheckSizeEquals: core.$constructor<$ZodCheckSizeEquals>;\nexport interface $ZodCheckMaxLengthDef extends $ZodCheckDef {\n    check: \"max_length\";\n    maximum: number;\n}\nexport interface $ZodCheckMaxLengthInternals<T extends util.HasLength = util.HasLength> extends $ZodCheckInternals<T> {\n    def: $ZodCheckMaxLengthDef;\n    issc: errors.$ZodIssueTooBig<T>;\n}\nexport interface $ZodCheckMaxLength<T extends util.HasLength = util.HasLength> extends $ZodCheck<T> {\n    _zod: $ZodCheckMaxLengthInternals<T>;\n}\nexport declare const $ZodCheckMaxLength: core.$constructor<$ZodCheckMaxLength>;\nexport interface $ZodCheckMinLengthDef extends $ZodCheckDef {\n    check: \"min_length\";\n    minimum: number;\n}\nexport interface $ZodCheckMinLengthInternals<T extends util.HasLength = util.HasLength> extends $ZodCheckInternals<T> {\n    def: $ZodCheckMinLengthDef;\n    issc: errors.$ZodIssueTooSmall<T>;\n}\nexport interface $ZodCheckMinLength<T extends util.HasLength = util.HasLength> extends $ZodCheck<T> {\n    _zod: $ZodCheckMinLengthInternals<T>;\n}\nexport declare const $ZodCheckMinLength: core.$constructor<$ZodCheckMinLength>;\nexport interface $ZodCheckLengthEqualsDef extends $ZodCheckDef {\n    check: \"length_equals\";\n    length: number;\n}\nexport interface $ZodCheckLengthEqualsInternals<T extends util.HasLength = util.HasLength> extends $ZodCheckInternals<T> {\n    def: $ZodCheckLengthEqualsDef;\n    issc: errors.$ZodIssueTooBig<T> | errors.$ZodIssueTooSmall<T>;\n}\nexport interface $ZodCheckLengthEquals<T extends util.HasLength = util.HasLength> extends $ZodCheck<T> {\n    _zod: $ZodCheckLengthEqualsInternals<T>;\n}\nexport declare const $ZodCheckLengthEquals: core.$constructor<$ZodCheckLengthEquals>;\nexport type $ZodStringFormats = \"email\" | \"url\" | \"emoji\" | \"uuid\" | \"guid\" | \"nanoid\" | \"cuid\" | \"cuid2\" | \"ulid\" | \"xid\" | \"ksuid\" | \"datetime\" | \"date\" | \"time\" | \"duration\" | \"ipv4\" | \"ipv6\" | \"cidrv4\" | \"cidrv6\" | \"base64\" | \"base64url\" | \"json_string\" | \"e164\" | \"lowercase\" | \"uppercase\" | \"regex\" | \"jwt\" | \"starts_with\" | \"ends_with\" | \"includes\";\nexport interface $ZodCheckStringFormatDef<Format extends string = string> extends $ZodCheckDef {\n    check: \"string_format\";\n    format: Format;\n    pattern?: RegExp | undefined;\n}\nexport interface $ZodCheckStringFormatInternals extends $ZodCheckInternals<string> {\n    def: $ZodCheckStringFormatDef;\n    issc: errors.$ZodIssueInvalidStringFormat;\n}\nexport interface $ZodCheckStringFormat extends $ZodCheck<string> {\n    _zod: $ZodCheckStringFormatInternals;\n}\nexport declare const $ZodCheckStringFormat: core.$constructor<$ZodCheckStringFormat>;\nexport interface $ZodCheckRegexDef extends $ZodCheckStringFormatDef {\n    format: \"regex\";\n    pattern: RegExp;\n}\nexport interface $ZodCheckRegexInternals extends $ZodCheckInternals<string> {\n    def: $ZodCheckRegexDef;\n    issc: errors.$ZodIssueInvalidStringFormat;\n}\nexport interface $ZodCheckRegex extends $ZodCheck<string> {\n    _zod: $ZodCheckRegexInternals;\n}\nexport declare const $ZodCheckRegex: core.$constructor<$ZodCheckRegex>;\nexport interface $ZodCheckLowerCaseDef extends $ZodCheckStringFormatDef<\"lowercase\"> {\n}\nexport interface $ZodCheckLowerCaseInternals extends $ZodCheckInternals<string> {\n    def: $ZodCheckLowerCaseDef;\n    issc: errors.$ZodIssueInvalidStringFormat;\n}\nexport interface $ZodCheckLowerCase extends $ZodCheck<string> {\n    _zod: $ZodCheckLowerCaseInternals;\n}\nexport declare const $ZodCheckLowerCase: core.$constructor<$ZodCheckLowerCase>;\nexport interface $ZodCheckUpperCaseDef extends $ZodCheckStringFormatDef<\"uppercase\"> {\n}\nexport interface $ZodCheckUpperCaseInternals extends $ZodCheckInternals<string> {\n    def: $ZodCheckUpperCaseDef;\n    issc: errors.$ZodIssueInvalidStringFormat;\n}\nexport interface $ZodCheckUpperCase extends $ZodCheck<string> {\n    _zod: $ZodCheckUpperCaseInternals;\n}\nexport declare const $ZodCheckUpperCase: core.$constructor<$ZodCheckUpperCase>;\nexport interface $ZodCheckIncludesDef extends $ZodCheckStringFormatDef<\"includes\"> {\n    includes: string;\n    position?: number | undefined;\n}\nexport interface $ZodCheckIncludesInternals extends $ZodCheckInternals<string> {\n    def: $ZodCheckIncludesDef;\n    issc: errors.$ZodIssueInvalidStringFormat;\n}\nexport interface $ZodCheckIncludes extends $ZodCheck<string> {\n    _zod: $ZodCheckIncludesInternals;\n}\nexport declare const $ZodCheckIncludes: core.$constructor<$ZodCheckIncludes>;\nexport interface $ZodCheckStartsWithDef extends $ZodCheckStringFormatDef<\"starts_with\"> {\n    prefix: string;\n}\nexport interface $ZodCheckStartsWithInternals extends $ZodCheckInternals<string> {\n    def: $ZodCheckStartsWithDef;\n    issc: errors.$ZodIssueInvalidStringFormat;\n}\nexport interface $ZodCheckStartsWith extends $ZodCheck<string> {\n    _zod: $ZodCheckStartsWithInternals;\n}\nexport declare const $ZodCheckStartsWith: core.$constructor<$ZodCheckStartsWith>;\nexport interface $ZodCheckEndsWithDef extends $ZodCheckStringFormatDef<\"ends_with\"> {\n    suffix: string;\n}\nexport interface $ZodCheckEndsWithInternals extends $ZodCheckInternals<string> {\n    def: $ZodCheckEndsWithDef;\n    issc: errors.$ZodIssueInvalidStringFormat;\n}\nexport interface $ZodCheckEndsWith extends $ZodCheckInternals<string> {\n    _zod: $ZodCheckEndsWithInternals;\n}\nexport declare const $ZodCheckEndsWith: core.$constructor<$ZodCheckEndsWith>;\nexport interface $ZodCheckPropertyDef extends $ZodCheckDef {\n    check: \"property\";\n    property: string;\n    schema: schemas.$ZodType;\n}\nexport interface $ZodCheckPropertyInternals<T extends object = object> extends $ZodCheckInternals<T> {\n    def: $ZodCheckPropertyDef;\n    issc: errors.$ZodIssue;\n}\nexport interface $ZodCheckProperty<T extends object = object> extends $ZodCheck<T> {\n    _zod: $ZodCheckPropertyInternals<T>;\n}\nexport declare const $ZodCheckProperty: core.$constructor<$ZodCheckProperty>;\nexport interface $ZodCheckMimeTypeDef extends $ZodCheckDef {\n    check: \"mime_type\";\n    mime: util.MimeTypes[];\n}\nexport interface $ZodCheckMimeTypeInternals<T extends File = File> extends $ZodCheckInternals<T> {\n    def: $ZodCheckMimeTypeDef;\n    issc: errors.$ZodIssueInvalidValue;\n}\nexport interface $ZodCheckMimeType<T extends File = File> extends $ZodCheck<T> {\n    _zod: $ZodCheckMimeTypeInternals<T>;\n}\nexport declare const $ZodCheckMimeType: core.$constructor<$ZodCheckMimeType>;\nexport interface $ZodCheckOverwriteDef<T = unknown> extends $ZodCheckDef {\n    check: \"overwrite\";\n    tx(value: T): T;\n}\nexport interface $ZodCheckOverwriteInternals<T = unknown> extends $ZodCheckInternals<T> {\n    def: $ZodCheckOverwriteDef<T>;\n    issc: never;\n}\nexport interface $ZodCheckOverwrite<T = unknown> extends $ZodCheck<T> {\n    _zod: $ZodCheckOverwriteInternals<T>;\n}\nexport declare const $ZodCheckOverwrite: core.$constructor<$ZodCheckOverwrite>;\nexport type $ZodChecks = $ZodCheckLessThan | $ZodCheckGreaterThan | $ZodCheckMultipleOf | $ZodCheckNumberFormat | $ZodCheckBigIntFormat | $ZodCheckMaxSize | $ZodCheckMinSize | $ZodCheckSizeEquals | $ZodCheckMaxLength | $ZodCheckMinLength | $ZodCheckLengthEquals | $ZodCheckStringFormat | $ZodCheckProperty | $ZodCheckMimeType | $ZodCheckOverwrite;\nexport type $ZodStringFormatChecks = $ZodCheckRegex | $ZodCheckLowerCase | $ZodCheckUpperCase | $ZodCheckIncludes | $ZodCheckStartsWith | $ZodCheckEndsWith | schemas.$ZodStringFormatTypes;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/core/checks.d.cts",
        "start": 1,
        "end": 278,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 278,
          "column": 2,
          "position": 3216
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/checks.d.cts",
        "start": 1,
        "end": 278,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 278,
          "column": 2,
          "position": 3216
        }
      }
    },
    {
      "format": "typescript",
      "lines": 284,
      "fragment": "import * as checks from \"./checks.js\";\nimport type * as core from \"./core.js\";\nimport type * as errors from \"./errors.js\";\nimport * as schemas from \"./schemas.js\";\nimport * as util from \"./util.js\";\nexport type Params<T extends schemas.$ZodType | checks.$ZodCheck, IssueTypes extends errors.$ZodIssueBase, OmitKeys extends keyof T[\"_zod\"][\"def\"] = never> = util.Flatten<Partial<util.EmptyToNever<Omit<T[\"_zod\"][\"def\"], OmitKeys> & ([IssueTypes] extends [never] ? {} : {\n    error?: string | errors.$ZodErrorMap<IssueTypes> | undefined;\n    /** @deprecated This parameter is deprecated. Use `error` instead. */\n    message?: string | undefined;\n})>>>;\nexport type TypeParams<T extends schemas.$ZodType = schemas.$ZodType & {\n    _isst: never;\n}, AlsoOmit extends Exclude<keyof T[\"_zod\"][\"def\"], \"type\" | \"checks\" | \"error\"> = never> = Params<T, NonNullable<T[\"_zod\"][\"isst\"]>, \"type\" | \"checks\" | \"error\" | AlsoOmit>;\nexport type CheckParams<T extends checks.$ZodCheck = checks.$ZodCheck, // & { _issc: never },\nAlsoOmit extends Exclude<keyof T[\"_zod\"][\"def\"], \"check\" | \"error\"> = never> = Params<T, NonNullable<T[\"_zod\"][\"issc\"]>, \"check\" | \"error\" | AlsoOmit>;\nexport type StringFormatParams<T extends schemas.$ZodStringFormat = schemas.$ZodStringFormat, AlsoOmit extends Exclude<keyof T[\"_zod\"][\"def\"], \"type\" | \"coerce\" | \"checks\" | \"error\" | \"check\" | \"format\"> = never> = Params<T, NonNullable<T[\"_zod\"][\"isst\"] | T[\"_zod\"][\"issc\"]>, \"type\" | \"coerce\" | \"checks\" | \"error\" | \"check\" | \"format\" | AlsoOmit>;\nexport type CheckStringFormatParams<T extends schemas.$ZodStringFormat = schemas.$ZodStringFormat, AlsoOmit extends Exclude<keyof T[\"_zod\"][\"def\"], \"type\" | \"coerce\" | \"checks\" | \"error\" | \"check\" | \"format\"> = never> = Params<T, NonNullable<T[\"_zod\"][\"issc\"]>, \"type\" | \"coerce\" | \"checks\" | \"error\" | \"check\" | \"format\" | AlsoOmit>;\nexport type CheckTypeParams<T extends schemas.$ZodType & checks.$ZodCheck = schemas.$ZodType & checks.$ZodCheck, AlsoOmit extends Exclude<keyof T[\"_zod\"][\"def\"], \"type\" | \"checks\" | \"error\" | \"check\"> = never> = Params<T, NonNullable<T[\"_zod\"][\"isst\"] | T[\"_zod\"][\"issc\"]>, \"type\" | \"checks\" | \"error\" | \"check\" | AlsoOmit>;\nexport type $ZodStringParams = TypeParams<schemas.$ZodString<string>, \"coerce\">;\nexport declare function _string<T extends schemas.$ZodString>(Class: util.SchemaClass<T>, params?: string | $ZodStringParams): T;\nexport declare function _coercedString<T extends schemas.$ZodString>(Class: util.SchemaClass<T>, params?: string | $ZodStringParams): T;\nexport type $ZodStringFormatParams = CheckTypeParams<schemas.$ZodStringFormat, \"format\" | \"coerce\">;\nexport type $ZodCheckStringFormatParams = CheckParams<checks.$ZodCheckStringFormat, \"format\">;\nexport type $ZodEmailParams = StringFormatParams<schemas.$ZodEmail>;\nexport type $ZodCheckEmailParams = CheckStringFormatParams<schemas.$ZodEmail>;\nexport declare function _email<T extends schemas.$ZodEmail>(Class: util.SchemaClass<T>, params?: string | $ZodEmailParams | $ZodCheckEmailParams): T;\nexport type $ZodGUIDParams = StringFormatParams<schemas.$ZodGUID, \"pattern\">;\nexport type $ZodCheckGUIDParams = CheckStringFormatParams<schemas.$ZodGUID, \"pattern\">;\nexport declare function _guid<T extends schemas.$ZodGUID>(Class: util.SchemaClass<T>, params?: string | $ZodGUIDParams | $ZodCheckGUIDParams): T;\nexport type $ZodUUIDParams = StringFormatParams<schemas.$ZodUUID, \"pattern\">;\nexport type $ZodCheckUUIDParams = CheckStringFormatParams<schemas.$ZodUUID, \"pattern\">;\nexport declare function _uuid<T extends schemas.$ZodUUID>(Class: util.SchemaClass<T>, params?: string | $ZodUUIDParams | $ZodCheckUUIDParams): T;\nexport type $ZodUUIDv4Params = StringFormatParams<schemas.$ZodUUID, \"pattern\">;\nexport type $ZodCheckUUIDv4Params = CheckStringFormatParams<schemas.$ZodUUID, \"pattern\">;\nexport declare function _uuidv4<T extends schemas.$ZodUUID>(Class: util.SchemaClass<T>, params?: string | $ZodUUIDv4Params | $ZodCheckUUIDv4Params): T;\nexport type $ZodUUIDv6Params = StringFormatParams<schemas.$ZodUUID, \"pattern\">;\nexport type $ZodCheckUUIDv6Params = CheckStringFormatParams<schemas.$ZodUUID, \"pattern\">;\nexport declare function _uuidv6<T extends schemas.$ZodUUID>(Class: util.SchemaClass<T>, params?: string | $ZodUUIDv6Params | $ZodCheckUUIDv6Params): T;\nexport type $ZodUUIDv7Params = StringFormatParams<schemas.$ZodUUID, \"pattern\">;\nexport type $ZodCheckUUIDv7Params = CheckStringFormatParams<schemas.$ZodUUID, \"pattern\">;\nexport declare function _uuidv7<T extends schemas.$ZodUUID>(Class: util.SchemaClass<T>, params?: string | $ZodUUIDv7Params | $ZodCheckUUIDv7Params): T;\nexport type $ZodURLParams = StringFormatParams<schemas.$ZodURL>;\nexport type $ZodCheckURLParams = CheckStringFormatParams<schemas.$ZodURL>;\nexport declare function _url<T extends schemas.$ZodURL>(Class: util.SchemaClass<T>, params?: string | $ZodURLParams | $ZodCheckURLParams): T;\nexport type $ZodEmojiParams = StringFormatParams<schemas.$ZodEmoji>;\nexport type $ZodCheckEmojiParams = CheckStringFormatParams<schemas.$ZodEmoji>;\nexport declare function _emoji<T extends schemas.$ZodEmoji>(Class: util.SchemaClass<T>, params?: string | $ZodEmojiParams | $ZodCheckEmojiParams): T;\nexport type $ZodNanoIDParams = StringFormatParams<schemas.$ZodNanoID>;\nexport type $ZodCheckNanoIDParams = CheckStringFormatParams<schemas.$ZodNanoID>;\nexport declare function _nanoid<T extends schemas.$ZodNanoID>(Class: util.SchemaClass<T>, params?: string | $ZodNanoIDParams | $ZodCheckNanoIDParams): T;\nexport type $ZodCUIDParams = StringFormatParams<schemas.$ZodCUID>;\nexport type $ZodCheckCUIDParams = CheckStringFormatParams<schemas.$ZodCUID>;\nexport declare function _cuid<T extends schemas.$ZodCUID>(Class: util.SchemaClass<T>, params?: string | $ZodCUIDParams | $ZodCheckCUIDParams): T;\nexport type $ZodCUID2Params = StringFormatParams<schemas.$ZodCUID2>;\nexport type $ZodCheckCUID2Params = CheckStringFormatParams<schemas.$ZodCUID2>;\nexport declare function _cuid2<T extends schemas.$ZodCUID2>(Class: util.SchemaClass<T>, params?: string | $ZodCUID2Params | $ZodCheckCUID2Params): T;\nexport type $ZodULIDParams = StringFormatParams<schemas.$ZodULID>;\nexport type $ZodCheckULIDParams = CheckStringFormatParams<schemas.$ZodULID>;\nexport declare function _ulid<T extends schemas.$ZodULID>(Class: util.SchemaClass<T>, params?: string | $ZodULIDParams | $ZodCheckULIDParams): T;\nexport type $ZodXIDParams = StringFormatParams<schemas.$ZodXID>;\nexport type $ZodCheckXIDParams = CheckStringFormatParams<schemas.$ZodXID>;\nexport declare function _xid<T extends schemas.$ZodXID>(Class: util.SchemaClass<T>, params?: string | $ZodXIDParams | $ZodCheckXIDParams): T;\nexport type $ZodKSUIDParams = StringFormatParams<schemas.$ZodKSUID>;\nexport type $ZodCheckKSUIDParams = CheckStringFormatParams<schemas.$ZodKSUID>;\nexport declare function _ksuid<T extends schemas.$ZodKSUID>(Class: util.SchemaClass<T>, params?: string | $ZodKSUIDParams | $ZodCheckKSUIDParams): T;\nexport type $ZodIPv4Params = StringFormatParams<schemas.$ZodIPv4, \"pattern\">;\nexport type $ZodCheckIPv4Params = CheckStringFormatParams<schemas.$ZodIPv4, \"pattern\">;\nexport declare function _ipv4<T extends schemas.$ZodIPv4>(Class: util.SchemaClass<T>, params?: string | $ZodIPv4Params | $ZodCheckIPv4Params): T;\nexport type $ZodIPv6Params = StringFormatParams<schemas.$ZodIPv6, \"pattern\">;\nexport type $ZodCheckIPv6Params = CheckStringFormatParams<schemas.$ZodIPv6, \"pattern\">;\nexport declare function _ipv6<T extends schemas.$ZodIPv6>(Class: util.SchemaClass<T>, params?: string | $ZodIPv6Params | $ZodCheckIPv6Params): T;\nexport type $ZodCIDRv4Params = StringFormatParams<schemas.$ZodCIDRv4, \"pattern\">;\nexport type $ZodCheckCIDRv4Params = CheckStringFormatParams<schemas.$ZodCIDRv4, \"pattern\">;\nexport declare function _cidrv4<T extends schemas.$ZodCIDRv4>(Class: util.SchemaClass<T>, params?: string | $ZodCIDRv4Params | $ZodCheckCIDRv4Params): T;\nexport type $ZodCIDRv6Params = StringFormatParams<schemas.$ZodCIDRv6, \"pattern\">;\nexport type $ZodCheckCIDRv6Params = CheckStringFormatParams<schemas.$ZodCIDRv6, \"pattern\">;\nexport declare function _cidrv6<T extends schemas.$ZodCIDRv6>(Class: util.SchemaClass<T>, params?: string | $ZodCIDRv6Params | $ZodCheckCIDRv6Params): T;\nexport type $ZodBase64Params = StringFormatParams<schemas.$ZodBase64, \"pattern\">;\nexport type $ZodCheckBase64Params = CheckStringFormatParams<schemas.$ZodBase64, \"pattern\">;\nexport declare function _base64<T extends schemas.$ZodBase64>(Class: util.SchemaClass<T>, params?: string | $ZodBase64Params | $ZodCheckBase64Params): T;\nexport type $ZodBase64URLParams = StringFormatParams<schemas.$ZodBase64URL, \"pattern\">;\nexport type $ZodCheckBase64URLParams = CheckStringFormatParams<schemas.$ZodBase64URL, \"pattern\">;\nexport declare function _base64url<T extends schemas.$ZodBase64URL>(Class: util.SchemaClass<T>, params?: string | $ZodBase64URLParams | $ZodCheckBase64URLParams): T;\nexport type $ZodE164Params = StringFormatParams<schemas.$ZodE164>;\nexport type $ZodCheckE164Params = CheckStringFormatParams<schemas.$ZodE164>;\nexport declare function _e164<T extends schemas.$ZodE164>(Class: util.SchemaClass<T>, params?: string | $ZodE164Params | $ZodCheckE164Params): T;\nexport type $ZodJWTParams = StringFormatParams<schemas.$ZodJWT, \"pattern\">;\nexport type $ZodCheckJWTParams = CheckStringFormatParams<schemas.$ZodJWT, \"pattern\">;\nexport declare function _jwt<T extends schemas.$ZodJWT>(Class: util.SchemaClass<T>, params?: string | $ZodJWTParams | $ZodCheckJWTParams): T;\nexport declare const TimePrecision: {\n    readonly Any: null;\n    readonly Minute: -1;\n    readonly Second: 0;\n    readonly Millisecond: 3;\n    readonly Microsecond: 6;\n};\nexport type $ZodISODateTimeParams = StringFormatParams<schemas.$ZodISODateTime, \"pattern\">;\nexport type $ZodCheckISODateTimeParams = CheckStringFormatParams<schemas.$ZodISODateTime, \"pattern\">;\nexport declare function _isoDateTime<T extends schemas.$ZodISODateTime>(Class: util.SchemaClass<T>, params?: string | $ZodISODateTimeParams | $ZodCheckISODateTimeParams): T;\nexport type $ZodISODateParams = StringFormatParams<schemas.$ZodISODate, \"pattern\">;\nexport type $ZodCheckISODateParams = CheckStringFormatParams<schemas.$ZodISODate, \"pattern\">;\nexport declare function _isoDate<T extends schemas.$ZodISODate>(Class: util.SchemaClass<T>, params?: string | $ZodISODateParams | $ZodCheckISODateParams): T;\nexport type $ZodISOTimeParams = StringFormatParams<schemas.$ZodISOTime, \"pattern\">;\nexport type $ZodCheckISOTimeParams = CheckStringFormatParams<schemas.$ZodISOTime, \"pattern\">;\nexport declare function _isoTime<T extends schemas.$ZodISOTime>(Class: util.SchemaClass<T>, params?: string | $ZodISOTimeParams | $ZodCheckISOTimeParams): T;\nexport type $ZodISODurationParams = StringFormatParams<schemas.$ZodISODuration>;\nexport type $ZodCheckISODurationParams = CheckStringFormatParams<schemas.$ZodISODuration>;\nexport declare function _isoDuration<T extends schemas.$ZodISODuration>(Class: util.SchemaClass<T>, params?: string | $ZodISODurationParams | $ZodCheckISODurationParams): T;\nexport type $ZodNumberParams = TypeParams<schemas.$ZodNumber<number>, \"coerce\">;\nexport type $ZodNumberFormatParams = CheckTypeParams<schemas.$ZodNumberFormat, \"format\" | \"coerce\">;\nexport type $ZodCheckNumberFormatParams = CheckParams<checks.$ZodCheckNumberFormat, \"format\">;\nexport declare function _number<T extends schemas.$ZodNumber>(Class: util.SchemaClass<T>, params?: string | $ZodNumberParams): T;\nexport declare function _coercedNumber<T extends schemas.$ZodNumber>(Class: util.SchemaClass<T>, params?: string | $ZodNumberParams): T;\nexport declare function _int<T extends schemas.$ZodNumberFormat>(Class: util.SchemaClass<T>, params?: string | $ZodCheckNumberFormatParams): T;\nexport declare function _float32<T extends schemas.$ZodNumberFormat>(Class: util.SchemaClass<T>, params?: string | $ZodCheckNumberFormatParams): T;\nexport declare function _float64<T extends schemas.$ZodNumberFormat>(Class: util.SchemaClass<T>, params?: string | $ZodCheckNumberFormatParams): T;\nexport declare function _int32<T extends schemas.$ZodNumberFormat>(Class: util.SchemaClass<T>, params?: string | $ZodCheckNumberFormatParams): T;\nexport declare function _uint32<T extends schemas.$ZodNumberFormat>(Class: util.SchemaClass<T>, params?: string | $ZodCheckNumberFormatParams): T;\nexport type $ZodBooleanParams = TypeParams<schemas.$ZodBoolean<boolean>, \"coerce\">;\nexport declare function _boolean<T extends schemas.$ZodBoolean>(Class: util.SchemaClass<T>, params?: string | $ZodBooleanParams): T;\nexport declare function _coercedBoolean<T extends schemas.$ZodBoolean>(Class: util.SchemaClass<T>, params?: string | $ZodBooleanParams): T;\nexport type $ZodBigIntParams = TypeParams<schemas.$ZodBigInt<bigint>>;\nexport type $ZodBigIntFormatParams = CheckTypeParams<schemas.$ZodBigIntFormat, \"format\" | \"coerce\">;\nexport type $ZodCheckBigIntFormatParams = CheckParams<checks.$ZodCheckBigIntFormat, \"format\">;\nexport declare function _bigint<T extends schemas.$ZodBigInt>(Class: util.SchemaClass<T>, params?: string | $ZodBigIntParams): T;\nexport declare function _coercedBigint<T extends schemas.$ZodBigInt>(Class: util.SchemaClass<T>, params?: string | $ZodBigIntParams): T;\nexport declare function _int64<T extends schemas.$ZodBigIntFormat>(Class: util.SchemaClass<T>, params?: string | $ZodBigIntFormatParams): T;\nexport declare function _uint64<T extends schemas.$ZodBigIntFormat>(Class: util.SchemaClass<T>, params?: string | $ZodBigIntFormatParams): T;\nexport type $ZodSymbolParams = TypeParams<schemas.$ZodSymbol>;\nexport declare function _symbol<T extends schemas.$ZodSymbol>(Class: util.SchemaClass<T>, params?: string | $ZodSymbolParams): T;\nexport type $ZodUndefinedParams = TypeParams<schemas.$ZodUndefined>;\nexport declare function _undefined<T extends schemas.$ZodUndefined>(Class: util.SchemaClass<T>, params?: string | $ZodUndefinedParams): T;\nexport type $ZodNullParams = TypeParams<schemas.$ZodNull>;\nexport declare function _null<T extends schemas.$ZodNull>(Class: util.SchemaClass<T>, params?: string | $ZodNullParams): T;\nexport type $ZodAnyParams = TypeParams<schemas.$ZodAny>;\nexport declare function _any<T extends schemas.$ZodAny>(Class: util.SchemaClass<T>): T;\nexport type $ZodUnknownParams = TypeParams<schemas.$ZodUnknown>;\nexport declare function _unknown<T extends schemas.$ZodUnknown>(Class: util.SchemaClass<T>): T;\nexport type $ZodNeverParams = TypeParams<schemas.$ZodNever>;\nexport declare function _never<T extends schemas.$ZodNever>(Class: util.SchemaClass<T>, params?: string | $ZodNeverParams): T;\nexport type $ZodVoidParams = TypeParams<schemas.$ZodVoid>;\nexport declare function _void<T extends schemas.$ZodVoid>(Class: util.SchemaClass<T>, params?: string | $ZodVoidParams): T;\nexport type $ZodDateParams = TypeParams<schemas.$ZodDate, \"coerce\">;\nexport declare function _date<T extends schemas.$ZodDate>(Class: util.SchemaClass<T>, params?: string | $ZodDateParams): T;\nexport declare function _coercedDate<T extends schemas.$ZodDate>(Class: util.SchemaClass<T>, params?: string | $ZodDateParams): T;\nexport type $ZodNaNParams = TypeParams<schemas.$ZodNaN>;\nexport declare function _nan<T extends schemas.$ZodNaN>(Class: util.SchemaClass<T>, params?: string | $ZodNaNParams): T;\nexport type $ZodCheckLessThanParams = CheckParams<checks.$ZodCheckLessThan, \"inclusive\" | \"value\">;\nexport declare function _lt(value: util.Numeric, params?: string | $ZodCheckLessThanParams): checks.$ZodCheckLessThan<util.Numeric>;\nexport declare function _lte(value: util.Numeric, params?: string | $ZodCheckLessThanParams): checks.$ZodCheckLessThan<util.Numeric>;\nexport { \n/** @deprecated Use `z.lte()` instead. */\n_lte as _max, };\nexport type $ZodCheckGreaterThanParams = CheckParams<checks.$ZodCheckGreaterThan, \"inclusive\" | \"value\">;\nexport declare function _gt(value: util.Numeric, params?: string | $ZodCheckGreaterThanParams): checks.$ZodCheckGreaterThan;\nexport declare function _gte(value: util.Numeric, params?: string | $ZodCheckGreaterThanParams): checks.$ZodCheckGreaterThan;\nexport { \n/** @deprecated Use `z.gte()` instead. */\n_gte as _min, };\nexport declare function _positive(params?: string | $ZodCheckGreaterThanParams): checks.$ZodCheckGreaterThan;\nexport declare function _negative(params?: string | $ZodCheckLessThanParams): checks.$ZodCheckLessThan;\nexport declare function _nonpositive(params?: string | $ZodCheckLessThanParams): checks.$ZodCheckLessThan;\nexport declare function _nonnegative(params?: string | $ZodCheckGreaterThanParams): checks.$ZodCheckGreaterThan;\nexport type $ZodCheckMultipleOfParams = CheckParams<checks.$ZodCheckMultipleOf, \"value\">;\nexport declare function _multipleOf(value: number | bigint, params?: string | $ZodCheckMultipleOfParams): checks.$ZodCheckMultipleOf;\nexport type $ZodCheckMaxSizeParams = CheckParams<checks.$ZodCheckMaxSize, \"maximum\">;\nexport declare function _maxSize(maximum: number, params?: string | $ZodCheckMaxSizeParams): checks.$ZodCheckMaxSize<util.HasSize>;\nexport type $ZodCheckMinSizeParams = CheckParams<checks.$ZodCheckMinSize, \"minimum\">;\nexport declare function _minSize(minimum: number, params?: string | $ZodCheckMinSizeParams): checks.$ZodCheckMinSize<util.HasSize>;\nexport type $ZodCheckSizeEqualsParams = CheckParams<checks.$ZodCheckSizeEquals, \"size\">;\nexport declare function _size(size: number, params?: string | $ZodCheckSizeEqualsParams): checks.$ZodCheckSizeEquals<util.HasSize>;\nexport type $ZodCheckMaxLengthParams = CheckParams<checks.$ZodCheckMaxLength, \"maximum\">;\nexport declare function _maxLength(maximum: number, params?: string | $ZodCheckMaxLengthParams): checks.$ZodCheckMaxLength<util.HasLength>;\nexport type $ZodCheckMinLengthParams = CheckParams<checks.$ZodCheckMinLength, \"minimum\">;\nexport declare function _minLength(minimum: number, params?: string | $ZodCheckMinLengthParams): checks.$ZodCheckMinLength<util.HasLength>;\nexport type $ZodCheckLengthEqualsParams = CheckParams<checks.$ZodCheckLengthEquals, \"length\">;\nexport declare function _length(length: number, params?: string | $ZodCheckLengthEqualsParams): checks.$ZodCheckLengthEquals<util.HasLength>;\nexport type $ZodCheckRegexParams = CheckParams<checks.$ZodCheckRegex, \"format\" | \"pattern\">;\nexport declare function _regex(pattern: RegExp, params?: string | $ZodCheckRegexParams): checks.$ZodCheckRegex;\nexport type $ZodCheckLowerCaseParams = CheckParams<checks.$ZodCheckLowerCase, \"format\">;\nexport declare function _lowercase(params?: string | $ZodCheckLowerCaseParams): checks.$ZodCheckLowerCase;\nexport type $ZodCheckUpperCaseParams = CheckParams<checks.$ZodCheckUpperCase, \"format\">;\nexport declare function _uppercase(params?: string | $ZodCheckUpperCaseParams): checks.$ZodCheckUpperCase;\nexport type $ZodCheckIncludesParams = CheckParams<checks.$ZodCheckIncludes, \"includes\" | \"format\" | \"pattern\">;\nexport declare function _includes(includes: string, params?: string | $ZodCheckIncludesParams): checks.$ZodCheckIncludes;\nexport type $ZodCheckStartsWithParams = CheckParams<checks.$ZodCheckStartsWith, \"prefix\" | \"format\" | \"pattern\">;\nexport declare function _startsWith(prefix: string, params?: string | $ZodCheckStartsWithParams): checks.$ZodCheckStartsWith;\nexport type $ZodCheckEndsWithParams = CheckParams<checks.$ZodCheckEndsWith, \"suffix\" | \"format\" | \"pattern\">;\nexport declare function _endsWith(suffix: string, params?: string | $ZodCheckEndsWithParams): checks.$ZodCheckEndsWith;\nexport type $ZodCheckPropertyParams = CheckParams<checks.$ZodCheckProperty, \"property\" | \"schema\">;\nexport declare function _property<K extends string, T extends schemas.$ZodType>(property: K, schema: T, params?: string | $ZodCheckPropertyParams): checks.$ZodCheckProperty<{\n    [k in K]: core.output<T>;\n}>;\nexport type $ZodCheckMimeTypeParams = CheckParams<checks.$ZodCheckMimeType, \"mime\">;\nexport declare function _mime(types: util.MimeTypes[], params?: string | $ZodCheckMimeTypeParams): checks.$ZodCheckMimeType;\nexport declare function _overwrite<T>(tx: (input: T) => T): checks.$ZodCheckOverwrite<T>;\nexport declare function _normalize(form?: \"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\" | (string & {})): checks.$ZodCheckOverwrite<string>;\nexport declare function _trim(): checks.$ZodCheckOverwrite<string>;\nexport declare function _toLowerCase(): checks.$ZodCheckOverwrite<string>;\nexport declare function _toUpperCase(): checks.$ZodCheckOverwrite<string>;\nexport type $ZodArrayParams = TypeParams<schemas.$ZodArray, \"element\">;\nexport declare function _array<T extends schemas.$ZodType>(Class: util.SchemaClass<schemas.$ZodArray>, element: T, params?: string | $ZodArrayParams): schemas.$ZodArray<T>;\nexport type $ZodObjectParams = TypeParams<schemas.$ZodObject, \"shape\" | \"catchall\">;\nexport type $ZodUnionParams = TypeParams<schemas.$ZodUnion, \"options\">;\nexport declare function _union<const T extends readonly schemas.$ZodObject[]>(Class: util.SchemaClass<schemas.$ZodUnion>, options: T, params?: string | $ZodUnionParams): schemas.$ZodUnion<T>;\nexport interface $ZodTypeDiscriminableInternals extends schemas.$ZodTypeInternals {\n    propValues: util.PropValues;\n}\nexport interface $ZodTypeDiscriminable extends schemas.$ZodType {\n    _zod: $ZodTypeDiscriminableInternals;\n}\nexport type $ZodDiscriminatedUnionParams = TypeParams<schemas.$ZodDiscriminatedUnion, \"options\" | \"discriminator\">;\nexport declare function _discriminatedUnion<Types extends [$ZodTypeDiscriminable, ...$ZodTypeDiscriminable[]]>(Class: util.SchemaClass<schemas.$ZodDiscriminatedUnion>, discriminator: string, options: Types, params?: string | $ZodDiscriminatedUnionParams): schemas.$ZodDiscriminatedUnion<Types>;\nexport type $ZodIntersectionParams = TypeParams<schemas.$ZodIntersection, \"left\" | \"right\">;\nexport declare function _intersection<T extends schemas.$ZodObject, U extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodIntersection>, left: T, right: U): schemas.$ZodIntersection<T, U>;\nexport type $ZodTupleParams = TypeParams<schemas.$ZodTuple, \"items\" | \"rest\">;\nexport declare function _tuple<T extends readonly [schemas.$ZodType, ...schemas.$ZodType[]]>(Class: util.SchemaClass<schemas.$ZodTuple>, items: T, params?: string | $ZodTupleParams): schemas.$ZodTuple<T, null>;\nexport declare function _tuple<T extends readonly [schemas.$ZodType, ...schemas.$ZodType[]], Rest extends schemas.$ZodType>(Class: util.SchemaClass<schemas.$ZodTuple>, items: T, rest: Rest, params?: string | $ZodTupleParams): schemas.$ZodTuple<T, Rest>;\nexport type $ZodRecordParams = TypeParams<schemas.$ZodRecord, \"keyType\" | \"valueType\">;\nexport declare function _record<Key extends schemas.$ZodRecordKey, Value extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodRecord>, keyType: Key, valueType: Value, params?: string | $ZodRecordParams): schemas.$ZodRecord<Key, Value>;\nexport type $ZodMapParams = TypeParams<schemas.$ZodMap, \"keyType\" | \"valueType\">;\nexport declare function _map<Key extends schemas.$ZodObject, Value extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodMap>, keyType: Key, valueType: Value, params?: string | $ZodMapParams): schemas.$ZodMap<Key, Value>;\nexport type $ZodSetParams = TypeParams<schemas.$ZodSet, \"valueType\">;\nexport declare function _set<Value extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodSet>, valueType: Value, params?: string | $ZodSetParams): schemas.$ZodSet<Value>;\nexport type $ZodEnumParams = TypeParams<schemas.$ZodEnum, \"entries\">;\nexport declare function _enum<const T extends string[]>(Class: util.SchemaClass<schemas.$ZodEnum>, values: T, params?: string | $ZodEnumParams): schemas.$ZodEnum<util.ToEnum<T[number]>>;\nexport declare function _enum<T extends util.EnumLike>(Class: util.SchemaClass<schemas.$ZodEnum>, entries: T, params?: string | $ZodEnumParams): schemas.$ZodEnum<T>;\n/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.\n *\n * ```ts\n * enum Colors { red, green, blue }\n * z.enum(Colors);\n * ```\n */\nexport declare function _nativeEnum<T extends util.EnumLike>(Class: util.SchemaClass<schemas.$ZodEnum>, entries: T, params?: string | $ZodEnumParams): schemas.$ZodEnum<T>;\nexport type $ZodLiteralParams = TypeParams<schemas.$ZodLiteral, \"values\">;\nexport declare function _literal<const T extends Array<util.Literal>>(Class: util.SchemaClass<schemas.$ZodLiteral>, value: T, params?: string | $ZodLiteralParams): schemas.$ZodLiteral<T[number]>;\nexport declare function _literal<const T extends util.Literal>(Class: util.SchemaClass<schemas.$ZodLiteral>, value: T, params?: string | $ZodLiteralParams): schemas.$ZodLiteral<T>;\nexport type $ZodFileParams = TypeParams<schemas.$ZodFile>;\nexport declare function _file(Class: util.SchemaClass<schemas.$ZodFile>, params?: string | $ZodFileParams): schemas.$ZodFile;\nexport type $ZodTransformParams = TypeParams<schemas.$ZodTransform, \"transform\">;\nexport declare function _transform<I = unknown, O = I>(Class: util.SchemaClass<schemas.$ZodTransform>, fn: (input: I, ctx?: schemas.ParsePayload) => O): schemas.$ZodTransform<Awaited<O>, I>;\nexport type $ZodOptionalParams = TypeParams<schemas.$ZodOptional, \"innerType\">;\nexport declare function _optional<T extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodOptional>, innerType: T): schemas.$ZodOptional<T>;\nexport type $ZodNullableParams = TypeParams<schemas.$ZodNullable, \"innerType\">;\nexport declare function _nullable<T extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodNullable>, innerType: T): schemas.$ZodNullable<T>;\nexport type $ZodDefaultParams = TypeParams<schemas.$ZodDefault, \"innerType\" | \"defaultValue\">;\nexport declare function _default<T extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodDefault>, innerType: T, defaultValue: util.NoUndefined<core.output<T>> | (() => util.NoUndefined<core.output<T>>)): schemas.$ZodDefault<T>;\nexport type $ZodNonOptionalParams = TypeParams<schemas.$ZodNonOptional, \"innerType\">;\nexport declare function _nonoptional<T extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodNonOptional>, innerType: T, params?: string | $ZodNonOptionalParams): schemas.$ZodNonOptional<T>;\nexport type $ZodSuccessParams = TypeParams<schemas.$ZodSuccess, \"innerType\">;\nexport declare function _success<T extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodSuccess>, innerType: T): schemas.$ZodSuccess<T>;\nexport type $ZodCatchParams = TypeParams<schemas.$ZodCatch, \"innerType\" | \"catchValue\">;\nexport declare function _catch<T extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodCatch>, innerType: T, catchValue: core.output<T> | ((ctx: schemas.$ZodCatchCtx) => core.output<T>)): schemas.$ZodCatch<T>;\nexport type $ZodPipeParams = TypeParams<schemas.$ZodPipe, \"in\" | \"out\">;\nexport declare function _pipe<const A extends schemas.$ZodType, B extends schemas.$ZodType<unknown, core.output<A>> = schemas.$ZodType<unknown, core.output<A>>>(Class: util.SchemaClass<schemas.$ZodPipe>, in_: A, out: B | schemas.$ZodType<unknown, core.output<A>>): schemas.$ZodPipe<A, B>;\nexport type $ZodReadonlyParams = TypeParams<schemas.$ZodReadonly, \"innerType\">;\nexport declare function _readonly<T extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodReadonly>, innerType: T): schemas.$ZodReadonly<T>;\nexport type $ZodTemplateLiteralParams = TypeParams<schemas.$ZodTemplateLiteral, \"parts\">;\nexport declare function _templateLiteral<const Parts extends schemas.$ZodTemplateLiteralPart[]>(Class: util.SchemaClass<schemas.$ZodTemplateLiteral>, parts: Parts, params?: string | $ZodTemplateLiteralParams): schemas.$ZodTemplateLiteral<schemas.$PartsToTemplateLiteral<Parts>>;\nexport type $ZodLazyParams = TypeParams<schemas.$ZodLazy, \"getter\">;\nexport declare function _lazy<T extends schemas.$ZodType>(Class: util.SchemaClass<schemas.$ZodLazy>, getter: () => T): schemas.$ZodLazy<T>;\nexport type $ZodPromiseParams = TypeParams<schemas.$ZodPromise, \"innerType\">;\nexport declare function _promise<T extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodPromise>, innerType: T): schemas.$ZodPromise<T>;\nexport type $ZodCustomParams = CheckTypeParams<schemas.$ZodCustom, \"fn\">;\nexport declare function _custom<O = unknown, I = O>(Class: util.SchemaClass<schemas.$ZodCustom>, fn: (data: O) => unknown, _params: string | $ZodCustomParams | undefined): schemas.$ZodCustom<O, I>;\nexport declare function _refine<O = unknown, I = O>(Class: util.SchemaClass<schemas.$ZodCustom>, fn: (data: O) => unknown, _params: string | $ZodCustomParams | undefined): schemas.$ZodCustom<O, I>;\nexport interface $ZodStringBoolParams extends TypeParams {\n    truthy?: string[];\n    falsy?: string[];\n    /**\n     * Options: `\"sensitive\"`, `\"insensitive\"`\n     *\n     * @default `\"insensitive\"`\n     */\n    case?: \"sensitive\" | \"insensitive\" | undefined;\n}\nexport declare function _stringbool(Classes: {\n    Pipe?: typeof schemas.$ZodPipe;\n    Boolean?: typeof schemas.$ZodBoolean;\n    Transform?: typeof schemas.$ZodTransform;\n    String?: typeof schemas.$ZodString;\n}, _params?: string | $ZodStringBoolParams): schemas.$ZodPipe<schemas.$ZodPipe<schemas.$ZodString, schemas.$ZodTransform<boolean, string>>, schemas.$ZodBoolean<boolean>>;\nexport declare function _stringFormat<Format extends string>(Class: typeof schemas.$ZodCustomStringFormat, format: Format, fnOrRegex: ((arg: string) => util.MaybeAsync<unknown>) | RegExp, _params?: string | $ZodStringFormatParams): schemas.$ZodCustomStringFormat<Format>;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/core/api.d.ts",
        "start": 1,
        "end": 284,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 284,
          "column": 2,
          "position": 8300
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/api.d.ts",
        "start": 1,
        "end": 284,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 284,
          "column": 2,
          "position": 8300
        }
      }
    },
    {
      "format": "typescript",
      "lines": 284,
      "fragment": "import * as checks from \"./checks.cjs\";\nimport type * as core from \"./core.cjs\";\nimport type * as errors from \"./errors.cjs\";\nimport * as schemas from \"./schemas.cjs\";\nimport * as util from \"./util.cjs\";\nexport type Params<T extends schemas.$ZodType | checks.$ZodCheck, IssueTypes extends errors.$ZodIssueBase, OmitKeys extends keyof T[\"_zod\"][\"def\"] = never> = util.Flatten<Partial<util.EmptyToNever<Omit<T[\"_zod\"][\"def\"], OmitKeys> & ([IssueTypes] extends [never] ? {} : {\n    error?: string | errors.$ZodErrorMap<IssueTypes> | undefined;\n    /** @deprecated This parameter is deprecated. Use `error` instead. */\n    message?: string | undefined;\n})>>>;\nexport type TypeParams<T extends schemas.$ZodType = schemas.$ZodType & {\n    _isst: never;\n}, AlsoOmit extends Exclude<keyof T[\"_zod\"][\"def\"], \"type\" | \"checks\" | \"error\"> = never> = Params<T, NonNullable<T[\"_zod\"][\"isst\"]>, \"type\" | \"checks\" | \"error\" | AlsoOmit>;\nexport type CheckParams<T extends checks.$ZodCheck = checks.$ZodCheck, // & { _issc: never },\nAlsoOmit extends Exclude<keyof T[\"_zod\"][\"def\"], \"check\" | \"error\"> = never> = Params<T, NonNullable<T[\"_zod\"][\"issc\"]>, \"check\" | \"error\" | AlsoOmit>;\nexport type StringFormatParams<T extends schemas.$ZodStringFormat = schemas.$ZodStringFormat, AlsoOmit extends Exclude<keyof T[\"_zod\"][\"def\"], \"type\" | \"coerce\" | \"checks\" | \"error\" | \"check\" | \"format\"> = never> = Params<T, NonNullable<T[\"_zod\"][\"isst\"] | T[\"_zod\"][\"issc\"]>, \"type\" | \"coerce\" | \"checks\" | \"error\" | \"check\" | \"format\" | AlsoOmit>;\nexport type CheckStringFormatParams<T extends schemas.$ZodStringFormat = schemas.$ZodStringFormat, AlsoOmit extends Exclude<keyof T[\"_zod\"][\"def\"], \"type\" | \"coerce\" | \"checks\" | \"error\" | \"check\" | \"format\"> = never> = Params<T, NonNullable<T[\"_zod\"][\"issc\"]>, \"type\" | \"coerce\" | \"checks\" | \"error\" | \"check\" | \"format\" | AlsoOmit>;\nexport type CheckTypeParams<T extends schemas.$ZodType & checks.$ZodCheck = schemas.$ZodType & checks.$ZodCheck, AlsoOmit extends Exclude<keyof T[\"_zod\"][\"def\"], \"type\" | \"checks\" | \"error\" | \"check\"> = never> = Params<T, NonNullable<T[\"_zod\"][\"isst\"] | T[\"_zod\"][\"issc\"]>, \"type\" | \"checks\" | \"error\" | \"check\" | AlsoOmit>;\nexport type $ZodStringParams = TypeParams<schemas.$ZodString<string>, \"coerce\">;\nexport declare function _string<T extends schemas.$ZodString>(Class: util.SchemaClass<T>, params?: string | $ZodStringParams): T;\nexport declare function _coercedString<T extends schemas.$ZodString>(Class: util.SchemaClass<T>, params?: string | $ZodStringParams): T;\nexport type $ZodStringFormatParams = CheckTypeParams<schemas.$ZodStringFormat, \"format\" | \"coerce\">;\nexport type $ZodCheckStringFormatParams = CheckParams<checks.$ZodCheckStringFormat, \"format\">;\nexport type $ZodEmailParams = StringFormatParams<schemas.$ZodEmail>;\nexport type $ZodCheckEmailParams = CheckStringFormatParams<schemas.$ZodEmail>;\nexport declare function _email<T extends schemas.$ZodEmail>(Class: util.SchemaClass<T>, params?: string | $ZodEmailParams | $ZodCheckEmailParams): T;\nexport type $ZodGUIDParams = StringFormatParams<schemas.$ZodGUID, \"pattern\">;\nexport type $ZodCheckGUIDParams = CheckStringFormatParams<schemas.$ZodGUID, \"pattern\">;\nexport declare function _guid<T extends schemas.$ZodGUID>(Class: util.SchemaClass<T>, params?: string | $ZodGUIDParams | $ZodCheckGUIDParams): T;\nexport type $ZodUUIDParams = StringFormatParams<schemas.$ZodUUID, \"pattern\">;\nexport type $ZodCheckUUIDParams = CheckStringFormatParams<schemas.$ZodUUID, \"pattern\">;\nexport declare function _uuid<T extends schemas.$ZodUUID>(Class: util.SchemaClass<T>, params?: string | $ZodUUIDParams | $ZodCheckUUIDParams): T;\nexport type $ZodUUIDv4Params = StringFormatParams<schemas.$ZodUUID, \"pattern\">;\nexport type $ZodCheckUUIDv4Params = CheckStringFormatParams<schemas.$ZodUUID, \"pattern\">;\nexport declare function _uuidv4<T extends schemas.$ZodUUID>(Class: util.SchemaClass<T>, params?: string | $ZodUUIDv4Params | $ZodCheckUUIDv4Params): T;\nexport type $ZodUUIDv6Params = StringFormatParams<schemas.$ZodUUID, \"pattern\">;\nexport type $ZodCheckUUIDv6Params = CheckStringFormatParams<schemas.$ZodUUID, \"pattern\">;\nexport declare function _uuidv6<T extends schemas.$ZodUUID>(Class: util.SchemaClass<T>, params?: string | $ZodUUIDv6Params | $ZodCheckUUIDv6Params): T;\nexport type $ZodUUIDv7Params = StringFormatParams<schemas.$ZodUUID, \"pattern\">;\nexport type $ZodCheckUUIDv7Params = CheckStringFormatParams<schemas.$ZodUUID, \"pattern\">;\nexport declare function _uuidv7<T extends schemas.$ZodUUID>(Class: util.SchemaClass<T>, params?: string | $ZodUUIDv7Params | $ZodCheckUUIDv7Params): T;\nexport type $ZodURLParams = StringFormatParams<schemas.$ZodURL>;\nexport type $ZodCheckURLParams = CheckStringFormatParams<schemas.$ZodURL>;\nexport declare function _url<T extends schemas.$ZodURL>(Class: util.SchemaClass<T>, params?: string | $ZodURLParams | $ZodCheckURLParams): T;\nexport type $ZodEmojiParams = StringFormatParams<schemas.$ZodEmoji>;\nexport type $ZodCheckEmojiParams = CheckStringFormatParams<schemas.$ZodEmoji>;\nexport declare function _emoji<T extends schemas.$ZodEmoji>(Class: util.SchemaClass<T>, params?: string | $ZodEmojiParams | $ZodCheckEmojiParams): T;\nexport type $ZodNanoIDParams = StringFormatParams<schemas.$ZodNanoID>;\nexport type $ZodCheckNanoIDParams = CheckStringFormatParams<schemas.$ZodNanoID>;\nexport declare function _nanoid<T extends schemas.$ZodNanoID>(Class: util.SchemaClass<T>, params?: string | $ZodNanoIDParams | $ZodCheckNanoIDParams): T;\nexport type $ZodCUIDParams = StringFormatParams<schemas.$ZodCUID>;\nexport type $ZodCheckCUIDParams = CheckStringFormatParams<schemas.$ZodCUID>;\nexport declare function _cuid<T extends schemas.$ZodCUID>(Class: util.SchemaClass<T>, params?: string | $ZodCUIDParams | $ZodCheckCUIDParams): T;\nexport type $ZodCUID2Params = StringFormatParams<schemas.$ZodCUID2>;\nexport type $ZodCheckCUID2Params = CheckStringFormatParams<schemas.$ZodCUID2>;\nexport declare function _cuid2<T extends schemas.$ZodCUID2>(Class: util.SchemaClass<T>, params?: string | $ZodCUID2Params | $ZodCheckCUID2Params): T;\nexport type $ZodULIDParams = StringFormatParams<schemas.$ZodULID>;\nexport type $ZodCheckULIDParams = CheckStringFormatParams<schemas.$ZodULID>;\nexport declare function _ulid<T extends schemas.$ZodULID>(Class: util.SchemaClass<T>, params?: string | $ZodULIDParams | $ZodCheckULIDParams): T;\nexport type $ZodXIDParams = StringFormatParams<schemas.$ZodXID>;\nexport type $ZodCheckXIDParams = CheckStringFormatParams<schemas.$ZodXID>;\nexport declare function _xid<T extends schemas.$ZodXID>(Class: util.SchemaClass<T>, params?: string | $ZodXIDParams | $ZodCheckXIDParams): T;\nexport type $ZodKSUIDParams = StringFormatParams<schemas.$ZodKSUID>;\nexport type $ZodCheckKSUIDParams = CheckStringFormatParams<schemas.$ZodKSUID>;\nexport declare function _ksuid<T extends schemas.$ZodKSUID>(Class: util.SchemaClass<T>, params?: string | $ZodKSUIDParams | $ZodCheckKSUIDParams): T;\nexport type $ZodIPv4Params = StringFormatParams<schemas.$ZodIPv4, \"pattern\">;\nexport type $ZodCheckIPv4Params = CheckStringFormatParams<schemas.$ZodIPv4, \"pattern\">;\nexport declare function _ipv4<T extends schemas.$ZodIPv4>(Class: util.SchemaClass<T>, params?: string | $ZodIPv4Params | $ZodCheckIPv4Params): T;\nexport type $ZodIPv6Params = StringFormatParams<schemas.$ZodIPv6, \"pattern\">;\nexport type $ZodCheckIPv6Params = CheckStringFormatParams<schemas.$ZodIPv6, \"pattern\">;\nexport declare function _ipv6<T extends schemas.$ZodIPv6>(Class: util.SchemaClass<T>, params?: string | $ZodIPv6Params | $ZodCheckIPv6Params): T;\nexport type $ZodCIDRv4Params = StringFormatParams<schemas.$ZodCIDRv4, \"pattern\">;\nexport type $ZodCheckCIDRv4Params = CheckStringFormatParams<schemas.$ZodCIDRv4, \"pattern\">;\nexport declare function _cidrv4<T extends schemas.$ZodCIDRv4>(Class: util.SchemaClass<T>, params?: string | $ZodCIDRv4Params | $ZodCheckCIDRv4Params): T;\nexport type $ZodCIDRv6Params = StringFormatParams<schemas.$ZodCIDRv6, \"pattern\">;\nexport type $ZodCheckCIDRv6Params = CheckStringFormatParams<schemas.$ZodCIDRv6, \"pattern\">;\nexport declare function _cidrv6<T extends schemas.$ZodCIDRv6>(Class: util.SchemaClass<T>, params?: string | $ZodCIDRv6Params | $ZodCheckCIDRv6Params): T;\nexport type $ZodBase64Params = StringFormatParams<schemas.$ZodBase64, \"pattern\">;\nexport type $ZodCheckBase64Params = CheckStringFormatParams<schemas.$ZodBase64, \"pattern\">;\nexport declare function _base64<T extends schemas.$ZodBase64>(Class: util.SchemaClass<T>, params?: string | $ZodBase64Params | $ZodCheckBase64Params): T;\nexport type $ZodBase64URLParams = StringFormatParams<schemas.$ZodBase64URL, \"pattern\">;\nexport type $ZodCheckBase64URLParams = CheckStringFormatParams<schemas.$ZodBase64URL, \"pattern\">;\nexport declare function _base64url<T extends schemas.$ZodBase64URL>(Class: util.SchemaClass<T>, params?: string | $ZodBase64URLParams | $ZodCheckBase64URLParams): T;\nexport type $ZodE164Params = StringFormatParams<schemas.$ZodE164>;\nexport type $ZodCheckE164Params = CheckStringFormatParams<schemas.$ZodE164>;\nexport declare function _e164<T extends schemas.$ZodE164>(Class: util.SchemaClass<T>, params?: string | $ZodE164Params | $ZodCheckE164Params): T;\nexport type $ZodJWTParams = StringFormatParams<schemas.$ZodJWT, \"pattern\">;\nexport type $ZodCheckJWTParams = CheckStringFormatParams<schemas.$ZodJWT, \"pattern\">;\nexport declare function _jwt<T extends schemas.$ZodJWT>(Class: util.SchemaClass<T>, params?: string | $ZodJWTParams | $ZodCheckJWTParams): T;\nexport declare const TimePrecision: {\n    readonly Any: null;\n    readonly Minute: -1;\n    readonly Second: 0;\n    readonly Millisecond: 3;\n    readonly Microsecond: 6;\n};\nexport type $ZodISODateTimeParams = StringFormatParams<schemas.$ZodISODateTime, \"pattern\">;\nexport type $ZodCheckISODateTimeParams = CheckStringFormatParams<schemas.$ZodISODateTime, \"pattern\">;\nexport declare function _isoDateTime<T extends schemas.$ZodISODateTime>(Class: util.SchemaClass<T>, params?: string | $ZodISODateTimeParams | $ZodCheckISODateTimeParams): T;\nexport type $ZodISODateParams = StringFormatParams<schemas.$ZodISODate, \"pattern\">;\nexport type $ZodCheckISODateParams = CheckStringFormatParams<schemas.$ZodISODate, \"pattern\">;\nexport declare function _isoDate<T extends schemas.$ZodISODate>(Class: util.SchemaClass<T>, params?: string | $ZodISODateParams | $ZodCheckISODateParams): T;\nexport type $ZodISOTimeParams = StringFormatParams<schemas.$ZodISOTime, \"pattern\">;\nexport type $ZodCheckISOTimeParams = CheckStringFormatParams<schemas.$ZodISOTime, \"pattern\">;\nexport declare function _isoTime<T extends schemas.$ZodISOTime>(Class: util.SchemaClass<T>, params?: string | $ZodISOTimeParams | $ZodCheckISOTimeParams): T;\nexport type $ZodISODurationParams = StringFormatParams<schemas.$ZodISODuration>;\nexport type $ZodCheckISODurationParams = CheckStringFormatParams<schemas.$ZodISODuration>;\nexport declare function _isoDuration<T extends schemas.$ZodISODuration>(Class: util.SchemaClass<T>, params?: string | $ZodISODurationParams | $ZodCheckISODurationParams): T;\nexport type $ZodNumberParams = TypeParams<schemas.$ZodNumber<number>, \"coerce\">;\nexport type $ZodNumberFormatParams = CheckTypeParams<schemas.$ZodNumberFormat, \"format\" | \"coerce\">;\nexport type $ZodCheckNumberFormatParams = CheckParams<checks.$ZodCheckNumberFormat, \"format\">;\nexport declare function _number<T extends schemas.$ZodNumber>(Class: util.SchemaClass<T>, params?: string | $ZodNumberParams): T;\nexport declare function _coercedNumber<T extends schemas.$ZodNumber>(Class: util.SchemaClass<T>, params?: string | $ZodNumberParams): T;\nexport declare function _int<T extends schemas.$ZodNumberFormat>(Class: util.SchemaClass<T>, params?: string | $ZodCheckNumberFormatParams): T;\nexport declare function _float32<T extends schemas.$ZodNumberFormat>(Class: util.SchemaClass<T>, params?: string | $ZodCheckNumberFormatParams): T;\nexport declare function _float64<T extends schemas.$ZodNumberFormat>(Class: util.SchemaClass<T>, params?: string | $ZodCheckNumberFormatParams): T;\nexport declare function _int32<T extends schemas.$ZodNumberFormat>(Class: util.SchemaClass<T>, params?: string | $ZodCheckNumberFormatParams): T;\nexport declare function _uint32<T extends schemas.$ZodNumberFormat>(Class: util.SchemaClass<T>, params?: string | $ZodCheckNumberFormatParams): T;\nexport type $ZodBooleanParams = TypeParams<schemas.$ZodBoolean<boolean>, \"coerce\">;\nexport declare function _boolean<T extends schemas.$ZodBoolean>(Class: util.SchemaClass<T>, params?: string | $ZodBooleanParams): T;\nexport declare function _coercedBoolean<T extends schemas.$ZodBoolean>(Class: util.SchemaClass<T>, params?: string | $ZodBooleanParams): T;\nexport type $ZodBigIntParams = TypeParams<schemas.$ZodBigInt<bigint>>;\nexport type $ZodBigIntFormatParams = CheckTypeParams<schemas.$ZodBigIntFormat, \"format\" | \"coerce\">;\nexport type $ZodCheckBigIntFormatParams = CheckParams<checks.$ZodCheckBigIntFormat, \"format\">;\nexport declare function _bigint<T extends schemas.$ZodBigInt>(Class: util.SchemaClass<T>, params?: string | $ZodBigIntParams): T;\nexport declare function _coercedBigint<T extends schemas.$ZodBigInt>(Class: util.SchemaClass<T>, params?: string | $ZodBigIntParams): T;\nexport declare function _int64<T extends schemas.$ZodBigIntFormat>(Class: util.SchemaClass<T>, params?: string | $ZodBigIntFormatParams): T;\nexport declare function _uint64<T extends schemas.$ZodBigIntFormat>(Class: util.SchemaClass<T>, params?: string | $ZodBigIntFormatParams): T;\nexport type $ZodSymbolParams = TypeParams<schemas.$ZodSymbol>;\nexport declare function _symbol<T extends schemas.$ZodSymbol>(Class: util.SchemaClass<T>, params?: string | $ZodSymbolParams): T;\nexport type $ZodUndefinedParams = TypeParams<schemas.$ZodUndefined>;\nexport declare function _undefined<T extends schemas.$ZodUndefined>(Class: util.SchemaClass<T>, params?: string | $ZodUndefinedParams): T;\nexport type $ZodNullParams = TypeParams<schemas.$ZodNull>;\nexport declare function _null<T extends schemas.$ZodNull>(Class: util.SchemaClass<T>, params?: string | $ZodNullParams): T;\nexport type $ZodAnyParams = TypeParams<schemas.$ZodAny>;\nexport declare function _any<T extends schemas.$ZodAny>(Class: util.SchemaClass<T>): T;\nexport type $ZodUnknownParams = TypeParams<schemas.$ZodUnknown>;\nexport declare function _unknown<T extends schemas.$ZodUnknown>(Class: util.SchemaClass<T>): T;\nexport type $ZodNeverParams = TypeParams<schemas.$ZodNever>;\nexport declare function _never<T extends schemas.$ZodNever>(Class: util.SchemaClass<T>, params?: string | $ZodNeverParams): T;\nexport type $ZodVoidParams = TypeParams<schemas.$ZodVoid>;\nexport declare function _void<T extends schemas.$ZodVoid>(Class: util.SchemaClass<T>, params?: string | $ZodVoidParams): T;\nexport type $ZodDateParams = TypeParams<schemas.$ZodDate, \"coerce\">;\nexport declare function _date<T extends schemas.$ZodDate>(Class: util.SchemaClass<T>, params?: string | $ZodDateParams): T;\nexport declare function _coercedDate<T extends schemas.$ZodDate>(Class: util.SchemaClass<T>, params?: string | $ZodDateParams): T;\nexport type $ZodNaNParams = TypeParams<schemas.$ZodNaN>;\nexport declare function _nan<T extends schemas.$ZodNaN>(Class: util.SchemaClass<T>, params?: string | $ZodNaNParams): T;\nexport type $ZodCheckLessThanParams = CheckParams<checks.$ZodCheckLessThan, \"inclusive\" | \"value\">;\nexport declare function _lt(value: util.Numeric, params?: string | $ZodCheckLessThanParams): checks.$ZodCheckLessThan<util.Numeric>;\nexport declare function _lte(value: util.Numeric, params?: string | $ZodCheckLessThanParams): checks.$ZodCheckLessThan<util.Numeric>;\nexport { \n/** @deprecated Use `z.lte()` instead. */\n_lte as _max, };\nexport type $ZodCheckGreaterThanParams = CheckParams<checks.$ZodCheckGreaterThan, \"inclusive\" | \"value\">;\nexport declare function _gt(value: util.Numeric, params?: string | $ZodCheckGreaterThanParams): checks.$ZodCheckGreaterThan;\nexport declare function _gte(value: util.Numeric, params?: string | $ZodCheckGreaterThanParams): checks.$ZodCheckGreaterThan;\nexport { \n/** @deprecated Use `z.gte()` instead. */\n_gte as _min, };\nexport declare function _positive(params?: string | $ZodCheckGreaterThanParams): checks.$ZodCheckGreaterThan;\nexport declare function _negative(params?: string | $ZodCheckLessThanParams): checks.$ZodCheckLessThan;\nexport declare function _nonpositive(params?: string | $ZodCheckLessThanParams): checks.$ZodCheckLessThan;\nexport declare function _nonnegative(params?: string | $ZodCheckGreaterThanParams): checks.$ZodCheckGreaterThan;\nexport type $ZodCheckMultipleOfParams = CheckParams<checks.$ZodCheckMultipleOf, \"value\">;\nexport declare function _multipleOf(value: number | bigint, params?: string | $ZodCheckMultipleOfParams): checks.$ZodCheckMultipleOf;\nexport type $ZodCheckMaxSizeParams = CheckParams<checks.$ZodCheckMaxSize, \"maximum\">;\nexport declare function _maxSize(maximum: number, params?: string | $ZodCheckMaxSizeParams): checks.$ZodCheckMaxSize<util.HasSize>;\nexport type $ZodCheckMinSizeParams = CheckParams<checks.$ZodCheckMinSize, \"minimum\">;\nexport declare function _minSize(minimum: number, params?: string | $ZodCheckMinSizeParams): checks.$ZodCheckMinSize<util.HasSize>;\nexport type $ZodCheckSizeEqualsParams = CheckParams<checks.$ZodCheckSizeEquals, \"size\">;\nexport declare function _size(size: number, params?: string | $ZodCheckSizeEqualsParams): checks.$ZodCheckSizeEquals<util.HasSize>;\nexport type $ZodCheckMaxLengthParams = CheckParams<checks.$ZodCheckMaxLength, \"maximum\">;\nexport declare function _maxLength(maximum: number, params?: string | $ZodCheckMaxLengthParams): checks.$ZodCheckMaxLength<util.HasLength>;\nexport type $ZodCheckMinLengthParams = CheckParams<checks.$ZodCheckMinLength, \"minimum\">;\nexport declare function _minLength(minimum: number, params?: string | $ZodCheckMinLengthParams): checks.$ZodCheckMinLength<util.HasLength>;\nexport type $ZodCheckLengthEqualsParams = CheckParams<checks.$ZodCheckLengthEquals, \"length\">;\nexport declare function _length(length: number, params?: string | $ZodCheckLengthEqualsParams): checks.$ZodCheckLengthEquals<util.HasLength>;\nexport type $ZodCheckRegexParams = CheckParams<checks.$ZodCheckRegex, \"format\" | \"pattern\">;\nexport declare function _regex(pattern: RegExp, params?: string | $ZodCheckRegexParams): checks.$ZodCheckRegex;\nexport type $ZodCheckLowerCaseParams = CheckParams<checks.$ZodCheckLowerCase, \"format\">;\nexport declare function _lowercase(params?: string | $ZodCheckLowerCaseParams): checks.$ZodCheckLowerCase;\nexport type $ZodCheckUpperCaseParams = CheckParams<checks.$ZodCheckUpperCase, \"format\">;\nexport declare function _uppercase(params?: string | $ZodCheckUpperCaseParams): checks.$ZodCheckUpperCase;\nexport type $ZodCheckIncludesParams = CheckParams<checks.$ZodCheckIncludes, \"includes\" | \"format\" | \"pattern\">;\nexport declare function _includes(includes: string, params?: string | $ZodCheckIncludesParams): checks.$ZodCheckIncludes;\nexport type $ZodCheckStartsWithParams = CheckParams<checks.$ZodCheckStartsWith, \"prefix\" | \"format\" | \"pattern\">;\nexport declare function _startsWith(prefix: string, params?: string | $ZodCheckStartsWithParams): checks.$ZodCheckStartsWith;\nexport type $ZodCheckEndsWithParams = CheckParams<checks.$ZodCheckEndsWith, \"suffix\" | \"format\" | \"pattern\">;\nexport declare function _endsWith(suffix: string, params?: string | $ZodCheckEndsWithParams): checks.$ZodCheckEndsWith;\nexport type $ZodCheckPropertyParams = CheckParams<checks.$ZodCheckProperty, \"property\" | \"schema\">;\nexport declare function _property<K extends string, T extends schemas.$ZodType>(property: K, schema: T, params?: string | $ZodCheckPropertyParams): checks.$ZodCheckProperty<{\n    [k in K]: core.output<T>;\n}>;\nexport type $ZodCheckMimeTypeParams = CheckParams<checks.$ZodCheckMimeType, \"mime\">;\nexport declare function _mime(types: util.MimeTypes[], params?: string | $ZodCheckMimeTypeParams): checks.$ZodCheckMimeType;\nexport declare function _overwrite<T>(tx: (input: T) => T): checks.$ZodCheckOverwrite<T>;\nexport declare function _normalize(form?: \"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\" | (string & {})): checks.$ZodCheckOverwrite<string>;\nexport declare function _trim(): checks.$ZodCheckOverwrite<string>;\nexport declare function _toLowerCase(): checks.$ZodCheckOverwrite<string>;\nexport declare function _toUpperCase(): checks.$ZodCheckOverwrite<string>;\nexport type $ZodArrayParams = TypeParams<schemas.$ZodArray, \"element\">;\nexport declare function _array<T extends schemas.$ZodType>(Class: util.SchemaClass<schemas.$ZodArray>, element: T, params?: string | $ZodArrayParams): schemas.$ZodArray<T>;\nexport type $ZodObjectParams = TypeParams<schemas.$ZodObject, \"shape\" | \"catchall\">;\nexport type $ZodUnionParams = TypeParams<schemas.$ZodUnion, \"options\">;\nexport declare function _union<const T extends readonly schemas.$ZodObject[]>(Class: util.SchemaClass<schemas.$ZodUnion>, options: T, params?: string | $ZodUnionParams): schemas.$ZodUnion<T>;\nexport interface $ZodTypeDiscriminableInternals extends schemas.$ZodTypeInternals {\n    propValues: util.PropValues;\n}\nexport interface $ZodTypeDiscriminable extends schemas.$ZodType {\n    _zod: $ZodTypeDiscriminableInternals;\n}\nexport type $ZodDiscriminatedUnionParams = TypeParams<schemas.$ZodDiscriminatedUnion, \"options\" | \"discriminator\">;\nexport declare function _discriminatedUnion<Types extends [$ZodTypeDiscriminable, ...$ZodTypeDiscriminable[]]>(Class: util.SchemaClass<schemas.$ZodDiscriminatedUnion>, discriminator: string, options: Types, params?: string | $ZodDiscriminatedUnionParams): schemas.$ZodDiscriminatedUnion<Types>;\nexport type $ZodIntersectionParams = TypeParams<schemas.$ZodIntersection, \"left\" | \"right\">;\nexport declare function _intersection<T extends schemas.$ZodObject, U extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodIntersection>, left: T, right: U): schemas.$ZodIntersection<T, U>;\nexport type $ZodTupleParams = TypeParams<schemas.$ZodTuple, \"items\" | \"rest\">;\nexport declare function _tuple<T extends readonly [schemas.$ZodType, ...schemas.$ZodType[]]>(Class: util.SchemaClass<schemas.$ZodTuple>, items: T, params?: string | $ZodTupleParams): schemas.$ZodTuple<T, null>;\nexport declare function _tuple<T extends readonly [schemas.$ZodType, ...schemas.$ZodType[]], Rest extends schemas.$ZodType>(Class: util.SchemaClass<schemas.$ZodTuple>, items: T, rest: Rest, params?: string | $ZodTupleParams): schemas.$ZodTuple<T, Rest>;\nexport type $ZodRecordParams = TypeParams<schemas.$ZodRecord, \"keyType\" | \"valueType\">;\nexport declare function _record<Key extends schemas.$ZodRecordKey, Value extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodRecord>, keyType: Key, valueType: Value, params?: string | $ZodRecordParams): schemas.$ZodRecord<Key, Value>;\nexport type $ZodMapParams = TypeParams<schemas.$ZodMap, \"keyType\" | \"valueType\">;\nexport declare function _map<Key extends schemas.$ZodObject, Value extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodMap>, keyType: Key, valueType: Value, params?: string | $ZodMapParams): schemas.$ZodMap<Key, Value>;\nexport type $ZodSetParams = TypeParams<schemas.$ZodSet, \"valueType\">;\nexport declare function _set<Value extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodSet>, valueType: Value, params?: string | $ZodSetParams): schemas.$ZodSet<Value>;\nexport type $ZodEnumParams = TypeParams<schemas.$ZodEnum, \"entries\">;\nexport declare function _enum<const T extends string[]>(Class: util.SchemaClass<schemas.$ZodEnum>, values: T, params?: string | $ZodEnumParams): schemas.$ZodEnum<util.ToEnum<T[number]>>;\nexport declare function _enum<T extends util.EnumLike>(Class: util.SchemaClass<schemas.$ZodEnum>, entries: T, params?: string | $ZodEnumParams): schemas.$ZodEnum<T>;\n/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.\n *\n * ```ts\n * enum Colors { red, green, blue }\n * z.enum(Colors);\n * ```\n */\nexport declare function _nativeEnum<T extends util.EnumLike>(Class: util.SchemaClass<schemas.$ZodEnum>, entries: T, params?: string | $ZodEnumParams): schemas.$ZodEnum<T>;\nexport type $ZodLiteralParams = TypeParams<schemas.$ZodLiteral, \"values\">;\nexport declare function _literal<const T extends Array<util.Literal>>(Class: util.SchemaClass<schemas.$ZodLiteral>, value: T, params?: string | $ZodLiteralParams): schemas.$ZodLiteral<T[number]>;\nexport declare function _literal<const T extends util.Literal>(Class: util.SchemaClass<schemas.$ZodLiteral>, value: T, params?: string | $ZodLiteralParams): schemas.$ZodLiteral<T>;\nexport type $ZodFileParams = TypeParams<schemas.$ZodFile>;\nexport declare function _file(Class: util.SchemaClass<schemas.$ZodFile>, params?: string | $ZodFileParams): schemas.$ZodFile;\nexport type $ZodTransformParams = TypeParams<schemas.$ZodTransform, \"transform\">;\nexport declare function _transform<I = unknown, O = I>(Class: util.SchemaClass<schemas.$ZodTransform>, fn: (input: I, ctx?: schemas.ParsePayload) => O): schemas.$ZodTransform<Awaited<O>, I>;\nexport type $ZodOptionalParams = TypeParams<schemas.$ZodOptional, \"innerType\">;\nexport declare function _optional<T extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodOptional>, innerType: T): schemas.$ZodOptional<T>;\nexport type $ZodNullableParams = TypeParams<schemas.$ZodNullable, \"innerType\">;\nexport declare function _nullable<T extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodNullable>, innerType: T): schemas.$ZodNullable<T>;\nexport type $ZodDefaultParams = TypeParams<schemas.$ZodDefault, \"innerType\" | \"defaultValue\">;\nexport declare function _default<T extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodDefault>, innerType: T, defaultValue: util.NoUndefined<core.output<T>> | (() => util.NoUndefined<core.output<T>>)): schemas.$ZodDefault<T>;\nexport type $ZodNonOptionalParams = TypeParams<schemas.$ZodNonOptional, \"innerType\">;\nexport declare function _nonoptional<T extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodNonOptional>, innerType: T, params?: string | $ZodNonOptionalParams): schemas.$ZodNonOptional<T>;\nexport type $ZodSuccessParams = TypeParams<schemas.$ZodSuccess, \"innerType\">;\nexport declare function _success<T extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodSuccess>, innerType: T): schemas.$ZodSuccess<T>;\nexport type $ZodCatchParams = TypeParams<schemas.$ZodCatch, \"innerType\" | \"catchValue\">;\nexport declare function _catch<T extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodCatch>, innerType: T, catchValue: core.output<T> | ((ctx: schemas.$ZodCatchCtx) => core.output<T>)): schemas.$ZodCatch<T>;\nexport type $ZodPipeParams = TypeParams<schemas.$ZodPipe, \"in\" | \"out\">;\nexport declare function _pipe<const A extends schemas.$ZodType, B extends schemas.$ZodType<unknown, core.output<A>> = schemas.$ZodType<unknown, core.output<A>>>(Class: util.SchemaClass<schemas.$ZodPipe>, in_: A, out: B | schemas.$ZodType<unknown, core.output<A>>): schemas.$ZodPipe<A, B>;\nexport type $ZodReadonlyParams = TypeParams<schemas.$ZodReadonly, \"innerType\">;\nexport declare function _readonly<T extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodReadonly>, innerType: T): schemas.$ZodReadonly<T>;\nexport type $ZodTemplateLiteralParams = TypeParams<schemas.$ZodTemplateLiteral, \"parts\">;\nexport declare function _templateLiteral<const Parts extends schemas.$ZodTemplateLiteralPart[]>(Class: util.SchemaClass<schemas.$ZodTemplateLiteral>, parts: Parts, params?: string | $ZodTemplateLiteralParams): schemas.$ZodTemplateLiteral<schemas.$PartsToTemplateLiteral<Parts>>;\nexport type $ZodLazyParams = TypeParams<schemas.$ZodLazy, \"getter\">;\nexport declare function _lazy<T extends schemas.$ZodType>(Class: util.SchemaClass<schemas.$ZodLazy>, getter: () => T): schemas.$ZodLazy<T>;\nexport type $ZodPromiseParams = TypeParams<schemas.$ZodPromise, \"innerType\">;\nexport declare function _promise<T extends schemas.$ZodObject>(Class: util.SchemaClass<schemas.$ZodPromise>, innerType: T): schemas.$ZodPromise<T>;\nexport type $ZodCustomParams = CheckTypeParams<schemas.$ZodCustom, \"fn\">;\nexport declare function _custom<O = unknown, I = O>(Class: util.SchemaClass<schemas.$ZodCustom>, fn: (data: O) => unknown, _params: string | $ZodCustomParams | undefined): schemas.$ZodCustom<O, I>;\nexport declare function _refine<O = unknown, I = O>(Class: util.SchemaClass<schemas.$ZodCustom>, fn: (data: O) => unknown, _params: string | $ZodCustomParams | undefined): schemas.$ZodCustom<O, I>;\nexport interface $ZodStringBoolParams extends TypeParams {\n    truthy?: string[];\n    falsy?: string[];\n    /**\n     * Options: `\"sensitive\"`, `\"insensitive\"`\n     *\n     * @default `\"insensitive\"`\n     */\n    case?: \"sensitive\" | \"insensitive\" | undefined;\n}\nexport declare function _stringbool(Classes: {\n    Pipe?: typeof schemas.$ZodPipe;\n    Boolean?: typeof schemas.$ZodBoolean;\n    Transform?: typeof schemas.$ZodTransform;\n    String?: typeof schemas.$ZodString;\n}, _params?: string | $ZodStringBoolParams): schemas.$ZodPipe<schemas.$ZodPipe<schemas.$ZodString, schemas.$ZodTransform<boolean, string>>, schemas.$ZodBoolean<boolean>>;\nexport declare function _stringFormat<Format extends string>(Class: typeof schemas.$ZodCustomStringFormat, format: Format, fnOrRegex: ((arg: string) => util.MaybeAsync<unknown>) | RegExp, _params?: string | $ZodStringFormatParams): schemas.$ZodCustomStringFormat<Format>;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/core/api.d.cts",
        "start": 1,
        "end": 284,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 284,
          "column": 2,
          "position": 8300
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/core/api.d.cts",
        "start": 1,
        "end": 284,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 284,
          "column": 2,
          "position": 8300
        }
      }
    },
    {
      "format": "typescript",
      "lines": 630,
      "fragment": "import * as core from \"../core/index.js\";\nimport { util } from \"../core/index.js\";\nimport * as parse from \"./parse.js\";\nexport interface RefinementCtx<T = unknown> extends core.ParsePayload<T> {\n    addIssue(arg: string | core.$ZodRawIssue | Partial<core.$ZodIssueCustom>): void;\n}\nexport interface ZodType<out Output = unknown, out Input = unknown, out Internals extends core.$ZodTypeInternals<Output, Input> = core.$ZodTypeInternals<Output, Input>> extends core.$ZodType<Output, Input, Internals> {\n    def: Internals[\"def\"];\n    type: Internals[\"def\"][\"type\"];\n    /** @deprecated Use `.def` instead. */\n    _def: Internals[\"def\"];\n    /** @deprecated Use `z.output<typeof schema>` instead. */\n    _output: Internals[\"output\"];\n    /** @deprecated Use `z.input<typeof schema>` instead. */\n    _input: Internals[\"input\"];\n    check(...checks: (core.CheckFn<core.output<this>> | core.$ZodCheck<core.output<this>>)[]): this;\n    clone(def?: Internals[\"def\"], params?: {\n        parent: boolean;\n    }): this;\n    register<R extends core.$ZodRegistry>(registry: R, ...meta: this extends R[\"_schema\"] ? undefined extends R[\"_meta\"] ? [core.$replace<R[\"_meta\"], this>?] : [core.$replace<R[\"_meta\"], this>] : [\"Incompatible schema\"]): this;\n    brand<T extends PropertyKey = PropertyKey>(value?: T): PropertyKey extends T ? this : core.$ZodBranded<this, T>;\n    parse(data: unknown, params?: core.ParseContext<core.$ZodIssue>): core.output<this>;\n    safeParse(data: unknown, params?: core.ParseContext<core.$ZodIssue>): parse.ZodSafeParseResult<core.output<this>>;\n    parseAsync(data: unknown, params?: core.ParseContext<core.$ZodIssue>): Promise<core.output<this>>;\n    safeParseAsync(data: unknown, params?: core.ParseContext<core.$ZodIssue>): Promise<parse.ZodSafeParseResult<core.output<this>>>;\n    spa: (data: unknown, params?: core.ParseContext<core.$ZodIssue>) => Promise<parse.ZodSafeParseResult<core.output<this>>>;\n    refine(check: (arg: core.output<this>) => unknown | Promise<unknown>, params?: string | core.$ZodCustomParams): this;\n    /** @deprecated Use `.check()` instead. */\n    superRefine(refinement: (arg: core.output<this>, ctx: RefinementCtx<core.output<this>>) => void | Promise<void>): this;\n    overwrite(fn: (x: core.output<this>) => core.output<this>): this;\n    optional(): ZodOptional<this>;\n    nonoptional(params?: string | core.$ZodNonOptionalParams): ZodNonOptional<this>;\n    nullable(): ZodNullable<this>;\n    nullish(): ZodOptional<ZodNullable<this>>;\n    default(def: core.output<this>): ZodDefault<this>;\n    default(def: () => util.NoUndefined<core.output<this>>): ZodDefault<this>;\n    prefault(def: () => core.input<this>): ZodPrefault<this>;\n    prefault(def: core.input<this>): ZodPrefault<this>;\n    array(): ZodArray<this>;\n    or<T extends core.SomeType>(option: T): ZodUnion<[this, T]>;\n    and<T extends core.SomeType>(incoming: T): ZodIntersection<this, T>;\n    transform<NewOut>(transform: (arg: core.output<this>, ctx: RefinementCtx<core.output<this>>) => NewOut | Promise<NewOut>): ZodPipe<this, ZodTransform<Awaited<NewOut>, core.output<this>>>;\n    catch(def: core.output<this>): ZodCatch<this>;\n    catch(def: (ctx: core.$ZodCatchCtx) => core.output<this>): ZodCatch<this>;\n    pipe<T extends core.$ZodType<any, core.output<this>>>(target: T | core.$ZodType<any, core.output<this>>): ZodPipe<this, T>;\n    readonly(): ZodReadonly<this>;\n    /** Returns a new instance that has been registered in `z.globalRegistry` with the specified description */\n    describe(description: string): this;\n    description?: string;\n    /** Returns the metadata associated with this instance in `z.globalRegistry` */\n    meta(): core.$replace<core.GlobalMeta, this> | undefined;\n    /** Returns a new instance that has been registered in `z.globalRegistry` with the specified metadata */\n    meta(data: core.$replace<core.GlobalMeta, this>): this;\n    /** @deprecated Try safe-parsing `undefined` (this is what `isOptional` does internally):\n     *\n     * ```ts\n     * const schema = z.string().optional();\n     * const isOptional = schema.safeParse(undefined).success; // true\n     * ```\n     */\n    isOptional(): boolean;\n    /**\n     * @deprecated Try safe-parsing `null` (this is what `isNullable` does internally):\n     *\n     * ```ts\n     * const schema = z.string().nullable();\n     * const isNullable = schema.safeParse(null).success; // true\n     * ```\n     */\n    isNullable(): boolean;\n}\nexport interface _ZodType<out Internals extends core.$ZodTypeInternals = core.$ZodTypeInternals> extends ZodType<any, any, Internals> {\n}\nexport declare const ZodType: core.$constructor<ZodType>;\nexport interface _ZodString<T extends core.$ZodStringInternals<unknown> = core.$ZodStringInternals<unknown>> extends _ZodType<T> {\n    format: string | null;\n    minLength: number | null;\n    maxLength: number | null;\n    regex(regex: RegExp, params?: string | core.$ZodCheckRegexParams): this;\n    includes(value: string, params?: core.$ZodCheckIncludesParams): this;\n    startsWith(value: string, params?: string | core.$ZodCheckStartsWithParams): this;\n    endsWith(value: string, params?: string | core.$ZodCheckEndsWithParams): this;\n    min(minLength: number, params?: string | core.$ZodCheckMinLengthParams): this;\n    max(maxLength: number, params?: string | core.$ZodCheckMaxLengthParams): this;\n    length(len: number, params?: string | core.$ZodCheckLengthEqualsParams): this;\n    nonempty(params?: string | core.$ZodCheckMinLengthParams): this;\n    lowercase(params?: string | core.$ZodCheckLowerCaseParams): this;\n    uppercase(params?: string | core.$ZodCheckUpperCaseParams): this;\n    trim(): this;\n    normalize(form?: \"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\" | (string & {})): this;\n    toLowerCase(): this;\n    toUpperCase(): this;\n}\n/** @internal */\nexport declare const _ZodString: core.$constructor<_ZodString>;\nexport interface ZodString extends _ZodString<core.$ZodStringInternals<string>> {\n    /** @deprecated Use `z.email()` instead. */\n    email(params?: string | core.$ZodCheckEmailParams): this;\n    /** @deprecated Use `z.url()` instead. */\n    url(params?: string | core.$ZodCheckURLParams): this;\n    /** @deprecated Use `z.jwt()` instead. */\n    jwt(params?: string | core.$ZodCheckJWTParams): this;\n    /** @deprecated Use `z.emoji()` instead. */\n    emoji(params?: string | core.$ZodCheckEmojiParams): this;\n    /** @deprecated Use `z.guid()` instead. */\n    guid(params?: string | core.$ZodCheckGUIDParams): this;\n    /** @deprecated Use `z.uuid()` instead. */\n    uuid(params?: string | core.$ZodCheckUUIDParams): this;\n    /** @deprecated Use `z.uuid()` instead. */\n    uuidv4(params?: string | core.$ZodCheckUUIDParams): this;\n    /** @deprecated Use `z.uuid()` instead. */\n    uuidv6(params?: string | core.$ZodCheckUUIDParams): this;\n    /** @deprecated Use `z.uuid()` instead. */\n    uuidv7(params?: string | core.$ZodCheckUUIDParams): this;\n    /** @deprecated Use `z.nanoid()` instead. */\n    nanoid(params?: string | core.$ZodCheckNanoIDParams): this;\n    /** @deprecated Use `z.guid()` instead. */\n    guid(params?: string | core.$ZodCheckGUIDParams): this;\n    /** @deprecated Use `z.cuid()` instead. */\n    cuid(params?: string | core.$ZodCheckCUIDParams): this;\n    /** @deprecated Use `z.cuid2()` instead. */\n    cuid2(params?: string | core.$ZodCheckCUID2Params): this;\n    /** @deprecated Use `z.ulid()` instead. */\n    ulid(params?: string | core.$ZodCheckULIDParams): this;\n    /** @deprecated Use `z.base64()` instead. */\n    base64(params?: string | core.$ZodCheckBase64Params): this;\n    /** @deprecated Use `z.base64url()` instead. */\n    base64url(params?: string | core.$ZodCheckBase64URLParams): this;\n    /** @deprecated Use `z.xid()` instead. */\n    xid(params?: string | core.$ZodCheckXIDParams): this;\n    /** @deprecated Use `z.ksuid()` instead. */\n    ksuid(params?: string | core.$ZodCheckKSUIDParams): this;\n    /** @deprecated Use `z.ipv4()` instead. */\n    ipv4(params?: string | core.$ZodCheckIPv4Params): this;\n    /** @deprecated Use `z.ipv6()` instead. */\n    ipv6(params?: string | core.$ZodCheckIPv6Params): this;\n    /** @deprecated Use `z.cidrv4()` instead. */\n    cidrv4(params?: string | core.$ZodCheckCIDRv4Params): this;\n    /** @deprecated Use `z.cidrv6()` instead. */\n    cidrv6(params?: string | core.$ZodCheckCIDRv6Params): this;\n    /** @deprecated Use `z.e164()` instead. */\n    e164(params?: string | core.$ZodCheckE164Params): this;\n    /** @deprecated Use `z.iso.datetime()` instead. */\n    datetime(params?: string | core.$ZodCheckISODateTimeParams): this;\n    /** @deprecated Use `z.iso.date()` instead. */\n    date(params?: string | core.$ZodCheckISODateParams): this;\n    /** @deprecated Use `z.iso.time()` instead. */\n    time(params?: string | core.$ZodCheckISOTimeParams): this;\n    /** @deprecated Use `z.iso.duration()` instead. */\n    duration(params?: string | core.$ZodCheckISODurationParams): this;\n}\nexport declare const ZodString: core.$constructor<ZodString>;\nexport declare function string(params?: string | core.$ZodStringParams): ZodString;\nexport declare function string<T extends string>(params?: string | core.$ZodStringParams): core.$ZodType<T, T>;\nexport interface ZodStringFormat<Format extends string = string> extends _ZodString<core.$ZodStringFormatInternals<Format>> {\n}\nexport declare const ZodStringFormat: core.$constructor<ZodStringFormat>;\nexport interface ZodEmail extends ZodStringFormat<\"email\"> {\n    _zod: core.$ZodEmailInternals;\n}\nexport declare const ZodEmail: core.$constructor<ZodEmail>;\nexport declare function email(params?: string | core.$ZodEmailParams): ZodEmail;\nexport interface ZodGUID extends ZodStringFormat<\"guid\"> {\n    _zod: core.$ZodGUIDInternals;\n}\nexport declare const ZodGUID: core.$constructor<ZodGUID>;\nexport declare function guid(params?: string | core.$ZodGUIDParams): ZodGUID;\nexport interface ZodUUID extends ZodStringFormat<\"uuid\"> {\n    _zod: core.$ZodUUIDInternals;\n}\nexport declare const ZodUUID: core.$constructor<ZodUUID>;\nexport declare function uuid(params?: string | core.$ZodUUIDParams): ZodUUID;\nexport declare function uuidv4(params?: string | core.$ZodUUIDv4Params): ZodUUID;\nexport declare function uuidv6(params?: string | core.$ZodUUIDv6Params): ZodUUID;\nexport declare function uuidv7(params?: string | core.$ZodUUIDv7Params): ZodUUID;\nexport interface ZodURL extends ZodStringFormat<\"url\"> {\n    _zod: core.$ZodURLInternals;\n}\nexport declare const ZodURL: core.$constructor<ZodURL>;\nexport declare function url(params?: string | core.$ZodURLParams): ZodURL;\nexport interface ZodEmoji extends ZodStringFormat<\"emoji\"> {\n    _zod: core.$ZodEmojiInternals;\n}\nexport declare const ZodEmoji: core.$constructor<ZodEmoji>;\nexport declare function emoji(params?: string | core.$ZodEmojiParams): ZodEmoji;\nexport interface ZodNanoID extends ZodStringFormat<\"nanoid\"> {\n    _zod: core.$ZodNanoIDInternals;\n}\nexport declare const ZodNanoID: core.$constructor<ZodNanoID>;\nexport declare function nanoid(params?: string | core.$ZodNanoIDParams): ZodNanoID;\nexport interface ZodCUID extends ZodStringFormat<\"cuid\"> {\n    _zod: core.$ZodCUIDInternals;\n}\nexport declare const ZodCUID: core.$constructor<ZodCUID>;\nexport declare function cuid(params?: string | core.$ZodCUIDParams): ZodCUID;\nexport interface ZodCUID2 extends ZodStringFormat<\"cuid2\"> {\n    _zod: core.$ZodCUID2Internals;\n}\nexport declare const ZodCUID2: core.$constructor<ZodCUID2>;\nexport declare function cuid2(params?: string | core.$ZodCUID2Params): ZodCUID2;\nexport interface ZodULID extends ZodStringFormat<\"ulid\"> {\n    _zod: core.$ZodULIDInternals;\n}\nexport declare const ZodULID: core.$constructor<ZodULID>;\nexport declare function ulid(params?: string | core.$ZodULIDParams): ZodULID;\nexport interface ZodXID extends ZodStringFormat<\"xid\"> {\n    _zod: core.$ZodXIDInternals;\n}\nexport declare const ZodXID: core.$constructor<ZodXID>;\nexport declare function xid(params?: string | core.$ZodXIDParams): ZodXID;\nexport interface ZodKSUID extends ZodStringFormat<\"ksuid\"> {\n    _zod: core.$ZodKSUIDInternals;\n}\nexport declare const ZodKSUID: core.$constructor<ZodKSUID>;\nexport declare function ksuid(params?: string | core.$ZodKSUIDParams): ZodKSUID;\nexport interface ZodIPv4 extends ZodStringFormat<\"ipv4\"> {\n    _zod: core.$ZodIPv4Internals;\n}\nexport declare const ZodIPv4: core.$constructor<ZodIPv4>;\nexport declare function ipv4(params?: string | core.$ZodIPv4Params): ZodIPv4;\nexport interface ZodIPv6 extends ZodStringFormat<\"ipv6\"> {\n    _zod: core.$ZodIPv6Internals;\n}\nexport declare const ZodIPv6: core.$constructor<ZodIPv6>;\nexport declare function ipv6(params?: string | core.$ZodIPv6Params): ZodIPv6;\nexport interface ZodCIDRv4 extends ZodStringFormat<\"cidrv4\"> {\n    _zod: core.$ZodCIDRv4Internals;\n}\nexport declare const ZodCIDRv4: core.$constructor<ZodCIDRv4>;\nexport declare function cidrv4(params?: string | core.$ZodCIDRv4Params): ZodCIDRv4;\nexport interface ZodCIDRv6 extends ZodStringFormat<\"cidrv6\"> {\n    _zod: core.$ZodCIDRv6Internals;\n}\nexport declare const ZodCIDRv6: core.$constructor<ZodCIDRv6>;\nexport declare function cidrv6(params?: string | core.$ZodCIDRv6Params): ZodCIDRv6;\nexport interface ZodBase64 extends ZodStringFormat<\"base64\"> {\n    _zod: core.$ZodBase64Internals;\n}\nexport declare const ZodBase64: core.$constructor<ZodBase64>;\nexport declare function base64(params?: string | core.$ZodBase64Params): ZodBase64;\nexport interface ZodBase64URL extends ZodStringFormat<\"base64url\"> {\n    _zod: core.$ZodBase64URLInternals;\n}\nexport declare const ZodBase64URL: core.$constructor<ZodBase64URL>;\nexport declare function base64url(params?: string | core.$ZodBase64URLParams): ZodBase64URL;\nexport interface ZodE164 extends ZodStringFormat<\"e164\"> {\n    _zod: core.$ZodE164Internals;\n}\nexport declare const ZodE164: core.$constructor<ZodE164>;\nexport declare function e164(params?: string | core.$ZodE164Params): ZodE164;\nexport interface ZodJWT extends ZodStringFormat<\"jwt\"> {\n    _zod: core.$ZodJWTInternals;\n}\nexport declare const ZodJWT: core.$constructor<ZodJWT>;\nexport declare function jwt(params?: string | core.$ZodJWTParams): ZodJWT;\nexport interface ZodCustomStringFormat<Format extends string = string> extends ZodStringFormat<Format>, core.$ZodCustomStringFormat<Format> {\n    _zod: core.$ZodCustomStringFormatInternals<Format>;\n}\nexport declare const ZodCustomStringFormat: core.$constructor<ZodCustomStringFormat>;\nexport declare function stringFormat<Format extends string>(format: Format, fnOrRegex: ((arg: string) => util.MaybeAsync<unknown>) | RegExp, _params?: string | core.$ZodStringFormatParams): ZodCustomStringFormat<Format>;\nexport interface _ZodNumber<Internals extends core.$ZodNumberInternals = core.$ZodNumberInternals> extends _ZodType<Internals> {\n    gt(value: number, params?: string | core.$ZodCheckGreaterThanParams): this;\n    /** Identical to .min() */\n    gte(value: number, params?: string | core.$ZodCheckGreaterThanParams): this;\n    min(value: number, params?: string | core.$ZodCheckGreaterThanParams): this;\n    lt(value: number, params?: string | core.$ZodCheckLessThanParams): this;\n    /** Identical to .max() */\n    lte(value: number, params?: string | core.$ZodCheckLessThanParams): this;\n    max(value: number, params?: string | core.$ZodCheckLessThanParams): this;\n    /** Consider `z.int()` instead. This API is considered *legacy*; it will never be removed but a better alternative exists. */\n    int(params?: string | core.$ZodCheckNumberFormatParams): this;\n    /** @deprecated This is now identical to `.int()`. Only numbers in the safe integer range are accepted. */\n    safe(params?: string | core.$ZodCheckNumberFormatParams): this;\n    positive(params?: string | core.$ZodCheckGreaterThanParams): this;\n    nonnegative(params?: string | core.$ZodCheckGreaterThanParams): this;\n    negative(params?: string | core.$ZodCheckLessThanParams): this;\n    nonpositive(params?: string | core.$ZodCheckLessThanParams): this;\n    multipleOf(value: number, params?: string | core.$ZodCheckMultipleOfParams): this;\n    /** @deprecated Use `.multipleOf()` instead. */\n    step(value: number, params?: string | core.$ZodCheckMultipleOfParams): this;\n    /** @deprecated In v4 and later, z.number() does not allow infinite values by default. This is a no-op. */\n    finite(params?: unknown): this;\n    minValue: number | null;\n    maxValue: number | null;\n    /** @deprecated Check the `format` property instead.  */\n    isInt: boolean;\n    /** @deprecated Number schemas no longer accept infinite values, so this always returns `true`. */\n    isFinite: boolean;\n    format: string | null;\n}\nexport interface ZodNumber extends _ZodNumber<core.$ZodNumberInternals<number>> {\n}\nexport declare const ZodNumber: core.$constructor<ZodNumber>;\nexport declare function number(params?: string | core.$ZodNumberParams): ZodNumber;\nexport interface ZodNumberFormat extends ZodNumber {\n    _zod: core.$ZodNumberFormatInternals;\n}\nexport declare const ZodNumberFormat: core.$constructor<ZodNumberFormat>;\nexport interface ZodInt extends ZodNumberFormat {\n}\nexport declare function int(params?: string | core.$ZodCheckNumberFormatParams): ZodInt;\nexport interface ZodFloat32 extends ZodNumberFormat {\n}\nexport declare function float32(params?: string | core.$ZodCheckNumberFormatParams): ZodFloat32;\nexport interface ZodFloat64 extends ZodNumberFormat {\n}\nexport declare function float64(params?: string | core.$ZodCheckNumberFormatParams): ZodFloat64;\nexport interface ZodInt32 extends ZodNumberFormat {\n}\nexport declare function int32(params?: string | core.$ZodCheckNumberFormatParams): ZodInt32;\nexport interface ZodUInt32 extends ZodNumberFormat {\n}\nexport declare function uint32(params?: string | core.$ZodCheckNumberFormatParams): ZodUInt32;\nexport interface _ZodBoolean<T extends core.$ZodBooleanInternals = core.$ZodBooleanInternals> extends _ZodType<T> {\n}\nexport interface ZodBoolean extends _ZodBoolean<core.$ZodBooleanInternals<boolean>> {\n}\nexport declare const ZodBoolean: core.$constructor<ZodBoolean>;\nexport declare function boolean(params?: string | core.$ZodBooleanParams): ZodBoolean;\nexport interface _ZodBigInt<T extends core.$ZodBigIntInternals = core.$ZodBigIntInternals> extends _ZodType<T> {\n    gte(value: bigint, params?: string | core.$ZodCheckGreaterThanParams): this;\n    /** Alias of `.gte()` */\n    min(value: bigint, params?: string | core.$ZodCheckGreaterThanParams): this;\n    gt(value: bigint, params?: string | core.$ZodCheckGreaterThanParams): this;\n    /** Alias of `.lte()` */\n    lte(value: bigint, params?: string | core.$ZodCheckLessThanParams): this;\n    max(value: bigint, params?: string | core.$ZodCheckLessThanParams): this;\n    lt(value: bigint, params?: string | core.$ZodCheckLessThanParams): this;\n    positive(params?: string | core.$ZodCheckGreaterThanParams): this;\n    negative(params?: string | core.$ZodCheckLessThanParams): this;\n    nonpositive(params?: string | core.$ZodCheckLessThanParams): this;\n    nonnegative(params?: string | core.$ZodCheckGreaterThanParams): this;\n    multipleOf(value: bigint, params?: string | core.$ZodCheckMultipleOfParams): this;\n    minValue: bigint | null;\n    maxValue: bigint | null;\n    format: string | null;\n}\nexport interface ZodBigInt extends _ZodBigInt<core.$ZodBigIntInternals<bigint>> {\n}\nexport declare const ZodBigInt: core.$constructor<ZodBigInt>;\nexport declare function bigint(params?: string | core.$ZodBigIntParams): ZodBigInt;\nexport interface ZodBigIntFormat extends ZodBigInt {\n    _zod: core.$ZodBigIntFormatInternals;\n}\nexport declare const ZodBigIntFormat: core.$constructor<ZodBigIntFormat>;\nexport declare function int64(params?: string | core.$ZodBigIntFormatParams): ZodBigIntFormat;\nexport declare function uint64(params?: string | core.$ZodBigIntFormatParams): ZodBigIntFormat;\nexport interface ZodSymbol extends _ZodType<core.$ZodSymbolInternals> {\n}\nexport declare const ZodSymbol: core.$constructor<ZodSymbol>;\nexport declare function symbol(params?: string | core.$ZodSymbolParams): ZodSymbol;\nexport interface ZodUndefined extends _ZodType<core.$ZodUndefinedInternals> {\n}\nexport declare const ZodUndefined: core.$constructor<ZodUndefined>;\ndeclare function _undefined(params?: string | core.$ZodUndefinedParams): ZodUndefined;\nexport { _undefined as undefined };\nexport interface ZodNull extends _ZodType<core.$ZodNullInternals> {\n}\nexport declare const ZodNull: core.$constructor<ZodNull>;\ndeclare function _null(params?: string | core.$ZodNullParams): ZodNull;\nexport { _null as null };\nexport interface ZodAny extends _ZodType<core.$ZodAnyInternals> {\n}\nexport declare const ZodAny: core.$constructor<ZodAny>;\nexport declare function any(): ZodAny;\nexport interface ZodUnknown extends _ZodType<core.$ZodUnknownInternals> {\n}\nexport declare const ZodUnknown: core.$constructor<ZodUnknown>;\nexport declare function unknown(): ZodUnknown;\nexport interface ZodNever extends _ZodType<core.$ZodNeverInternals> {\n}\nexport declare const ZodNever: core.$constructor<ZodNever>;\nexport declare function never(params?: string | core.$ZodNeverParams): ZodNever;\nexport interface ZodVoid extends _ZodType<core.$ZodVoidInternals> {\n}\nexport declare const ZodVoid: core.$constructor<ZodVoid>;\ndeclare function _void(params?: string | core.$ZodVoidParams): ZodVoid;\nexport { _void as void };\nexport interface _ZodDate<T extends core.$ZodDateInternals = core.$ZodDateInternals> extends _ZodType<T> {\n    min(value: number | Date, params?: string | core.$ZodCheckGreaterThanParams): this;\n    max(value: number | Date, params?: string | core.$ZodCheckLessThanParams): this;\n    /** @deprecated Not recommended. */\n    minDate: Date | null;\n    /** @deprecated Not recommended. */\n    maxDate: Date | null;\n}\nexport interface ZodDate extends _ZodDate<core.$ZodDateInternals<Date>> {\n}\nexport declare const ZodDate: core.$constructor<ZodDate>;\nexport declare function date(params?: string | core.$ZodDateParams): ZodDate;\nexport interface ZodArray<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodArrayInternals<T>>, core.$ZodArray<T> {\n    element: T;\n    min(minLength: number, params?: string | core.$ZodCheckMinLengthParams): this;\n    nonempty(params?: string | core.$ZodCheckMinLengthParams): this;\n    max(maxLength: number, params?: string | core.$ZodCheckMaxLengthParams): this;\n    length(len: number, params?: string | core.$ZodCheckLengthEqualsParams): this;\n    unwrap(): T;\n}\nexport declare const ZodArray: core.$constructor<ZodArray>;\nexport declare function array<T extends core.SomeType>(element: T, params?: string | core.$ZodArrayParams): ZodArray<T>;\nexport declare function keyof<T extends ZodObject>(schema: T): ZodLiteral<Exclude<keyof T[\"_zod\"][\"output\"], symbol>>;\nexport interface ZodObject<\n/** @ts-ignore Cast variance */\nout Shape extends core.$ZodShape = core.$ZodLooseShape, out Config extends core.$ZodObjectConfig = core.$strip> extends _ZodType<core.$ZodObjectInternals<Shape, Config>>, core.$ZodObject<Shape, Config> {\n    shape: Shape;\n    keyof(): ZodEnum<util.ToEnum<keyof Shape & string>>;\n    /** Define a schema to validate all unrecognized keys. This overrides the existing strict/loose behavior. */\n    catchall<T extends core.SomeType>(schema: T): ZodObject<Shape, core.$catchall<T>>;\n    /** @deprecated Use `z.looseObject()` or `.loose()` instead. */\n    passthrough(): ZodObject<Shape, core.$loose>;\n    /** Consider `z.looseObject(A.shape)` instead */\n    loose(): ZodObject<Shape, core.$loose>;\n    /** Consider `z.strictObject(A.shape)` instead */\n    strict(): ZodObject<Shape, core.$strict>;\n    /** This is the default behavior. This method call is likely unnecessary. */\n    strip(): ZodObject<Shape, core.$strip>;\n    extend<U extends core.$ZodLooseShape & Partial<Record<keyof Shape, core.SomeType>>>(shape: U): ZodObject<util.Extend<Shape, U>, Config>;\n    /**\n     * @deprecated Use spread syntax and the `.shape` property to combine two object schemas:\n     *\n     * ```ts\n     * const A = z.object({ a: z.string() });\n     * const B = z.object({ b: z.number() });\n     *\n     * const C = z.object({\n     *    ...A.shape,\n     *    ...B.shape\n     * });\n     * ```\n     */\n    merge<U extends ZodObject>(other: U): ZodObject<util.Extend<Shape, U[\"shape\"]>, U[\"_zod\"][\"config\"]>;\n    pick<M extends util.Mask<keyof Shape>>(mask: M): ZodObject<util.Flatten<Pick<Shape, Extract<keyof Shape, keyof M>>>, Config>;\n    omit<M extends util.Mask<keyof Shape>>(mask: M): ZodObject<util.Flatten<Omit<Shape, Extract<keyof Shape, keyof M>>>, Config>;\n    partial(): ZodObject<{\n        [k in keyof Shape]: ZodOptional<Shape[k]>;\n    }, Config>;\n    partial<M extends util.Mask<keyof Shape>>(mask: M): ZodObject<{\n        [k in keyof Shape]: k extends keyof M ? ZodOptional<Shape[k]> : Shape[k];\n    }, Config>;\n    required(): ZodObject<{\n        [k in keyof Shape]: ZodNonOptional<Shape[k]>;\n    }, Config>;\n    required<M extends util.Mask<keyof Shape>>(mask: M): ZodObject<{\n        [k in keyof Shape]: k extends keyof M ? ZodNonOptional<Shape[k]> : Shape[k];\n    }, Config>;\n}\nexport declare const ZodObject: core.$constructor<ZodObject>;\nexport declare function object<T extends core.$ZodLooseShape = Partial<Record<never, core.SomeType>>>(shape?: T, params?: string | core.$ZodObjectParams): ZodObject<util.Writeable<T>, core.$strip>;\nexport declare function strictObject<T extends core.$ZodLooseShape>(shape: T, params?: string | core.$ZodObjectParams): ZodObject<T, core.$strict>;\nexport declare function looseObject<T extends core.$ZodLooseShape>(shape: T, params?: string | core.$ZodObjectParams): ZodObject<T, core.$loose>;\nexport interface ZodUnion<T extends readonly core.SomeType[] = readonly core.$ZodType[]> extends _ZodType<core.$ZodUnionInternals<T>>, core.$ZodUnion<T> {\n    options: T;\n}\nexport declare const ZodUnion: core.$constructor<ZodUnion>;\nexport declare function union<const T extends readonly core.SomeType[]>(options: T, params?: string | core.$ZodUnionParams): ZodUnion<T>;\nexport interface ZodDiscriminatedUnion<Options extends readonly core.SomeType[] = readonly core.$ZodType[]> extends ZodUnion<Options>, core.$ZodDiscriminatedUnion<Options> {\n    _zod: core.$ZodDiscriminatedUnionInternals<Options>;\n}\nexport declare const ZodDiscriminatedUnion: core.$constructor<ZodDiscriminatedUnion>;\nexport declare function discriminatedUnion<Types extends readonly [core.$ZodTypeDiscriminable, ...core.$ZodTypeDiscriminable[]]>(discriminator: string, options: Types, params?: string | core.$ZodDiscriminatedUnionParams): ZodDiscriminatedUnion<Types>;\nexport interface ZodIntersection<A extends core.SomeType = core.$ZodType, B extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodIntersectionInternals<A, B>>, core.$ZodIntersection<A, B> {\n}\nexport declare const ZodIntersection: core.$constructor<ZodIntersection>;\nexport declare function intersection<T extends core.SomeType, U extends core.SomeType>(left: T, right: U): ZodIntersection<T, U>;\nexport interface ZodTuple<T extends util.TupleItems = readonly core.$ZodType[], Rest extends core.SomeType | null = core.$ZodType | null> extends _ZodType<core.$ZodTupleInternals<T, Rest>>, core.$ZodTuple<T, Rest> {\n    rest<Rest extends core.SomeType = core.$ZodType>(rest: Rest): ZodTuple<T, Rest>;\n}\nexport declare const ZodTuple: core.$constructor<ZodTuple>;\nexport declare function tuple<T extends readonly [core.SomeType, ...core.SomeType[]]>(items: T, params?: string | core.$ZodTupleParams): ZodTuple<T, null>;\nexport declare function tuple<T extends readonly [core.SomeType, ...core.SomeType[]], Rest extends core.SomeType>(items: T, rest: Rest, params?: string | core.$ZodTupleParams): ZodTuple<T, Rest>;\nexport declare function tuple(items: [], params?: string | core.$ZodTupleParams): ZodTuple<[], null>;\nexport interface ZodRecord<Key extends core.$ZodRecordKey = core.$ZodRecordKey, Value extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodRecordInternals<Key, Value>>, core.$ZodRecord<Key, Value> {\n    keyType: Key;\n    valueType: Value;\n}\nexport declare const ZodRecord: core.$constructor<ZodRecord>;\nexport declare function record<Key extends core.$ZodRecordKey, Value extends core.SomeType>(keyType: Key, valueType: Value, params?: string | core.$ZodRecordParams): ZodRecord<Key, Value>;\nexport declare function partialRecord<Key extends core.$ZodRecordKey, Value extends core.SomeType>(keyType: Key, valueType: Value, params?: string | core.$ZodRecordParams): ZodRecord<Key & core.$partial, Value>;\nexport interface ZodMap<Key extends core.SomeType = core.$ZodType, Value extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodMapInternals<Key, Value>>, core.$ZodMap<Key, Value> {\n    keyType: Key;\n    valueType: Value;\n}\nexport declare const ZodMap: core.$constructor<ZodMap>;\nexport declare function map<Key extends core.SomeType, Value extends core.SomeType>(keyType: Key, valueType: Value, params?: string | core.$ZodMapParams): ZodMap<Key, Value>;\nexport interface ZodSet<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodSetInternals<T>>, core.$ZodSet<T> {\n    min(minSize: number, params?: string | core.$ZodCheckMinSizeParams): this;\n    /** */\n    nonempty(params?: string | core.$ZodCheckMinSizeParams): this;\n    max(maxSize: number, params?: string | core.$ZodCheckMaxSizeParams): this;\n    size(size: number, params?: string | core.$ZodCheckSizeEqualsParams): this;\n}\nexport declare const ZodSet: core.$constructor<ZodSet>;\nexport declare function set<Value extends core.SomeType>(valueType: Value, params?: string | core.$ZodSetParams): ZodSet<Value>;\nexport interface ZodEnum<\n/** @ts-ignore Cast variance */\nout T extends util.EnumLike = util.EnumLike> extends _ZodType<core.$ZodEnumInternals<T>>, core.$ZodEnum<T> {\n    enum: T;\n    options: Array<T[keyof T]>;\n    extract<const U extends readonly (keyof T)[]>(values: U, params?: string | core.$ZodEnumParams): ZodEnum<util.Flatten<Pick<T, U[number]>>>;\n    exclude<const U extends readonly (keyof T)[]>(values: U, params?: string | core.$ZodEnumParams): ZodEnum<util.Flatten<Omit<T, U[number]>>>;\n}\nexport declare const ZodEnum: core.$constructor<ZodEnum>;\ndeclare function _enum<const T extends readonly string[]>(values: T, params?: string | core.$ZodEnumParams): ZodEnum<util.ToEnum<T[number]>>;\ndeclare function _enum<const T extends util.EnumLike>(entries: T, params?: string | core.$ZodEnumParams): ZodEnum<T>;\nexport { _enum as enum };\n/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.\n *\n * ```ts\n * enum Colors { red, green, blue }\n * z.enum(Colors);\n * ```\n */\nexport declare function nativeEnum<T extends util.EnumLike>(entries: T, params?: string | core.$ZodEnumParams): ZodEnum<T>;\nexport interface ZodLiteral<T extends util.Literal = util.Literal> extends _ZodType<core.$ZodLiteralInternals<T>>, core.$ZodLiteral<T> {\n    values: Set<T>;\n    /** @legacy Use `.values` instead. Accessing this property will throw an error if the literal accepts multiple values. */\n    value: T;\n}\nexport declare const ZodLiteral: core.$constructor<ZodLiteral>;\nexport declare function literal<const T extends ReadonlyArray<util.Literal>>(value: T, params?: string | core.$ZodLiteralParams): ZodLiteral<T[number]>;\nexport declare function literal<const T extends util.Literal>(value: T, params?: string | core.$ZodLiteralParams): ZodLiteral<T>;\nexport interface ZodFile extends _ZodType<core.$ZodFileInternals>, core.$ZodFile {\n    min(size: number, params?: string | core.$ZodCheckMinSizeParams): this;\n    max(size: number, params?: string | core.$ZodCheckMaxSizeParams): this;\n    mime(types: util.MimeTypes | Array<util.MimeTypes>, params?: string | core.$ZodCheckMimeTypeParams): this;\n}\nexport declare const ZodFile: core.$constructor<ZodFile>;\nexport declare function file(params?: string | core.$ZodFileParams): ZodFile;\nexport interface ZodTransform<O = unknown, I = unknown> extends _ZodType<core.$ZodTransformInternals<O, I>>, core.$ZodTransform<O, I> {\n}\nexport declare const ZodTransform: core.$constructor<ZodTransform>;\nexport declare function transform<I = unknown, O = I>(fn: (input: I, ctx: core.ParsePayload) => O): ZodTransform<Awaited<O>, I>;\nexport interface ZodOptional<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodOptionalInternals<T>>, core.$ZodOptional<T> {\n    unwrap(): T;\n}\nexport declare const ZodOptional: core.$constructor<ZodOptional>;\nexport declare function optional<T extends core.SomeType>(innerType: T): ZodOptional<T>;\nexport interface ZodNullable<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodNullableInternals<T>>, core.$ZodNullable<T> {\n    unwrap(): T;\n}\nexport declare const ZodNullable: core.$constructor<ZodNullable>;\nexport declare function nullable<T extends core.SomeType>(innerType: T): ZodNullable<T>;\nexport declare function nullish<T extends core.SomeType>(innerType: T): ZodOptional<ZodNullable<T>>;\nexport interface ZodDefault<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodDefaultInternals<T>>, core.$ZodDefault<T> {\n    unwrap(): T;\n    /** @deprecated Use `.unwrap()` instead. */\n    removeDefault(): T;\n}\nexport declare const ZodDefault: core.$constructor<ZodDefault>;\nexport declare function _default<T extends core.SomeType>(innerType: T, defaultValue: util.NoUndefined<core.output<T>> | (() => util.NoUndefined<core.output<T>>)): ZodDefault<T>;\nexport interface ZodPrefault<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodPrefaultInternals<T>>, core.$ZodPrefault<T> {\n    unwrap(): T;\n}\nexport declare const ZodPrefault: core.$constructor<ZodPrefault>;\nexport declare function prefault<T extends core.SomeType>(innerType: T, defaultValue: core.input<T> | (() => core.input<T>)): ZodPrefault<T>;\nexport interface ZodNonOptional<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodNonOptionalInternals<T>>, core.$ZodNonOptional<T> {\n    unwrap(): T;\n}\nexport declare const ZodNonOptional: core.$constructor<ZodNonOptional>;\nexport declare function nonoptional<T extends core.SomeType>(innerType: T, params?: string | core.$ZodNonOptionalParams): ZodNonOptional<T>;\nexport interface ZodSuccess<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodSuccessInternals<T>>, core.$ZodSuccess<T> {\n    unwrap(): T;\n}\nexport declare const ZodSuccess: core.$constructor<ZodSuccess>;\nexport declare function success<T extends core.SomeType>(innerType: T): ZodSuccess<T>;\nexport interface ZodCatch<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodCatchInternals<T>>, core.$ZodCatch<T> {\n    unwrap(): T;\n    /** @deprecated Use `.unwrap()` instead. */\n    removeCatch(): T;\n}\nexport declare const ZodCatch: core.$constructor<ZodCatch>;\ndeclare function _catch<T extends core.SomeType>(innerType: T, catchValue: core.output<T> | ((ctx: core.$ZodCatchCtx) => core.output<T>)): ZodCatch<T>;\nexport { _catch as catch };\nexport interface ZodNaN extends _ZodType<core.$ZodNaNInternals>, core.$ZodNaN {\n}\nexport declare const ZodNaN: core.$constructor<ZodNaN>;\nexport declare function nan(params?: string | core.$ZodNaNParams): ZodNaN;\nexport interface ZodPipe<A extends core.SomeType = core.$ZodType, B extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodPipeInternals<A, B>>, core.$ZodPipe<A, B> {\n    in: A;\n    out: B;\n}\nexport declare const ZodPipe: core.$constructor<ZodPipe>;\nexport declare function pipe<const A extends core.SomeType, B extends core.$ZodType<unknown, core.output<A>> = core.$ZodType<unknown, core.output<A>>>(in_: A, out: B | core.$ZodType<unknown, core.output<A>>): ZodPipe<A, B>;\nexport interface ZodReadonly<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodReadonlyInternals<T>>, core.$ZodReadonly<T> {\n}\nexport declare const ZodReadonly: core.$constructor<ZodReadonly>;\nexport declare function readonly<T extends core.SomeType>(innerType: T): ZodReadonly<T>;\nexport interface ZodTemplateLiteral<Template extends string = string> extends _ZodType<core.$ZodTemplateLiteralInternals<Template>>, core.$ZodTemplateLiteral<Template> {\n}\nexport declare const ZodTemplateLiteral: core.$constructor<ZodTemplateLiteral>;\nexport declare function templateLiteral<const Parts extends core.$ZodTemplateLiteralPart[]>(parts: Parts, params?: string | core.$ZodTemplateLiteralParams): ZodTemplateLiteral<core.$PartsToTemplateLiteral<Parts>>;\nexport interface ZodLazy<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodLazyInternals<T>>, core.$ZodLazy<T> {\n    unwrap(): T;\n}\nexport declare const ZodLazy: core.$constructor<ZodLazy>;\nexport declare function lazy<T extends core.SomeType>(getter: () => T): ZodLazy<T>;\nexport interface ZodPromise<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodPromiseInternals<T>>, core.$ZodPromise<T> {\n    unwrap(): T;\n}\nexport declare const ZodPromise: core.$constructor<ZodPromise>;\nexport declare function promise<T extends core.SomeType>(innerType: T): ZodPromise<T>;\nexport interface ZodCustom<O = unknown, I = unknown> extends _ZodType<core.$ZodCustomInternals<O, I>>, core.$ZodCustom<O, I> {\n}\nexport declare const ZodCustom: core.$constructor<ZodCustom>;\nexport declare function check<O = unknown>(fn: core.CheckFn<O>): core.$ZodCheck<O>;\nexport declare function custom<O>(fn?: (data: unknown) => unknown, _params?: string | core.$ZodCustomParams | undefined): ZodCustom<O, O>;\nexport declare function refine<T>(fn: (arg: NoInfer<T>) => util.MaybeAsync<unknown>, _params?: string | core.$ZodCustomParams): core.$ZodCheck<T>;\nexport declare function superRefine<T>(fn: (arg: T, payload: RefinementCtx<T>) => void | Promise<void>): core.$ZodCheck<T>;\ntype ZodInstanceOfParams = core.Params<ZodCustom, core.$ZodIssueCustom, \"type\" | \"check\" | \"checks\" | \"fn\" | \"abort\" | \"error\" | \"params\" | \"path\">;\ndeclare function _instanceof<T extends typeof util.Class>(cls: T, params?: ZodInstanceOfParams): ZodCustom<InstanceType<T>, InstanceType<T>>;\nexport { _instanceof as instanceof };\nexport declare const stringbool: (_params?: string | core.$ZodStringBoolParams) => ZodPipe<ZodPipe<ZodString, ZodTransform<boolean, string>>, ZodBoolean>;\ntype _ZodJSONSchema = ZodUnion<[\n    ZodString,\n    ZodNumber,\n    ZodBoolean,\n    ZodNull,\n    ZodArray<ZodJSONSchema>,\n    ZodRecord<ZodString, ZodJSONSchema>\n]>;\ntype _ZodJSONSchemaInternals = _ZodJSONSchema[\"_zod\"];\nexport interface ZodJSONSchemaInternals extends _ZodJSONSchemaInternals {\n    output: util.JSONType;\n    input: util.JSONType;\n}\nexport interface ZodJSONSchema extends _ZodJSONSchema {\n    _zod: ZodJSONSchemaInternals;\n}\nexport declare function json(params?: string | core.$ZodCustomParams): ZodJSONSchema;\nexport declare function preprocess<A, U extends core.SomeType, B = unknown>(fn: (arg: B, ctx: RefinementCtx) => A, schema: U): ZodPipe<ZodTransform<A, B>, U>;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/classic/schemas.d.ts",
        "start": 1,
        "end": 630,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 630,
          "column": 2,
          "position": 11305
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/classic/schemas.d.ts",
        "start": 1,
        "end": 630,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 630,
          "column": 2,
          "position": 11305
        }
      }
    },
    {
      "format": "typescript",
      "lines": 630,
      "fragment": "import * as core from \"../core/index.cjs\";\nimport { util } from \"../core/index.cjs\";\nimport * as parse from \"./parse.cjs\";\nexport interface RefinementCtx<T = unknown> extends core.ParsePayload<T> {\n    addIssue(arg: string | core.$ZodRawIssue | Partial<core.$ZodIssueCustom>): void;\n}\nexport interface ZodType<out Output = unknown, out Input = unknown, out Internals extends core.$ZodTypeInternals<Output, Input> = core.$ZodTypeInternals<Output, Input>> extends core.$ZodType<Output, Input, Internals> {\n    def: Internals[\"def\"];\n    type: Internals[\"def\"][\"type\"];\n    /** @deprecated Use `.def` instead. */\n    _def: Internals[\"def\"];\n    /** @deprecated Use `z.output<typeof schema>` instead. */\n    _output: Internals[\"output\"];\n    /** @deprecated Use `z.input<typeof schema>` instead. */\n    _input: Internals[\"input\"];\n    check(...checks: (core.CheckFn<core.output<this>> | core.$ZodCheck<core.output<this>>)[]): this;\n    clone(def?: Internals[\"def\"], params?: {\n        parent: boolean;\n    }): this;\n    register<R extends core.$ZodRegistry>(registry: R, ...meta: this extends R[\"_schema\"] ? undefined extends R[\"_meta\"] ? [core.$replace<R[\"_meta\"], this>?] : [core.$replace<R[\"_meta\"], this>] : [\"Incompatible schema\"]): this;\n    brand<T extends PropertyKey = PropertyKey>(value?: T): PropertyKey extends T ? this : core.$ZodBranded<this, T>;\n    parse(data: unknown, params?: core.ParseContext<core.$ZodIssue>): core.output<this>;\n    safeParse(data: unknown, params?: core.ParseContext<core.$ZodIssue>): parse.ZodSafeParseResult<core.output<this>>;\n    parseAsync(data: unknown, params?: core.ParseContext<core.$ZodIssue>): Promise<core.output<this>>;\n    safeParseAsync(data: unknown, params?: core.ParseContext<core.$ZodIssue>): Promise<parse.ZodSafeParseResult<core.output<this>>>;\n    spa: (data: unknown, params?: core.ParseContext<core.$ZodIssue>) => Promise<parse.ZodSafeParseResult<core.output<this>>>;\n    refine(check: (arg: core.output<this>) => unknown | Promise<unknown>, params?: string | core.$ZodCustomParams): this;\n    /** @deprecated Use `.check()` instead. */\n    superRefine(refinement: (arg: core.output<this>, ctx: RefinementCtx<core.output<this>>) => void | Promise<void>): this;\n    overwrite(fn: (x: core.output<this>) => core.output<this>): this;\n    optional(): ZodOptional<this>;\n    nonoptional(params?: string | core.$ZodNonOptionalParams): ZodNonOptional<this>;\n    nullable(): ZodNullable<this>;\n    nullish(): ZodOptional<ZodNullable<this>>;\n    default(def: core.output<this>): ZodDefault<this>;\n    default(def: () => util.NoUndefined<core.output<this>>): ZodDefault<this>;\n    prefault(def: () => core.input<this>): ZodPrefault<this>;\n    prefault(def: core.input<this>): ZodPrefault<this>;\n    array(): ZodArray<this>;\n    or<T extends core.SomeType>(option: T): ZodUnion<[this, T]>;\n    and<T extends core.SomeType>(incoming: T): ZodIntersection<this, T>;\n    transform<NewOut>(transform: (arg: core.output<this>, ctx: RefinementCtx<core.output<this>>) => NewOut | Promise<NewOut>): ZodPipe<this, ZodTransform<Awaited<NewOut>, core.output<this>>>;\n    catch(def: core.output<this>): ZodCatch<this>;\n    catch(def: (ctx: core.$ZodCatchCtx) => core.output<this>): ZodCatch<this>;\n    pipe<T extends core.$ZodType<any, core.output<this>>>(target: T | core.$ZodType<any, core.output<this>>): ZodPipe<this, T>;\n    readonly(): ZodReadonly<this>;\n    /** Returns a new instance that has been registered in `z.globalRegistry` with the specified description */\n    describe(description: string): this;\n    description?: string;\n    /** Returns the metadata associated with this instance in `z.globalRegistry` */\n    meta(): core.$replace<core.GlobalMeta, this> | undefined;\n    /** Returns a new instance that has been registered in `z.globalRegistry` with the specified metadata */\n    meta(data: core.$replace<core.GlobalMeta, this>): this;\n    /** @deprecated Try safe-parsing `undefined` (this is what `isOptional` does internally):\n     *\n     * ```ts\n     * const schema = z.string().optional();\n     * const isOptional = schema.safeParse(undefined).success; // true\n     * ```\n     */\n    isOptional(): boolean;\n    /**\n     * @deprecated Try safe-parsing `null` (this is what `isNullable` does internally):\n     *\n     * ```ts\n     * const schema = z.string().nullable();\n     * const isNullable = schema.safeParse(null).success; // true\n     * ```\n     */\n    isNullable(): boolean;\n}\nexport interface _ZodType<out Internals extends core.$ZodTypeInternals = core.$ZodTypeInternals> extends ZodType<any, any, Internals> {\n}\nexport declare const ZodType: core.$constructor<ZodType>;\nexport interface _ZodString<T extends core.$ZodStringInternals<unknown> = core.$ZodStringInternals<unknown>> extends _ZodType<T> {\n    format: string | null;\n    minLength: number | null;\n    maxLength: number | null;\n    regex(regex: RegExp, params?: string | core.$ZodCheckRegexParams): this;\n    includes(value: string, params?: core.$ZodCheckIncludesParams): this;\n    startsWith(value: string, params?: string | core.$ZodCheckStartsWithParams): this;\n    endsWith(value: string, params?: string | core.$ZodCheckEndsWithParams): this;\n    min(minLength: number, params?: string | core.$ZodCheckMinLengthParams): this;\n    max(maxLength: number, params?: string | core.$ZodCheckMaxLengthParams): this;\n    length(len: number, params?: string | core.$ZodCheckLengthEqualsParams): this;\n    nonempty(params?: string | core.$ZodCheckMinLengthParams): this;\n    lowercase(params?: string | core.$ZodCheckLowerCaseParams): this;\n    uppercase(params?: string | core.$ZodCheckUpperCaseParams): this;\n    trim(): this;\n    normalize(form?: \"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\" | (string & {})): this;\n    toLowerCase(): this;\n    toUpperCase(): this;\n}\n/** @internal */\nexport declare const _ZodString: core.$constructor<_ZodString>;\nexport interface ZodString extends _ZodString<core.$ZodStringInternals<string>> {\n    /** @deprecated Use `z.email()` instead. */\n    email(params?: string | core.$ZodCheckEmailParams): this;\n    /** @deprecated Use `z.url()` instead. */\n    url(params?: string | core.$ZodCheckURLParams): this;\n    /** @deprecated Use `z.jwt()` instead. */\n    jwt(params?: string | core.$ZodCheckJWTParams): this;\n    /** @deprecated Use `z.emoji()` instead. */\n    emoji(params?: string | core.$ZodCheckEmojiParams): this;\n    /** @deprecated Use `z.guid()` instead. */\n    guid(params?: string | core.$ZodCheckGUIDParams): this;\n    /** @deprecated Use `z.uuid()` instead. */\n    uuid(params?: string | core.$ZodCheckUUIDParams): this;\n    /** @deprecated Use `z.uuid()` instead. */\n    uuidv4(params?: string | core.$ZodCheckUUIDParams): this;\n    /** @deprecated Use `z.uuid()` instead. */\n    uuidv6(params?: string | core.$ZodCheckUUIDParams): this;\n    /** @deprecated Use `z.uuid()` instead. */\n    uuidv7(params?: string | core.$ZodCheckUUIDParams): this;\n    /** @deprecated Use `z.nanoid()` instead. */\n    nanoid(params?: string | core.$ZodCheckNanoIDParams): this;\n    /** @deprecated Use `z.guid()` instead. */\n    guid(params?: string | core.$ZodCheckGUIDParams): this;\n    /** @deprecated Use `z.cuid()` instead. */\n    cuid(params?: string | core.$ZodCheckCUIDParams): this;\n    /** @deprecated Use `z.cuid2()` instead. */\n    cuid2(params?: string | core.$ZodCheckCUID2Params): this;\n    /** @deprecated Use `z.ulid()` instead. */\n    ulid(params?: string | core.$ZodCheckULIDParams): this;\n    /** @deprecated Use `z.base64()` instead. */\n    base64(params?: string | core.$ZodCheckBase64Params): this;\n    /** @deprecated Use `z.base64url()` instead. */\n    base64url(params?: string | core.$ZodCheckBase64URLParams): this;\n    /** @deprecated Use `z.xid()` instead. */\n    xid(params?: string | core.$ZodCheckXIDParams): this;\n    /** @deprecated Use `z.ksuid()` instead. */\n    ksuid(params?: string | core.$ZodCheckKSUIDParams): this;\n    /** @deprecated Use `z.ipv4()` instead. */\n    ipv4(params?: string | core.$ZodCheckIPv4Params): this;\n    /** @deprecated Use `z.ipv6()` instead. */\n    ipv6(params?: string | core.$ZodCheckIPv6Params): this;\n    /** @deprecated Use `z.cidrv4()` instead. */\n    cidrv4(params?: string | core.$ZodCheckCIDRv4Params): this;\n    /** @deprecated Use `z.cidrv6()` instead. */\n    cidrv6(params?: string | core.$ZodCheckCIDRv6Params): this;\n    /** @deprecated Use `z.e164()` instead. */\n    e164(params?: string | core.$ZodCheckE164Params): this;\n    /** @deprecated Use `z.iso.datetime()` instead. */\n    datetime(params?: string | core.$ZodCheckISODateTimeParams): this;\n    /** @deprecated Use `z.iso.date()` instead. */\n    date(params?: string | core.$ZodCheckISODateParams): this;\n    /** @deprecated Use `z.iso.time()` instead. */\n    time(params?: string | core.$ZodCheckISOTimeParams): this;\n    /** @deprecated Use `z.iso.duration()` instead. */\n    duration(params?: string | core.$ZodCheckISODurationParams): this;\n}\nexport declare const ZodString: core.$constructor<ZodString>;\nexport declare function string(params?: string | core.$ZodStringParams): ZodString;\nexport declare function string<T extends string>(params?: string | core.$ZodStringParams): core.$ZodType<T, T>;\nexport interface ZodStringFormat<Format extends string = string> extends _ZodString<core.$ZodStringFormatInternals<Format>> {\n}\nexport declare const ZodStringFormat: core.$constructor<ZodStringFormat>;\nexport interface ZodEmail extends ZodStringFormat<\"email\"> {\n    _zod: core.$ZodEmailInternals;\n}\nexport declare const ZodEmail: core.$constructor<ZodEmail>;\nexport declare function email(params?: string | core.$ZodEmailParams): ZodEmail;\nexport interface ZodGUID extends ZodStringFormat<\"guid\"> {\n    _zod: core.$ZodGUIDInternals;\n}\nexport declare const ZodGUID: core.$constructor<ZodGUID>;\nexport declare function guid(params?: string | core.$ZodGUIDParams): ZodGUID;\nexport interface ZodUUID extends ZodStringFormat<\"uuid\"> {\n    _zod: core.$ZodUUIDInternals;\n}\nexport declare const ZodUUID: core.$constructor<ZodUUID>;\nexport declare function uuid(params?: string | core.$ZodUUIDParams): ZodUUID;\nexport declare function uuidv4(params?: string | core.$ZodUUIDv4Params): ZodUUID;\nexport declare function uuidv6(params?: string | core.$ZodUUIDv6Params): ZodUUID;\nexport declare function uuidv7(params?: string | core.$ZodUUIDv7Params): ZodUUID;\nexport interface ZodURL extends ZodStringFormat<\"url\"> {\n    _zod: core.$ZodURLInternals;\n}\nexport declare const ZodURL: core.$constructor<ZodURL>;\nexport declare function url(params?: string | core.$ZodURLParams): ZodURL;\nexport interface ZodEmoji extends ZodStringFormat<\"emoji\"> {\n    _zod: core.$ZodEmojiInternals;\n}\nexport declare const ZodEmoji: core.$constructor<ZodEmoji>;\nexport declare function emoji(params?: string | core.$ZodEmojiParams): ZodEmoji;\nexport interface ZodNanoID extends ZodStringFormat<\"nanoid\"> {\n    _zod: core.$ZodNanoIDInternals;\n}\nexport declare const ZodNanoID: core.$constructor<ZodNanoID>;\nexport declare function nanoid(params?: string | core.$ZodNanoIDParams): ZodNanoID;\nexport interface ZodCUID extends ZodStringFormat<\"cuid\"> {\n    _zod: core.$ZodCUIDInternals;\n}\nexport declare const ZodCUID: core.$constructor<ZodCUID>;\nexport declare function cuid(params?: string | core.$ZodCUIDParams): ZodCUID;\nexport interface ZodCUID2 extends ZodStringFormat<\"cuid2\"> {\n    _zod: core.$ZodCUID2Internals;\n}\nexport declare const ZodCUID2: core.$constructor<ZodCUID2>;\nexport declare function cuid2(params?: string | core.$ZodCUID2Params): ZodCUID2;\nexport interface ZodULID extends ZodStringFormat<\"ulid\"> {\n    _zod: core.$ZodULIDInternals;\n}\nexport declare const ZodULID: core.$constructor<ZodULID>;\nexport declare function ulid(params?: string | core.$ZodULIDParams): ZodULID;\nexport interface ZodXID extends ZodStringFormat<\"xid\"> {\n    _zod: core.$ZodXIDInternals;\n}\nexport declare const ZodXID: core.$constructor<ZodXID>;\nexport declare function xid(params?: string | core.$ZodXIDParams): ZodXID;\nexport interface ZodKSUID extends ZodStringFormat<\"ksuid\"> {\n    _zod: core.$ZodKSUIDInternals;\n}\nexport declare const ZodKSUID: core.$constructor<ZodKSUID>;\nexport declare function ksuid(params?: string | core.$ZodKSUIDParams): ZodKSUID;\nexport interface ZodIPv4 extends ZodStringFormat<\"ipv4\"> {\n    _zod: core.$ZodIPv4Internals;\n}\nexport declare const ZodIPv4: core.$constructor<ZodIPv4>;\nexport declare function ipv4(params?: string | core.$ZodIPv4Params): ZodIPv4;\nexport interface ZodIPv6 extends ZodStringFormat<\"ipv6\"> {\n    _zod: core.$ZodIPv6Internals;\n}\nexport declare const ZodIPv6: core.$constructor<ZodIPv6>;\nexport declare function ipv6(params?: string | core.$ZodIPv6Params): ZodIPv6;\nexport interface ZodCIDRv4 extends ZodStringFormat<\"cidrv4\"> {\n    _zod: core.$ZodCIDRv4Internals;\n}\nexport declare const ZodCIDRv4: core.$constructor<ZodCIDRv4>;\nexport declare function cidrv4(params?: string | core.$ZodCIDRv4Params): ZodCIDRv4;\nexport interface ZodCIDRv6 extends ZodStringFormat<\"cidrv6\"> {\n    _zod: core.$ZodCIDRv6Internals;\n}\nexport declare const ZodCIDRv6: core.$constructor<ZodCIDRv6>;\nexport declare function cidrv6(params?: string | core.$ZodCIDRv6Params): ZodCIDRv6;\nexport interface ZodBase64 extends ZodStringFormat<\"base64\"> {\n    _zod: core.$ZodBase64Internals;\n}\nexport declare const ZodBase64: core.$constructor<ZodBase64>;\nexport declare function base64(params?: string | core.$ZodBase64Params): ZodBase64;\nexport interface ZodBase64URL extends ZodStringFormat<\"base64url\"> {\n    _zod: core.$ZodBase64URLInternals;\n}\nexport declare const ZodBase64URL: core.$constructor<ZodBase64URL>;\nexport declare function base64url(params?: string | core.$ZodBase64URLParams): ZodBase64URL;\nexport interface ZodE164 extends ZodStringFormat<\"e164\"> {\n    _zod: core.$ZodE164Internals;\n}\nexport declare const ZodE164: core.$constructor<ZodE164>;\nexport declare function e164(params?: string | core.$ZodE164Params): ZodE164;\nexport interface ZodJWT extends ZodStringFormat<\"jwt\"> {\n    _zod: core.$ZodJWTInternals;\n}\nexport declare const ZodJWT: core.$constructor<ZodJWT>;\nexport declare function jwt(params?: string | core.$ZodJWTParams): ZodJWT;\nexport interface ZodCustomStringFormat<Format extends string = string> extends ZodStringFormat<Format>, core.$ZodCustomStringFormat<Format> {\n    _zod: core.$ZodCustomStringFormatInternals<Format>;\n}\nexport declare const ZodCustomStringFormat: core.$constructor<ZodCustomStringFormat>;\nexport declare function stringFormat<Format extends string>(format: Format, fnOrRegex: ((arg: string) => util.MaybeAsync<unknown>) | RegExp, _params?: string | core.$ZodStringFormatParams): ZodCustomStringFormat<Format>;\nexport interface _ZodNumber<Internals extends core.$ZodNumberInternals = core.$ZodNumberInternals> extends _ZodType<Internals> {\n    gt(value: number, params?: string | core.$ZodCheckGreaterThanParams): this;\n    /** Identical to .min() */\n    gte(value: number, params?: string | core.$ZodCheckGreaterThanParams): this;\n    min(value: number, params?: string | core.$ZodCheckGreaterThanParams): this;\n    lt(value: number, params?: string | core.$ZodCheckLessThanParams): this;\n    /** Identical to .max() */\n    lte(value: number, params?: string | core.$ZodCheckLessThanParams): this;\n    max(value: number, params?: string | core.$ZodCheckLessThanParams): this;\n    /** Consider `z.int()` instead. This API is considered *legacy*; it will never be removed but a better alternative exists. */\n    int(params?: string | core.$ZodCheckNumberFormatParams): this;\n    /** @deprecated This is now identical to `.int()`. Only numbers in the safe integer range are accepted. */\n    safe(params?: string | core.$ZodCheckNumberFormatParams): this;\n    positive(params?: string | core.$ZodCheckGreaterThanParams): this;\n    nonnegative(params?: string | core.$ZodCheckGreaterThanParams): this;\n    negative(params?: string | core.$ZodCheckLessThanParams): this;\n    nonpositive(params?: string | core.$ZodCheckLessThanParams): this;\n    multipleOf(value: number, params?: string | core.$ZodCheckMultipleOfParams): this;\n    /** @deprecated Use `.multipleOf()` instead. */\n    step(value: number, params?: string | core.$ZodCheckMultipleOfParams): this;\n    /** @deprecated In v4 and later, z.number() does not allow infinite values by default. This is a no-op. */\n    finite(params?: unknown): this;\n    minValue: number | null;\n    maxValue: number | null;\n    /** @deprecated Check the `format` property instead.  */\n    isInt: boolean;\n    /** @deprecated Number schemas no longer accept infinite values, so this always returns `true`. */\n    isFinite: boolean;\n    format: string | null;\n}\nexport interface ZodNumber extends _ZodNumber<core.$ZodNumberInternals<number>> {\n}\nexport declare const ZodNumber: core.$constructor<ZodNumber>;\nexport declare function number(params?: string | core.$ZodNumberParams): ZodNumber;\nexport interface ZodNumberFormat extends ZodNumber {\n    _zod: core.$ZodNumberFormatInternals;\n}\nexport declare const ZodNumberFormat: core.$constructor<ZodNumberFormat>;\nexport interface ZodInt extends ZodNumberFormat {\n}\nexport declare function int(params?: string | core.$ZodCheckNumberFormatParams): ZodInt;\nexport interface ZodFloat32 extends ZodNumberFormat {\n}\nexport declare function float32(params?: string | core.$ZodCheckNumberFormatParams): ZodFloat32;\nexport interface ZodFloat64 extends ZodNumberFormat {\n}\nexport declare function float64(params?: string | core.$ZodCheckNumberFormatParams): ZodFloat64;\nexport interface ZodInt32 extends ZodNumberFormat {\n}\nexport declare function int32(params?: string | core.$ZodCheckNumberFormatParams): ZodInt32;\nexport interface ZodUInt32 extends ZodNumberFormat {\n}\nexport declare function uint32(params?: string | core.$ZodCheckNumberFormatParams): ZodUInt32;\nexport interface _ZodBoolean<T extends core.$ZodBooleanInternals = core.$ZodBooleanInternals> extends _ZodType<T> {\n}\nexport interface ZodBoolean extends _ZodBoolean<core.$ZodBooleanInternals<boolean>> {\n}\nexport declare const ZodBoolean: core.$constructor<ZodBoolean>;\nexport declare function boolean(params?: string | core.$ZodBooleanParams): ZodBoolean;\nexport interface _ZodBigInt<T extends core.$ZodBigIntInternals = core.$ZodBigIntInternals> extends _ZodType<T> {\n    gte(value: bigint, params?: string | core.$ZodCheckGreaterThanParams): this;\n    /** Alias of `.gte()` */\n    min(value: bigint, params?: string | core.$ZodCheckGreaterThanParams): this;\n    gt(value: bigint, params?: string | core.$ZodCheckGreaterThanParams): this;\n    /** Alias of `.lte()` */\n    lte(value: bigint, params?: string | core.$ZodCheckLessThanParams): this;\n    max(value: bigint, params?: string | core.$ZodCheckLessThanParams): this;\n    lt(value: bigint, params?: string | core.$ZodCheckLessThanParams): this;\n    positive(params?: string | core.$ZodCheckGreaterThanParams): this;\n    negative(params?: string | core.$ZodCheckLessThanParams): this;\n    nonpositive(params?: string | core.$ZodCheckLessThanParams): this;\n    nonnegative(params?: string | core.$ZodCheckGreaterThanParams): this;\n    multipleOf(value: bigint, params?: string | core.$ZodCheckMultipleOfParams): this;\n    minValue: bigint | null;\n    maxValue: bigint | null;\n    format: string | null;\n}\nexport interface ZodBigInt extends _ZodBigInt<core.$ZodBigIntInternals<bigint>> {\n}\nexport declare const ZodBigInt: core.$constructor<ZodBigInt>;\nexport declare function bigint(params?: string | core.$ZodBigIntParams): ZodBigInt;\nexport interface ZodBigIntFormat extends ZodBigInt {\n    _zod: core.$ZodBigIntFormatInternals;\n}\nexport declare const ZodBigIntFormat: core.$constructor<ZodBigIntFormat>;\nexport declare function int64(params?: string | core.$ZodBigIntFormatParams): ZodBigIntFormat;\nexport declare function uint64(params?: string | core.$ZodBigIntFormatParams): ZodBigIntFormat;\nexport interface ZodSymbol extends _ZodType<core.$ZodSymbolInternals> {\n}\nexport declare const ZodSymbol: core.$constructor<ZodSymbol>;\nexport declare function symbol(params?: string | core.$ZodSymbolParams): ZodSymbol;\nexport interface ZodUndefined extends _ZodType<core.$ZodUndefinedInternals> {\n}\nexport declare const ZodUndefined: core.$constructor<ZodUndefined>;\ndeclare function _undefined(params?: string | core.$ZodUndefinedParams): ZodUndefined;\nexport { _undefined as undefined };\nexport interface ZodNull extends _ZodType<core.$ZodNullInternals> {\n}\nexport declare const ZodNull: core.$constructor<ZodNull>;\ndeclare function _null(params?: string | core.$ZodNullParams): ZodNull;\nexport { _null as null };\nexport interface ZodAny extends _ZodType<core.$ZodAnyInternals> {\n}\nexport declare const ZodAny: core.$constructor<ZodAny>;\nexport declare function any(): ZodAny;\nexport interface ZodUnknown extends _ZodType<core.$ZodUnknownInternals> {\n}\nexport declare const ZodUnknown: core.$constructor<ZodUnknown>;\nexport declare function unknown(): ZodUnknown;\nexport interface ZodNever extends _ZodType<core.$ZodNeverInternals> {\n}\nexport declare const ZodNever: core.$constructor<ZodNever>;\nexport declare function never(params?: string | core.$ZodNeverParams): ZodNever;\nexport interface ZodVoid extends _ZodType<core.$ZodVoidInternals> {\n}\nexport declare const ZodVoid: core.$constructor<ZodVoid>;\ndeclare function _void(params?: string | core.$ZodVoidParams): ZodVoid;\nexport { _void as void };\nexport interface _ZodDate<T extends core.$ZodDateInternals = core.$ZodDateInternals> extends _ZodType<T> {\n    min(value: number | Date, params?: string | core.$ZodCheckGreaterThanParams): this;\n    max(value: number | Date, params?: string | core.$ZodCheckLessThanParams): this;\n    /** @deprecated Not recommended. */\n    minDate: Date | null;\n    /** @deprecated Not recommended. */\n    maxDate: Date | null;\n}\nexport interface ZodDate extends _ZodDate<core.$ZodDateInternals<Date>> {\n}\nexport declare const ZodDate: core.$constructor<ZodDate>;\nexport declare function date(params?: string | core.$ZodDateParams): ZodDate;\nexport interface ZodArray<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodArrayInternals<T>>, core.$ZodArray<T> {\n    element: T;\n    min(minLength: number, params?: string | core.$ZodCheckMinLengthParams): this;\n    nonempty(params?: string | core.$ZodCheckMinLengthParams): this;\n    max(maxLength: number, params?: string | core.$ZodCheckMaxLengthParams): this;\n    length(len: number, params?: string | core.$ZodCheckLengthEqualsParams): this;\n    unwrap(): T;\n}\nexport declare const ZodArray: core.$constructor<ZodArray>;\nexport declare function array<T extends core.SomeType>(element: T, params?: string | core.$ZodArrayParams): ZodArray<T>;\nexport declare function keyof<T extends ZodObject>(schema: T): ZodLiteral<Exclude<keyof T[\"_zod\"][\"output\"], symbol>>;\nexport interface ZodObject<\n/** @ts-ignore Cast variance */\nout Shape extends core.$ZodShape = core.$ZodLooseShape, out Config extends core.$ZodObjectConfig = core.$strip> extends _ZodType<core.$ZodObjectInternals<Shape, Config>>, core.$ZodObject<Shape, Config> {\n    shape: Shape;\n    keyof(): ZodEnum<util.ToEnum<keyof Shape & string>>;\n    /** Define a schema to validate all unrecognized keys. This overrides the existing strict/loose behavior. */\n    catchall<T extends core.SomeType>(schema: T): ZodObject<Shape, core.$catchall<T>>;\n    /** @deprecated Use `z.looseObject()` or `.loose()` instead. */\n    passthrough(): ZodObject<Shape, core.$loose>;\n    /** Consider `z.looseObject(A.shape)` instead */\n    loose(): ZodObject<Shape, core.$loose>;\n    /** Consider `z.strictObject(A.shape)` instead */\n    strict(): ZodObject<Shape, core.$strict>;\n    /** This is the default behavior. This method call is likely unnecessary. */\n    strip(): ZodObject<Shape, core.$strip>;\n    extend<U extends core.$ZodLooseShape & Partial<Record<keyof Shape, core.SomeType>>>(shape: U): ZodObject<util.Extend<Shape, U>, Config>;\n    /**\n     * @deprecated Use spread syntax and the `.shape` property to combine two object schemas:\n     *\n     * ```ts\n     * const A = z.object({ a: z.string() });\n     * const B = z.object({ b: z.number() });\n     *\n     * const C = z.object({\n     *    ...A.shape,\n     *    ...B.shape\n     * });\n     * ```\n     */\n    merge<U extends ZodObject>(other: U): ZodObject<util.Extend<Shape, U[\"shape\"]>, U[\"_zod\"][\"config\"]>;\n    pick<M extends util.Mask<keyof Shape>>(mask: M): ZodObject<util.Flatten<Pick<Shape, Extract<keyof Shape, keyof M>>>, Config>;\n    omit<M extends util.Mask<keyof Shape>>(mask: M): ZodObject<util.Flatten<Omit<Shape, Extract<keyof Shape, keyof M>>>, Config>;\n    partial(): ZodObject<{\n        [k in keyof Shape]: ZodOptional<Shape[k]>;\n    }, Config>;\n    partial<M extends util.Mask<keyof Shape>>(mask: M): ZodObject<{\n        [k in keyof Shape]: k extends keyof M ? ZodOptional<Shape[k]> : Shape[k];\n    }, Config>;\n    required(): ZodObject<{\n        [k in keyof Shape]: ZodNonOptional<Shape[k]>;\n    }, Config>;\n    required<M extends util.Mask<keyof Shape>>(mask: M): ZodObject<{\n        [k in keyof Shape]: k extends keyof M ? ZodNonOptional<Shape[k]> : Shape[k];\n    }, Config>;\n}\nexport declare const ZodObject: core.$constructor<ZodObject>;\nexport declare function object<T extends core.$ZodLooseShape = Partial<Record<never, core.SomeType>>>(shape?: T, params?: string | core.$ZodObjectParams): ZodObject<util.Writeable<T>, core.$strip>;\nexport declare function strictObject<T extends core.$ZodLooseShape>(shape: T, params?: string | core.$ZodObjectParams): ZodObject<T, core.$strict>;\nexport declare function looseObject<T extends core.$ZodLooseShape>(shape: T, params?: string | core.$ZodObjectParams): ZodObject<T, core.$loose>;\nexport interface ZodUnion<T extends readonly core.SomeType[] = readonly core.$ZodType[]> extends _ZodType<core.$ZodUnionInternals<T>>, core.$ZodUnion<T> {\n    options: T;\n}\nexport declare const ZodUnion: core.$constructor<ZodUnion>;\nexport declare function union<const T extends readonly core.SomeType[]>(options: T, params?: string | core.$ZodUnionParams): ZodUnion<T>;\nexport interface ZodDiscriminatedUnion<Options extends readonly core.SomeType[] = readonly core.$ZodType[]> extends ZodUnion<Options>, core.$ZodDiscriminatedUnion<Options> {\n    _zod: core.$ZodDiscriminatedUnionInternals<Options>;\n}\nexport declare const ZodDiscriminatedUnion: core.$constructor<ZodDiscriminatedUnion>;\nexport declare function discriminatedUnion<Types extends readonly [core.$ZodTypeDiscriminable, ...core.$ZodTypeDiscriminable[]]>(discriminator: string, options: Types, params?: string | core.$ZodDiscriminatedUnionParams): ZodDiscriminatedUnion<Types>;\nexport interface ZodIntersection<A extends core.SomeType = core.$ZodType, B extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodIntersectionInternals<A, B>>, core.$ZodIntersection<A, B> {\n}\nexport declare const ZodIntersection: core.$constructor<ZodIntersection>;\nexport declare function intersection<T extends core.SomeType, U extends core.SomeType>(left: T, right: U): ZodIntersection<T, U>;\nexport interface ZodTuple<T extends util.TupleItems = readonly core.$ZodType[], Rest extends core.SomeType | null = core.$ZodType | null> extends _ZodType<core.$ZodTupleInternals<T, Rest>>, core.$ZodTuple<T, Rest> {\n    rest<Rest extends core.SomeType = core.$ZodType>(rest: Rest): ZodTuple<T, Rest>;\n}\nexport declare const ZodTuple: core.$constructor<ZodTuple>;\nexport declare function tuple<T extends readonly [core.SomeType, ...core.SomeType[]]>(items: T, params?: string | core.$ZodTupleParams): ZodTuple<T, null>;\nexport declare function tuple<T extends readonly [core.SomeType, ...core.SomeType[]], Rest extends core.SomeType>(items: T, rest: Rest, params?: string | core.$ZodTupleParams): ZodTuple<T, Rest>;\nexport declare function tuple(items: [], params?: string | core.$ZodTupleParams): ZodTuple<[], null>;\nexport interface ZodRecord<Key extends core.$ZodRecordKey = core.$ZodRecordKey, Value extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodRecordInternals<Key, Value>>, core.$ZodRecord<Key, Value> {\n    keyType: Key;\n    valueType: Value;\n}\nexport declare const ZodRecord: core.$constructor<ZodRecord>;\nexport declare function record<Key extends core.$ZodRecordKey, Value extends core.SomeType>(keyType: Key, valueType: Value, params?: string | core.$ZodRecordParams): ZodRecord<Key, Value>;\nexport declare function partialRecord<Key extends core.$ZodRecordKey, Value extends core.SomeType>(keyType: Key, valueType: Value, params?: string | core.$ZodRecordParams): ZodRecord<Key & core.$partial, Value>;\nexport interface ZodMap<Key extends core.SomeType = core.$ZodType, Value extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodMapInternals<Key, Value>>, core.$ZodMap<Key, Value> {\n    keyType: Key;\n    valueType: Value;\n}\nexport declare const ZodMap: core.$constructor<ZodMap>;\nexport declare function map<Key extends core.SomeType, Value extends core.SomeType>(keyType: Key, valueType: Value, params?: string | core.$ZodMapParams): ZodMap<Key, Value>;\nexport interface ZodSet<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodSetInternals<T>>, core.$ZodSet<T> {\n    min(minSize: number, params?: string | core.$ZodCheckMinSizeParams): this;\n    /** */\n    nonempty(params?: string | core.$ZodCheckMinSizeParams): this;\n    max(maxSize: number, params?: string | core.$ZodCheckMaxSizeParams): this;\n    size(size: number, params?: string | core.$ZodCheckSizeEqualsParams): this;\n}\nexport declare const ZodSet: core.$constructor<ZodSet>;\nexport declare function set<Value extends core.SomeType>(valueType: Value, params?: string | core.$ZodSetParams): ZodSet<Value>;\nexport interface ZodEnum<\n/** @ts-ignore Cast variance */\nout T extends util.EnumLike = util.EnumLike> extends _ZodType<core.$ZodEnumInternals<T>>, core.$ZodEnum<T> {\n    enum: T;\n    options: Array<T[keyof T]>;\n    extract<const U extends readonly (keyof T)[]>(values: U, params?: string | core.$ZodEnumParams): ZodEnum<util.Flatten<Pick<T, U[number]>>>;\n    exclude<const U extends readonly (keyof T)[]>(values: U, params?: string | core.$ZodEnumParams): ZodEnum<util.Flatten<Omit<T, U[number]>>>;\n}\nexport declare const ZodEnum: core.$constructor<ZodEnum>;\ndeclare function _enum<const T extends readonly string[]>(values: T, params?: string | core.$ZodEnumParams): ZodEnum<util.ToEnum<T[number]>>;\ndeclare function _enum<const T extends util.EnumLike>(entries: T, params?: string | core.$ZodEnumParams): ZodEnum<T>;\nexport { _enum as enum };\n/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.\n *\n * ```ts\n * enum Colors { red, green, blue }\n * z.enum(Colors);\n * ```\n */\nexport declare function nativeEnum<T extends util.EnumLike>(entries: T, params?: string | core.$ZodEnumParams): ZodEnum<T>;\nexport interface ZodLiteral<T extends util.Literal = util.Literal> extends _ZodType<core.$ZodLiteralInternals<T>>, core.$ZodLiteral<T> {\n    values: Set<T>;\n    /** @legacy Use `.values` instead. Accessing this property will throw an error if the literal accepts multiple values. */\n    value: T;\n}\nexport declare const ZodLiteral: core.$constructor<ZodLiteral>;\nexport declare function literal<const T extends ReadonlyArray<util.Literal>>(value: T, params?: string | core.$ZodLiteralParams): ZodLiteral<T[number]>;\nexport declare function literal<const T extends util.Literal>(value: T, params?: string | core.$ZodLiteralParams): ZodLiteral<T>;\nexport interface ZodFile extends _ZodType<core.$ZodFileInternals>, core.$ZodFile {\n    min(size: number, params?: string | core.$ZodCheckMinSizeParams): this;\n    max(size: number, params?: string | core.$ZodCheckMaxSizeParams): this;\n    mime(types: util.MimeTypes | Array<util.MimeTypes>, params?: string | core.$ZodCheckMimeTypeParams): this;\n}\nexport declare const ZodFile: core.$constructor<ZodFile>;\nexport declare function file(params?: string | core.$ZodFileParams): ZodFile;\nexport interface ZodTransform<O = unknown, I = unknown> extends _ZodType<core.$ZodTransformInternals<O, I>>, core.$ZodTransform<O, I> {\n}\nexport declare const ZodTransform: core.$constructor<ZodTransform>;\nexport declare function transform<I = unknown, O = I>(fn: (input: I, ctx: core.ParsePayload) => O): ZodTransform<Awaited<O>, I>;\nexport interface ZodOptional<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodOptionalInternals<T>>, core.$ZodOptional<T> {\n    unwrap(): T;\n}\nexport declare const ZodOptional: core.$constructor<ZodOptional>;\nexport declare function optional<T extends core.SomeType>(innerType: T): ZodOptional<T>;\nexport interface ZodNullable<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodNullableInternals<T>>, core.$ZodNullable<T> {\n    unwrap(): T;\n}\nexport declare const ZodNullable: core.$constructor<ZodNullable>;\nexport declare function nullable<T extends core.SomeType>(innerType: T): ZodNullable<T>;\nexport declare function nullish<T extends core.SomeType>(innerType: T): ZodOptional<ZodNullable<T>>;\nexport interface ZodDefault<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodDefaultInternals<T>>, core.$ZodDefault<T> {\n    unwrap(): T;\n    /** @deprecated Use `.unwrap()` instead. */\n    removeDefault(): T;\n}\nexport declare const ZodDefault: core.$constructor<ZodDefault>;\nexport declare function _default<T extends core.SomeType>(innerType: T, defaultValue: util.NoUndefined<core.output<T>> | (() => util.NoUndefined<core.output<T>>)): ZodDefault<T>;\nexport interface ZodPrefault<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodPrefaultInternals<T>>, core.$ZodPrefault<T> {\n    unwrap(): T;\n}\nexport declare const ZodPrefault: core.$constructor<ZodPrefault>;\nexport declare function prefault<T extends core.SomeType>(innerType: T, defaultValue: core.input<T> | (() => core.input<T>)): ZodPrefault<T>;\nexport interface ZodNonOptional<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodNonOptionalInternals<T>>, core.$ZodNonOptional<T> {\n    unwrap(): T;\n}\nexport declare const ZodNonOptional: core.$constructor<ZodNonOptional>;\nexport declare function nonoptional<T extends core.SomeType>(innerType: T, params?: string | core.$ZodNonOptionalParams): ZodNonOptional<T>;\nexport interface ZodSuccess<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodSuccessInternals<T>>, core.$ZodSuccess<T> {\n    unwrap(): T;\n}\nexport declare const ZodSuccess: core.$constructor<ZodSuccess>;\nexport declare function success<T extends core.SomeType>(innerType: T): ZodSuccess<T>;\nexport interface ZodCatch<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodCatchInternals<T>>, core.$ZodCatch<T> {\n    unwrap(): T;\n    /** @deprecated Use `.unwrap()` instead. */\n    removeCatch(): T;\n}\nexport declare const ZodCatch: core.$constructor<ZodCatch>;\ndeclare function _catch<T extends core.SomeType>(innerType: T, catchValue: core.output<T> | ((ctx: core.$ZodCatchCtx) => core.output<T>)): ZodCatch<T>;\nexport { _catch as catch };\nexport interface ZodNaN extends _ZodType<core.$ZodNaNInternals>, core.$ZodNaN {\n}\nexport declare const ZodNaN: core.$constructor<ZodNaN>;\nexport declare function nan(params?: string | core.$ZodNaNParams): ZodNaN;\nexport interface ZodPipe<A extends core.SomeType = core.$ZodType, B extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodPipeInternals<A, B>>, core.$ZodPipe<A, B> {\n    in: A;\n    out: B;\n}\nexport declare const ZodPipe: core.$constructor<ZodPipe>;\nexport declare function pipe<const A extends core.SomeType, B extends core.$ZodType<unknown, core.output<A>> = core.$ZodType<unknown, core.output<A>>>(in_: A, out: B | core.$ZodType<unknown, core.output<A>>): ZodPipe<A, B>;\nexport interface ZodReadonly<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodReadonlyInternals<T>>, core.$ZodReadonly<T> {\n}\nexport declare const ZodReadonly: core.$constructor<ZodReadonly>;\nexport declare function readonly<T extends core.SomeType>(innerType: T): ZodReadonly<T>;\nexport interface ZodTemplateLiteral<Template extends string = string> extends _ZodType<core.$ZodTemplateLiteralInternals<Template>>, core.$ZodTemplateLiteral<Template> {\n}\nexport declare const ZodTemplateLiteral: core.$constructor<ZodTemplateLiteral>;\nexport declare function templateLiteral<const Parts extends core.$ZodTemplateLiteralPart[]>(parts: Parts, params?: string | core.$ZodTemplateLiteralParams): ZodTemplateLiteral<core.$PartsToTemplateLiteral<Parts>>;\nexport interface ZodLazy<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodLazyInternals<T>>, core.$ZodLazy<T> {\n    unwrap(): T;\n}\nexport declare const ZodLazy: core.$constructor<ZodLazy>;\nexport declare function lazy<T extends core.SomeType>(getter: () => T): ZodLazy<T>;\nexport interface ZodPromise<T extends core.SomeType = core.$ZodType> extends _ZodType<core.$ZodPromiseInternals<T>>, core.$ZodPromise<T> {\n    unwrap(): T;\n}\nexport declare const ZodPromise: core.$constructor<ZodPromise>;\nexport declare function promise<T extends core.SomeType>(innerType: T): ZodPromise<T>;\nexport interface ZodCustom<O = unknown, I = unknown> extends _ZodType<core.$ZodCustomInternals<O, I>>, core.$ZodCustom<O, I> {\n}\nexport declare const ZodCustom: core.$constructor<ZodCustom>;\nexport declare function check<O = unknown>(fn: core.CheckFn<O>): core.$ZodCheck<O>;\nexport declare function custom<O>(fn?: (data: unknown) => unknown, _params?: string | core.$ZodCustomParams | undefined): ZodCustom<O, O>;\nexport declare function refine<T>(fn: (arg: NoInfer<T>) => util.MaybeAsync<unknown>, _params?: string | core.$ZodCustomParams): core.$ZodCheck<T>;\nexport declare function superRefine<T>(fn: (arg: T, payload: RefinementCtx<T>) => void | Promise<void>): core.$ZodCheck<T>;\ntype ZodInstanceOfParams = core.Params<ZodCustom, core.$ZodIssueCustom, \"type\" | \"check\" | \"checks\" | \"fn\" | \"abort\" | \"error\" | \"params\" | \"path\">;\ndeclare function _instanceof<T extends typeof util.Class>(cls: T, params?: ZodInstanceOfParams): ZodCustom<InstanceType<T>, InstanceType<T>>;\nexport { _instanceof as instanceof };\nexport declare const stringbool: (_params?: string | core.$ZodStringBoolParams) => ZodPipe<ZodPipe<ZodString, ZodTransform<boolean, string>>, ZodBoolean>;\ntype _ZodJSONSchema = ZodUnion<[\n    ZodString,\n    ZodNumber,\n    ZodBoolean,\n    ZodNull,\n    ZodArray<ZodJSONSchema>,\n    ZodRecord<ZodString, ZodJSONSchema>\n]>;\ntype _ZodJSONSchemaInternals = _ZodJSONSchema[\"_zod\"];\nexport interface ZodJSONSchemaInternals extends _ZodJSONSchemaInternals {\n    output: util.JSONType;\n    input: util.JSONType;\n}\nexport interface ZodJSONSchema extends _ZodJSONSchema {\n    _zod: ZodJSONSchemaInternals;\n}\nexport declare function json(params?: string | core.$ZodCustomParams): ZodJSONSchema;\nexport declare function preprocess<A, U extends core.SomeType, B = unknown>(fn: (arg: B, ctx: RefinementCtx) => A, schema: U): ZodPipe<ZodTransform<A, B>, U>;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/classic/schemas.d.cts",
        "start": 1,
        "end": 630,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 630,
          "column": 2,
          "position": 11305
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/classic/schemas.d.cts",
        "start": 1,
        "end": 630,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 630,
          "column": 2,
          "position": 11305
        }
      }
    },
    {
      "format": "typescript",
      "lines": 23,
      "fragment": "import * as core from \"../core/index.js\";\nimport { type ZodError } from \"./errors.js\";\nexport type ZodSafeParseResult<T> = ZodSafeParseSuccess<T> | ZodSafeParseError<T>;\nexport type ZodSafeParseSuccess<T> = {\n    success: true;\n    data: T;\n    error?: never;\n};\nexport type ZodSafeParseError<T> = {\n    success: false;\n    data?: never;\n    error: ZodError<T>;\n};\nexport declare const parse: <T extends core.$ZodType>(schema: T, value: unknown, _ctx?: core.ParseContext<core.$ZodIssue>, _params?: {\n    callee?: core.util.AnyFunc;\n    Err?: core.$ZodErrorClass;\n}) => core.output<T>;\nexport declare const parseAsync: <T extends core.$ZodType>(schema: T, value: unknown, _ctx?: core.ParseContext<core.$ZodIssue>, _params?: {\n    callee?: core.util.AnyFunc;\n    Err?: core.$ZodErrorClass;\n}) => Promise<core.output<T>>;\nexport declare const safeParse: <T extends core.$ZodType>(schema: T, value: unknown, _ctx?: core.ParseContext<core.$ZodIssue>) => ZodSafeParseResult<core.output<T>>;\nexport declare const safeParseAsync: <T extends core.$ZodType>(schema: T, value: unknown, _ctx?: core.ParseContext<core.$ZodIssue>) => Promise<ZodSafeParseResult<core.output<T>>>;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/classic/parse.d.ts",
        "start": 1,
        "end": 23,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 23,
          "column": 2,
          "position": 419
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/classic/parse.d.ts",
        "start": 1,
        "end": 23,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 23,
          "column": 2,
          "position": 419
        }
      }
    },
    {
      "format": "typescript",
      "lines": 23,
      "fragment": "import * as core from \"../core/index.cjs\";\nimport { type ZodError } from \"./errors.cjs\";\nexport type ZodSafeParseResult<T> = ZodSafeParseSuccess<T> | ZodSafeParseError<T>;\nexport type ZodSafeParseSuccess<T> = {\n    success: true;\n    data: T;\n    error?: never;\n};\nexport type ZodSafeParseError<T> = {\n    success: false;\n    data?: never;\n    error: ZodError<T>;\n};\nexport declare const parse: <T extends core.$ZodType>(schema: T, value: unknown, _ctx?: core.ParseContext<core.$ZodIssue>, _params?: {\n    callee?: core.util.AnyFunc;\n    Err?: core.$ZodErrorClass;\n}) => core.output<T>;\nexport declare const parseAsync: <T extends core.$ZodType>(schema: T, value: unknown, _ctx?: core.ParseContext<core.$ZodIssue>, _params?: {\n    callee?: core.util.AnyFunc;\n    Err?: core.$ZodErrorClass;\n}) => Promise<core.output<T>>;\nexport declare const safeParse: <T extends core.$ZodType>(schema: T, value: unknown, _ctx?: core.ParseContext<core.$ZodIssue>) => ZodSafeParseResult<core.output<T>>;\nexport declare const safeParseAsync: <T extends core.$ZodType>(schema: T, value: unknown, _ctx?: core.ParseContext<core.$ZodIssue>) => Promise<ZodSafeParseResult<core.output<T>>>;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/classic/parse.d.cts",
        "start": 1,
        "end": 23,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 23,
          "column": 2,
          "position": 419
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/classic/parse.d.cts",
        "start": 1,
        "end": 23,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 23,
          "column": 2,
          "position": 419
        }
      }
    },
    {
      "format": "typescript",
      "lines": 22,
      "fragment": "import * as core from \"../core/index.js\";\nimport * as schemas from \"./schemas.js\";\nexport interface ZodISODateTime extends schemas.ZodStringFormat {\n    _zod: core.$ZodISODateTimeInternals;\n}\nexport declare const ZodISODateTime: core.$constructor<ZodISODateTime>;\nexport declare function datetime(params?: string | core.$ZodISODateTimeParams): ZodISODateTime;\nexport interface ZodISODate extends schemas.ZodStringFormat {\n    _zod: core.$ZodISODateInternals;\n}\nexport declare const ZodISODate: core.$constructor<ZodISODate>;\nexport declare function date(params?: string | core.$ZodISODateParams): ZodISODate;\nexport interface ZodISOTime extends schemas.ZodStringFormat {\n    _zod: core.$ZodISOTimeInternals;\n}\nexport declare const ZodISOTime: core.$constructor<ZodISOTime>;\nexport declare function time(params?: string | core.$ZodISOTimeParams): ZodISOTime;\nexport interface ZodISODuration extends schemas.ZodStringFormat {\n    _zod: core.$ZodISODurationInternals;\n}\nexport declare const ZodISODuration: core.$constructor<ZodISODuration>;\nexport declare function duration(params?: string | core.$ZodISODurationParams): ZodISODuration;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/classic/iso.d.ts",
        "start": 1,
        "end": 22,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 22,
          "column": 2,
          "position": 296
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/classic/iso.d.ts",
        "start": 1,
        "end": 22,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 22,
          "column": 2,
          "position": 296
        }
      }
    },
    {
      "format": "typescript",
      "lines": 22,
      "fragment": "import * as core from \"../core/index.cjs\";\nimport * as schemas from \"./schemas.cjs\";\nexport interface ZodISODateTime extends schemas.ZodStringFormat {\n    _zod: core.$ZodISODateTimeInternals;\n}\nexport declare const ZodISODateTime: core.$constructor<ZodISODateTime>;\nexport declare function datetime(params?: string | core.$ZodISODateTimeParams): ZodISODateTime;\nexport interface ZodISODate extends schemas.ZodStringFormat {\n    _zod: core.$ZodISODateInternals;\n}\nexport declare const ZodISODate: core.$constructor<ZodISODate>;\nexport declare function date(params?: string | core.$ZodISODateParams): ZodISODate;\nexport interface ZodISOTime extends schemas.ZodStringFormat {\n    _zod: core.$ZodISOTimeInternals;\n}\nexport declare const ZodISOTime: core.$constructor<ZodISOTime>;\nexport declare function time(params?: string | core.$ZodISOTimeParams): ZodISOTime;\nexport interface ZodISODuration extends schemas.ZodStringFormat {\n    _zod: core.$ZodISODurationInternals;\n}\nexport declare const ZodISODuration: core.$constructor<ZodISODuration>;\nexport declare function duration(params?: string | core.$ZodISODurationParams): ZodISODuration;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/classic/iso.d.cts",
        "start": 1,
        "end": 22,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 22,
          "column": 2,
          "position": 296
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/classic/iso.d.cts",
        "start": 1,
        "end": 22,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 22,
          "column": 2,
          "position": 296
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "export * as core from \"../core/index.js\";\nexport * from \"./schemas.js\";\nexport * from \"./checks.js\";\nexport * from \"./errors.js\";\nexport * from \"./parse.js\";\nexport * from \"./compat.js\";\nexport type { infer, output, input } from \"../core/index.js\";\nexport { globalRegistry, type GlobalMeta, registry, config, function, $output, $input, $brand, clone, regexes, treeifyError, prettifyError, formatError, flattenError, toJSONSchema, TimePrecision, NEVER, } from \"../core/index.js\";\nexport * as locales from \"../locales/index.js\";\nexport { ZodISODateTime, ZodISODate, ZodISOTime, ZodISODuration } from \"./iso.js\";\nexport * as iso from \"./iso.js\";\nexport type { ZodCoercedString, ZodCoercedNumber, ZodCoercedBigInt, ZodCoercedBoolean, ZodCoercedDate, } from \"./coerce.js\";\nexport * as coerce from \"./coerce.js\";",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/classic/external.d.ts",
        "start": 1,
        "end": 13,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 13,
          "column": 2,
          "position": 230
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/classic/external.d.ts",
        "start": 1,
        "end": 13,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 13,
          "column": 2,
          "position": 230
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": "export * as core from \"../core/index.cjs\";\nexport * from \"./schemas.cjs\";\nexport * from \"./checks.cjs\";\nexport * from \"./errors.cjs\";\nexport * from \"./parse.cjs\";\nexport * from \"./compat.cjs\";\nexport type { infer, output, input } from \"../core/index.cjs\";\nexport { globalRegistry, type GlobalMeta, registry, config, function, $output, $input, $brand, clone, regexes, treeifyError, prettifyError, formatError, flattenError, toJSONSchema, TimePrecision, NEVER, } from \"../core/index.cjs\";\nexport * as locales from \"../locales/index.cjs\";\nexport { ZodISODateTime, ZodISODate, ZodISOTime, ZodISODuration } from \"./iso.cjs\";\nexport * as iso from \"./iso.cjs\";\nexport type { ZodCoercedString, ZodCoercedNumber, ZodCoercedBigInt, ZodCoercedBoolean, ZodCoercedDate, } from \"./coerce.cjs\";\nexport * as coerce from \"./coerce.cjs\";",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/classic/external.d.cts",
        "start": 1,
        "end": 13,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 13,
          "column": 2,
          "position": 230
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/classic/external.d.cts",
        "start": 1,
        "end": 13,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 13,
          "column": 2,
          "position": 230
        }
      }
    },
    {
      "format": "typescript",
      "lines": 30,
      "fragment": "import * as core from \"../core/index.js\";\nimport { $ZodError } from \"../core/index.js\";\n/** @deprecated Use `z.core.$ZodIssue` from `@zod/core` instead, especially if you are building a library on top of Zod. */\nexport type ZodIssue = core.$ZodIssue;\n/** An Error-like class used to store Zod validation issues.  */\nexport interface ZodError<T = unknown> extends $ZodError<T> {\n    /** @deprecated Use the `z.treeifyError(err)` function instead. */\n    format(): core.$ZodFormattedError<T>;\n    format<U>(mapper: (issue: core.$ZodIssue) => U): core.$ZodFormattedError<T, U>;\n    /** @deprecated Use the `z.treeifyError(err)` function instead. */\n    flatten(): core.$ZodFlattenedError<T>;\n    flatten<U>(mapper: (issue: core.$ZodIssue) => U): core.$ZodFlattenedError<T, U>;\n    /** @deprecated Push directly to `.issues` instead. */\n    addIssue(issue: core.$ZodIssue): void;\n    /** @deprecated Push directly to `.issues` instead. */\n    addIssues(issues: core.$ZodIssue[]): void;\n    /** @deprecated Check `err.issues.length === 0` instead. */\n    isEmpty: boolean;\n}\nexport declare const ZodError: core.$constructor<ZodError>;\nexport declare const ZodRealError: core.$constructor<ZodError>;\nexport type { \n/** @deprecated Use `z.core.$ZodFlattenedError` instead. */\n$ZodFlattenedError as ZodFlattenedError, \n/** @deprecated Use `z.core.$ZodFormattedError` instead. */\n$ZodFormattedError as ZodFormattedError, \n/** @deprecated Use `z.core.$ZodErrorMap` instead. */\n$ZodErrorMap as ZodErrorMap, } from \"../core/index.js\";\n/** @deprecated Use `z.core.$ZodRawIssue` instead. */\nexport type IssueData = core.$ZodRawIssue;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/classic/errors.d.ts",
        "start": 1,
        "end": 30,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 30,
          "column": 2,
          "position": 311
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v4/classic/errors.ts",
        "start": 1,
        "end": 30,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 30,
          "column": 2,
          "position": 311
        }
      }
    },
    {
      "format": "typescript",
      "lines": 30,
      "fragment": "import * as core from \"../core/index.cjs\";\nimport { $ZodError } from \"../core/index.cjs\";\n/** @deprecated Use `z.core.$ZodIssue` from `@zod/core` instead, especially if you are building a library on top of Zod. */\nexport type ZodIssue = core.$ZodIssue;\n/** An Error-like class used to store Zod validation issues.  */\nexport interface ZodError<T = unknown> extends $ZodError<T> {\n    /** @deprecated Use the `z.treeifyError(err)` function instead. */\n    format(): core.$ZodFormattedError<T>;\n    format<U>(mapper: (issue: core.$ZodIssue) => U): core.$ZodFormattedError<T, U>;\n    /** @deprecated Use the `z.treeifyError(err)` function instead. */\n    flatten(): core.$ZodFlattenedError<T>;\n    flatten<U>(mapper: (issue: core.$ZodIssue) => U): core.$ZodFlattenedError<T, U>;\n    /** @deprecated Push directly to `.issues` instead. */\n    addIssue(issue: core.$ZodIssue): void;\n    /** @deprecated Push directly to `.issues` instead. */\n    addIssues(issues: core.$ZodIssue[]): void;\n    /** @deprecated Check `err.issues.length === 0` instead. */\n    isEmpty: boolean;\n}\nexport declare const ZodError: core.$constructor<ZodError>;\nexport declare const ZodRealError: core.$constructor<ZodError>;\nexport type { \n/** @deprecated Use `z.core.$ZodFlattenedError` instead. */\n$ZodFlattenedError as ZodFlattenedError, \n/** @deprecated Use `z.core.$ZodFormattedError` instead. */\n$ZodFormattedError as ZodFormattedError, \n/** @deprecated Use `z.core.$ZodErrorMap` instead. */\n$ZodErrorMap as ZodErrorMap, } from \"../core/index.cjs\";\n/** @deprecated Use `z.core.$ZodRawIssue` instead. */\nexport type IssueData = core.$ZodRawIssue;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/classic/errors.d.cts",
        "start": 1,
        "end": 30,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 30,
          "column": 2,
          "position": 311
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/classic/errors.d.cts",
        "start": 1,
        "end": 30,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 30,
          "column": 2,
          "position": 311
        }
      }
    },
    {
      "format": "typescript",
      "lines": 46,
      "fragment": "import * as core from \"../core/index.js\";\nimport type { ZodType } from \"./schemas.js\";\nexport type { \n/** @deprecated Use `z.output<T>` instead. */\noutput as TypeOf, \n/** @deprecated Use `z.output<T>` instead. */\noutput as Infer, \n/** @deprecated Use `z.core.$$ZodFirstPartyTypes` instead */\n$ZodTypes as ZodFirstPartySchemaTypes, } from \"../core/index.js\";\n/** @deprecated Use the raw string literal codes instead, e.g. \"invalid_type\". */\nexport declare const ZodIssueCode: {\n    readonly invalid_type: \"invalid_type\";\n    readonly too_big: \"too_big\";\n    readonly too_small: \"too_small\";\n    readonly invalid_format: \"invalid_format\";\n    readonly not_multiple_of: \"not_multiple_of\";\n    readonly unrecognized_keys: \"unrecognized_keys\";\n    readonly invalid_union: \"invalid_union\";\n    readonly invalid_key: \"invalid_key\";\n    readonly invalid_element: \"invalid_element\";\n    readonly invalid_value: \"invalid_value\";\n    readonly custom: \"custom\";\n};\n/** @deprecated Use `z.$ZodFlattenedError` */\nexport type inferFlattenedErrors<T extends core.$ZodType, U = string> = core.$ZodFlattenedError<core.output<T>, U>;\n/** @deprecated Use `z.$ZodFormattedError` */\nexport type inferFormattedError<T extends core.$ZodType<any, any>, U = string> = core.$ZodFormattedError<core.output<T>, U>;\n/** Use `z.$brand` instead */\nexport type BRAND<T extends string | number | symbol = string | number | symbol> = {\n    [core.$brand]: {\n        [k in T]: true;\n    };\n};\nexport { $brand, config } from \"../core/index.js\";\n/** @deprecated Use `z.config(params)` instead. */\nexport declare function setErrorMap(map: core.$ZodErrorMap): void;\n/** @deprecated Use `z.config()` instead. */\nexport declare function getErrorMap(): core.$ZodErrorMap<core.$ZodIssue> | undefined;\nexport type { \n/** @deprecated Use z.ZodType (without generics) instead. */\nZodType as ZodTypeAny, \n/** @deprecated Use `z.ZodType` */\nZodType as ZodSchema, \n/** @deprecated Use `z.ZodType` */\nZodType as Schema, };\nexport type ZodRawShape = core.$ZodShape;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/classic/compat.d.ts",
        "start": 1,
        "end": 46,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 46,
          "column": 2,
          "position": 460
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/classic/compat.d.ts",
        "start": 1,
        "end": 46,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 46,
          "column": 2,
          "position": 460
        }
      }
    },
    {
      "format": "typescript",
      "lines": 46,
      "fragment": "import * as core from \"../core/index.cjs\";\nimport type { ZodType } from \"./schemas.cjs\";\nexport type { \n/** @deprecated Use `z.output<T>` instead. */\noutput as TypeOf, \n/** @deprecated Use `z.output<T>` instead. */\noutput as Infer, \n/** @deprecated Use `z.core.$$ZodFirstPartyTypes` instead */\n$ZodTypes as ZodFirstPartySchemaTypes, } from \"../core/index.cjs\";\n/** @deprecated Use the raw string literal codes instead, e.g. \"invalid_type\". */\nexport declare const ZodIssueCode: {\n    readonly invalid_type: \"invalid_type\";\n    readonly too_big: \"too_big\";\n    readonly too_small: \"too_small\";\n    readonly invalid_format: \"invalid_format\";\n    readonly not_multiple_of: \"not_multiple_of\";\n    readonly unrecognized_keys: \"unrecognized_keys\";\n    readonly invalid_union: \"invalid_union\";\n    readonly invalid_key: \"invalid_key\";\n    readonly invalid_element: \"invalid_element\";\n    readonly invalid_value: \"invalid_value\";\n    readonly custom: \"custom\";\n};\n/** @deprecated Use `z.$ZodFlattenedError` */\nexport type inferFlattenedErrors<T extends core.$ZodType, U = string> = core.$ZodFlattenedError<core.output<T>, U>;\n/** @deprecated Use `z.$ZodFormattedError` */\nexport type inferFormattedError<T extends core.$ZodType<any, any>, U = string> = core.$ZodFormattedError<core.output<T>, U>;\n/** Use `z.$brand` instead */\nexport type BRAND<T extends string | number | symbol = string | number | symbol> = {\n    [core.$brand]: {\n        [k in T]: true;\n    };\n};\nexport { $brand, config } from \"../core/index.cjs\";\n/** @deprecated Use `z.config(params)` instead. */\nexport declare function setErrorMap(map: core.$ZodErrorMap): void;\n/** @deprecated Use `z.config()` instead. */\nexport declare function getErrorMap(): core.$ZodErrorMap<core.$ZodIssue> | undefined;\nexport type { \n/** @deprecated Use z.ZodType (without generics) instead. */\nZodType as ZodTypeAny, \n/** @deprecated Use `z.ZodType` */\nZodType as ZodSchema, \n/** @deprecated Use `z.ZodType` */\nZodType as Schema, };\nexport type ZodRawShape = core.$ZodShape;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/classic/compat.d.cts",
        "start": 1,
        "end": 46,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 46,
          "column": 2,
          "position": 460
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/classic/compat.d.cts",
        "start": 1,
        "end": 46,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 46,
          "column": 2,
          "position": 460
        }
      }
    },
    {
      "format": "typescript",
      "lines": 17,
      "fragment": "import * as core from \"../core/index.js\";\nimport * as schemas from \"./schemas.js\";\nexport interface ZodCoercedString<T = unknown> extends schemas._ZodString<core.$ZodStringInternals<T>> {\n}\nexport declare function string<T = unknown>(params?: string | core.$ZodStringParams): ZodCoercedString<T>;\nexport interface ZodCoercedNumber<T = unknown> extends schemas._ZodNumber<core.$ZodNumberInternals<T>> {\n}\nexport declare function number<T = unknown>(params?: string | core.$ZodNumberParams): ZodCoercedNumber<T>;\nexport interface ZodCoercedBoolean<T = unknown> extends schemas._ZodBoolean<core.$ZodBooleanInternals<T>> {\n}\nexport declare function boolean<T = unknown>(params?: string | core.$ZodBooleanParams): ZodCoercedBoolean<T>;\nexport interface ZodCoercedBigInt<T = unknown> extends schemas._ZodBigInt<core.$ZodBigIntInternals<T>> {\n}\nexport declare function bigint<T = unknown>(params?: string | core.$ZodBigIntParams): ZodCoercedBigInt<T>;\nexport interface ZodCoercedDate<T = unknown> extends schemas._ZodDate<core.$ZodDateInternals<T>> {\n}\nexport declare function date<T = unknown>(params?: string | core.$ZodDateParams): ZodCoercedDate<T>;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/classic/coerce.d.ts",
        "start": 1,
        "end": 17,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 17,
          "column": 2,
          "position": 349
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/classic/coerce.d.ts",
        "start": 1,
        "end": 17,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 17,
          "column": 2,
          "position": 349
        }
      }
    },
    {
      "format": "typescript",
      "lines": 17,
      "fragment": "import * as core from \"../core/index.cjs\";\nimport * as schemas from \"./schemas.cjs\";\nexport interface ZodCoercedString<T = unknown> extends schemas._ZodString<core.$ZodStringInternals<T>> {\n}\nexport declare function string<T = unknown>(params?: string | core.$ZodStringParams): ZodCoercedString<T>;\nexport interface ZodCoercedNumber<T = unknown> extends schemas._ZodNumber<core.$ZodNumberInternals<T>> {\n}\nexport declare function number<T = unknown>(params?: string | core.$ZodNumberParams): ZodCoercedNumber<T>;\nexport interface ZodCoercedBoolean<T = unknown> extends schemas._ZodBoolean<core.$ZodBooleanInternals<T>> {\n}\nexport declare function boolean<T = unknown>(params?: string | core.$ZodBooleanParams): ZodCoercedBoolean<T>;\nexport interface ZodCoercedBigInt<T = unknown> extends schemas._ZodBigInt<core.$ZodBigIntInternals<T>> {\n}\nexport declare function bigint<T = unknown>(params?: string | core.$ZodBigIntParams): ZodCoercedBigInt<T>;\nexport interface ZodCoercedDate<T = unknown> extends schemas._ZodDate<core.$ZodDateInternals<T>> {\n}\nexport declare function date<T = unknown>(params?: string | core.$ZodDateParams): ZodCoercedDate<T>;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v4/classic/coerce.d.cts",
        "start": 1,
        "end": 17,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 17,
          "column": 2,
          "position": 349
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v4/classic/coerce.d.cts",
        "start": 1,
        "end": 17,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 17,
          "column": 2,
          "position": 349
        }
      }
    },
    {
      "format": "typescript",
      "lines": 85,
      "fragment": "export declare namespace util {\n    type AssertEqual<T, U> = (<V>() => V extends T ? 1 : 2) extends <V>() => V extends U ? 1 : 2 ? true : false;\n    export type isAny<T> = 0 extends 1 & T ? true : false;\n    export const assertEqual: <A, B>(_: AssertEqual<A, B>) => void;\n    export function assertIs<T>(_arg: T): void;\n    export function assertNever(_x: never): never;\n    export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n    export type OmitKeys<T, K extends string> = Pick<T, Exclude<keyof T, K>>;\n    export type MakePartial<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n    export type Exactly<T, X> = T & Record<Exclude<keyof X, keyof T>, never>;\n    export type InexactPartial<T> = {\n        [k in keyof T]?: T[k] | undefined;\n    };\n    export const arrayToEnum: <T extends string, U extends [T, ...T[]]>(items: U) => { [k in U[number]]: k; };\n    export const getValidEnumValues: (obj: any) => any[];\n    export const objectValues: (obj: any) => any[];\n    export const objectKeys: ObjectConstructor[\"keys\"];\n    export const find: <T>(arr: T[], checker: (arg: T) => any) => T | undefined;\n    export type identity<T> = objectUtil.identity<T>;\n    export type flatten<T> = objectUtil.flatten<T>;\n    export type noUndefined<T> = T extends undefined ? never : T;\n    export const isInteger: NumberConstructor[\"isInteger\"];\n    export function joinValues<T extends any[]>(array: T, separator?: string): string;\n    export const jsonStringifyReplacer: (_: string, value: any) => any;\n    export {};\n}\nexport declare namespace objectUtil {\n    export type MergeShapes<U, V> = keyof U & keyof V extends never ? U & V : {\n        [k in Exclude<keyof U, keyof V>]: U[k];\n    } & V;\n    type optionalKeys<T extends object> = {\n        [k in keyof T]: undefined extends T[k] ? k : never;\n    }[keyof T];\n    type requiredKeys<T extends object> = {\n        [k in keyof T]: undefined extends T[k] ? never : k;\n    }[keyof T];\n    export type addQuestionMarks<T extends object, _O = any> = {\n        [K in requiredKeys<T>]: T[K];\n    } & {\n        [K in optionalKeys<T>]?: T[K];\n    } & {\n        [k in keyof T]?: unknown;\n    };\n    export type identity<T> = T;\n    export type flatten<T> = identity<{\n        [k in keyof T]: T[k];\n    }>;\n    export type noNeverKeys<T> = {\n        [k in keyof T]: [T[k]] extends [never] ? never : k;\n    }[keyof T];\n    export type noNever<T> = identity<{\n        [k in noNeverKeys<T>]: k extends keyof T ? T[k] : never;\n    }>;\n    export const mergeShapes: <U, T>(first: U, second: T) => T & U;\n    export type extendShape<A extends object, B extends object> = keyof A & keyof B extends never ? A & B : {\n        [K in keyof A as K extends keyof B ? never : K]: A[K];\n    } & {\n        [K in keyof B]: B[K];\n    };\n    export {};\n}\nexport declare const ZodParsedType: {\n    string: \"string\";\n    nan: \"nan\";\n    number: \"number\";\n    integer: \"integer\";\n    float: \"float\";\n    boolean: \"boolean\";\n    date: \"date\";\n    bigint: \"bigint\";\n    symbol: \"symbol\";\n    function: \"function\";\n    undefined: \"undefined\";\n    null: \"null\";\n    array: \"array\";\n    object: \"object\";\n    unknown: \"unknown\";\n    promise: \"promise\";\n    void: \"void\";\n    never: \"never\";\n    map: \"map\";\n    set: \"set\";\n};\nexport type ZodParsedType = keyof typeof ZodParsedType;\nexport declare const getParsedType: (data: any) => ZodParsedType;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v3/helpers/util.d.ts",
        "start": 1,
        "end": 85,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 85,
          "column": 2,
          "position": 1488
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v3/helpers/util.d.ts",
        "start": 1,
        "end": 85,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 85,
          "column": 2,
          "position": 1488
        }
      }
    },
    {
      "format": "typescript",
      "lines": 85,
      "fragment": "export declare namespace util {\n    type AssertEqual<T, U> = (<V>() => V extends T ? 1 : 2) extends <V>() => V extends U ? 1 : 2 ? true : false;\n    export type isAny<T> = 0 extends 1 & T ? true : false;\n    export const assertEqual: <A, B>(_: AssertEqual<A, B>) => void;\n    export function assertIs<T>(_arg: T): void;\n    export function assertNever(_x: never): never;\n    export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n    export type OmitKeys<T, K extends string> = Pick<T, Exclude<keyof T, K>>;\n    export type MakePartial<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n    export type Exactly<T, X> = T & Record<Exclude<keyof X, keyof T>, never>;\n    export type InexactPartial<T> = {\n        [k in keyof T]?: T[k] | undefined;\n    };\n    export const arrayToEnum: <T extends string, U extends [T, ...T[]]>(items: U) => { [k in U[number]]: k; };\n    export const getValidEnumValues: (obj: any) => any[];\n    export const objectValues: (obj: any) => any[];\n    export const objectKeys: ObjectConstructor[\"keys\"];\n    export const find: <T>(arr: T[], checker: (arg: T) => any) => T | undefined;\n    export type identity<T> = objectUtil.identity<T>;\n    export type flatten<T> = objectUtil.flatten<T>;\n    export type noUndefined<T> = T extends undefined ? never : T;\n    export const isInteger: NumberConstructor[\"isInteger\"];\n    export function joinValues<T extends any[]>(array: T, separator?: string): string;\n    export const jsonStringifyReplacer: (_: string, value: any) => any;\n    export {};\n}\nexport declare namespace objectUtil {\n    export type MergeShapes<U, V> = keyof U & keyof V extends never ? U & V : {\n        [k in Exclude<keyof U, keyof V>]: U[k];\n    } & V;\n    type optionalKeys<T extends object> = {\n        [k in keyof T]: undefined extends T[k] ? k : never;\n    }[keyof T];\n    type requiredKeys<T extends object> = {\n        [k in keyof T]: undefined extends T[k] ? never : k;\n    }[keyof T];\n    export type addQuestionMarks<T extends object, _O = any> = {\n        [K in requiredKeys<T>]: T[K];\n    } & {\n        [K in optionalKeys<T>]?: T[K];\n    } & {\n        [k in keyof T]?: unknown;\n    };\n    export type identity<T> = T;\n    export type flatten<T> = identity<{\n        [k in keyof T]: T[k];\n    }>;\n    export type noNeverKeys<T> = {\n        [k in keyof T]: [T[k]] extends [never] ? never : k;\n    }[keyof T];\n    export type noNever<T> = identity<{\n        [k in noNeverKeys<T>]: k extends keyof T ? T[k] : never;\n    }>;\n    export const mergeShapes: <U, T>(first: U, second: T) => T & U;\n    export type extendShape<A extends object, B extends object> = keyof A & keyof B extends never ? A & B : {\n        [K in keyof A as K extends keyof B ? never : K]: A[K];\n    } & {\n        [K in keyof B]: B[K];\n    };\n    export {};\n}\nexport declare const ZodParsedType: {\n    string: \"string\";\n    nan: \"nan\";\n    number: \"number\";\n    integer: \"integer\";\n    float: \"float\";\n    boolean: \"boolean\";\n    date: \"date\";\n    bigint: \"bigint\";\n    symbol: \"symbol\";\n    function: \"function\";\n    undefined: \"undefined\";\n    null: \"null\";\n    array: \"array\";\n    object: \"object\";\n    unknown: \"unknown\";\n    promise: \"promise\";\n    void: \"void\";\n    never: \"never\";\n    map: \"map\";\n    set: \"set\";\n};\nexport type ZodParsedType = keyof typeof ZodParsedType;\nexport declare const getParsedType: (data: any) => ZodParsedType;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v3/helpers/util.d.cts",
        "start": 1,
        "end": 85,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 85,
          "column": 2,
          "position": 1488
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v3/helpers/util.d.ts",
        "start": 1,
        "end": 85,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 85,
          "column": 2,
          "position": 1488
        }
      }
    },
    {
      "format": "typescript",
      "lines": 78,
      "fragment": "import type { IssueData, ZodErrorMap, ZodIssue } from \"../ZodError.js\";\nimport type { ZodParsedType } from \"./util.js\";\nexport declare const makeIssue: (params: {\n    data: any;\n    path: (string | number)[];\n    errorMaps: ZodErrorMap[];\n    issueData: IssueData;\n}) => ZodIssue;\nexport type ParseParams = {\n    path: (string | number)[];\n    errorMap: ZodErrorMap;\n    async: boolean;\n};\nexport type ParsePathComponent = string | number;\nexport type ParsePath = ParsePathComponent[];\nexport declare const EMPTY_PATH: ParsePath;\nexport interface ParseContext {\n    readonly common: {\n        readonly issues: ZodIssue[];\n        readonly contextualErrorMap?: ZodErrorMap | undefined;\n        readonly async: boolean;\n    };\n    readonly path: ParsePath;\n    readonly schemaErrorMap?: ZodErrorMap | undefined;\n    readonly parent: ParseContext | null;\n    readonly data: any;\n    readonly parsedType: ZodParsedType;\n}\nexport type ParseInput = {\n    data: any;\n    path: (string | number)[];\n    parent: ParseContext;\n};\nexport declare function addIssueToContext(ctx: ParseContext, issueData: IssueData): void;\nexport type ObjectPair = {\n    key: SyncParseReturnType<any>;\n    value: SyncParseReturnType<any>;\n};\nexport declare class ParseStatus {\n    value: \"aborted\" | \"dirty\" | \"valid\";\n    dirty(): void;\n    abort(): void;\n    static mergeArray(status: ParseStatus, results: SyncParseReturnType<any>[]): SyncParseReturnType;\n    static mergeObjectAsync(status: ParseStatus, pairs: {\n        key: ParseReturnType<any>;\n        value: ParseReturnType<any>;\n    }[]): Promise<SyncParseReturnType<any>>;\n    static mergeObjectSync(status: ParseStatus, pairs: {\n        key: SyncParseReturnType<any>;\n        value: SyncParseReturnType<any>;\n        alwaysSet?: boolean;\n    }[]): SyncParseReturnType;\n}\nexport interface ParseResult {\n    status: \"aborted\" | \"dirty\" | \"valid\";\n    data: any;\n}\nexport type INVALID = {\n    status: \"aborted\";\n};\nexport declare const INVALID: INVALID;\nexport type DIRTY<T> = {\n    status: \"dirty\";\n    value: T;\n};\nexport declare const DIRTY: <T>(value: T) => DIRTY<T>;\nexport type OK<T> = {\n    status: \"valid\";\n    value: T;\n};\nexport declare const OK: <T>(value: T) => OK<T>;\nexport type SyncParseReturnType<T = any> = OK<T> | DIRTY<T> | INVALID;\nexport type AsyncParseReturnType<T> = Promise<SyncParseReturnType<T>>;\nexport type ParseReturnType<T> = SyncParseReturnType<T> | AsyncParseReturnType<T>;\nexport declare const isAborted: (x: ParseReturnType<any>) => x is INVALID;\nexport declare const isDirty: <T>(x: ParseReturnType<T>) => x is OK<T> | DIRTY<T>;\nexport declare const isValid: <T>(x: ParseReturnType<T>) => x is OK<T>;\nexport declare const isAsync: <T>(x: ParseReturnType<T>) => x is AsyncParseReturnType<T>;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v3/helpers/parseUtil.d.ts",
        "start": 1,
        "end": 78,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 78,
          "column": 2,
          "position": 952
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v3/helpers/parseUtil.d.ts",
        "start": 1,
        "end": 78,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 78,
          "column": 2,
          "position": 952
        }
      }
    },
    {
      "format": "typescript",
      "lines": 78,
      "fragment": "import type { IssueData, ZodErrorMap, ZodIssue } from \"../ZodError.cjs\";\nimport type { ZodParsedType } from \"./util.cjs\";\nexport declare const makeIssue: (params: {\n    data: any;\n    path: (string | number)[];\n    errorMaps: ZodErrorMap[];\n    issueData: IssueData;\n}) => ZodIssue;\nexport type ParseParams = {\n    path: (string | number)[];\n    errorMap: ZodErrorMap;\n    async: boolean;\n};\nexport type ParsePathComponent = string | number;\nexport type ParsePath = ParsePathComponent[];\nexport declare const EMPTY_PATH: ParsePath;\nexport interface ParseContext {\n    readonly common: {\n        readonly issues: ZodIssue[];\n        readonly contextualErrorMap?: ZodErrorMap | undefined;\n        readonly async: boolean;\n    };\n    readonly path: ParsePath;\n    readonly schemaErrorMap?: ZodErrorMap | undefined;\n    readonly parent: ParseContext | null;\n    readonly data: any;\n    readonly parsedType: ZodParsedType;\n}\nexport type ParseInput = {\n    data: any;\n    path: (string | number)[];\n    parent: ParseContext;\n};\nexport declare function addIssueToContext(ctx: ParseContext, issueData: IssueData): void;\nexport type ObjectPair = {\n    key: SyncParseReturnType<any>;\n    value: SyncParseReturnType<any>;\n};\nexport declare class ParseStatus {\n    value: \"aborted\" | \"dirty\" | \"valid\";\n    dirty(): void;\n    abort(): void;\n    static mergeArray(status: ParseStatus, results: SyncParseReturnType<any>[]): SyncParseReturnType;\n    static mergeObjectAsync(status: ParseStatus, pairs: {\n        key: ParseReturnType<any>;\n        value: ParseReturnType<any>;\n    }[]): Promise<SyncParseReturnType<any>>;\n    static mergeObjectSync(status: ParseStatus, pairs: {\n        key: SyncParseReturnType<any>;\n        value: SyncParseReturnType<any>;\n        alwaysSet?: boolean;\n    }[]): SyncParseReturnType;\n}\nexport interface ParseResult {\n    status: \"aborted\" | \"dirty\" | \"valid\";\n    data: any;\n}\nexport type INVALID = {\n    status: \"aborted\";\n};\nexport declare const INVALID: INVALID;\nexport type DIRTY<T> = {\n    status: \"dirty\";\n    value: T;\n};\nexport declare const DIRTY: <T>(value: T) => DIRTY<T>;\nexport type OK<T> = {\n    status: \"valid\";\n    value: T;\n};\nexport declare const OK: <T>(value: T) => OK<T>;\nexport type SyncParseReturnType<T = any> = OK<T> | DIRTY<T> | INVALID;\nexport type AsyncParseReturnType<T> = Promise<SyncParseReturnType<T>>;\nexport type ParseReturnType<T> = SyncParseReturnType<T> | AsyncParseReturnType<T>;\nexport declare const isAborted: (x: ParseReturnType<any>) => x is INVALID;\nexport declare const isDirty: <T>(x: ParseReturnType<T>) => x is OK<T> | DIRTY<T>;\nexport declare const isValid: <T>(x: ParseReturnType<T>) => x is OK<T>;\nexport declare const isAsync: <T>(x: ParseReturnType<T>) => x is AsyncParseReturnType<T>;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v3/helpers/parseUtil.d.cts",
        "start": 1,
        "end": 78,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 78,
          "column": 2,
          "position": 952
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v3/helpers/parseUtil.d.cts",
        "start": 1,
        "end": 78,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 78,
          "column": 2,
          "position": 952
        }
      }
    },
    {
      "format": "typescript",
      "lines": 113,
      "fragment": "/**\n * The Standard Schema interface.\n */\nexport type StandardSchemaV1<Input = unknown, Output = Input> = {\n  /**\n   * The Standard Schema properties.\n   */\n  readonly \"~standard\": StandardSchemaV1.Props<Input, Output>;\n};\n\nexport declare namespace StandardSchemaV1 {\n  /**\n   * The Standard Schema properties interface.\n   */\n  export interface Props<Input = unknown, Output = Input> {\n    /**\n     * The version number of the standard.\n     */\n    readonly version: 1;\n    /**\n     * The vendor name of the schema library.\n     */\n    readonly vendor: string;\n    /**\n     * Validates unknown input values.\n     */\n    readonly validate: (value: unknown) => Result<Output> | Promise<Result<Output>>;\n    /**\n     * Inferred types associated with the schema.\n     */\n    readonly types?: Types<Input, Output> | undefined;\n  }\n\n  /**\n   * The result interface of the validate function.\n   */\n  export type Result<Output> = SuccessResult<Output> | FailureResult;\n\n  /**\n   * The result interface if validation succeeds.\n   */\n  export interface SuccessResult<Output> {\n    /**\n     * The typed output value.\n     */\n    readonly value: Output;\n    /**\n     * The non-existent issues.\n     */\n    readonly issues?: undefined;\n  }\n\n  /**\n   * The result interface if validation fails.\n   */\n  export interface FailureResult {\n    /**\n     * The issues of failed validation.\n     */\n    readonly issues: ReadonlyArray<Issue>;\n  }\n\n  /**\n   * The issue interface of the failure output.\n   */\n  export interface Issue {\n    /**\n     * The error message of the issue.\n     */\n    readonly message: string;\n    /**\n     * The path of the issue, if any.\n     */\n    readonly path?: ReadonlyArray<PropertyKey | PathSegment> | undefined;\n  }\n\n  /**\n   * The path segment interface of the issue.\n   */\n  export interface PathSegment {\n    /**\n     * The key representing a path segment.\n     */\n    readonly key: PropertyKey;\n  }\n\n  /**\n   * The Standard Schema types interface.\n   */\n  export interface Types<Input = unknown, Output = Input> {\n    /**\n     * The input type of the schema.\n     */\n    readonly input: Input;\n    /**\n     * The output type of the schema.\n     */\n    readonly output: Output;\n  }\n\n  /**\n   * Infers the input type of a Standard Schema.\n   */\n  export type InferInput<Schema extends StandardSchemaV1> = NonNullable<Schema[\"~standard\"][\"types\"]>[\"input\"];\n\n  /**\n   * Infers the output type of a Standard Schema.\n   */\n  export type InferOutput<Schema extends StandardSchemaV1> = NonNullable<Schema[\"~standard\"][\"types\"]>[\"output\"];\n\n  // biome-ignore lint/complexity/noUselessEmptyExport: needed for granular visibility control of TS namespace\n  export {};\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/standard-schema.ts",
        "start": 1,
        "end": 113,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 113,
          "column": 2,
          "position": 485
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/standard-schema.ts",
        "start": 1,
        "end": 113,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 113,
          "column": 2,
          "position": 485
        }
      }
    },
    {
      "format": "typescript",
      "lines": 330,
      "fragment": "import type { Primitive } from \"./helpers/typeAliases.js\";\nimport { util, type ZodParsedType } from \"./helpers/util.js\";\nimport type { TypeOf, ZodType } from \"./index.js\";\n\ntype allKeys<T> = T extends any ? keyof T : never;\n\nexport type inferFlattenedErrors<T extends ZodType<any, any, any>, U = string> = typeToFlattenedError<TypeOf<T>, U>;\nexport type typeToFlattenedError<T, U = string> = {\n  formErrors: U[];\n  fieldErrors: {\n    [P in allKeys<T>]?: U[];\n  };\n};\n\nexport const ZodIssueCode = util.arrayToEnum([\n  \"invalid_type\",\n  \"invalid_literal\",\n  \"custom\",\n  \"invalid_union\",\n  \"invalid_union_discriminator\",\n  \"invalid_enum_value\",\n  \"unrecognized_keys\",\n  \"invalid_arguments\",\n  \"invalid_return_type\",\n  \"invalid_date\",\n  \"invalid_string\",\n  \"too_small\",\n  \"too_big\",\n  \"invalid_intersection_types\",\n  \"not_multiple_of\",\n  \"not_finite\",\n]);\n\nexport type ZodIssueCode = keyof typeof ZodIssueCode;\n\nexport type ZodIssueBase = {\n  path: (string | number)[];\n  message?: string | undefined;\n};\n\nexport interface ZodInvalidTypeIssue extends ZodIssueBase {\n  code: typeof ZodIssueCode.invalid_type;\n  expected: ZodParsedType;\n  received: ZodParsedType;\n}\n\nexport interface ZodInvalidLiteralIssue extends ZodIssueBase {\n  code: typeof ZodIssueCode.invalid_literal;\n  expected: unknown;\n  received: unknown;\n}\n\nexport interface ZodUnrecognizedKeysIssue extends ZodIssueBase {\n  code: typeof ZodIssueCode.unrecognized_keys;\n  keys: string[];\n}\n\nexport interface ZodInvalidUnionIssue extends ZodIssueBase {\n  code: typeof ZodIssueCode.invalid_union;\n  unionErrors: ZodError[];\n}\n\nexport interface ZodInvalidUnionDiscriminatorIssue extends ZodIssueBase {\n  code: typeof ZodIssueCode.invalid_union_discriminator;\n  options: Primitive[];\n}\n\nexport interface ZodInvalidEnumValueIssue extends ZodIssueBase {\n  received: string | number;\n  code: typeof ZodIssueCode.invalid_enum_value;\n  options: (string | number)[];\n}\n\nexport interface ZodInvalidArgumentsIssue extends ZodIssueBase {\n  code: typeof ZodIssueCode.invalid_arguments;\n  argumentsError: ZodError;\n}\n\nexport interface ZodInvalidReturnTypeIssue extends ZodIssueBase {\n  code: typeof ZodIssueCode.invalid_return_type;\n  returnTypeError: ZodError;\n}\n\nexport interface ZodInvalidDateIssue extends ZodIssueBase {\n  code: typeof ZodIssueCode.invalid_date;\n}\n\nexport type StringValidation =\n  | \"email\"\n  | \"url\"\n  | \"emoji\"\n  | \"uuid\"\n  | \"nanoid\"\n  | \"regex\"\n  | \"cuid\"\n  | \"cuid2\"\n  | \"ulid\"\n  | \"datetime\"\n  | \"date\"\n  | \"time\"\n  | \"duration\"\n  | \"ip\"\n  | \"cidr\"\n  | \"base64\"\n  | \"jwt\"\n  | \"base64url\"\n  | { includes: string; position?: number | undefined }\n  | { startsWith: string }\n  | { endsWith: string };\n\nexport interface ZodInvalidStringIssue extends ZodIssueBase {\n  code: typeof ZodIssueCode.invalid_string;\n  validation: StringValidation;\n}\n\nexport interface ZodTooSmallIssue extends ZodIssueBase {\n  code: typeof ZodIssueCode.too_small;\n  minimum: number | bigint;\n  inclusive: boolean;\n  exact?: boolean;\n  type: \"array\" | \"string\" | \"number\" | \"set\" | \"date\" | \"bigint\";\n}\n\nexport interface ZodTooBigIssue extends ZodIssueBase {\n  code: typeof ZodIssueCode.too_big;\n  maximum: number | bigint;\n  inclusive: boolean;\n  exact?: boolean;\n  type: \"array\" | \"string\" | \"number\" | \"set\" | \"date\" | \"bigint\";\n}\n\nexport interface ZodInvalidIntersectionTypesIssue extends ZodIssueBase {\n  code: typeof ZodIssueCode.invalid_intersection_types;\n}\n\nexport interface ZodNotMultipleOfIssue extends ZodIssueBase {\n  code: typeof ZodIssueCode.not_multiple_of;\n  multipleOf: number | bigint;\n}\n\nexport interface ZodNotFiniteIssue extends ZodIssueBase {\n  code: typeof ZodIssueCode.not_finite;\n}\n\nexport interface ZodCustomIssue extends ZodIssueBase {\n  code: typeof ZodIssueCode.custom;\n  params?: { [k: string]: any };\n}\n\nexport type DenormalizedError = { [k: string]: DenormalizedError | string[] };\n\nexport type ZodIssueOptionalMessage =\n  | ZodInvalidTypeIssue\n  | ZodInvalidLiteralIssue\n  | ZodUnrecognizedKeysIssue\n  | ZodInvalidUnionIssue\n  | ZodInvalidUnionDiscriminatorIssue\n  | ZodInvalidEnumValueIssue\n  | ZodInvalidArgumentsIssue\n  | ZodInvalidReturnTypeIssue\n  | ZodInvalidDateIssue\n  | ZodInvalidStringIssue\n  | ZodTooSmallIssue\n  | ZodTooBigIssue\n  | ZodInvalidIntersectionTypesIssue\n  | ZodNotMultipleOfIssue\n  | ZodNotFiniteIssue\n  | ZodCustomIssue;\n\nexport type ZodIssue = ZodIssueOptionalMessage & {\n  fatal?: boolean | undefined;\n  message: string;\n};\n\nexport const quotelessJson = (obj: any) => {\n  const json = JSON.stringify(obj, null, 2);\n  return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\n\ntype recursiveZodFormattedError<T> = T extends [any, ...any[]]\n  ? { [K in keyof T]?: ZodFormattedError<T[K]> }\n  : T extends any[]\n    ? { [k: number]: ZodFormattedError<T[number]> }\n    : T extends object\n      ? { [K in keyof T]?: ZodFormattedError<T[K]> }\n      : unknown;\n\nexport type ZodFormattedError<T, U = string> = {\n  _errors: U[];\n} & recursiveZodFormattedError<NonNullable<T>>;\n\nexport type inferFormattedError<T extends ZodType<any, any, any>, U = string> = ZodFormattedError<TypeOf<T>, U>;\n\nexport class ZodError<T = any> extends Error {\n  issues: ZodIssue[] = [];\n\n  get errors() {\n    return this.issues;\n  }\n\n  constructor(issues: ZodIssue[]) {\n    super();\n\n    const actualProto = new.target.prototype;\n    if (Object.setPrototypeOf) {\n      // eslint-disable-next-line ban/ban\n      Object.setPrototypeOf(this, actualProto);\n    } else {\n      (this as any).__proto__ = actualProto;\n    }\n    this.name = \"ZodError\";\n    this.issues = issues;\n  }\n\n  format(): ZodFormattedError<T>;\n  format<U>(mapper: (issue: ZodIssue) => U): ZodFormattedError<T, U>;\n  format(_mapper?: any) {\n    const mapper: (issue: ZodIssue) => any =\n      _mapper ||\n      function (issue: ZodIssue) {\n        return issue.message;\n      };\n    const fieldErrors: ZodFormattedError<T> = { _errors: [] } as any;\n    const processError = (error: ZodError) => {\n      for (const issue of error.issues) {\n        if (issue.code === \"invalid_union\") {\n          issue.unionErrors.map(processError);\n        } else if (issue.code === \"invalid_return_type\") {\n          processError(issue.returnTypeError);\n        } else if (issue.code === \"invalid_arguments\") {\n          processError(issue.argumentsError);\n        } else if (issue.path.length === 0) {\n          (fieldErrors as any)._errors.push(mapper(issue));\n        } else {\n          let curr: any = fieldErrors;\n          let i = 0;\n          while (i < issue.path.length) {\n            const el = issue.path[i]!;\n            const terminal = i === issue.path.length - 1;\n\n            if (!terminal) {\n              curr[el] = curr[el] || { _errors: [] };\n              // if (typeof el === \"string\") {\n              //   curr[el] = curr[el] || { _errors: [] };\n              // } else if (typeof el === \"number\") {\n              //   const errorArray: any = [];\n              //   errorArray._errors = [];\n              //   curr[el] = curr[el] || errorArray;\n              // }\n            } else {\n              curr[el] = curr[el] || { _errors: [] };\n              curr[el]._errors.push(mapper(issue));\n            }\n\n            curr = curr[el];\n            i++;\n          }\n        }\n      }\n    };\n\n    processError(this);\n    return fieldErrors;\n  }\n\n  static create = (issues: ZodIssue[]) => {\n    const error = new ZodError(issues);\n    return error;\n  };\n\n  static assert(value: unknown): asserts value is ZodError {\n    if (!(value instanceof ZodError)) {\n      throw new Error(`Not a ZodError: ${value}`);\n    }\n  }\n\n  override toString() {\n    return this.message;\n  }\n  override get message() {\n    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n  }\n\n  get isEmpty(): boolean {\n    return this.issues.length === 0;\n  }\n\n  addIssue = (sub: ZodIssue) => {\n    this.issues = [...this.issues, sub];\n  };\n\n  addIssues = (subs: ZodIssue[] = []) => {\n    this.issues = [...this.issues, ...subs];\n  };\n\n  flatten(): typeToFlattenedError<T>;\n  flatten<U>(mapper?: (issue: ZodIssue) => U): typeToFlattenedError<T, U>;\n  flatten<U = string>(mapper: (issue: ZodIssue) => U = (issue: ZodIssue) => issue.message as any): any {\n    const fieldErrors: any = {};\n    const formErrors: U[] = [];\n    for (const sub of this.issues) {\n      if (sub.path.length > 0) {\n        const firstEl = sub.path[0]!;\n        fieldErrors[firstEl] = fieldErrors[firstEl] || [];\n        fieldErrors[firstEl].push(mapper(sub));\n      } else {\n        formErrors.push(mapper(sub));\n      }\n    }\n    return { formErrors, fieldErrors };\n  }\n\n  get formErrors() {\n    return this.flatten();\n  }\n}\n\ntype stripPath<T extends object> = T extends any ? util.OmitKeys<T, \"path\"> : never;\n\nexport type IssueData = stripPath<ZodIssueOptionalMessage> & {\n  path?: (string | number)[];\n  fatal?: boolean | undefined;\n};\n\nexport type ErrorMapCtx = {\n  defaultError: string;\n  data: any;\n};\n\nexport type ZodErrorMap = (issue: ZodIssueOptionalMessage, _ctx: ErrorMapCtx) => { message: string };",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/src/v3/ZodError.ts",
        "start": 1,
        "end": 330,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 330,
          "column": 2,
          "position": 2949
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/ZodError.ts",
        "start": 1,
        "end": 330,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 330,
          "column": 2,
          "position": 2949
        }
      }
    },
    {
      "format": "typescript",
      "lines": 17,
      "fragment": "import type { Collection } from '../nodes/Collection';\nimport type { StringifyContext } from './stringify';\ninterface StringifyCollectionOptions {\n    blockItemPrefix: string;\n    flowChars: {\n        start: '{';\n        end: '}';\n    } | {\n        start: '[';\n        end: ']';\n    };\n    itemIndent: string;\n    onChompKeep?: () => void;\n    onComment?: () => void;\n}\nexport declare function stringifyCollection(collection: Readonly<Collection>, ctx: StringifyContext, options: StringifyCollectionOptions): string;\nexport {};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/stringify/stringifyCollection.d.ts",
        "start": 1,
        "end": 17,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 17,
          "column": 2,
          "position": 160
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/stringify/stringifyCollection.d.ts",
        "start": 1,
        "end": 17,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 17,
          "column": 2,
          "position": 160
        }
      }
    },
    {
      "format": "typescript",
      "lines": 21,
      "fragment": "import type { Document } from '../doc/Document';\nimport type { Alias } from '../nodes/Alias';\nimport type { ToStringOptions } from '../options';\nexport type StringifyContext = {\n    actualString?: boolean;\n    allNullValues?: boolean;\n    anchors: Set<string>;\n    doc: Document;\n    forceBlockIndent?: boolean;\n    implicitKey?: boolean;\n    indent: string;\n    indentStep: string;\n    indentAtStart?: number;\n    inFlow: boolean | null;\n    inStringifyKey?: boolean;\n    flowCollectionPadding: string;\n    options: Readonly<Required<Omit<ToStringOptions, 'collectionStyle' | 'indent'>>>;\n    resolvedAliases?: Set<Alias>;\n};\nexport declare function createStringifyContext(doc: Document, options: ToStringOptions): StringifyContext;\nexport declare function stringify(item: unknown, ctx: StringifyContext, onComment?: () => void, onChompKeep?: () => void): string;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/stringify/stringify.d.ts",
        "start": 1,
        "end": 21,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 21,
          "column": 2,
          "position": 257
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/stringify/stringify.d.ts",
        "start": 1,
        "end": 21,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 21,
          "column": 2,
          "position": 257
        }
      }
    },
    {
      "format": "typescript",
      "lines": 34,
      "fragment": "export declare const FOLD_FLOW = \"flow\";\nexport declare const FOLD_BLOCK = \"block\";\nexport declare const FOLD_QUOTED = \"quoted\";\n/**\n * `'block'` prevents more-indented lines from being folded;\n * `'quoted'` allows for `\\` escapes, including escaped newlines\n */\nexport type FoldMode = 'flow' | 'block' | 'quoted';\nexport interface FoldOptions {\n    /**\n     * Accounts for leading contents on the first line, defaulting to\n     * `indent.length`\n     */\n    indentAtStart?: number;\n    /** Default: `80` */\n    lineWidth?: number;\n    /**\n     * Allow highly indented lines to stretch the line width or indent content\n     * from the start.\n     *\n     * Default: `20`\n     */\n    minContentWidth?: number;\n    /** Called once if the text is folded */\n    onFold?: () => void;\n    /** Called once if any line of text exceeds lineWidth characters */\n    onOverflow?: () => void;\n}\n/**\n * Tries to keep input at up to `lineWidth` characters, splitting only on spaces\n * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are\n * terminated with `\\n` and started with `indent`.\n */\nexport declare function foldFlowLines(text: string, indent: string, mode?: FoldMode, { indentAtStart, lineWidth, minContentWidth, onFold, onOverflow }?: FoldOptions): string;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/stringify/foldFlowLines.d.ts",
        "start": 1,
        "end": 34,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 34,
          "column": 2,
          "position": 189
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/stringify/foldFlowLines.d.ts",
        "start": 1,
        "end": 34,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 34,
          "column": 2,
          "position": 189
        }
      }
    },
    {
      "format": "typescript",
      "lines": 92,
      "fragment": "import type { CreateNodeContext } from '../doc/createNode';\nimport type { Node } from '../nodes/Node';\nimport type { Scalar } from '../nodes/Scalar';\nimport type { YAMLMap } from '../nodes/YAMLMap';\nimport type { YAMLSeq } from '../nodes/YAMLSeq';\nimport type { ParseOptions } from '../options';\nimport type { StringifyContext } from '../stringify/stringify';\nimport type { Schema } from './Schema';\ninterface TagBase {\n    /**\n     * An optional factory function, used e.g. by collections when wrapping JS objects as AST nodes.\n     */\n    createNode?: (schema: Schema, value: unknown, ctx: CreateNodeContext) => Node;\n    /**\n     * If `true`, allows for values to be stringified without\n     * an explicit tag together with `test`.\n     * If `'key'`, this only applies if the value is used as a mapping key.\n     * For most cases, it's unlikely that you'll actually want to use this,\n     * even if you first think you do.\n     */\n    default?: boolean | 'key';\n    /**\n     * If a tag has multiple forms that should be parsed and/or stringified\n     * differently, use `format` to identify them.\n     */\n    format?: string;\n    /**\n     * Used by `YAML.createNode` to detect your data type, e.g. using `typeof` or\n     * `instanceof`.\n     */\n    identify?: (value: unknown) => boolean;\n    /**\n     * The identifier for your data type, with which its stringified form will be\n     * prefixed. Should either be a !-prefixed local `!tag`, or a fully qualified\n     * `tag:domain,date:foo`.\n     */\n    tag: string;\n}\nexport interface ScalarTag extends TagBase {\n    collection?: never;\n    nodeClass?: never;\n    /**\n     * Turns a value into an AST node.\n     * If returning a non-`Node` value, the output will be wrapped as a `Scalar`.\n     */\n    resolve(value: string, onError: (message: string) => void, options: ParseOptions): unknown;\n    /**\n     * Optional function stringifying a Scalar node. If your data includes a\n     * suitable `.toString()` method, you can probably leave this undefined and\n     * use the default stringifier.\n     *\n     * @param item The node being stringified.\n     * @param ctx Contains the stringifying context variables.\n     * @param onComment Callback to signal that the stringifier includes the\n     *   item's comment in its output.\n     * @param onChompKeep Callback to signal that the output uses a block scalar\n     *   type with the `+` chomping indicator.\n     */\n    stringify?: (item: Scalar, ctx: StringifyContext, onComment?: () => void, onChompKeep?: () => void) => string;\n    /**\n     * Together with `default` allows for values to be stringified without an\n     * explicit tag and detected using a regular expression. For most cases, it's\n     * unlikely that you'll actually want to use these, even if you first think\n     * you do.\n     */\n    test?: RegExp;\n}\nexport interface CollectionTag extends TagBase {\n    stringify?: never;\n    test?: never;\n    /** The source collection type supported by this tag. */\n    collection: 'map' | 'seq';\n    /**\n     * The `Node` child class that implements this tag.\n     * If set, used to select this tag when stringifying.\n     *\n     * If the class provides a static `from` method, then that\n     * will be used if the tag object doesn't have a `createNode` method.\n     */\n    nodeClass?: {\n        new (schema?: Schema): Node;\n        from?: (schema: Schema, obj: unknown, ctx: CreateNodeContext) => Node;\n    };\n    /**\n     * Turns a value into an AST node.\n     * If returning a non-`Node` value, the output will be wrapped as a `Scalar`.\n     *\n     * Note: this is required if nodeClass is not provided.\n     */\n    resolve?: (value: YAMLMap.Parsed | YAMLSeq.Parsed, onError: (message: string) => void, options: ParseOptions) => unknown;\n}\nexport {};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/schema/types.d.ts",
        "start": 1,
        "end": 92,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 92,
          "column": 2,
          "position": 499
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/schema/types.d.ts",
        "start": 1,
        "end": 92,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 92,
          "column": 2,
          "position": 499
        }
      }
    },
    {
      "format": "typescript",
      "lines": 48,
      "fragment": "import type { SchemaOptions } from '../options';\nimport type { CollectionTag, ScalarTag } from './types';\ndeclare const tagsByName: {\n    binary: ScalarTag;\n    bool: ScalarTag & {\n        test: RegExp;\n    };\n    float: ScalarTag;\n    floatExp: ScalarTag;\n    floatNaN: ScalarTag;\n    floatTime: ScalarTag;\n    int: ScalarTag;\n    intHex: ScalarTag;\n    intOct: ScalarTag;\n    intTime: ScalarTag;\n    map: CollectionTag;\n    merge: ScalarTag & {\n        identify(value: unknown): boolean;\n        test: RegExp;\n    };\n    null: ScalarTag & {\n        test: RegExp;\n    };\n    omap: CollectionTag;\n    pairs: CollectionTag;\n    seq: CollectionTag;\n    set: CollectionTag;\n    timestamp: ScalarTag & {\n        test: RegExp;\n    };\n};\nexport type TagId = keyof typeof tagsByName;\nexport type Tags = Array<ScalarTag | CollectionTag | TagId>;\nexport declare const coreKnownTags: {\n    'tag:yaml.org,2002:binary': ScalarTag;\n    'tag:yaml.org,2002:merge': ScalarTag & {\n        identify(value: unknown): boolean;\n        test: RegExp;\n    };\n    'tag:yaml.org,2002:omap': CollectionTag;\n    'tag:yaml.org,2002:pairs': CollectionTag;\n    'tag:yaml.org,2002:set': CollectionTag;\n    'tag:yaml.org,2002:timestamp': ScalarTag & {\n        test: RegExp;\n    };\n};\nexport declare function getTags(customTags: SchemaOptions['customTags'] | undefined, schemaName: string, addMergeTag?: boolean): (CollectionTag | ScalarTag)[];\nexport {};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/schema/tags.d.ts",
        "start": 1,
        "end": 48,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 48,
          "column": 2,
          "position": 424
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/schema/tags.d.ts",
        "start": 1,
        "end": 48,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 48,
          "column": 2,
          "position": 424
        }
      }
    },
    {
      "format": "typescript",
      "lines": 69,
      "fragment": "type JsonSchema = boolean | ArraySchema | ObjectSchema | NumberSchema | StringSchema;\ntype JsonType = 'array' | 'object' | 'string' | 'number' | 'integer' | 'boolean' | 'null';\ninterface CommonSchema {\n    type?: JsonType | JsonType[];\n    const?: unknown;\n    enum?: unknown[];\n    format?: string;\n    allOf?: JsonSchema[];\n    anyOf?: JsonSchema[];\n    oneOf?: JsonSchema[];\n    not?: JsonSchema;\n    if?: JsonSchema;\n    then?: JsonSchema;\n    else?: JsonSchema;\n    $id?: string;\n    $defs?: Record<string, JsonSchema>;\n    $anchor?: string;\n    $dynamicAnchor?: string;\n    $ref?: string;\n    $dynamicRef?: string;\n    $schema?: string;\n    $vocabulary?: Record<string, boolean>;\n    $comment?: string;\n    default?: unknown;\n    deprecated?: boolean;\n    readOnly?: boolean;\n    writeOnly?: boolean;\n    title?: string;\n    description?: string;\n    examples?: unknown[];\n}\ninterface ArraySchema extends CommonSchema {\n    prefixItems?: JsonSchema[];\n    items?: JsonSchema;\n    contains?: JsonSchema;\n    unevaluatedItems?: JsonSchema;\n    maxItems?: number;\n    minItems?: number;\n    uniqueItems?: boolean;\n    maxContains?: number;\n    minContains?: number;\n}\ninterface ObjectSchema extends CommonSchema {\n    properties?: Record<string, JsonSchema>;\n    patternProperties?: Record<string, JsonSchema>;\n    additionalProperties?: JsonSchema;\n    propertyNames?: JsonSchema;\n    unevaluatedProperties?: JsonSchema;\n    maxProperties?: number;\n    minProperties?: number;\n    required?: string[];\n    dependentRequired?: Record<string, string[]>;\n    dependentSchemas?: Record<string, JsonSchema>;\n}\ninterface StringSchema extends CommonSchema {\n    maxLength?: number;\n    minLength?: number;\n    patter?: string;\n    contentEncoding?: string;\n    contentMediaType?: string;\n    contentSchema?: JsonSchema;\n}\ninterface NumberSchema extends CommonSchema {\n    multipleOf?: number;\n    maximum?: number;\n    exclusiveMaximum?: number;\n    minimum?: number;\n    exclusiveMinimum?: number;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/schema/json-schema.d.ts",
        "start": 1,
        "end": 69,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 69,
          "column": 2,
          "position": 626
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/schema/json-schema.d.ts",
        "start": 1,
        "end": 69,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 69,
          "column": 2,
          "position": 626
        }
      }
    },
    {
      "format": "typescript",
      "lines": 17,
      "fragment": "import { MAP, SCALAR, SEQ } from '../nodes/identity';\nimport type { Pair } from '../nodes/Pair';\nimport type { SchemaOptions, ToStringOptions } from '../options';\nimport type { CollectionTag, ScalarTag } from './types';\nexport declare class Schema {\n    compat: Array<CollectionTag | ScalarTag> | null;\n    knownTags: Record<string, CollectionTag | ScalarTag>;\n    name: string;\n    sortMapEntries: ((a: Pair, b: Pair) => number) | null;\n    tags: Array<CollectionTag | ScalarTag>;\n    toStringOptions: Readonly<ToStringOptions> | null;\n    readonly [MAP]: CollectionTag;\n    readonly [SCALAR]: ScalarTag;\n    readonly [SEQ]: CollectionTag;\n    constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }: SchemaOptions);\n    clone(): Schema;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/schema/Schema.d.ts",
        "start": 1,
        "end": 17,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 17,
          "column": 2,
          "position": 252
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/schema/Schema.d.ts",
        "start": 1,
        "end": 17,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 17,
          "column": 2,
          "position": 252
        }
      }
    },
    {
      "format": "typescript",
      "lines": 84,
      "fragment": "import type { Token } from './cst';\n/**\n * A YAML concrete syntax tree (CST) parser\n *\n * ```ts\n * const src: string = ...\n * for (const token of new Parser().parse(src)) {\n *   // token: Token\n * }\n * ```\n *\n * To use the parser with a user-provided lexer:\n *\n * ```ts\n * function* parse(source: string, lexer: Lexer) {\n *   const parser = new Parser()\n *   for (const lexeme of lexer.lex(source))\n *     yield* parser.next(lexeme)\n *   yield* parser.end()\n * }\n *\n * const src: string = ...\n * const lexer = new Lexer()\n * for (const token of parse(src, lexer)) {\n *   // token: Token\n * }\n * ```\n */\nexport declare class Parser {\n    private onNewLine?;\n    /** If true, space and sequence indicators count as indentation */\n    private atNewLine;\n    /** If true, next token is a scalar value */\n    private atScalar;\n    /** Current indentation level */\n    private indent;\n    /** Current offset since the start of parsing */\n    offset: number;\n    /** On the same line with a block map key */\n    private onKeyLine;\n    /** Top indicates the node that's currently being built */\n    stack: Token[];\n    /** The source of the current token, set in parse() */\n    private source;\n    /** The type of the current token, set in parse() */\n    private type;\n    /**\n     * @param onNewLine - If defined, called separately with the start position of\n     *   each new line (in `parse()`, including the start of input).\n     */\n    constructor(onNewLine?: (offset: number) => void);\n    /**\n     * Parse `source` as a YAML stream.\n     * If `incomplete`, a part of the last line may be left as a buffer for the next call.\n     *\n     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.\n     *\n     * @returns A generator of tokens representing each directive, document, and other structure.\n     */\n    parse(source: string, incomplete?: boolean): Generator<Token, void>;\n    /**\n     * Advance the parser by the `source` of one lexical token.\n     */\n    next(source: string): Generator<Token, void>;\n    private lexer;\n    /** Call at end of input to push out any remaining constructions */\n    end(): Generator<Token, void>;\n    private get sourceToken();\n    private step;\n    private peek;\n    private pop;\n    private stream;\n    private document;\n    private scalar;\n    private blockScalar;\n    private blockMap;\n    private blockSequence;\n    private flowCollection;\n    private flowScalar;\n    private startBlockValue;\n    private atIndentedComment;\n    private documentEnd;\n    private lineEnd;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/parse/parser.d.ts",
        "start": 1,
        "end": 84,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 84,
          "column": 2,
          "position": 308
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/parse/parser.d.ts",
        "start": 1,
        "end": 84,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 84,
          "column": 2,
          "position": 308
        }
      }
    },
    {
      "format": "typescript",
      "lines": 87,
      "fragment": "/**\n * Splits an input string into lexical tokens, i.e. smaller strings that are\n * easily identifiable by `tokens.tokenType()`.\n *\n * Lexing starts always in a \"stream\" context. Incomplete input may be buffered\n * until a complete token can be emitted.\n *\n * In addition to slices of the original input, the following control characters\n * may also be emitted:\n *\n * - `\\x02` (Start of Text): A document starts with the next token\n * - `\\x18` (Cancel): Unexpected end of flow-mode (indicates an error)\n * - `\\x1f` (Unit Separator): Next token is a scalar value\n * - `\\u{FEFF}` (Byte order mark): Emitted separately outside documents\n */\nexport declare class Lexer {\n    /**\n     * Flag indicating whether the end of the current buffer marks the end of\n     * all input\n     */\n    private atEnd;\n    /**\n     * Explicit indent set in block scalar header, as an offset from the current\n     * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not\n     * explicitly set.\n     */\n    private blockScalarIndent;\n    /**\n     * Block scalars that include a + (keep) chomping indicator in their header\n     * include trailing empty lines, which are otherwise excluded from the\n     * scalar's contents.\n     */\n    private blockScalarKeep;\n    /** Current input */\n    private buffer;\n    /**\n     * Flag noting whether the map value indicator : can immediately follow this\n     * node within a flow context.\n     */\n    private flowKey;\n    /** Count of surrounding flow collection levels. */\n    private flowLevel;\n    /**\n     * Minimum level of indentation required for next lines to be parsed as a\n     * part of the current scalar value.\n     */\n    private indentNext;\n    /** Indentation level of the current line. */\n    private indentValue;\n    /** Position of the next \\n character. */\n    private lineEndPos;\n    /** Stores the state of the lexer if reaching the end of incpomplete input */\n    private next;\n    /** A pointer to `buffer`; the current position of the lexer. */\n    private pos;\n    /**\n     * Generate YAML tokens from the `source` string. If `incomplete`,\n     * a part of the last line may be left as a buffer for the next call.\n     *\n     * @returns A generator of lexical tokens\n     */\n    lex(source: string, incomplete?: boolean): Generator<string, void>;\n    private atLineEnd;\n    private charAt;\n    private continueScalar;\n    private getLine;\n    private hasChars;\n    private setNext;\n    private peek;\n    private parseNext;\n    private parseStream;\n    private parseLineStart;\n    private parseBlockStart;\n    private parseDocument;\n    private parseFlowCollection;\n    private parseQuotedScalar;\n    private parseBlockScalarHeader;\n    private parseBlockScalar;\n    private parsePlainScalar;\n    private pushCount;\n    private pushToIndex;\n    private pushIndicators;\n    private pushTag;\n    private pushNewline;\n    private pushSpaces;\n    private pushUntil;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/parse/lexer.d.ts",
        "start": 1,
        "end": 87,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 87,
          "column": 2,
          "position": 284
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/parse/lexer.d.ts",
        "start": 1,
        "end": 87,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 87,
          "column": 2,
          "position": 284
        }
      }
    },
    {
      "format": "typescript",
      "lines": 109,
      "fragment": "export { createScalarToken, resolveAsScalar, setScalarValue } from './cst-scalar';\nexport { stringify } from './cst-stringify';\nexport type { Visitor, VisitPath } from './cst-visit';\nexport { visit } from './cst-visit';\nexport interface SourceToken {\n    type: 'byte-order-mark' | 'doc-mode' | 'doc-start' | 'space' | 'comment' | 'newline' | 'directive-line' | 'anchor' | 'tag' | 'seq-item-ind' | 'explicit-key-ind' | 'map-value-ind' | 'flow-map-start' | 'flow-map-end' | 'flow-seq-start' | 'flow-seq-end' | 'flow-error-end' | 'comma' | 'block-scalar-header';\n    offset: number;\n    indent: number;\n    source: string;\n}\nexport interface ErrorToken {\n    type: 'error';\n    offset: number;\n    source: string;\n    message: string;\n}\nexport interface Directive {\n    type: 'directive';\n    offset: number;\n    source: string;\n}\nexport interface Document {\n    type: 'document';\n    offset: number;\n    start: SourceToken[];\n    value?: Token;\n    end?: SourceToken[];\n}\nexport interface DocumentEnd {\n    type: 'doc-end';\n    offset: number;\n    source: string;\n    end?: SourceToken[];\n}\nexport interface FlowScalar {\n    type: 'alias' | 'scalar' | 'single-quoted-scalar' | 'double-quoted-scalar';\n    offset: number;\n    indent: number;\n    source: string;\n    end?: SourceToken[];\n}\nexport interface BlockScalar {\n    type: 'block-scalar';\n    offset: number;\n    indent: number;\n    props: Token[];\n    source: string;\n}\nexport interface BlockMap {\n    type: 'block-map';\n    offset: number;\n    indent: number;\n    items: Array<{\n        start: SourceToken[];\n        explicitKey?: true;\n        key?: never;\n        sep?: never;\n        value?: never;\n    } | {\n        start: SourceToken[];\n        explicitKey?: true;\n        key: Token | null;\n        sep: SourceToken[];\n        value?: Token;\n    }>;\n}\nexport interface BlockSequence {\n    type: 'block-seq';\n    offset: number;\n    indent: number;\n    items: Array<{\n        start: SourceToken[];\n        key?: never;\n        sep?: never;\n        value?: Token;\n    }>;\n}\nexport type CollectionItem = {\n    start: SourceToken[];\n    key?: Token | null;\n    sep?: SourceToken[];\n    value?: Token;\n};\nexport interface FlowCollection {\n    type: 'flow-collection';\n    offset: number;\n    indent: number;\n    start: SourceToken;\n    items: CollectionItem[];\n    end: SourceToken[];\n}\nexport type Token = SourceToken | ErrorToken | Directive | Document | DocumentEnd | FlowScalar | BlockScalar | BlockMap | BlockSequence | FlowCollection;\nexport type TokenType = SourceToken['type'] | DocumentEnd['type'] | FlowScalar['type'];\n/** The byte order mark */\nexport declare const BOM = \"\\uFEFF\";\n/** Start of doc-mode */\nexport declare const DOCUMENT = \"\\u0002\";\n/** Unexpected end of flow-mode */\nexport declare const FLOW_END = \"\\u0018\";\n/** Next token is a scalar value */\nexport declare const SCALAR = \"\\u001F\";\n/** @returns `true` if `token` is a flow or block collection */\nexport declare const isCollection: (token: Token | null | undefined) => token is BlockMap | BlockSequence | FlowCollection;\n/** @returns `true` if `token` is a flow or block scalar; not an alias */\nexport declare const isScalar: (token: Token | null | undefined) => token is FlowScalar | BlockScalar;\n/** Get a printable representation of a lexer token */\nexport declare function prettyToken(token: string): string;\n/** Identify the type of a lexer token. May return `null` for unknown tokens. */\nexport declare function tokenType(source: string): TokenType | null;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/parse/cst.d.ts",
        "start": 1,
        "end": 109,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 109,
          "column": 2,
          "position": 1022
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/parse/cst.d.ts",
        "start": 1,
        "end": 109,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 109,
          "column": 2,
          "position": 1022
        }
      }
    },
    {
      "format": "typescript",
      "lines": 39,
      "fragment": "import type { BlockMap, BlockSequence, CollectionItem, Document, FlowCollection } from './cst';\nexport type VisitPath = readonly ['key' | 'value', number][];\nexport type Visitor = (item: CollectionItem, path: VisitPath) => number | symbol | Visitor | void;\n/**\n * Apply a visitor to a CST document or item.\n *\n * Walks through the tree (depth-first) starting from the root, calling a\n * `visitor` function with two arguments when entering each item:\n *   - `item`: The current item, which included the following members:\n *     - `start: SourceToken[]`  Source tokens before the key or value,\n *       possibly including its anchor or tag.\n *     - `key?: Token | null`  Set for pair values. May then be `null`, if\n *       the key before the `:` separator is empty.\n *     - `sep?: SourceToken[]`  Source tokens between the key and the value,\n *       which should include the `:` map value indicator if `value` is set.\n *     - `value?: Token`  The value of a sequence item, or of a map pair.\n *   - `path`: The steps from the root to the current node, as an array of\n *     `['key' | 'value', number]` tuples.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this token, continue with\n *      next sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current item, then continue with the next one\n *   - `number`: Set the index of the next step. This is useful especially if\n *     the index of the current token has changed.\n *   - `function`: Define the next visitor for this item. After the original\n *     visitor is called on item entry, next visitors are called after handling\n *     a non-empty `key` and when exiting the item.\n */\nexport declare function visit(cst: Document | CollectionItem, visitor: Visitor): void;\nexport declare namespace visit {\n    var BREAK: symbol;\n    var SKIP: symbol;\n    var REMOVE: symbol;\n    var itemAtPath: (cst: Document | CollectionItem, path: VisitPath) => CollectionItem | undefined;\n    var parentCollection: (cst: Document | CollectionItem, path: VisitPath) => BlockMap | BlockSequence | FlowCollection;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/parse/cst-visit.d.ts",
        "start": 1,
        "end": 39,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 39,
          "column": 2,
          "position": 224
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/parse/cst-visit.d.ts",
        "start": 1,
        "end": 39,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 39,
          "column": 2,
          "position": 224
        }
      }
    },
    {
      "format": "typescript",
      "lines": 64,
      "fragment": "import type { ErrorCode } from '../errors';\nimport type { Range } from '../nodes/Node';\nimport type { Scalar } from '../nodes/Scalar';\nimport type { BlockScalar, FlowScalar, SourceToken, Token } from './cst';\n/**\n * If `token` is a CST flow or block scalar, determine its string value and a few other attributes.\n * Otherwise, return `null`.\n */\nexport declare function resolveAsScalar(token: FlowScalar | BlockScalar, strict?: boolean, onError?: (offset: number, code: ErrorCode, message: string) => void): {\n    value: string;\n    type: Scalar.Type | null;\n    comment: string;\n    range: Range;\n};\nexport declare function resolveAsScalar(token: Token | null | undefined, strict?: boolean, onError?: (offset: number, code: ErrorCode, message: string) => void): {\n    value: string;\n    type: Scalar.Type | null;\n    comment: string;\n    range: Range;\n} | null;\n/**\n * Create a new scalar token with `value`\n *\n * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,\n * as this function does not support any schema operations and won't check for such conflicts.\n *\n * @param value The string representation of the value, which will have its content properly indented.\n * @param context.end Comments and whitespace after the end of the value, or after the block scalar header. If undefined, a newline will be added.\n * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.\n * @param context.indent The indent level of the token.\n * @param context.inFlow Is this scalar within a flow collection? This may affect the resolved type of the token's value.\n * @param context.offset The offset position of the token.\n * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.\n */\nexport declare function createScalarToken(value: string, context: {\n    end?: SourceToken[];\n    implicitKey?: boolean;\n    indent: number;\n    inFlow?: boolean;\n    offset?: number;\n    type?: Scalar.Type;\n}): BlockScalar | FlowScalar;\n/**\n * Set the value of `token` to the given string `value`, overwriting any previous contents and type that it may have.\n *\n * Best efforts are made to retain any comments previously associated with the `token`,\n * though all contents within a collection's `items` will be overwritten.\n *\n * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,\n * as this function does not support any schema operations and won't check for such conflicts.\n *\n * @param token Any token. If it does not include an `indent` value, the value will be stringified as if it were an implicit key.\n * @param value The string representation of the value, which will have its content properly indented.\n * @param context.afterKey In most cases, values after a key should have an additional level of indentation.\n * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.\n * @param context.inFlow Being within a flow collection may affect the resolved type of the token's value.\n * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.\n */\nexport declare function setScalarValue(token: Token, value: string, context?: {\n    afterKey?: boolean;\n    implicitKey?: boolean;\n    inFlow?: boolean;\n    type?: Scalar.Type;\n}): void;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/parse/cst-scalar.d.ts",
        "start": 1,
        "end": 64,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 64,
          "column": 2,
          "position": 415
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/parse/cst-scalar.d.ts",
        "start": 1,
        "end": 64,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 64,
          "column": 2,
          "position": 415
        }
      }
    },
    {
      "format": "typescript",
      "lines": 29,
      "fragment": "import type { Document } from '../doc/Document';\nimport type { Node } from './Node';\nexport interface AnchorData {\n    aliasCount: number;\n    count: number;\n    res: unknown;\n}\nexport interface ToJSContext {\n    anchors: Map<Node, AnchorData>;\n    /** Cached anchor and alias nodes in the order they occur in the document */\n    aliasResolveCache?: Node[];\n    doc: Document<Node, boolean>;\n    keep: boolean;\n    mapAsMap: boolean;\n    mapKeyWarned: boolean;\n    maxAliasCount: number;\n    onCreate?: (res: unknown) => void;\n}\n/**\n * Recursively convert any node or its contents to native JavaScript\n *\n * @param value - The input value\n * @param arg - If `value` defines a `toJSON()` method, use this\n *   as its first argument\n * @param ctx - Conversion context, originally set in Document#toJS(). If\n *   `{ keep: true }` is not set, output should be suitable for JSON\n *   stringification.\n */\nexport declare function toJS(value: any, arg: string | null, ctx?: ToJSContext): any;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/nodes/toJS.d.ts",
        "start": 1,
        "end": 29,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 29,
          "column": 2,
          "position": 190
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/nodes/toJS.d.ts",
        "start": 1,
        "end": 29,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 29,
          "column": 2,
          "position": 190
        }
      }
    },
    {
      "format": "typescript",
      "lines": 23,
      "fragment": "import type { Document } from '../doc/Document';\nimport type { Alias } from './Alias';\nimport type { Node } from './Node';\nimport type { Pair } from './Pair';\nimport type { Scalar } from './Scalar';\nimport type { YAMLMap } from './YAMLMap';\nimport type { YAMLSeq } from './YAMLSeq';\nexport declare const ALIAS: unique symbol;\nexport declare const DOC: unique symbol;\nexport declare const MAP: unique symbol;\nexport declare const PAIR: unique symbol;\nexport declare const SCALAR: unique symbol;\nexport declare const SEQ: unique symbol;\nexport declare const NODE_TYPE: unique symbol;\nexport declare const isAlias: (node: any) => node is Alias;\nexport declare const isDocument: <T extends Node = Node>(node: any) => node is Document<T>;\nexport declare const isMap: <K = unknown, V = unknown>(node: any) => node is YAMLMap<K, V>;\nexport declare const isPair: <K = unknown, V = unknown>(node: any) => node is Pair<K, V>;\nexport declare const isScalar: <T = unknown>(node: any) => node is Scalar<T>;\nexport declare const isSeq: <T = unknown>(node: any) => node is YAMLSeq<T>;\nexport declare function isCollection<K = unknown, V = unknown>(node: any): node is YAMLMap<K, V> | YAMLSeq<V>;\nexport declare function isNode<T = unknown>(node: any): node is Node<T>;\nexport declare const hasAnchor: <K = unknown, V = unknown>(node: unknown) => node is Scalar<V> | YAMLMap<K, V> | YAMLSeq<V>;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/nodes/identity.d.ts",
        "start": 1,
        "end": 23,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 23,
          "column": 2,
          "position": 565
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/nodes/identity.d.ts",
        "start": 1,
        "end": 23,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 23,
          "column": 2,
          "position": 565
        }
      }
    },
    {
      "format": "typescript",
      "lines": 60,
      "fragment": "import type { CreateNodeContext } from '../doc/createNode';\nimport type { BlockSequence, FlowCollection } from '../parse/cst';\nimport type { Schema } from '../schema/Schema';\nimport type { StringifyContext } from '../stringify/stringify';\nimport { Collection } from './Collection';\nimport type { ParsedNode, Range } from './Node';\nimport type { Pair } from './Pair';\nimport type { Scalar } from './Scalar';\nimport type { ToJSContext } from './toJS';\nexport declare namespace YAMLSeq {\n    interface Parsed<T extends ParsedNode | Pair<ParsedNode, ParsedNode | null> = ParsedNode> extends YAMLSeq<T> {\n        items: T[];\n        range: Range;\n        srcToken?: BlockSequence | FlowCollection;\n    }\n}\nexport declare class YAMLSeq<T = unknown> extends Collection {\n    static get tagName(): 'tag:yaml.org,2002:seq';\n    items: T[];\n    constructor(schema?: Schema);\n    add(value: T): void;\n    /**\n     * Removes a value from the collection.\n     *\n     * `key` must contain a representation of an integer for this to succeed.\n     * It may be wrapped in a `Scalar`.\n     *\n     * @returns `true` if the item was found and removed.\n     */\n    delete(key: unknown): boolean;\n    /**\n     * Returns item at `key`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     *\n     * `key` must contain a representation of an integer for this to succeed.\n     * It may be wrapped in a `Scalar`.\n     */\n    get(key: unknown, keepScalar: true): Scalar<T> | undefined;\n    get(key: unknown, keepScalar?: false): T | undefined;\n    get(key: unknown, keepScalar?: boolean): T | Scalar<T> | undefined;\n    /**\n     * Checks if the collection includes a value with the key `key`.\n     *\n     * `key` must contain a representation of an integer for this to succeed.\n     * It may be wrapped in a `Scalar`.\n     */\n    has(key: unknown): boolean;\n    /**\n     * Sets a value in this collection. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     *\n     * If `key` does not contain a representation of an integer, this will throw.\n     * It may be wrapped in a `Scalar`.\n     */\n    set(key: unknown, value: T): void;\n    toJSON(_?: unknown, ctx?: ToJSContext): unknown[];\n    toString(ctx?: StringifyContext, onComment?: () => void, onChompKeep?: () => void): string;\n    static from(schema: Schema, obj: unknown, ctx: CreateNodeContext): YAMLSeq;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/nodes/YAMLSeq.d.ts",
        "start": 1,
        "end": 60,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 60,
          "column": 2,
          "position": 514
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/nodes/YAMLSeq.d.ts",
        "start": 1,
        "end": 60,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 60,
          "column": 2,
          "position": 514
        }
      }
    },
    {
      "format": "typescript",
      "lines": 53,
      "fragment": "import type { BlockMap, FlowCollection } from '../parse/cst';\nimport type { Schema } from '../schema/Schema';\nimport type { StringifyContext } from '../stringify/stringify';\nimport type { CreateNodeContext } from '../util';\nimport { Collection } from './Collection';\nimport type { ParsedNode, Range } from './Node';\nimport { Pair } from './Pair';\nimport type { Scalar } from './Scalar';\nimport type { ToJSContext } from './toJS';\nexport type MapLike = Map<unknown, unknown> | Set<unknown> | Record<string | number | symbol, unknown>;\nexport declare function findPair<K = unknown, V = unknown>(items: Iterable<Pair<K, V>>, key: unknown): Pair<K, V> | undefined;\nexport declare namespace YAMLMap {\n    interface Parsed<K extends ParsedNode = ParsedNode, V extends ParsedNode | null = ParsedNode | null> extends YAMLMap<K, V> {\n        items: Pair<K, V>[];\n        range: Range;\n        srcToken?: BlockMap | FlowCollection;\n    }\n}\nexport declare class YAMLMap<K = unknown, V = unknown> extends Collection {\n    static get tagName(): 'tag:yaml.org,2002:map';\n    items: Pair<K, V>[];\n    constructor(schema?: Schema);\n    /**\n     * A generic collection parsing method that can be extended\n     * to other node classes that inherit from YAMLMap\n     */\n    static from(schema: Schema, obj: unknown, ctx: CreateNodeContext): YAMLMap;\n    /**\n     * Adds a value to the collection.\n     *\n     * @param overwrite - If not set `true`, using a key that is already in the\n     *   collection will throw. Otherwise, overwrites the previous value.\n     */\n    add(pair: Pair<K, V> | {\n        key: K;\n        value: V;\n    }, overwrite?: boolean): void;\n    delete(key: unknown): boolean;\n    get(key: unknown, keepScalar: true): Scalar<V> | undefined;\n    get(key: unknown, keepScalar?: false): V | undefined;\n    get(key: unknown, keepScalar?: boolean): V | Scalar<V> | undefined;\n    has(key: unknown): boolean;\n    set(key: K, value: V): void;\n    /**\n     * @param ctx - Conversion context, originally set in Document#toJS()\n     * @param {Class} Type - If set, forces the returned collection type\n     * @returns Instance of Type, Map, or Object\n     */\n    toJSON<T extends MapLike = Map<unknown, unknown>>(_?: unknown, ctx?: ToJSContext, Type?: {\n        new (): T;\n    }): any;\n    toString(ctx?: StringifyContext, onComment?: () => void, onChompKeep?: () => void): string;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/nodes/YAMLMap.d.ts",
        "start": 1,
        "end": 53,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 53,
          "column": 2,
          "position": 702
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/nodes/YAMLMap.d.ts",
        "start": 1,
        "end": 53,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 53,
          "column": 2,
          "position": 702
        }
      }
    },
    {
      "format": "typescript",
      "lines": 43,
      "fragment": "import type { BlockScalar, FlowScalar } from '../parse/cst';\nimport type { Range } from './Node';\nimport { NodeBase } from './Node';\nimport type { ToJSContext } from './toJS';\nexport declare const isScalarValue: (value: unknown) => boolean;\nexport declare namespace Scalar {\n    interface Parsed extends Scalar {\n        range: Range;\n        source: string;\n        srcToken?: FlowScalar | BlockScalar;\n    }\n    type BLOCK_FOLDED = 'BLOCK_FOLDED';\n    type BLOCK_LITERAL = 'BLOCK_LITERAL';\n    type PLAIN = 'PLAIN';\n    type QUOTE_DOUBLE = 'QUOTE_DOUBLE';\n    type QUOTE_SINGLE = 'QUOTE_SINGLE';\n    type Type = BLOCK_FOLDED | BLOCK_LITERAL | PLAIN | QUOTE_DOUBLE | QUOTE_SINGLE;\n}\nexport declare class Scalar<T = unknown> extends NodeBase {\n    static readonly BLOCK_FOLDED = \"BLOCK_FOLDED\";\n    static readonly BLOCK_LITERAL = \"BLOCK_LITERAL\";\n    static readonly PLAIN = \"PLAIN\";\n    static readonly QUOTE_DOUBLE = \"QUOTE_DOUBLE\";\n    static readonly QUOTE_SINGLE = \"QUOTE_SINGLE\";\n    value: T;\n    /** An optional anchor on this node. Used by alias nodes. */\n    anchor?: string;\n    /**\n     * By default (undefined), numbers use decimal notation.\n     * The YAML 1.2 core schema only supports 'HEX' and 'OCT'.\n     * The YAML 1.1 schema also supports 'BIN' and 'TIME'\n     */\n    format?: string;\n    /** If `value` is a number, use this value when stringifying this node. */\n    minFractionDigits?: number;\n    /** Set during parsing to the source string value */\n    source?: string;\n    /** The scalar style used for the node's string representation */\n    type?: Scalar.Type;\n    constructor(value: T);\n    toJSON(arg?: any, ctx?: ToJSContext): any;\n    toString(): string;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/nodes/Scalar.d.ts",
        "start": 1,
        "end": 43,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 43,
          "column": 2,
          "position": 395
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/nodes/Scalar.d.ts",
        "start": 1,
        "end": 43,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 43,
          "column": 2,
          "position": 395
        }
      }
    },
    {
      "format": "typescript",
      "lines": 22,
      "fragment": "import type { CreateNodeContext } from '../doc/createNode';\nimport type { CollectionItem } from '../parse/cst';\nimport type { Schema } from '../schema/Schema';\nimport type { StringifyContext } from '../stringify/stringify';\nimport { addPairToJSMap } from './addPairToJSMap';\nimport { NODE_TYPE } from './identity';\nimport type { Node } from './Node';\nimport type { ToJSContext } from './toJS';\nexport declare function createPair(key: unknown, value: unknown, ctx: CreateNodeContext): Pair<Node, Node>;\nexport declare class Pair<K = unknown, V = unknown> {\n    readonly [NODE_TYPE]: symbol;\n    /** Always Node or null when parsed, but can be set to anything. */\n    key: K;\n    /** Always Node or null when parsed, but can be set to anything. */\n    value: V | null;\n    /** The CST token that was composed into this pair.  */\n    srcToken?: CollectionItem;\n    constructor(key: K, value?: V | null);\n    clone(schema?: Schema): Pair<K, V>;\n    toJSON(_?: unknown, ctx?: ToJSContext): ReturnType<typeof addPairToJSMap>;\n    toString(ctx?: StringifyContext, onComment?: () => void, onChompKeep?: () => void): string;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/nodes/Pair.d.ts",
        "start": 1,
        "end": 22,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 22,
          "column": 2,
          "position": 327
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/nodes/Pair.d.ts",
        "start": 1,
        "end": 22,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 22,
          "column": 2,
          "position": 327
        }
      }
    },
    {
      "format": "typescript",
      "lines": 53,
      "fragment": "import type { Document } from '../doc/Document';\nimport type { ToJSOptions } from '../options';\nimport type { Token } from '../parse/cst';\nimport type { StringifyContext } from '../stringify/stringify';\nimport type { Alias } from './Alias';\nimport { NODE_TYPE } from './identity';\nimport type { Scalar } from './Scalar';\nimport type { ToJSContext } from './toJS';\nimport type { MapLike, YAMLMap } from './YAMLMap';\nimport type { YAMLSeq } from './YAMLSeq';\nexport type Node<T = unknown> = Alias | Scalar<T> | YAMLMap<unknown, T> | YAMLSeq<T>;\n/** Utility type mapper */\nexport type NodeType<T> = T extends string | number | bigint | boolean | null | undefined ? Scalar<T> : T extends Date ? Scalar<string | Date> : T extends Array<any> ? YAMLSeq<NodeType<T[number]>> : T extends {\n    [key: string]: any;\n} ? YAMLMap<NodeType<keyof T>, NodeType<T[keyof T]>> : T extends {\n    [key: number]: any;\n} ? YAMLMap<NodeType<keyof T>, NodeType<T[keyof T]>> : Node;\nexport type ParsedNode = Alias.Parsed | Scalar.Parsed | YAMLMap.Parsed | YAMLSeq.Parsed;\n/** `[start, value-end, node-end]` */\nexport type Range = [number, number, number];\nexport declare abstract class NodeBase {\n    readonly [NODE_TYPE]: symbol;\n    /** A comment on or immediately after this */\n    comment?: string | null;\n    /** A comment before this */\n    commentBefore?: string | null;\n    /**\n     * The `[start, value-end, node-end]` character offsets for the part of the\n     * source parsed into this node (undefined if not parsed). The `value-end`\n     * and `node-end` positions are themselves not included in their respective\n     * ranges.\n     */\n    range?: Range | null;\n    /** A blank line before this node and its commentBefore */\n    spaceBefore?: boolean;\n    /** The CST token that was composed into this node.  */\n    srcToken?: Token;\n    /** A fully qualified tag, if required */\n    tag?: string;\n    /**\n     * Customize the way that a key-value pair is resolved.\n     * Used for YAML 1.1 !!merge << handling.\n     */\n    addToJSMap?: (ctx: ToJSContext | undefined, map: MapLike, value: unknown) => void;\n    /** A plain JS representation of this node */\n    abstract toJSON(): any;\n    abstract toString(ctx?: StringifyContext, onComment?: () => void, onChompKeep?: () => void): string;\n    constructor(type: symbol);\n    /** Create a copy of this node.  */\n    clone(): NodeBase;\n    /** A plain JavaScript representation of this node. */\n    toJS(doc: Document<Node, boolean>, { mapAsMap, maxAliasCount, onAnchor, reviver }?: ToJSOptions): any;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/nodes/Node.d.ts",
        "start": 1,
        "end": 53,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 53,
          "column": 2,
          "position": 681
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/nodes/Node.d.ts",
        "start": 1,
        "end": 53,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 53,
          "column": 2,
          "position": 681
        }
      }
    },
    {
      "format": "typescript",
      "lines": 73,
      "fragment": "import type { Schema } from '../schema/Schema';\nimport { NODE_TYPE } from './identity';\nimport { NodeBase } from './Node';\nexport declare function collectionFromPath(schema: Schema, path: unknown[], value: unknown): import('./Node').Node;\nexport declare const isEmptyPath: (path: Iterable<unknown> | null | undefined) => path is null | undefined;\nexport declare abstract class Collection extends NodeBase {\n    schema: Schema | undefined;\n    [NODE_TYPE]: symbol;\n    items: unknown[];\n    /** An optional anchor on this node. Used by alias nodes. */\n    anchor?: string;\n    /**\n     * If true, stringify this and all child nodes using flow rather than\n     * block styles.\n     */\n    flow?: boolean;\n    constructor(type: symbol, schema?: Schema);\n    /**\n     * Create a copy of this collection.\n     *\n     * @param schema - If defined, overwrites the original's schema\n     */\n    clone(schema?: Schema): Collection;\n    /** Adds a value to the collection. */\n    abstract add(value: unknown): void;\n    /**\n     * Removes a value from the collection.\n     * @returns `true` if the item was found and removed.\n     */\n    abstract delete(key: unknown): boolean;\n    /**\n     * Returns item at `key`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    abstract get(key: unknown, keepScalar?: boolean): unknown;\n    /**\n     * Checks if the collection includes a value with the key `key`.\n     */\n    abstract has(key: unknown): boolean;\n    /**\n     * Sets a value in this collection. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    abstract set(key: unknown, value: unknown): void;\n    /**\n     * Adds a value to the collection. For `!!map` and `!!omap` the value must\n     * be a Pair instance or a `{ key, value }` object, which may not have a key\n     * that already exists in the map.\n     */\n    addIn(path: Iterable<unknown>, value: unknown): void;\n    /**\n     * Removes a value from the collection.\n     * @returns `true` if the item was found and removed.\n     */\n    deleteIn(path: Iterable<unknown>): boolean;\n    /**\n     * Returns item at `key`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    getIn(path: Iterable<unknown>, keepScalar?: boolean): unknown;\n    hasAllNullValues(allowScalar?: boolean): boolean;\n    /**\n     * Checks if the collection includes a value with the key `key`.\n     */\n    hasIn(path: Iterable<unknown>): boolean;\n    /**\n     * Sets a value in this collection. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    setIn(path: Iterable<unknown>, value: unknown): void;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/nodes/Collection.d.ts",
        "start": 1,
        "end": 73,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 73,
          "column": 2,
          "position": 450
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/nodes/Collection.d.ts",
        "start": 1,
        "end": 73,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 73,
          "column": 2,
          "position": 450
        }
      }
    },
    {
      "format": "typescript",
      "lines": 29,
      "fragment": "import type { Document } from '../doc/Document';\nimport type { FlowScalar } from '../parse/cst';\nimport type { StringifyContext } from '../stringify/stringify';\nimport type { Range } from './Node';\nimport { NodeBase } from './Node';\nimport type { Scalar } from './Scalar';\nimport type { ToJSContext } from './toJS';\nimport type { YAMLMap } from './YAMLMap';\nimport type { YAMLSeq } from './YAMLSeq';\nexport declare namespace Alias {\n    interface Parsed extends Alias {\n        range: Range;\n        srcToken?: FlowScalar & {\n            type: 'alias';\n        };\n    }\n}\nexport declare class Alias extends NodeBase {\n    source: string;\n    anchor?: never;\n    constructor(source: string);\n    /**\n     * Resolve the value of this alias within `doc`, finding the last\n     * instance of the `source` anchor before this node.\n     */\n    resolve(doc: Document, ctx?: ToJSContext): Scalar | YAMLMap | YAMLSeq | undefined;\n    toJSON(_arg?: unknown, ctx?: ToJSContext): unknown;\n    toString(ctx?: StringifyContext, _onComment?: () => void, _onChompKeep?: () => void): string;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/nodes/Alias.d.ts",
        "start": 1,
        "end": 29,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 29,
          "column": 2,
          "position": 321
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/nodes/Alias.d.ts",
        "start": 1,
        "end": 29,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 29,
          "column": 2,
          "position": 321
        }
      }
    },
    {
      "format": "typescript",
      "lines": 49,
      "fragment": "import type { Document } from './Document';\nexport declare class Directives {\n    static defaultYaml: Directives['yaml'];\n    static defaultTags: Directives['tags'];\n    yaml: {\n        version: '1.1' | '1.2' | 'next';\n        explicit?: boolean;\n    };\n    tags: Record<string, string>;\n    /**\n     * The directives-end/doc-start marker `---`. If `null`, a marker may still be\n     * included in the document's stringified representation.\n     */\n    docStart: true | null;\n    /** The doc-end marker `...`.  */\n    docEnd: boolean;\n    /**\n     * Used when parsing YAML 1.1, where:\n     * > If the document specifies no directives, it is parsed using the same\n     * > settings as the previous document. If the document does specify any\n     * > directives, all directives of previous documents, if any, are ignored.\n     */\n    private atNextDocument?;\n    constructor(yaml?: Directives['yaml'], tags?: Directives['tags']);\n    clone(): Directives;\n    /**\n     * During parsing, get a Directives instance for the current document and\n     * update the stream state according to the current version's spec.\n     */\n    atDocument(): Directives;\n    /**\n     * @param onError - May be called even if the action was successful\n     * @returns `true` on success\n     */\n    add(line: string, onError: (offset: number, message: string, warning?: boolean) => void): boolean;\n    /**\n     * Resolves a tag, matching handles to those defined in %TAG directives.\n     *\n     * @returns Resolved tag, which may also be the non-specific tag `'!'` or a\n     *   `'!local'` tag, or `null` if unresolvable.\n     */\n    tagName(source: string, onError: (message: string) => void): string | null;\n    /**\n     * Given a fully resolved tag, returns its printable string form,\n     * taking into account current tag prefixes and defaults.\n     */\n    tagString(tag: string): string;\n    toString(doc?: Document): string;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/doc/directives.d.ts",
        "start": 1,
        "end": 49,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 49,
          "column": 2,
          "position": 283
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/doc/directives.d.ts",
        "start": 1,
        "end": 49,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 49,
          "column": 2,
          "position": 283
        }
      }
    },
    {
      "format": "typescript",
      "lines": 17,
      "fragment": "import type { Node } from '../nodes/Node';\nimport type { Schema } from '../schema/Schema';\nimport type { CollectionTag, ScalarTag } from '../schema/types';\nimport type { Replacer } from './Document';\nexport interface CreateNodeContext {\n    aliasDuplicateObjects: boolean;\n    keepUndefined: boolean;\n    onAnchor: (source: unknown) => string;\n    onTagObj?: (tagObj: ScalarTag | CollectionTag) => void;\n    sourceObjects: Map<unknown, {\n        anchor: string | null;\n        node: Node | null;\n    }>;\n    replacer?: Replacer;\n    schema: Schema;\n}\nexport declare function createNode(value: unknown, tagName: string | undefined, ctx: CreateNodeContext): Node;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/doc/createNode.d.ts",
        "start": 1,
        "end": 17,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 17,
          "column": 2,
          "position": 209
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/doc/createNode.d.ts",
        "start": 1,
        "end": 17,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 17,
          "column": 2,
          "position": 209
        }
      }
    },
    {
      "format": "typescript",
      "lines": 24,
      "fragment": "import type { Node } from '../nodes/Node';\nimport type { Document } from './Document';\n/**\n * Verify that the input string is a valid anchor.\n *\n * Will throw on errors.\n */\nexport declare function anchorIsValid(anchor: string): true;\nexport declare function anchorNames(root: Document<Node, boolean> | Node): Set<string>;\n/** Find a new anchor name with the given `prefix` and a one-indexed suffix. */\nexport declare function findNewAnchor(prefix: string, exclude: Set<string>): string;\nexport declare function createNodeAnchors(doc: Document<Node, boolean>, prefix: string): {\n    onAnchor: (source: unknown) => string;\n    /**\n     * With circular references, the source node is only resolved after all\n     * of its child nodes are. This is why anchors are set only after all of\n     * the nodes have been created.\n     */\n    setAnchors: () => void;\n    sourceObjects: Map<unknown, {\n        anchor: string | null;\n        node: Node | null;\n    }>;\n};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/doc/anchors.d.ts",
        "start": 1,
        "end": 24,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 24,
          "column": 2,
          "position": 209
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/doc/anchors.d.ts",
        "start": 1,
        "end": 24,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 24,
          "column": 2,
          "position": 209
        }
      }
    },
    {
      "format": "typescript",
      "lines": 141,
      "fragment": "import type { YAMLError, YAMLWarning } from '../errors';\nimport { Alias } from '../nodes/Alias';\nimport { NODE_TYPE } from '../nodes/identity';\nimport type { Node, NodeType, ParsedNode, Range } from '../nodes/Node';\nimport { Pair } from '../nodes/Pair';\nimport type { Scalar } from '../nodes/Scalar';\nimport type { YAMLMap } from '../nodes/YAMLMap';\nimport type { YAMLSeq } from '../nodes/YAMLSeq';\nimport type { CreateNodeOptions, DocumentOptions, ParseOptions, SchemaOptions, ToJSOptions, ToStringOptions } from '../options';\nimport { Schema } from '../schema/Schema';\nimport { Directives } from './directives';\nexport type Replacer = any[] | ((key: any, value: any) => unknown);\nexport declare namespace Document {\n    /** @ts-ignore The typing of directives fails in TS <= 4.2 */\n    interface Parsed<Contents extends ParsedNode = ParsedNode, Strict extends boolean = true> extends Document<Contents, Strict> {\n        directives: Directives;\n        range: Range;\n    }\n}\nexport declare class Document<Contents extends Node = Node, Strict extends boolean = true> {\n    readonly [NODE_TYPE]: symbol;\n    /** A comment before this Document */\n    commentBefore: string | null;\n    /** A comment immediately after this Document */\n    comment: string | null;\n    /** The document contents. */\n    contents: Strict extends true ? Contents | null : Contents;\n    directives: Strict extends true ? Directives | undefined : Directives;\n    /** Errors encountered during parsing. */\n    errors: YAMLError[];\n    options: Required<Omit<ParseOptions & DocumentOptions, '_directives' | 'lineCounter' | 'version'>>;\n    /**\n     * The `[start, value-end, node-end]` character offsets for the part of the\n     * source parsed into this document (undefined if not parsed). The `value-end`\n     * and `node-end` positions are themselves not included in their respective\n     * ranges.\n     */\n    range?: Range;\n    /** The schema used with the document. Use `setSchema()` to change. */\n    schema: Schema;\n    /** Warnings encountered during parsing. */\n    warnings: YAMLWarning[];\n    /**\n     * @param value - The initial value for the document, which will be wrapped\n     *   in a Node container.\n     */\n    constructor(value?: any, options?: DocumentOptions & SchemaOptions & ParseOptions & CreateNodeOptions);\n    constructor(value: any, replacer: null | Replacer, options?: DocumentOptions & SchemaOptions & ParseOptions & CreateNodeOptions);\n    /**\n     * Create a deep copy of this Document and its contents.\n     *\n     * Custom Node values that inherit from `Object` still refer to their original instances.\n     */\n    clone(): Document<Contents, Strict>;\n    /** Adds a value to the document. */\n    add(value: any): void;\n    /** Adds a value to the document. */\n    addIn(path: Iterable<unknown>, value: unknown): void;\n    /**\n     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.\n     *\n     * If `node` already has an anchor, `name` is ignored.\n     * Otherwise, the `node.anchor` value will be set to `name`,\n     * or if an anchor with that name is already present in the document,\n     * `name` will be used as a prefix for a new unique anchor.\n     * If `name` is undefined, the generated anchor will use 'a' as a prefix.\n     */\n    createAlias(node: Strict extends true ? Scalar | YAMLMap | YAMLSeq : Node, name?: string): Alias;\n    /**\n     * Convert any value into a `Node` using the current schema, recursively\n     * turning objects into collections.\n     */\n    createNode<T = unknown>(value: T, options?: CreateNodeOptions): NodeType<T>;\n    createNode<T = unknown>(value: T, replacer: Replacer | CreateNodeOptions | null, options?: CreateNodeOptions): NodeType<T>;\n    /**\n     * Convert a key and a value into a `Pair` using the current schema,\n     * recursively wrapping all values as `Scalar` or `Collection` nodes.\n     */\n    createPair<K extends Node = Node, V extends Node = Node>(key: unknown, value: unknown, options?: CreateNodeOptions): Pair<K, V>;\n    /**\n     * Removes a value from the document.\n     * @returns `true` if the item was found and removed.\n     */\n    delete(key: unknown): boolean;\n    /**\n     * Removes a value from the document.\n     * @returns `true` if the item was found and removed.\n     */\n    deleteIn(path: Iterable<unknown> | null): boolean;\n    /**\n     * Returns item at `key`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    get(key: unknown, keepScalar?: boolean): Strict extends true ? unknown : any;\n    /**\n     * Returns item at `path`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    getIn(path: Iterable<unknown> | null, keepScalar?: boolean): Strict extends true ? unknown : any;\n    /**\n     * Checks if the document includes a value with the key `key`.\n     */\n    has(key: unknown): boolean;\n    /**\n     * Checks if the document includes a value at `path`.\n     */\n    hasIn(path: Iterable<unknown> | null): boolean;\n    /**\n     * Sets a value in this document. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    set(key: any, value: unknown): void;\n    /**\n     * Sets a value in this document. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    setIn(path: Iterable<unknown> | null, value: unknown): void;\n    /**\n     * Change the YAML version and schema used by the document.\n     * A `null` version disables support for directives, explicit tags, anchors, and aliases.\n     * It also requires the `schema` option to be given as a `Schema` instance value.\n     *\n     * Overrides all previously set schema options.\n     */\n    setSchema(version: '1.1' | '1.2' | 'next' | null, options?: SchemaOptions): void;\n    /** A plain JavaScript representation of the document `contents`. */\n    toJS(opt?: ToJSOptions & {\n        [ignored: string]: unknown;\n    }): any;\n    /**\n     * A JSON representation of the document `contents`.\n     *\n     * @param jsonArg Used by `JSON.stringify` to indicate the array index or\n     *   property name.\n     */\n    toJSON(jsonArg?: string | null, onAnchor?: ToJSOptions['onAnchor']): any;\n    /** A YAML representation of the document. */\n    toString(options?: ToStringOptions): string;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/doc/Document.d.ts",
        "start": 1,
        "end": 141,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 141,
          "column": 2,
          "position": 1112
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/doc/Document.d.ts",
        "start": 1,
        "end": 141,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 141,
          "column": 2,
          "position": 1112
        }
      }
    },
    {
      "format": "typescript",
      "lines": 23,
      "fragment": "import type { SourceToken, Token } from '../parse/cst';\nimport type { ComposeErrorHandler } from './composer';\nexport interface ResolvePropsArg {\n    flow?: 'flow map' | 'flow sequence';\n    indicator: 'doc-start' | 'explicit-key-ind' | 'map-value-ind' | 'seq-item-ind';\n    next: Token | null | undefined;\n    offset: number;\n    onError: ComposeErrorHandler;\n    parentIndent: number;\n    startOnNewline: boolean;\n}\nexport declare function resolveProps(tokens: SourceToken[], { flow, indicator, next, offset, onError, parentIndent, startOnNewline }: ResolvePropsArg): {\n    comma: SourceToken | null;\n    found: SourceToken | null;\n    spaceBefore: boolean;\n    comment: string;\n    hasNewline: boolean;\n    anchor: SourceToken | null;\n    tag: SourceToken | null;\n    newlineAfterProp: SourceToken | null;\n    end: number;\n    start: number;\n};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/compose/resolve-props.d.ts",
        "start": 1,
        "end": 23,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 23,
          "column": 2,
          "position": 255
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/compose/resolve-props.d.ts",
        "start": 1,
        "end": 23,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 23,
          "column": 2,
          "position": 255
        }
      }
    },
    {
      "format": "typescript",
      "lines": 11,
      "fragment": "import type { Range } from '../nodes/Node';\nimport { Scalar } from '../nodes/Scalar';\nimport type { BlockScalar } from '../parse/cst';\nimport type { ComposeContext } from './compose-node';\nimport type { ComposeErrorHandler } from './composer';\nexport declare function resolveBlockScalar(ctx: ComposeContext, scalar: BlockScalar, onError: ComposeErrorHandler): {\n    value: string;\n    type: Scalar.BLOCK_FOLDED | Scalar.BLOCK_LITERAL | null;\n    comment: string;\n    range: Range;\n};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/compose/resolve-block-scalar.d.ts",
        "start": 1,
        "end": 11,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 11,
          "column": 2,
          "position": 143
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/compose/resolve-block-scalar.d.ts",
        "start": 1,
        "end": 11,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 11,
          "column": 2,
          "position": 143
        }
      }
    },
    {
      "format": "typescript",
      "lines": 63,
      "fragment": "import { Directives } from '../doc/directives';\nimport { Document } from '../doc/Document';\nimport type { ErrorCode } from '../errors';\nimport { YAMLParseError, YAMLWarning } from '../errors';\nimport type { ParsedNode, Range } from '../nodes/Node';\nimport type { DocumentOptions, ParseOptions, SchemaOptions } from '../options';\nimport type { Token } from '../parse/cst';\ntype ErrorSource = number | [number, number] | Range | {\n    offset: number;\n    source?: string;\n};\nexport type ComposeErrorHandler = (source: ErrorSource, code: ErrorCode, message: string, warning?: boolean) => void;\n/**\n * Compose a stream of CST nodes into a stream of YAML Documents.\n *\n * ```ts\n * import { Composer, Parser } from 'yaml'\n *\n * const src: string = ...\n * const tokens = new Parser().parse(src)\n * const docs = new Composer().compose(tokens)\n * ```\n */\nexport declare class Composer<Contents extends ParsedNode = ParsedNode, Strict extends boolean = true> {\n    private directives;\n    private doc;\n    private options;\n    private atDirectives;\n    private prelude;\n    private errors;\n    private warnings;\n    constructor(options?: ParseOptions & DocumentOptions & SchemaOptions);\n    private onError;\n    private decorate;\n    /**\n     * Current stream status information.\n     *\n     * Mostly useful at the end of input for an empty stream.\n     */\n    streamInfo(): {\n        comment: string;\n        directives: Directives;\n        errors: YAMLParseError[];\n        warnings: YAMLWarning[];\n    };\n    /**\n     * Compose tokens into documents.\n     *\n     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n     */\n    compose(tokens: Iterable<Token>, forceDoc?: boolean, endOffset?: number): Generator<Document.Parsed<Contents, Strict>, void, unknown>;\n    /** Advance the composer by one CST token. */\n    next(token: Token): Generator<Document.Parsed<Contents, Strict>, void, unknown>;\n    /**\n     * Call at end of input to yield any remaining document.\n     *\n     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n     */\n    end(forceDoc?: boolean, endOffset?: number): Generator<Document.Parsed<Contents, Strict>, void, unknown>;\n}\nexport {};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/compose/composer.d.ts",
        "start": 1,
        "end": 63,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 63,
          "column": 2,
          "position": 477
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/compose/composer.d.ts",
        "start": 1,
        "end": 63,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 63,
          "column": 2,
          "position": 477
        }
      }
    },
    {
      "format": "typescript",
      "lines": 29,
      "fragment": "import type { Directives } from '../doc/directives';\nimport type { ParsedNode } from '../nodes/Node';\nimport type { ParseOptions } from '../options';\nimport type { SourceToken, Token } from '../parse/cst';\nimport type { Schema } from '../schema/Schema';\nimport type { ComposeErrorHandler } from './composer';\nexport interface ComposeContext {\n    atKey: boolean;\n    atRoot: boolean;\n    directives: Directives;\n    options: Readonly<Required<Omit<ParseOptions, 'lineCounter'>>>;\n    schema: Readonly<Schema>;\n}\ninterface Props {\n    spaceBefore: boolean;\n    comment: string;\n    anchor: SourceToken | null;\n    tag: SourceToken | null;\n    newlineAfterProp: SourceToken | null;\n    end: number;\n}\ndeclare const CN: {\n    composeNode: typeof composeNode;\n    composeEmptyNode: typeof composeEmptyNode;\n};\nexport type ComposeNode = typeof CN;\nexport declare function composeNode(ctx: ComposeContext, token: Token, props: Props, onError: ComposeErrorHandler): ParsedNode;\nexport declare function composeEmptyNode(ctx: ComposeContext, offset: number, before: Token[] | undefined, pos: number | null, { spaceBefore, comment, anchor, tag, end }: Props, onError: ComposeErrorHandler): import('../index').Scalar.Parsed;\nexport {};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/compose/compose-node.d.ts",
        "start": 1,
        "end": 29,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 29,
          "column": 2,
          "position": 377
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/compose/compose-node.d.ts",
        "start": 1,
        "end": 29,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 29,
          "column": 2,
          "position": 377
        }
      }
    },
    {
      "format": "typescript",
      "lines": 11,
      "fragment": "import type { ParsedNode } from '../nodes/Node';\nimport type { BlockMap, BlockSequence, FlowCollection, SourceToken } from '../parse/cst';\nimport type { ComposeContext, ComposeNode } from './compose-node';\nimport type { ComposeErrorHandler } from './composer';\ninterface Props {\n    anchor: SourceToken | null;\n    tag: SourceToken | null;\n    newlineAfterProp: SourceToken | null;\n}\nexport declare function composeCollection(CN: ComposeNode, ctx: ComposeContext, token: BlockMap | BlockSequence | FlowCollection, props: Props, onError: ComposeErrorHandler): ParsedNode;\nexport {};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/compose/compose-collection.d.ts",
        "start": 1,
        "end": 11,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 11,
          "column": 2,
          "position": 167
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/compose/compose-collection.d.ts",
        "start": 1,
        "end": 11,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 11,
          "column": 2,
          "position": 167
        }
      }
    },
    {
      "format": "typescript",
      "lines": 102,
      "fragment": "/**\n * The Standard Schema interface.\n */\nexport type StandardSchemaV1<Input = unknown, Output = Input> = {\n    /**\n     * The Standard Schema properties.\n     */\n    readonly \"~standard\": StandardSchemaV1.Props<Input, Output>;\n};\nexport declare namespace StandardSchemaV1 {\n    /**\n     * The Standard Schema properties interface.\n     */\n    export interface Props<Input = unknown, Output = Input> {\n        /**\n         * The version number of the standard.\n         */\n        readonly version: 1;\n        /**\n         * The vendor name of the schema library.\n         */\n        readonly vendor: string;\n        /**\n         * Validates unknown input values.\n         */\n        readonly validate: (value: unknown) => Result<Output> | Promise<Result<Output>>;\n        /**\n         * Inferred types associated with the schema.\n         */\n        readonly types?: Types<Input, Output> | undefined;\n    }\n    /**\n     * The result interface of the validate function.\n     */\n    export type Result<Output> = SuccessResult<Output> | FailureResult;\n    /**\n     * The result interface if validation succeeds.\n     */\n    export interface SuccessResult<Output> {\n        /**\n         * The typed output value.\n         */\n        readonly value: Output;\n        /**\n         * The non-existent issues.\n         */\n        readonly issues?: undefined;\n    }\n    /**\n     * The result interface if validation fails.\n     */\n    export interface FailureResult {\n        /**\n         * The issues of failed validation.\n         */\n        readonly issues: ReadonlyArray<Issue>;\n    }\n    /**\n     * The issue interface of the failure output.\n     */\n    export interface Issue {\n        /**\n         * The error message of the issue.\n         */\n        readonly message: string;\n        /**\n         * The path of the issue, if any.\n         */\n        readonly path?: ReadonlyArray<PropertyKey | PathSegment> | undefined;\n    }\n    /**\n     * The path segment interface of the issue.\n     */\n    export interface PathSegment {\n        /**\n         * The key representing a path segment.\n         */\n        readonly key: PropertyKey;\n    }\n    /**\n     * The Standard Schema types interface.\n     */\n    export interface Types<Input = unknown, Output = Input> {\n        /**\n         * The input type of the schema.\n         */\n        readonly input: Input;\n        /**\n         * The output type of the schema.\n         */\n        readonly output: Output;\n    }\n    /**\n     * Infers the input type of a Standard Schema.\n     */\n    export type InferInput<Schema extends StandardSchemaV1> = NonNullable<Schema[\"~standard\"][\"types\"]>[\"input\"];\n    /**\n     * Infers the output type of a Standard Schema.\n     */\n    export type InferOutput<Schema extends StandardSchemaV1> = NonNullable<Schema[\"~standard\"][\"types\"]>[\"output\"];\n    export {};\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v3/standard-schema.d.ts",
        "start": 1,
        "end": 102,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 102,
          "column": 2,
          "position": 472
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v3/standard-schema.d.ts",
        "start": 1,
        "end": 102,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 102,
          "column": 2,
          "position": 472
        }
      }
    },
    {
      "format": "typescript",
      "lines": 102,
      "fragment": "/**\n * The Standard Schema interface.\n */\nexport type StandardSchemaV1<Input = unknown, Output = Input> = {\n    /**\n     * The Standard Schema properties.\n     */\n    readonly \"~standard\": StandardSchemaV1.Props<Input, Output>;\n};\nexport declare namespace StandardSchemaV1 {\n    /**\n     * The Standard Schema properties interface.\n     */\n    export interface Props<Input = unknown, Output = Input> {\n        /**\n         * The version number of the standard.\n         */\n        readonly version: 1;\n        /**\n         * The vendor name of the schema library.\n         */\n        readonly vendor: string;\n        /**\n         * Validates unknown input values.\n         */\n        readonly validate: (value: unknown) => Result<Output> | Promise<Result<Output>>;\n        /**\n         * Inferred types associated with the schema.\n         */\n        readonly types?: Types<Input, Output> | undefined;\n    }\n    /**\n     * The result interface of the validate function.\n     */\n    export type Result<Output> = SuccessResult<Output> | FailureResult;\n    /**\n     * The result interface if validation succeeds.\n     */\n    export interface SuccessResult<Output> {\n        /**\n         * The typed output value.\n         */\n        readonly value: Output;\n        /**\n         * The non-existent issues.\n         */\n        readonly issues?: undefined;\n    }\n    /**\n     * The result interface if validation fails.\n     */\n    export interface FailureResult {\n        /**\n         * The issues of failed validation.\n         */\n        readonly issues: ReadonlyArray<Issue>;\n    }\n    /**\n     * The issue interface of the failure output.\n     */\n    export interface Issue {\n        /**\n         * The error message of the issue.\n         */\n        readonly message: string;\n        /**\n         * The path of the issue, if any.\n         */\n        readonly path?: ReadonlyArray<PropertyKey | PathSegment> | undefined;\n    }\n    /**\n     * The path segment interface of the issue.\n     */\n    export interface PathSegment {\n        /**\n         * The key representing a path segment.\n         */\n        readonly key: PropertyKey;\n    }\n    /**\n     * The Standard Schema types interface.\n     */\n    export interface Types<Input = unknown, Output = Input> {\n        /**\n         * The input type of the schema.\n         */\n        readonly input: Input;\n        /**\n         * The output type of the schema.\n         */\n        readonly output: Output;\n    }\n    /**\n     * Infers the input type of a Standard Schema.\n     */\n    export type InferInput<Schema extends StandardSchemaV1> = NonNullable<Schema[\"~standard\"][\"types\"]>[\"input\"];\n    /**\n     * Infers the output type of a Standard Schema.\n     */\n    export type InferOutput<Schema extends StandardSchemaV1> = NonNullable<Schema[\"~standard\"][\"types\"]>[\"output\"];\n    export {};\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v3/standard-schema.d.cts",
        "start": 1,
        "end": 102,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 102,
          "column": 2,
          "position": 472
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v3/standard-schema.d.ts",
        "start": 1,
        "end": 102,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 102,
          "column": 2,
          "position": 472
        }
      }
    },
    {
      "format": "typescript",
      "lines": 164,
      "fragment": "import type { Primitive } from \"./helpers/typeAliases.js\";\nimport { util, type ZodParsedType } from \"./helpers/util.js\";\nimport type { TypeOf, ZodType } from \"./index.js\";\ntype allKeys<T> = T extends any ? keyof T : never;\nexport type inferFlattenedErrors<T extends ZodType<any, any, any>, U = string> = typeToFlattenedError<TypeOf<T>, U>;\nexport type typeToFlattenedError<T, U = string> = {\n    formErrors: U[];\n    fieldErrors: {\n        [P in allKeys<T>]?: U[];\n    };\n};\nexport declare const ZodIssueCode: {\n    invalid_type: \"invalid_type\";\n    invalid_literal: \"invalid_literal\";\n    custom: \"custom\";\n    invalid_union: \"invalid_union\";\n    invalid_union_discriminator: \"invalid_union_discriminator\";\n    invalid_enum_value: \"invalid_enum_value\";\n    unrecognized_keys: \"unrecognized_keys\";\n    invalid_arguments: \"invalid_arguments\";\n    invalid_return_type: \"invalid_return_type\";\n    invalid_date: \"invalid_date\";\n    invalid_string: \"invalid_string\";\n    too_small: \"too_small\";\n    too_big: \"too_big\";\n    invalid_intersection_types: \"invalid_intersection_types\";\n    not_multiple_of: \"not_multiple_of\";\n    not_finite: \"not_finite\";\n};\nexport type ZodIssueCode = keyof typeof ZodIssueCode;\nexport type ZodIssueBase = {\n    path: (string | number)[];\n    message?: string | undefined;\n};\nexport interface ZodInvalidTypeIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_type;\n    expected: ZodParsedType;\n    received: ZodParsedType;\n}\nexport interface ZodInvalidLiteralIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_literal;\n    expected: unknown;\n    received: unknown;\n}\nexport interface ZodUnrecognizedKeysIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.unrecognized_keys;\n    keys: string[];\n}\nexport interface ZodInvalidUnionIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_union;\n    unionErrors: ZodError[];\n}\nexport interface ZodInvalidUnionDiscriminatorIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_union_discriminator;\n    options: Primitive[];\n}\nexport interface ZodInvalidEnumValueIssue extends ZodIssueBase {\n    received: string | number;\n    code: typeof ZodIssueCode.invalid_enum_value;\n    options: (string | number)[];\n}\nexport interface ZodInvalidArgumentsIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_arguments;\n    argumentsError: ZodError;\n}\nexport interface ZodInvalidReturnTypeIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_return_type;\n    returnTypeError: ZodError;\n}\nexport interface ZodInvalidDateIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_date;\n}\nexport type StringValidation = \"email\" | \"url\" | \"emoji\" | \"uuid\" | \"nanoid\" | \"regex\" | \"cuid\" | \"cuid2\" | \"ulid\" | \"datetime\" | \"date\" | \"time\" | \"duration\" | \"ip\" | \"cidr\" | \"base64\" | \"jwt\" | \"base64url\" | {\n    includes: string;\n    position?: number | undefined;\n} | {\n    startsWith: string;\n} | {\n    endsWith: string;\n};\nexport interface ZodInvalidStringIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_string;\n    validation: StringValidation;\n}\nexport interface ZodTooSmallIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.too_small;\n    minimum: number | bigint;\n    inclusive: boolean;\n    exact?: boolean;\n    type: \"array\" | \"string\" | \"number\" | \"set\" | \"date\" | \"bigint\";\n}\nexport interface ZodTooBigIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.too_big;\n    maximum: number | bigint;\n    inclusive: boolean;\n    exact?: boolean;\n    type: \"array\" | \"string\" | \"number\" | \"set\" | \"date\" | \"bigint\";\n}\nexport interface ZodInvalidIntersectionTypesIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_intersection_types;\n}\nexport interface ZodNotMultipleOfIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.not_multiple_of;\n    multipleOf: number | bigint;\n}\nexport interface ZodNotFiniteIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.not_finite;\n}\nexport interface ZodCustomIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.custom;\n    params?: {\n        [k: string]: any;\n    };\n}\nexport type DenormalizedError = {\n    [k: string]: DenormalizedError | string[];\n};\nexport type ZodIssueOptionalMessage = ZodInvalidTypeIssue | ZodInvalidLiteralIssue | ZodUnrecognizedKeysIssue | ZodInvalidUnionIssue | ZodInvalidUnionDiscriminatorIssue | ZodInvalidEnumValueIssue | ZodInvalidArgumentsIssue | ZodInvalidReturnTypeIssue | ZodInvalidDateIssue | ZodInvalidStringIssue | ZodTooSmallIssue | ZodTooBigIssue | ZodInvalidIntersectionTypesIssue | ZodNotMultipleOfIssue | ZodNotFiniteIssue | ZodCustomIssue;\nexport type ZodIssue = ZodIssueOptionalMessage & {\n    fatal?: boolean | undefined;\n    message: string;\n};\nexport declare const quotelessJson: (obj: any) => string;\ntype recursiveZodFormattedError<T> = T extends [any, ...any[]] ? {\n    [K in keyof T]?: ZodFormattedError<T[K]>;\n} : T extends any[] ? {\n    [k: number]: ZodFormattedError<T[number]>;\n} : T extends object ? {\n    [K in keyof T]?: ZodFormattedError<T[K]>;\n} : unknown;\nexport type ZodFormattedError<T, U = string> = {\n    _errors: U[];\n} & recursiveZodFormattedError<NonNullable<T>>;\nexport type inferFormattedError<T extends ZodType<any, any, any>, U = string> = ZodFormattedError<TypeOf<T>, U>;\nexport declare class ZodError<T = any> extends Error {\n    issues: ZodIssue[];\n    get errors(): ZodIssue[];\n    constructor(issues: ZodIssue[]);\n    format(): ZodFormattedError<T>;\n    format<U>(mapper: (issue: ZodIssue) => U): ZodFormattedError<T, U>;\n    static create: (issues: ZodIssue[]) => ZodError<any>;\n    static assert(value: unknown): asserts value is ZodError;\n    toString(): string;\n    get message(): string;\n    get isEmpty(): boolean;\n    addIssue: (sub: ZodIssue) => void;\n    addIssues: (subs?: ZodIssue[]) => void;\n    flatten(): typeToFlattenedError<T>;\n    flatten<U>(mapper?: (issue: ZodIssue) => U): typeToFlattenedError<T, U>;\n    get formErrors(): typeToFlattenedError<T, string>;\n}\ntype stripPath<T extends object> = T extends any ? util.OmitKeys<T, \"path\"> : never;\nexport type IssueData = stripPath<ZodIssueOptionalMessage> & {\n    path?: (string | number)[];\n    fatal?: boolean | undefined;\n};\nexport type ErrorMapCtx = {\n    defaultError: string;\n    data: any;\n};\nexport type ZodErrorMap = (issue: ZodIssueOptionalMessage, _ctx: ErrorMapCtx) => {\n    message: string;\n};\nexport {};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v3/ZodError.d.ts",
        "start": 1,
        "end": 164,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 164,
          "column": 2,
          "position": 1924
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/src/v3/ZodError.ts",
        "start": 1,
        "end": 164,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 164,
          "column": 2,
          "position": 1924
        }
      }
    },
    {
      "format": "typescript",
      "lines": 164,
      "fragment": "import type { Primitive } from \"./helpers/typeAliases.cjs\";\nimport { util, type ZodParsedType } from \"./helpers/util.cjs\";\nimport type { TypeOf, ZodType } from \"./index.cjs\";\ntype allKeys<T> = T extends any ? keyof T : never;\nexport type inferFlattenedErrors<T extends ZodType<any, any, any>, U = string> = typeToFlattenedError<TypeOf<T>, U>;\nexport type typeToFlattenedError<T, U = string> = {\n    formErrors: U[];\n    fieldErrors: {\n        [P in allKeys<T>]?: U[];\n    };\n};\nexport declare const ZodIssueCode: {\n    invalid_type: \"invalid_type\";\n    invalid_literal: \"invalid_literal\";\n    custom: \"custom\";\n    invalid_union: \"invalid_union\";\n    invalid_union_discriminator: \"invalid_union_discriminator\";\n    invalid_enum_value: \"invalid_enum_value\";\n    unrecognized_keys: \"unrecognized_keys\";\n    invalid_arguments: \"invalid_arguments\";\n    invalid_return_type: \"invalid_return_type\";\n    invalid_date: \"invalid_date\";\n    invalid_string: \"invalid_string\";\n    too_small: \"too_small\";\n    too_big: \"too_big\";\n    invalid_intersection_types: \"invalid_intersection_types\";\n    not_multiple_of: \"not_multiple_of\";\n    not_finite: \"not_finite\";\n};\nexport type ZodIssueCode = keyof typeof ZodIssueCode;\nexport type ZodIssueBase = {\n    path: (string | number)[];\n    message?: string | undefined;\n};\nexport interface ZodInvalidTypeIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_type;\n    expected: ZodParsedType;\n    received: ZodParsedType;\n}\nexport interface ZodInvalidLiteralIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_literal;\n    expected: unknown;\n    received: unknown;\n}\nexport interface ZodUnrecognizedKeysIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.unrecognized_keys;\n    keys: string[];\n}\nexport interface ZodInvalidUnionIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_union;\n    unionErrors: ZodError[];\n}\nexport interface ZodInvalidUnionDiscriminatorIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_union_discriminator;\n    options: Primitive[];\n}\nexport interface ZodInvalidEnumValueIssue extends ZodIssueBase {\n    received: string | number;\n    code: typeof ZodIssueCode.invalid_enum_value;\n    options: (string | number)[];\n}\nexport interface ZodInvalidArgumentsIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_arguments;\n    argumentsError: ZodError;\n}\nexport interface ZodInvalidReturnTypeIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_return_type;\n    returnTypeError: ZodError;\n}\nexport interface ZodInvalidDateIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_date;\n}\nexport type StringValidation = \"email\" | \"url\" | \"emoji\" | \"uuid\" | \"nanoid\" | \"regex\" | \"cuid\" | \"cuid2\" | \"ulid\" | \"datetime\" | \"date\" | \"time\" | \"duration\" | \"ip\" | \"cidr\" | \"base64\" | \"jwt\" | \"base64url\" | {\n    includes: string;\n    position?: number | undefined;\n} | {\n    startsWith: string;\n} | {\n    endsWith: string;\n};\nexport interface ZodInvalidStringIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_string;\n    validation: StringValidation;\n}\nexport interface ZodTooSmallIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.too_small;\n    minimum: number | bigint;\n    inclusive: boolean;\n    exact?: boolean;\n    type: \"array\" | \"string\" | \"number\" | \"set\" | \"date\" | \"bigint\";\n}\nexport interface ZodTooBigIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.too_big;\n    maximum: number | bigint;\n    inclusive: boolean;\n    exact?: boolean;\n    type: \"array\" | \"string\" | \"number\" | \"set\" | \"date\" | \"bigint\";\n}\nexport interface ZodInvalidIntersectionTypesIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_intersection_types;\n}\nexport interface ZodNotMultipleOfIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.not_multiple_of;\n    multipleOf: number | bigint;\n}\nexport interface ZodNotFiniteIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.not_finite;\n}\nexport interface ZodCustomIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.custom;\n    params?: {\n        [k: string]: any;\n    };\n}\nexport type DenormalizedError = {\n    [k: string]: DenormalizedError | string[];\n};\nexport type ZodIssueOptionalMessage = ZodInvalidTypeIssue | ZodInvalidLiteralIssue | ZodUnrecognizedKeysIssue | ZodInvalidUnionIssue | ZodInvalidUnionDiscriminatorIssue | ZodInvalidEnumValueIssue | ZodInvalidArgumentsIssue | ZodInvalidReturnTypeIssue | ZodInvalidDateIssue | ZodInvalidStringIssue | ZodTooSmallIssue | ZodTooBigIssue | ZodInvalidIntersectionTypesIssue | ZodNotMultipleOfIssue | ZodNotFiniteIssue | ZodCustomIssue;\nexport type ZodIssue = ZodIssueOptionalMessage & {\n    fatal?: boolean | undefined;\n    message: string;\n};\nexport declare const quotelessJson: (obj: any) => string;\ntype recursiveZodFormattedError<T> = T extends [any, ...any[]] ? {\n    [K in keyof T]?: ZodFormattedError<T[K]>;\n} : T extends any[] ? {\n    [k: number]: ZodFormattedError<T[number]>;\n} : T extends object ? {\n    [K in keyof T]?: ZodFormattedError<T[K]>;\n} : unknown;\nexport type ZodFormattedError<T, U = string> = {\n    _errors: U[];\n} & recursiveZodFormattedError<NonNullable<T>>;\nexport type inferFormattedError<T extends ZodType<any, any, any>, U = string> = ZodFormattedError<TypeOf<T>, U>;\nexport declare class ZodError<T = any> extends Error {\n    issues: ZodIssue[];\n    get errors(): ZodIssue[];\n    constructor(issues: ZodIssue[]);\n    format(): ZodFormattedError<T>;\n    format<U>(mapper: (issue: ZodIssue) => U): ZodFormattedError<T, U>;\n    static create: (issues: ZodIssue[]) => ZodError<any>;\n    static assert(value: unknown): asserts value is ZodError;\n    toString(): string;\n    get message(): string;\n    get isEmpty(): boolean;\n    addIssue: (sub: ZodIssue) => void;\n    addIssues: (subs?: ZodIssue[]) => void;\n    flatten(): typeToFlattenedError<T>;\n    flatten<U>(mapper?: (issue: ZodIssue) => U): typeToFlattenedError<T, U>;\n    get formErrors(): typeToFlattenedError<T, string>;\n}\ntype stripPath<T extends object> = T extends any ? util.OmitKeys<T, \"path\"> : never;\nexport type IssueData = stripPath<ZodIssueOptionalMessage> & {\n    path?: (string | number)[];\n    fatal?: boolean | undefined;\n};\nexport type ErrorMapCtx = {\n    defaultError: string;\n    data: any;\n};\nexport type ZodErrorMap = (issue: ZodIssueOptionalMessage, _ctx: ErrorMapCtx) => {\n    message: string;\n};\nexport {};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod/v3/ZodError.d.cts",
        "start": 1,
        "end": 164,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 164,
          "column": 2,
          "position": 1924
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod/v3/ZodError.d.cts",
        "start": 1,
        "end": 164,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 164,
          "column": 2,
          "position": 1924
        }
      }
    },
    {
      "format": "typescript",
      "lines": 102,
      "fragment": "import type { Document } from './doc/Document';\nimport type { Alias } from './nodes/Alias';\nimport type { Node } from './nodes/Node';\nimport type { Pair } from './nodes/Pair';\nimport type { Scalar } from './nodes/Scalar';\nimport type { YAMLMap } from './nodes/YAMLMap';\nimport type { YAMLSeq } from './nodes/YAMLSeq';\nexport type visitorFn<T> = (key: number | 'key' | 'value' | null, node: T, path: readonly (Document | Node | Pair)[]) => void | symbol | number | Node | Pair;\nexport type visitor = visitorFn<unknown> | {\n    Alias?: visitorFn<Alias>;\n    Collection?: visitorFn<YAMLMap | YAMLSeq>;\n    Map?: visitorFn<YAMLMap>;\n    Node?: visitorFn<Alias | Scalar | YAMLMap | YAMLSeq>;\n    Pair?: visitorFn<Pair>;\n    Scalar?: visitorFn<Scalar>;\n    Seq?: visitorFn<YAMLSeq>;\n    Value?: visitorFn<Scalar | YAMLMap | YAMLSeq>;\n};\nexport type asyncVisitorFn<T> = (key: number | 'key' | 'value' | null, node: T, path: readonly (Document | Node | Pair)[]) => void | symbol | number | Node | Pair | Promise<void | symbol | number | Node | Pair>;\nexport type asyncVisitor = asyncVisitorFn<unknown> | {\n    Alias?: asyncVisitorFn<Alias>;\n    Collection?: asyncVisitorFn<YAMLMap | YAMLSeq>;\n    Map?: asyncVisitorFn<YAMLMap>;\n    Node?: asyncVisitorFn<Alias | Scalar | YAMLMap | YAMLSeq>;\n    Pair?: asyncVisitorFn<Pair>;\n    Scalar?: asyncVisitorFn<Scalar>;\n    Seq?: asyncVisitorFn<YAMLSeq>;\n    Value?: asyncVisitorFn<Scalar | YAMLMap | YAMLSeq>;\n};\n/**\n * Apply a visitor to an AST node or document.\n *\n * Walks through the tree (depth-first) starting from `node`, calling a\n * `visitor` function with three arguments:\n *   - `key`: For sequence values and map `Pair`, the node's index in the\n *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.\n *     `null` for the root node.\n *   - `node`: The current node.\n *   - `path`: The ancestry of the current node.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this node, continue with next\n *     sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current node, then continue with the next one\n *   - `Node`: Replace the current node, then continue by visiting it\n *   - `number`: While iterating the items of a sequence or map, set the index\n *     of the next step. This is useful especially if the index of the current\n *     node has changed.\n *\n * If `visitor` is a single function, it will be called with all values\n * encountered in the tree, including e.g. `null` values. Alternatively,\n * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,\n * `Alias` and `Scalar` node. To define the same visitor function for more than\n * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)\n * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most\n * specific defined one will be used for each node.\n */\nexport declare function visit(node: Node | Document | null, visitor: visitor): void;\nexport declare namespace visit {\n    var BREAK: symbol;\n    var SKIP: symbol;\n    var REMOVE: symbol;\n}\n/**\n * Apply an async visitor to an AST node or document.\n *\n * Walks through the tree (depth-first) starting from `node`, calling a\n * `visitor` function with three arguments:\n *   - `key`: For sequence values and map `Pair`, the node's index in the\n *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.\n *     `null` for the root node.\n *   - `node`: The current node.\n *   - `path`: The ancestry of the current node.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `Promise`: Must resolve to one of the following values\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this node, continue with next\n *     sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current node, then continue with the next one\n *   - `Node`: Replace the current node, then continue by visiting it\n *   - `number`: While iterating the items of a sequence or map, set the index\n *     of the next step. This is useful especially if the index of the current\n *     node has changed.\n *\n * If `visitor` is a single function, it will be called with all values\n * encountered in the tree, including e.g. `null` values. Alternatively,\n * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,\n * `Alias` and `Scalar` node. To define the same visitor function for more than\n * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)\n * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most\n * specific defined one will be used for each node.\n */\nexport declare function visitAsync(node: Node | Document | null, visitor: asyncVisitor): Promise<void>;\nexport declare namespace visitAsync {\n    var BREAK: symbol;\n    var SKIP: symbol;\n    var REMOVE: symbol;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/visit.d.ts",
        "start": 1,
        "end": 102,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 102,
          "column": 2,
          "position": 693
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/visit.d.ts",
        "start": 1,
        "end": 102,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 102,
          "column": 2,
          "position": 693
        }
      }
    },
    {
      "format": "typescript",
      "lines": 16,
      "fragment": "export { createNode } from './doc/createNode';\nexport type { CreateNodeContext } from './doc/createNode';\nexport { debug, warn } from './log';\nexport type { LogLevelId } from './log';\nexport { createPair } from './nodes/Pair';\nexport { toJS } from './nodes/toJS';\nexport type { ToJSContext } from './nodes/toJS';\nexport { findPair } from './nodes/YAMLMap';\nexport { map as mapTag } from './schema/common/map';\nexport { seq as seqTag } from './schema/common/seq';\nexport { string as stringTag } from './schema/common/string';\nexport { foldFlowLines } from './stringify/foldFlowLines';\nexport type { FoldOptions } from './stringify/foldFlowLines';\nexport type { StringifyContext } from './stringify/stringify';\nexport { stringifyNumber } from './stringify/stringifyNumber';\nexport { stringifyString } from './stringify/stringifyString';",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/util.d.ts",
        "start": 1,
        "end": 16,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 16,
          "column": 2,
          "position": 231
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/util.d.ts",
        "start": 1,
        "end": 16,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 16,
          "column": 2,
          "position": 231
        }
      }
    },
    {
      "format": "typescript",
      "lines": 44,
      "fragment": "import { Composer } from './compose/composer';\nimport type { Reviver } from './doc/applyReviver';\nimport type { Replacer } from './doc/Document';\nimport { Document } from './doc/Document';\nimport type { Node, ParsedNode } from './nodes/Node';\nimport type { CreateNodeOptions, DocumentOptions, ParseOptions, SchemaOptions, ToJSOptions, ToStringOptions } from './options';\nexport interface EmptyStream extends Array<Document.Parsed>, ReturnType<Composer['streamInfo']> {\n    empty: true;\n}\n/**\n * Parse the input as a stream of YAML documents.\n *\n * Documents should be separated from each other by `...` or `---` marker lines.\n *\n * @returns If an empty `docs` array is returned, it will be of type\n *   EmptyStream and contain additional stream information. In\n *   TypeScript, you should use `'empty' in docs` as a type guard for it.\n */\nexport declare function parseAllDocuments<Contents extends Node = ParsedNode, Strict extends boolean = true>(source: string, options?: ParseOptions & DocumentOptions & SchemaOptions): Array<Contents extends ParsedNode ? Document.Parsed<Contents, Strict> : Document<Contents, Strict>> | EmptyStream;\n/** Parse an input string into a single YAML.Document */\nexport declare function parseDocument<Contents extends Node = ParsedNode, Strict extends boolean = true>(source: string, options?: ParseOptions & DocumentOptions & SchemaOptions): Contents extends ParsedNode ? Document.Parsed<Contents, Strict> : Document<Contents, Strict>;\n/**\n * Parse an input string into JavaScript.\n *\n * Only supports input consisting of a single YAML document; for multi-document\n * support you should use `YAML.parseAllDocuments`. May throw on error, and may\n * log warnings using `console.warn`.\n *\n * @param str - A string with YAML formatting.\n * @param reviver - A reviver function, as in `JSON.parse()`\n * @returns The value will match the type of the root value of the parsed YAML\n *   document, so Maps become objects, Sequences arrays, and scalars result in\n *   nulls, booleans, numbers and strings.\n */\nexport declare function parse(src: string, options?: ParseOptions & DocumentOptions & SchemaOptions & ToJSOptions): any;\nexport declare function parse(src: string, reviver: Reviver, options?: ParseOptions & DocumentOptions & SchemaOptions & ToJSOptions): any;\n/**\n * Stringify a value as a YAML document.\n *\n * @param replacer - A replacer array or function, as in `JSON.stringify()`\n * @returns Will always include `\\n` as the last character, as is expected of YAML documents.\n */\nexport declare function stringify(value: any, options?: DocumentOptions & SchemaOptions & ParseOptions & CreateNodeOptions & ToStringOptions): string;\nexport declare function stringify(value: any, replacer?: Replacer | null, options?: string | number | (DocumentOptions & SchemaOptions & ParseOptions & CreateNodeOptions & ToStringOptions)): string;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/public-api.d.ts",
        "start": 1,
        "end": 44,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 44,
          "column": 2,
          "position": 496
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/public-api.d.ts",
        "start": 1,
        "end": 44,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 44,
          "column": 2,
          "position": 496
        }
      }
    },
    {
      "format": "typescript",
      "lines": 344,
      "fragment": "import type { Reviver } from './doc/applyReviver';\nimport type { Directives } from './doc/directives';\nimport type { LogLevelId } from './log';\nimport type { ParsedNode } from './nodes/Node';\nimport type { Pair } from './nodes/Pair';\nimport type { Scalar } from './nodes/Scalar';\nimport type { LineCounter } from './parse/line-counter';\nimport type { Schema } from './schema/Schema';\nimport type { Tags } from './schema/tags';\nimport type { CollectionTag, ScalarTag } from './schema/types';\nexport type ParseOptions = {\n    /**\n     * Whether integers should be parsed into BigInt rather than number values.\n     *\n     * Default: `false`\n     *\n     * https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/BigInt\n     */\n    intAsBigInt?: boolean;\n    /**\n     * Include a `srcToken` value on each parsed `Node`, containing the CST token\n     * that was composed into this node.\n     *\n     * Default: `false`\n     */\n    keepSourceTokens?: boolean;\n    /**\n     * If set, newlines will be tracked, to allow for `lineCounter.linePos(offset)`\n     * to provide the `{ line, col }` positions within the input.\n     */\n    lineCounter?: LineCounter;\n    /**\n     * Include line/col position & node type directly in parse errors.\n     *\n     * Default: `true`\n     */\n    prettyErrors?: boolean;\n    /**\n     * Detect and report errors that are required by the YAML 1.2 spec,\n     * but are caused by unambiguous content.\n     *\n     * Default: `true`\n     */\n    strict?: boolean;\n    /**\n     * Parse all mapping keys as strings. Treat all non-scalar keys as errors.\n     *\n     * Default: `false`\n     */\n    stringKeys?: boolean;\n    /**\n     * YAML requires map keys to be unique. By default, this is checked by\n     * comparing scalar values with `===`; deep equality is not checked for\n     * aliases or collections. If merge keys are enabled by the schema,\n     * multiple `<<` keys are allowed.\n     *\n     * Set `false` to disable, or provide your own comparator function to\n     * customise. The comparator will be passed two `ParsedNode` values, and\n     * is expected to return a `boolean` indicating their equality.\n     *\n     * Default: `true`\n     */\n    uniqueKeys?: boolean | ((a: ParsedNode, b: ParsedNode) => boolean);\n};\nexport type DocumentOptions = {\n    /**\n     * @internal\n     * Used internally by Composer. If set and includes an explicit version,\n     * that overrides the `version` option.\n     */\n    _directives?: Directives;\n    /**\n     * Control the logging level during parsing\n     *\n     * Default: `'warn'`\n     */\n    logLevel?: LogLevelId;\n    /**\n     * The YAML version used by documents without a `%YAML` directive.\n     *\n     * Default: `\"1.2\"`\n     */\n    version?: '1.1' | '1.2' | 'next';\n};\nexport type SchemaOptions = {\n    /**\n     * When parsing, warn about compatibility issues with the given schema.\n     * When stringifying, use scalar styles that are parsed correctly\n     * by the `compat` schema as well as the actual schema.\n     *\n     * Default: `null`\n     */\n    compat?: string | Tags | null;\n    /**\n     * Array of additional tags to include in the schema, or a function that may\n     * modify the schema's base tag array.\n     */\n    customTags?: Tags | ((tags: Tags) => Tags) | null;\n    /**\n     * Enable support for `<<` merge keys.\n     *\n     * Default: `false` for YAML 1.2, `true` for earlier versions\n     */\n    merge?: boolean;\n    /**\n     * When using the `'core'` schema, support parsing values with these\n     * explicit YAML 1.1 tags:\n     *\n     * `!!binary`, `!!omap`, `!!pairs`, `!!set`, `!!timestamp`.\n     *\n     * Default `true`\n     */\n    resolveKnownTags?: boolean;\n    /**\n     * The base schema to use.\n     *\n     * The core library has built-in support for the following:\n     * - `'failsafe'`: A minimal schema that parses all scalars as strings\n     * - `'core'`: The YAML 1.2 core schema\n     * - `'json'`: The YAML 1.2 JSON schema, with minimal rules for JSON compatibility\n     * - `'yaml-1.1'`: The YAML 1.1 schema\n     *\n     * If using another (custom) schema, the `customTags` array needs to\n     * fully define the schema's tags.\n     *\n     * Default: `'core'` for YAML 1.2, `'yaml-1.1'` for earlier versions\n     */\n    schema?: string | Schema;\n    /**\n     * When adding to or stringifying a map, sort the entries.\n     * If `true`, sort by comparing key values with `<`.\n     * Does not affect item order when parsing.\n     *\n     * Default: `false`\n     */\n    sortMapEntries?: boolean | ((a: Pair, b: Pair) => number);\n    /**\n     * Override default values for `toString()` options.\n     */\n    toStringDefaults?: ToStringOptions;\n};\nexport type CreateNodeOptions = {\n    /**\n     * During node construction, use anchors and aliases to keep strictly equal\n     * non-null objects as equivalent in YAML.\n     *\n     * Default: `true`\n     */\n    aliasDuplicateObjects?: boolean;\n    /**\n     * Default prefix for anchors.\n     *\n     * Default: `'a'`, resulting in anchors `a1`, `a2`, etc.\n     */\n    anchorPrefix?: string;\n    /** Force the top-level collection node to use flow style. */\n    flow?: boolean;\n    /**\n     * Keep `undefined` object values when creating mappings, rather than\n     * discarding them.\n     *\n     * Default: `false`\n     */\n    keepUndefined?: boolean | null;\n    onTagObj?: (tagObj: ScalarTag | CollectionTag) => void;\n    /**\n     * Specify the top-level collection type, e.g. `\"!!omap\"`. Note that this\n     * requires the corresponding tag to be available in this document's schema.\n     */\n    tag?: string;\n};\nexport type ToJSOptions = {\n    /**\n     * Use Map rather than Object to represent mappings.\n     *\n     * Default: `false`\n     */\n    mapAsMap?: boolean;\n    /**\n     * Prevent exponential entity expansion attacks by limiting data aliasing count;\n     * set to `-1` to disable checks; `0` disallows all alias nodes.\n     *\n     * Default: `100`\n     */\n    maxAliasCount?: number;\n    /**\n     * If defined, called with the resolved `value` and reference `count` for\n     * each anchor in the document.\n     */\n    onAnchor?: (value: unknown, count: number) => void;\n    /**\n     * Optional function that may filter or modify the output JS value\n     *\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#using_the_reviver_parameter\n     */\n    reviver?: Reviver;\n};\nexport type ToStringOptions = {\n    /**\n     * Use block quote styles for scalar values where applicable.\n     * Set to `false` to disable block quotes completely.\n     *\n     * Default: `true`\n     */\n    blockQuote?: boolean | 'folded' | 'literal';\n    /**\n     * Enforce `'block'` or `'flow'` style on maps and sequences.\n     * Empty collections will always be stringified as `{}` or `[]`.\n     *\n     * Default: `'any'`, allowing each node to set its style separately\n     * with its `flow: boolean` (default `false`) property.\n     */\n    collectionStyle?: 'any' | 'block' | 'flow';\n    /**\n     * Comment stringifier.\n     * Output should be valid for the current schema.\n     *\n     * By default, empty comment lines are left empty,\n     * lines consisting of a single space are replaced by `#`,\n     * and all other lines are prefixed with a `#`.\n     */\n    commentString?: (comment: string) => string;\n    /**\n     * The default type of string literal used to stringify implicit key values.\n     * Output may use other types if required to fully represent the value.\n     *\n     * If `null`, the value of `defaultStringType` is used.\n     *\n     * Default: `null`\n     */\n    defaultKeyType?: Scalar.Type | null;\n    /**\n     * The default type of string literal used to stringify values in general.\n     * Output may use other types if required to fully represent the value.\n     *\n     * Default: `'PLAIN'`\n     */\n    defaultStringType?: Scalar.Type;\n    /**\n     * Include directives in the output.\n     *\n     * - If `true`, at least the document-start marker `---` is always included.\n     *   This does not force the `%YAML` directive to be included. To do that,\n     *   set `doc.directives.yaml.explicit = true`.\n     * - If `false`, no directives or marker is ever included. If using the `%TAG`\n     *   directive, you are expected to include it manually in the stream before\n     *   its use.\n     * - If `null`, directives and marker may be included if required.\n     *\n     * Default: `null`\n     */\n    directives?: boolean | null;\n    /**\n     * Restrict double-quoted strings to use JSON-compatible syntax.\n     *\n     * Default: `false`\n     */\n    doubleQuotedAsJSON?: boolean;\n    /**\n     * Minimum length for double-quoted strings to use multiple lines to\n     * represent the value. Ignored if `doubleQuotedAsJSON` is set.\n     *\n     * Default: `40`\n     */\n    doubleQuotedMinMultiLineLength?: number;\n    /**\n     * String representation for `false`.\n     * With the core schema, use `'false'`, `'False'`, or `'FALSE'`.\n     *\n     * Default: `'false'`\n     */\n    falseStr?: string;\n    /**\n     * When true, a single space of padding will be added inside the delimiters\n     * of non-empty single-line flow collections.\n     *\n     * Default: `true`\n     */\n    flowCollectionPadding?: boolean;\n    /**\n     * The number of spaces to use when indenting code.\n     *\n     * Default: `2`\n     */\n    indent?: number;\n    /**\n     * Whether block sequences should be indented.\n     *\n     * Default: `true`\n     */\n    indentSeq?: boolean;\n    /**\n     * Maximum line width (set to `0` to disable folding).\n     *\n     * This is a soft limit, as only double-quoted semantics allow for inserting\n     * a line break in the middle of a word, as well as being influenced by the\n     * `minContentWidth` option.\n     *\n     * Default: `80`\n     */\n    lineWidth?: number;\n    /**\n     * Minimum line width for highly-indented content (set to `0` to disable).\n     *\n     * Default: `20`\n     */\n    minContentWidth?: number;\n    /**\n     * String representation for `null`.\n     * With the core schema, use `'null'`, `'Null'`, `'NULL'`, `'~'`, or an empty\n     * string `''`.\n     *\n     * Default: `'null'`\n     */\n    nullStr?: string;\n    /**\n     * Require keys to be scalars and to use implicit rather than explicit notation.\n     *\n     * Default: `false`\n     */\n    simpleKeys?: boolean;\n    /**\n     * Use 'single quote' rather than \"double quote\" where applicable.\n     * Set to `false` to disable single quotes completely.\n     *\n     * Default: `null`\n     */\n    singleQuote?: boolean | null;\n    /**\n     * String representation for `true`.\n     * With the core schema, use `'true'`, `'True'`, or `'TRUE'`.\n     *\n     * Default: `'true'`\n     */\n    trueStr?: string;\n    /**\n     * The anchor used by an alias must be defined before the alias node. As it's\n     * possible for the document to be modified manually, the order may be\n     * verified during stringification.\n     *\n     * Default: `'true'`\n     */\n    verifyAliasOrder?: boolean;\n};",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/options.d.ts",
        "start": 1,
        "end": 344,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 344,
          "column": 2,
          "position": 886
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/options.d.ts",
        "start": 1,
        "end": 344,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 344,
          "column": 2,
          "position": 886
        }
      }
    },
    {
      "format": "typescript",
      "lines": 25,
      "fragment": "export { Composer } from './compose/composer';\nexport { Document } from './doc/Document';\nexport { Schema } from './schema/Schema';\nexport type { ErrorCode } from './errors';\nexport { YAMLError, YAMLParseError, YAMLWarning } from './errors';\nexport { Alias } from './nodes/Alias';\nexport { isAlias, isCollection, isDocument, isMap, isNode, isPair, isScalar, isSeq } from './nodes/identity';\nexport type { Node, ParsedNode, Range } from './nodes/Node';\nexport { Pair } from './nodes/Pair';\nexport { Scalar } from './nodes/Scalar';\nexport { YAMLMap } from './nodes/YAMLMap';\nexport { YAMLSeq } from './nodes/YAMLSeq';\nexport type { CreateNodeOptions, DocumentOptions, ParseOptions, SchemaOptions, ToJSOptions, ToStringOptions } from './options';\nexport * as CST from './parse/cst';\nexport { Lexer } from './parse/lexer';\nexport { LineCounter } from './parse/line-counter';\nexport { Parser } from './parse/parser';\nexport type { EmptyStream } from './public-api';\nexport { parse, parseAllDocuments, parseDocument, stringify } from './public-api';\nexport type { TagId, Tags } from './schema/tags';\nexport type { CollectionTag, ScalarTag } from './schema/types';\nexport type { YAMLOMap } from './schema/yaml-1.1/omap';\nexport type { YAMLSet } from './schema/yaml-1.1/set';\nexport type { asyncVisitor, asyncVisitorFn, visitor, visitorFn } from './visit';\nexport { visit, visitAsync } from './visit';",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/index.d.ts",
        "start": 1,
        "end": 25,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 25,
          "column": 2,
          "position": 416
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/index.d.ts",
        "start": 1,
        "end": 25,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 25,
          "column": 2,
          "position": 416
        }
      }
    },
    {
      "format": "typescript",
      "lines": 21,
      "fragment": "import type { LineCounter } from './parse/line-counter';\nexport type ErrorCode = 'ALIAS_PROPS' | 'BAD_ALIAS' | 'BAD_DIRECTIVE' | 'BAD_DQ_ESCAPE' | 'BAD_INDENT' | 'BAD_PROP_ORDER' | 'BAD_SCALAR_START' | 'BLOCK_AS_IMPLICIT_KEY' | 'BLOCK_IN_FLOW' | 'DUPLICATE_KEY' | 'IMPOSSIBLE' | 'KEY_OVER_1024_CHARS' | 'MISSING_CHAR' | 'MULTILINE_IMPLICIT_KEY' | 'MULTIPLE_ANCHORS' | 'MULTIPLE_DOCS' | 'MULTIPLE_TAGS' | 'NON_STRING_KEY' | 'TAB_AS_INDENT' | 'TAG_RESOLVE_FAILED' | 'UNEXPECTED_TOKEN' | 'BAD_COLLECTION_TYPE';\nexport type LinePos = {\n    line: number;\n    col: number;\n};\nexport declare class YAMLError extends Error {\n    name: 'YAMLParseError' | 'YAMLWarning';\n    code: ErrorCode;\n    message: string;\n    pos: [number, number];\n    linePos?: [LinePos] | [LinePos, LinePos];\n    constructor(name: YAMLError['name'], pos: [number, number], code: ErrorCode, message: string);\n}\nexport declare class YAMLParseError extends YAMLError {\n    constructor(pos: [number, number], code: ErrorCode, message: string);\n}\nexport declare class YAMLWarning extends YAMLError {\n    constructor(pos: [number, number], code: ErrorCode, message: string);\n}\nexport declare const prettifyError: (src: string, lc: LineCounter) => (error: YAMLError) => void;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/yaml/dist/errors.d.ts",
        "start": 1,
        "end": 21,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 21,
          "column": 2,
          "position": 365
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/yaml/dist/errors.d.ts",
        "start": 1,
        "end": 21,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 21,
          "column": 2,
          "position": 365
        }
      }
    },
    {
      "format": "typescript",
      "lines": 340,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\n/////////////////////////////\n/// Worker Iterable APIs\n/////////////////////////////\n\ninterface CSSNumericArray {\n    [Symbol.iterator](): ArrayIterator<CSSNumericValue>;\n    entries(): ArrayIterator<[number, CSSNumericValue]>;\n    keys(): ArrayIterator<number>;\n    values(): ArrayIterator<CSSNumericValue>;\n}\n\ninterface CSSTransformValue {\n    [Symbol.iterator](): ArrayIterator<CSSTransformComponent>;\n    entries(): ArrayIterator<[number, CSSTransformComponent]>;\n    keys(): ArrayIterator<number>;\n    values(): ArrayIterator<CSSTransformComponent>;\n}\n\ninterface CSSUnparsedValue {\n    [Symbol.iterator](): ArrayIterator<CSSUnparsedSegment>;\n    entries(): ArrayIterator<[number, CSSUnparsedSegment]>;\n    keys(): ArrayIterator<number>;\n    values(): ArrayIterator<CSSUnparsedSegment>;\n}\n\ninterface Cache {\n    /**\n     * The **`addAll()`** method of the Cache interface takes an array of URLs, retrieves them, and adds the resulting response objects to the given cache.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Cache/addAll)\n     */\n    addAll(requests: Iterable<RequestInfo>): Promise<void>;\n}\n\ninterface CanvasPath {\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/roundRect) */\n    roundRect(x: number, y: number, w: number, h: number, radii?: number | DOMPointInit | Iterable<number | DOMPointInit>): void;\n}\n\ninterface CanvasPathDrawingStyles {\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash) */\n    setLineDash(segments: Iterable<number>): void;\n}\n\ninterface CookieStoreManager {\n    /**\n     * The **`subscribe()`** method of the CookieStoreManager interface subscribes a ServiceWorkerRegistration to cookie change events.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/CookieStoreManager/subscribe)\n     */\n    subscribe(subscriptions: Iterable<CookieStoreGetOptions>): Promise<void>;\n    /**\n     * The **`unsubscribe()`** method of the CookieStoreManager interface stops the ServiceWorkerRegistration from receiving previously subscribed events.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/CookieStoreManager/unsubscribe)\n     */\n    unsubscribe(subscriptions: Iterable<CookieStoreGetOptions>): Promise<void>;\n}\n\ninterface DOMStringList {\n    [Symbol.iterator](): ArrayIterator<string>;\n}\n\ninterface FileList {\n    [Symbol.iterator](): ArrayIterator<File>;\n}\n\ninterface FontFaceSet extends Set<FontFace> {\n}\n\ninterface FormDataIterator<T> extends IteratorObject<T, BuiltinIteratorReturn, unknown> {\n    [Symbol.iterator](): FormDataIterator<T>;\n}\n\ninterface FormData {\n    [Symbol.iterator](): FormDataIterator<[string, FormDataEntryValue]>;\n    /** Returns an array of key, value pairs for every entry in the list. */\n    entries(): FormDataIterator<[string, FormDataEntryValue]>;\n    /** Returns a list of keys in the list. */\n    keys(): FormDataIterator<string>;\n    /** Returns a list of values in the list. */\n    values(): FormDataIterator<FormDataEntryValue>;\n}\n\ninterface HeadersIterator<T> extends IteratorObject<T, BuiltinIteratorReturn, unknown> {\n    [Symbol.iterator](): HeadersIterator<T>;\n}\n\ninterface Headers {\n    [Symbol.iterator](): HeadersIterator<[string, string]>;\n    /** Returns an iterator allowing to go through all key/value pairs contained in this object. */\n    entries(): HeadersIterator<[string, string]>;\n    /** Returns an iterator allowing to go through all keys of the key/value pairs contained in this object. */\n    keys(): HeadersIterator<string>;\n    /** Returns an iterator allowing to go through all values of the key/value pairs contained in this object. */\n    values(): HeadersIterator<string>;\n}\n\ninterface IDBDatabase {\n    /**\n     * The **`transaction`** method of the IDBDatabase interface immediately returns a transaction object (IDBTransaction) containing the IDBTransaction.objectStore method, which you can use to access your object store.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBDatabase/transaction)\n     */\n    transaction(storeNames: string | Iterable<string>, mode?: IDBTransactionMode, options?: IDBTransactionOptions): IDBTransaction;\n}\n\ninterface IDBObjectStore {\n    /**\n     * The **`createIndex()`** method of the field/column defining a new data point for each database record to contain.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBObjectStore/createIndex)\n     */\n    createIndex(name: string, keyPath: string | Iterable<string>, options?: IDBIndexParameters): IDBIndex;\n}\n\ninterface ImageTrackList {\n    [Symbol.iterator](): ArrayIterator<ImageTrack>;\n}\n\ninterface MessageEvent<T = any> {\n    /** @deprecated */\n    initMessageEvent(type: string, bubbles?: boolean, cancelable?: boolean, data?: any, origin?: string, lastEventId?: string, source?: MessageEventSource | null, ports?: Iterable<MessagePort>): void;\n}\n\ninterface StylePropertyMapReadOnlyIterator<T> extends IteratorObject<T, BuiltinIteratorReturn, unknown> {\n    [Symbol.iterator](): StylePropertyMapReadOnlyIterator<T>;\n}\n\ninterface StylePropertyMapReadOnly {\n    [Symbol.iterator](): StylePropertyMapReadOnlyIterator<[string, Iterable<CSSStyleValue>]>;\n    entries(): StylePropertyMapReadOnlyIterator<[string, Iterable<CSSStyleValue>]>;\n    keys(): StylePropertyMapReadOnlyIterator<string>;\n    values(): StylePropertyMapReadOnlyIterator<Iterable<CSSStyleValue>>;\n}\n\ninterface SubtleCrypto {\n    /**\n     * The **`deriveKey()`** method of the SubtleCrypto interface can be used to derive a secret key from a master key.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/deriveKey)\n     */\n    deriveKey(algorithm: AlgorithmIdentifier | EcdhKeyDeriveParams | HkdfParams | Pbkdf2Params, baseKey: CryptoKey, derivedKeyType: AlgorithmIdentifier | AesDerivedKeyParams | HmacImportParams | HkdfParams | Pbkdf2Params, extractable: boolean, keyUsages: Iterable<KeyUsage>): Promise<CryptoKey>;\n    /**\n     * The **`generateKey()`** method of the SubtleCrypto interface is used to generate a new key (for symmetric algorithms) or key pair (for public-key algorithms).\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/generateKey)\n     */\n    generateKey(algorithm: \"Ed25519\" | { name: \"Ed25519\" }, extractable: boolean, keyUsages: ReadonlyArray<\"sign\" | \"verify\">): Promise<CryptoKeyPair>;\n    generateKey(algorithm: RsaHashedKeyGenParams | EcKeyGenParams, extractable: boolean, keyUsages: ReadonlyArray<KeyUsage>): Promise<CryptoKeyPair>;\n    generateKey(algorithm: AesKeyGenParams | HmacKeyGenParams | Pbkdf2Params, extractable: boolean, keyUsages: ReadonlyArray<KeyUsage>): Promise<CryptoKey>;\n    generateKey(algorithm: AlgorithmIdentifier, extractable: boolean, keyUsages: Iterable<KeyUsage>): Promise<CryptoKeyPair | CryptoKey>;\n    /**\n     * The **`importKey()`** method of the SubtleCrypto interface imports a key: that is, it takes as input a key in an external, portable format and gives you a CryptoKey object that you can use in the Web Crypto API.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/importKey)\n     */\n    importKey(format: \"jwk\", keyData: JsonWebKey, algorithm: AlgorithmIdentifier | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | AesKeyAlgorithm, extractable: boolean, keyUsages: ReadonlyArray<KeyUsage>): Promise<CryptoKey>;\n    importKey(format: Exclude<KeyFormat, \"jwk\">, keyData: BufferSource, algorithm: AlgorithmIdentifier | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | AesKeyAlgorithm, extractable: boolean, keyUsages: Iterable<KeyUsage>): Promise<CryptoKey>;\n    /**\n     * The **`unwrapKey()`** method of the SubtleCrypto interface 'unwraps' a key.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/unwrapKey)\n     */\n    unwrapKey(format: KeyFormat, wrappedKey: BufferSource, unwrappingKey: CryptoKey, unwrapAlgorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams, unwrappedKeyAlgorithm: AlgorithmIdentifier | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | AesKeyAlgorithm, extractable: boolean, keyUsages: Iterable<KeyUsage>): Promise<CryptoKey>;\n}\n\ninterface URLSearchParamsIterator<T> extends IteratorObject<T, BuiltinIteratorReturn, unknown> {\n    [Symbol.iterator](): URLSearchParamsIterator<T>;\n}\n\ninterface URLSearchParams {\n    [Symbol.iterator](): URLSearchParamsIterator<[string, string]>;\n    /** Returns an array of key, value pairs for every entry in the search params. */\n    entries(): URLSearchParamsIterator<[string, string]>;\n    /** Returns a list of keys in the search params. */\n    keys(): URLSearchParamsIterator<string>;\n    /** Returns a list of values in the search params. */\n    values(): URLSearchParamsIterator<string>;\n}\n\ninterface WEBGL_draw_buffers {\n    /**\n     * The **`WEBGL_draw_buffers.drawBuffersWEBGL()`** method is part of the WebGL API and allows you to define the draw buffers to which all fragment colors are written.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_draw_buffers/drawBuffersWEBGL)\n     */\n    drawBuffersWEBGL(buffers: Iterable<GLenum>): void;\n}\n\ninterface WEBGL_multi_draw {\n    /**\n     * The **`WEBGL_multi_draw.multiDrawArraysInstancedWEBGL()`** method of the WebGL API renders multiple primitives from array data.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_multi_draw/multiDrawArraysInstancedWEBGL)\n     */\n    multiDrawArraysInstancedWEBGL(mode: GLenum, firstsList: Int32Array<ArrayBufferLike> | Iterable<GLint>, firstsOffset: number, countsList: Int32Array<ArrayBufferLike> | Iterable<GLsizei>, countsOffset: number, instanceCountsList: Int32Array<ArrayBufferLike> | Iterable<GLsizei>, instanceCountsOffset: number, drawcount: GLsizei): void;\n    /**\n     * The **`WEBGL_multi_draw.multiDrawArraysWEBGL()`** method of the WebGL API renders multiple primitives from array data.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_multi_draw/multiDrawArraysWEBGL)\n     */\n    multiDrawArraysWEBGL(mode: GLenum, firstsList: Int32Array<ArrayBufferLike> | Iterable<GLint>, firstsOffset: number, countsList: Int32Array<ArrayBufferLike> | Iterable<GLsizei>, countsOffset: number, drawcount: GLsizei): void;\n    /**\n     * The **`WEBGL_multi_draw.multiDrawElementsInstancedWEBGL()`** method of the WebGL API renders multiple primitives from array data.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_multi_draw/multiDrawElementsInstancedWEBGL)\n     */\n    multiDrawElementsInstancedWEBGL(mode: GLenum, countsList: Int32Array<ArrayBufferLike> | Iterable<GLsizei>, countsOffset: number, type: GLenum, offsetsList: Int32Array<ArrayBufferLike> | Iterable<GLsizei>, offsetsOffset: number, instanceCountsList: Int32Array<ArrayBufferLike> | Iterable<GLsizei>, instanceCountsOffset: number, drawcount: GLsizei): void;\n    /**\n     * The **`WEBGL_multi_draw.multiDrawElementsWEBGL()`** method of the WebGL API renders multiple primitives from array data.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_multi_draw/multiDrawElementsWEBGL)\n     */\n    multiDrawElementsWEBGL(mode: GLenum, countsList: Int32Array<ArrayBufferLike> | Iterable<GLsizei>, countsOffset: number, type: GLenum, offsetsList: Int32Array<ArrayBufferLike> | Iterable<GLsizei>, offsetsOffset: number, drawcount: GLsizei): void;\n}\n\ninterface WebGL2RenderingContextBase {\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/clearBuffer) */\n    clearBufferfv(buffer: GLenum, drawbuffer: GLint, values: Iterable<GLfloat>, srcOffset?: number): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/clearBuffer) */\n    clearBufferiv(buffer: GLenum, drawbuffer: GLint, values: Iterable<GLint>, srcOffset?: number): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/clearBuffer) */\n    clearBufferuiv(buffer: GLenum, drawbuffer: GLint, values: Iterable<GLuint>, srcOffset?: number): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/drawBuffers) */\n    drawBuffers(buffers: Iterable<GLenum>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/getActiveUniforms) */\n    getActiveUniforms(program: WebGLProgram, uniformIndices: Iterable<GLuint>, pname: GLenum): any;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/getUniformIndices) */\n    getUniformIndices(program: WebGLProgram, uniformNames: Iterable<string>): GLuint[] | null;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/invalidateFramebuffer) */\n    invalidateFramebuffer(target: GLenum, attachments: Iterable<GLenum>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/invalidateSubFramebuffer) */\n    invalidateSubFramebuffer(target: GLenum, attachments: Iterable<GLenum>, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/transformFeedbackVaryings) */\n    transformFeedbackVaryings(program: WebGLProgram, varyings: Iterable<string>, bufferMode: GLenum): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniform) */\n    uniform1uiv(location: WebGLUniformLocation | null, data: Iterable<GLuint>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniform) */\n    uniform2uiv(location: WebGLUniformLocation | null, data: Iterable<GLuint>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniform) */\n    uniform3uiv(location: WebGLUniformLocation | null, data: Iterable<GLuint>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniform) */\n    uniform4uiv(location: WebGLUniformLocation | null, data: Iterable<GLuint>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniformMatrix) */\n    uniformMatrix2x3fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniformMatrix) */\n    uniformMatrix2x4fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniformMatrix) */\n    uniformMatrix3x2fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniformMatrix) */\n    uniformMatrix3x4fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniformMatrix) */\n    uniformMatrix4x2fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniformMatrix) */\n    uniformMatrix4x3fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/vertexAttribI) */\n    vertexAttribI4iv(index: GLuint, values: Iterable<GLint>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/vertexAttribI) */\n    vertexAttribI4uiv(index: GLuint, values: Iterable<GLuint>): void;\n}\n\ninterface WebGL2RenderingContextOverloads {\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform1fv(location: WebGLUniformLocation | null, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform1iv(location: WebGLUniformLocation | null, data: Iterable<GLint>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform2fv(location: WebGLUniformLocation | null, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform2iv(location: WebGLUniformLocation | null, data: Iterable<GLint>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform3fv(location: WebGLUniformLocation | null, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform3iv(location: WebGLUniformLocation | null, data: Iterable<GLint>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform4fv(location: WebGLUniformLocation | null, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform4iv(location: WebGLUniformLocation | null, data: Iterable<GLint>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniformMatrix) */\n    uniformMatrix2fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniformMatrix) */\n    uniformMatrix3fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniformMatrix) */\n    uniformMatrix4fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n}\n\ninterface WebGLRenderingContextBase {\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/vertexAttrib) */\n    vertexAttrib1fv(index: GLuint, values: Iterable<GLfloat>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/vertexAttrib) */\n    vertexAttrib2fv(index: GLuint, values: Iterable<GLfloat>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/vertexAttrib) */\n    vertexAttrib3fv(index: GLuint, values: Iterable<GLfloat>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/vertexAttrib) */\n    vertexAttrib4fv(index: GLuint, values: Iterable<GLfloat>): void;\n}\n\ninterface WebGLRenderingContextOverloads {\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform1fv(location: WebGLUniformLocation | null, v: Iterable<GLfloat>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform1iv(location: WebGLUniformLocation | null, v: Iterable<GLint>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform2fv(location: WebGLUniformLocation | null, v: Iterable<GLfloat>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform2iv(location: WebGLUniformLocation | null, v: Iterable<GLint>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform3fv(location: WebGLUniformLocation | null, v: Iterable<GLfloat>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform3iv(location: WebGLUniformLocation | null, v: Iterable<GLint>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform4fv(location: WebGLUniformLocation | null, v: Iterable<GLfloat>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform4iv(location: WebGLUniformLocation | null, v: Iterable<GLint>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniformMatrix) */\n    uniformMatrix2fv(location: WebGLUniformLocation | null, transpose: GLboolean, value: Iterable<GLfloat>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniformMatrix) */\n    uniformMatrix3fv(location: WebGLUniformLocation | null, transpose: GLboolean, value: Iterable<GLfloat>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniformMatrix) */\n    uniformMatrix4fv(location: WebGLUniformLocation | null, transpose: GLboolean, value: Iterable<GLfloat>): void;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.webworker.iterable.d.ts",
        "start": 1,
        "end": 340,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 340,
          "column": 2,
          "position": 3734
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.webworker.iterable.d.ts",
        "start": 1,
        "end": 340,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 340,
          "column": 2,
          "position": 3734
        }
      }
    },
    {
      "format": "typescript",
      "lines": 41,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\n/////////////////////////////\n/// Worker Async Iterable APIs\n/////////////////////////////\n\ninterface FileSystemDirectoryHandleAsyncIterator<T> extends AsyncIteratorObject<T, BuiltinIteratorReturn, unknown> {\n    [Symbol.asyncIterator](): FileSystemDirectoryHandleAsyncIterator<T>;\n}\n\ninterface FileSystemDirectoryHandle {\n    [Symbol.asyncIterator](): FileSystemDirectoryHandleAsyncIterator<[string, FileSystemHandle]>;\n    entries(): FileSystemDirectoryHandleAsyncIterator<[string, FileSystemHandle]>;\n    keys(): FileSystemDirectoryHandleAsyncIterator<string>;\n    values(): FileSystemDirectoryHandleAsyncIterator<FileSystemHandle>;\n}\n\ninterface ReadableStreamAsyncIterator<T> extends AsyncIteratorObject<T, BuiltinIteratorReturn, unknown> {\n    [Symbol.asyncIterator](): ReadableStreamAsyncIterator<T>;\n}\n\ninterface ReadableStream<R = any> {\n    [Symbol.asyncIterator](options?: ReadableStreamIteratorOptions): ReadableStreamAsyncIterator<R>;\n    values(options?: ReadableStreamIteratorOptions): ReadableStreamAsyncIterator<R>;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.webworker.asynciterable.d.ts",
        "start": 1,
        "end": 41,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 41,
          "column": 2,
          "position": 218
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.webworker.asynciterable.d.ts",
        "start": 1,
        "end": 41,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 41,
          "column": 2,
          "position": 218
        }
      }
    },
    {
      "format": "typescript",
      "lines": 322,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\n/////////////////////////////\n/// Windows Script Host APIS\n/////////////////////////////\n\ninterface ActiveXObject {\n    new (s: string): any;\n}\ndeclare var ActiveXObject: ActiveXObject;\n\ninterface ITextWriter {\n    Write(s: string): void;\n    WriteLine(s: string): void;\n    Close(): void;\n}\n\ninterface TextStreamBase {\n    /**\n     * The column number of the current character position in an input stream.\n     */\n    Column: number;\n\n    /**\n     * The current line number in an input stream.\n     */\n    Line: number;\n\n    /**\n     * Closes a text stream.\n     * It is not necessary to close standard streams; they close automatically when the process ends. If\n     * you close a standard stream, be aware that any other pointers to that standard stream become invalid.\n     */\n    Close(): void;\n}\n\ninterface TextStreamWriter extends TextStreamBase {\n    /**\n     * Sends a string to an output stream.\n     */\n    Write(s: string): void;\n\n    /**\n     * Sends a specified number of blank lines (newline characters) to an output stream.\n     */\n    WriteBlankLines(intLines: number): void;\n\n    /**\n     * Sends a string followed by a newline character to an output stream.\n     */\n    WriteLine(s: string): void;\n}\n\ninterface TextStreamReader extends TextStreamBase {\n    /**\n     * Returns a specified number of characters from an input stream, starting at the current pointer position.\n     * Does not return until the ENTER key is pressed.\n     * Can only be used on a stream in reading mode; causes an error in writing or appending mode.\n     */\n    Read(characters: number): string;\n\n    /**\n     * Returns all characters from an input stream.\n     * Can only be used on a stream in reading mode; causes an error in writing or appending mode.\n     */\n    ReadAll(): string;\n\n    /**\n     * Returns an entire line from an input stream.\n     * Although this method extracts the newline character, it does not add it to the returned string.\n     * Can only be used on a stream in reading mode; causes an error in writing or appending mode.\n     */\n    ReadLine(): string;\n\n    /**\n     * Skips a specified number of characters when reading from an input text stream.\n     * Can only be used on a stream in reading mode; causes an error in writing or appending mode.\n     * @param characters Positive number of characters to skip forward. (Backward skipping is not supported.)\n     */\n    Skip(characters: number): void;\n\n    /**\n     * Skips the next line when reading from an input text stream.\n     * Can only be used on a stream in reading mode, not writing or appending mode.\n     */\n    SkipLine(): void;\n\n    /**\n     * Indicates whether the stream pointer position is at the end of a line.\n     */\n    AtEndOfLine: boolean;\n\n    /**\n     * Indicates whether the stream pointer position is at the end of a stream.\n     */\n    AtEndOfStream: boolean;\n}\n\ndeclare var WScript: {\n    /**\n     * Outputs text to either a message box (under WScript.exe) or the command console window followed by\n     * a newline (under CScript.exe).\n     */\n    Echo(s: any): void;\n\n    /**\n     * Exposes the write-only error output stream for the current script.\n     * Can be accessed only while using CScript.exe.\n     */\n    StdErr: TextStreamWriter;\n\n    /**\n     * Exposes the write-only output stream for the current script.\n     * Can be accessed only while using CScript.exe.\n     */\n    StdOut: TextStreamWriter;\n    Arguments: { length: number; Item(n: number): string; };\n\n    /**\n     *  The full path of the currently running script.\n     */\n    ScriptFullName: string;\n\n    /**\n     * Forces the script to stop immediately, with an optional exit code.\n     */\n    Quit(exitCode?: number): number;\n\n    /**\n     * The Windows Script Host build version number.\n     */\n    BuildVersion: number;\n\n    /**\n     * Fully qualified path of the host executable.\n     */\n    FullName: string;\n\n    /**\n     * Gets/sets the script mode - interactive(true) or batch(false).\n     */\n    Interactive: boolean;\n\n    /**\n     * The name of the host executable (WScript.exe or CScript.exe).\n     */\n    Name: string;\n\n    /**\n     * Path of the directory containing the host executable.\n     */\n    Path: string;\n\n    /**\n     * The filename of the currently running script.\n     */\n    ScriptName: string;\n\n    /**\n     * Exposes the read-only input stream for the current script.\n     * Can be accessed only while using CScript.exe.\n     */\n    StdIn: TextStreamReader;\n\n    /**\n     * Windows Script Host version\n     */\n    Version: string;\n\n    /**\n     * Connects a COM object's event sources to functions named with a given prefix, in the form prefix_event.\n     */\n    ConnectObject(objEventSource: any, strPrefix: string): void;\n\n    /**\n     * Creates a COM object.\n     * @param strProgiID\n     * @param strPrefix Function names in the form prefix_event will be bound to this object's COM events.\n     */\n    CreateObject(strProgID: string, strPrefix?: string): any;\n\n    /**\n     * Disconnects a COM object from its event sources.\n     */\n    DisconnectObject(obj: any): void;\n\n    /**\n     * Retrieves an existing object with the specified ProgID from memory, or creates a new one from a file.\n     * @param strPathname Fully qualified path to the file containing the object persisted to disk.\n     *                       For objects in memory, pass a zero-length string.\n     * @param strProgID\n     * @param strPrefix Function names in the form prefix_event will be bound to this object's COM events.\n     */\n    GetObject(strPathname: string, strProgID?: string, strPrefix?: string): any;\n\n    /**\n     * Suspends script execution for a specified length of time, then continues execution.\n     * @param intTime Interval (in milliseconds) to suspend script execution.\n     */\n    Sleep(intTime: number): void;\n};\n\n/**\n * WSH is an alias for WScript under Windows Script Host\n */\ndeclare var WSH: typeof WScript;\n\n/**\n * Represents an Automation SAFEARRAY\n */\ndeclare class SafeArray<T = any> {\n    private constructor();\n    private SafeArray_typekey: SafeArray<T>;\n}\n\n/**\n * Allows enumerating over a COM collection, which may not have indexed item access.\n */\ninterface Enumerator<T = any> {\n    /**\n     * Returns true if the current item is the last one in the collection, or the collection is empty,\n     * or the current item is undefined.\n     */\n    atEnd(): boolean;\n\n    /**\n     * Returns the current item in the collection\n     */\n    item(): T;\n\n    /**\n     * Resets the current item in the collection to the first item. If there are no items in the collection,\n     * the current item is set to undefined.\n     */\n    moveFirst(): void;\n\n    /**\n     * Moves the current item to the next item in the collection. If the enumerator is at the end of\n     * the collection or the collection is empty, the current item is set to undefined.\n     */\n    moveNext(): void;\n}\n\ninterface EnumeratorConstructor {\n    new <T = any>(safearray: SafeArray<T>): Enumerator<T>;\n    new <T = any>(collection: { Item(index: any): T; }): Enumerator<T>;\n    new <T = any>(collection: any): Enumerator<T>;\n}\n\ndeclare var Enumerator: EnumeratorConstructor;\n\n/**\n * Enables reading from a COM safe array, which might have an alternate lower bound, or multiple dimensions.\n */\ninterface VBArray<T = any> {\n    /**\n     * Returns the number of dimensions (1-based).\n     */\n    dimensions(): number;\n\n    /**\n     * Takes an index for each dimension in the array, and returns the item at the corresponding location.\n     */\n    getItem(dimension1Index: number, ...dimensionNIndexes: number[]): T;\n\n    /**\n     * Returns the smallest available index for a given dimension.\n     * @param dimension 1-based dimension (defaults to 1)\n     */\n    lbound(dimension?: number): number;\n\n    /**\n     * Returns the largest available index for a given dimension.\n     * @param dimension 1-based dimension (defaults to 1)\n     */\n    ubound(dimension?: number): number;\n\n    /**\n     * Returns a Javascript array with all the elements in the VBArray. If there are multiple dimensions,\n     * each successive dimension is appended to the end of the array.\n     * Example: [[1,2,3],[4,5,6]] becomes [1,2,3,4,5,6]\n     */\n    toArray(): T[];\n}\n\ninterface VBArrayConstructor {\n    new <T = any>(safeArray: SafeArray<T>): VBArray<T>;\n}\n\ndeclare var VBArray: VBArrayConstructor;\n\n/**\n * Automation date (VT_DATE)\n */\ndeclare class VarDate {\n    private constructor();\n    private VarDate_typekey: VarDate;\n}\n\ninterface DateConstructor {\n    new (vd: VarDate): Date;\n}\n\ninterface Date {\n    getVarDate: () => VarDate;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.scripthost.d.ts",
        "start": 1,
        "end": 322,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 322,
          "column": 2,
          "position": 1069
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.scripthost.d.ts",
        "start": 1,
        "end": 322,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 322,
          "column": 2,
          "position": 1069
        }
      }
    },
    {
      "format": "typescript",
      "lines": 148,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\n/// <reference lib=\"es2015.iterable\" />\n\n// NOTE: This is specified as what is essentially an unreachable module. All actual global declarations can be found\n//       in the `declare global` section, below. This is necessary as there is currently no way to declare an `abstract`\n//       member without declaring a `class`, but declaring `class Iterator<T>` globally would conflict with TypeScript's\n//       general purpose `Iterator<T>` interface.\nexport {};\n\n// Abstract type that allows us to mark `next` as `abstract`\ndeclare abstract class Iterator<T, TResult = undefined, TNext = unknown> { // eslint-disable-line @typescript-eslint/no-unsafe-declaration-merging\n    abstract next(value?: TNext): IteratorResult<T, TResult>;\n}\n\n// Merge all members of `IteratorObject<T>` into `Iterator<T>`\ninterface Iterator<T, TResult, TNext> extends globalThis.IteratorObject<T, TResult, TNext> {}\n\n// Capture the `Iterator` constructor in a type we can use in the `extends` clause of `IteratorConstructor`.\ntype IteratorObjectConstructor = typeof Iterator;\n\ndeclare global {\n    // Global `IteratorObject<T, TReturn, TNext>` interface that can be augmented by polyfills\n    interface IteratorObject<T, TReturn, TNext> {\n        /**\n         * Returns this iterator.\n         */\n        [Symbol.iterator](): IteratorObject<T, TReturn, TNext>;\n\n        /**\n         * Creates an iterator whose values are the result of applying the callback to the values from this iterator.\n         * @param callbackfn A function that accepts up to two arguments to be used to transform values from the underlying iterator.\n         */\n        map<U>(callbackfn: (value: T, index: number) => U): IteratorObject<U, undefined, unknown>;\n\n        /**\n         * Creates an iterator whose values are those from this iterator for which the provided predicate returns true.\n         * @param predicate A function that accepts up to two arguments to be used to test values from the underlying iterator.\n         */\n        filter<S extends T>(predicate: (value: T, index: number) => value is S): IteratorObject<S, undefined, unknown>;\n\n        /**\n         * Creates an iterator whose values are those from this iterator for which the provided predicate returns true.\n         * @param predicate A function that accepts up to two arguments to be used to test values from the underlying iterator.\n         */\n        filter(predicate: (value: T, index: number) => unknown): IteratorObject<T, undefined, unknown>;\n\n        /**\n         * Creates an iterator whose values are the values from this iterator, stopping once the provided limit is reached.\n         * @param limit The maximum number of values to yield.\n         */\n        take(limit: number): IteratorObject<T, undefined, unknown>;\n\n        /**\n         * Creates an iterator whose values are the values from this iterator after skipping the provided count.\n         * @param count The number of values to drop.\n         */\n        drop(count: number): IteratorObject<T, undefined, unknown>;\n\n        /**\n         * Creates an iterator whose values are the result of applying the callback to the values from this iterator and then flattening the resulting iterators or iterables.\n         * @param callback A function that accepts up to two arguments to be used to transform values from the underlying iterator into new iterators or iterables to be flattened into the result.\n         */\n        flatMap<U>(callback: (value: T, index: number) => Iterator<U, unknown, undefined> | Iterable<U, unknown, undefined>): IteratorObject<U, undefined, unknown>;\n\n        /**\n         * Calls the specified callback function for all the elements in this iterator. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n         * @param callbackfn A function that accepts up to three arguments. The reduce method calls the callbackfn function one time for each element in the iterator.\n         * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of a value from the iterator.\n         */\n        reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number) => T): T;\n        reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number) => T, initialValue: T): T;\n\n        /**\n         * Calls the specified callback function for all the elements in this iterator. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n         * @param callbackfn A function that accepts up to three arguments. The reduce method calls the callbackfn function one time for each element in the iterator.\n         * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of a value from the iterator.\n         */\n        reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number) => U, initialValue: U): U;\n\n        /**\n         * Creates a new array from the values yielded by this iterator.\n         */\n        toArray(): T[];\n\n        /**\n         * Performs the specified action for each element in the iterator.\n         * @param callbackfn A function that accepts up to two arguments. forEach calls the callbackfn function one time for each element in the iterator.\n         */\n        forEach(callbackfn: (value: T, index: number) => void): void;\n\n        /**\n         * Determines whether the specified callback function returns true for any element of this iterator.\n         * @param predicate A function that accepts up to two arguments. The some method calls\n         * the predicate function for each element in this iterator until the predicate returns a value\n         * true, or until the end of the iterator.\n         */\n        some(predicate: (value: T, index: number) => unknown): boolean;\n\n        /**\n         * Determines whether all the members of this iterator satisfy the specified test.\n         * @param predicate A function that accepts up to two arguments. The every method calls\n         * the predicate function for each element in this iterator until the predicate returns\n         * false, or until the end of this iterator.\n         */\n        every(predicate: (value: T, index: number) => unknown): boolean;\n\n        /**\n         * Returns the value of the first element in this iterator where predicate is true, and undefined\n         * otherwise.\n         * @param predicate find calls predicate once for each element of this iterator, in\n         * order, until it finds one where predicate returns true. If such an element is found, find\n         * immediately returns that element value. Otherwise, find returns undefined.\n         */\n        find<S extends T>(predicate: (value: T, index: number) => value is S): S | undefined;\n        find(predicate: (value: T, index: number) => unknown): T | undefined;\n\n        readonly [Symbol.toStringTag]: string;\n    }\n\n    // Global `IteratorConstructor` interface that can be augmented by polyfills\n    interface IteratorConstructor extends IteratorObjectConstructor {\n        /**\n         * Creates a native iterator from an iterator or iterable object.\n         * Returns its input if the input already inherits from the built-in Iterator class.\n         * @param value An iterator or iterable object to convert a native iterator.\n         */\n        from<T>(value: Iterator<T, unknown, undefined> | Iterable<T, unknown, undefined>): IteratorObject<T, undefined, unknown>;\n    }\n\n    var Iterator: IteratorConstructor;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.esnext.iterator.d.ts",
        "start": 1,
        "end": 148,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 148,
          "column": 2,
          "position": 844
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.esnext.iterator.d.ts",
        "start": 1,
        "end": 148,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 148,
          "column": 2,
          "position": 844
        }
      }
    },
    {
      "format": "typescript",
      "lines": 445,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\n/// <reference lib=\"es2015.symbol\" />\n/// <reference lib=\"es2015.iterable\" />\n\n/**\n * A typed array of 16-bit float values. The contents are initialized to 0. If the requested number\n * of bytes could not be allocated an exception is raised.\n */\ninterface Float16Array<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike> {\n    /**\n     * The size in bytes of each element in the array.\n     */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n     * The ArrayBuffer instance referenced by the array.\n     */\n    readonly buffer: TArrayBuffer;\n\n    /**\n     * The length in bytes of the array.\n     */\n    readonly byteLength: number;\n\n    /**\n     * The offset in bytes of the array.\n     */\n    readonly byteOffset: number;\n\n    /**\n     * Returns the item located at the specified index.\n     * @param index The zero-based index of the desired code unit. A negative index will count back from the last item.\n     */\n    at(index: number): number | undefined;\n\n    /**\n     * Returns the this object after copying a section of the array identified by start and end\n     * to the same array starting at position target\n     * @param target If target is negative, it is treated as length+target where length is the\n     * length of the array.\n     * @param start If start is negative, it is treated as length+start. If end is negative, it\n     * is treated as length+end.\n     * @param end If not specified, length of the this object is used as its default value.\n     */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n     * Determines whether all the members of an array satisfy the specified test.\n     * @param predicate A function that accepts up to three arguments. The every method calls\n     * the predicate function for each element in the array until the predicate returns a value\n     * which is coercible to the Boolean value false, or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    every(predicate: (value: number, index: number, array: this) => unknown, thisArg?: any): boolean;\n\n    /**\n     * Changes all array elements from `start` to `end` index to a static `value` and returns the modified array\n     * @param value value to fill array section with\n     * @param start index to start filling the array at. If start is negative, it is treated as\n     * length+start where length is the length of the array.\n     * @param end index to stop filling the array at. If end is negative, it is treated as\n     * length+end.\n     */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n     * Returns the elements of an array that meet the condition specified in a callback function.\n     * @param predicate A function that accepts up to three arguments. The filter method calls\n     * the predicate function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    filter(predicate: (value: number, index: number, array: this) => any, thisArg?: any): Float16Array<ArrayBuffer>;\n\n    /**\n     * Returns the value of the first element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found, find\n     * immediately returns that element value. Otherwise, find returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    find(predicate: (value: number, index: number, obj: this) => boolean, thisArg?: any): number | undefined;\n\n    /**\n     * Returns the index of the first element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findIndex(predicate: (value: number, index: number, obj: this) => boolean, thisArg?: any): number;\n\n    /**\n     * Returns the value of the last element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate findLast calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found, findLast\n     * immediately returns that element value. Otherwise, findLast returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLast<S extends number>(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => value is S,\n        thisArg?: any,\n    ): S | undefined;\n    findLast(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => unknown,\n        thisArg?: any,\n    ): number | undefined;\n\n    /**\n     * Returns the index of the last element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate findLastIndex calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLastIndex(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => unknown,\n        thisArg?: any,\n    ): number;\n\n    /**\n     * Performs the specified action for each element in an array.\n     * @param callbackfn A function that accepts up to three arguments. forEach calls the\n     * callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    forEach(callbackfn: (value: number, index: number, array: this) => void, thisArg?: any): void;\n\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n\n    /**\n     * Returns the index of the first occurrence of a value in an array.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n     * search starts at index 0.\n     */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n     * Adds all the elements of an array separated by the specified separator string.\n     * @param separator A string used to separate one element of an array from the next in the\n     * resulting String. If omitted, the array elements are separated with a comma.\n     */\n    join(separator?: string): string;\n\n    /**\n     * Returns the index of the last occurrence of a value in an array.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n     * search starts at index 0.\n     */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n     * The length of the array.\n     */\n    readonly length: number;\n\n    /**\n     * Calls a defined callback function on each element of an array, and returns an array that\n     * contains the results.\n     * @param callbackfn A function that accepts up to three arguments. The map method calls the\n     * callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    map(callbackfn: (value: number, index: number, array: this) => number, thisArg?: any): Float16Array<ArrayBuffer>;\n\n    /**\n     * Calls the specified callback function for all the elements in an array. The return value of\n     * the callback function is the accumulated result, and is provided as an argument in the next\n     * call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n     * callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: this) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: this) => number, initialValue: number): number;\n\n    /**\n     * Calls the specified callback function for all the elements in an array. The return value of\n     * the callback function is the accumulated result, and is provided as an argument in the next\n     * call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n     * callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: this) => U, initialValue: U): U;\n\n    /**\n     * Calls the specified callback function for all the elements in an array, in descending order.\n     * The return value of the callback function is the accumulated result, and is provided as an\n     * argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n     * the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an\n     * argument instead of an array value.\n     */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: this) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: this) => number, initialValue: number): number;\n\n    /**\n     * Calls the specified callback function for all the elements in an array, in descending order.\n     * The return value of the callback function is the accumulated result, and is provided as an\n     * argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n     * the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: this) => U, initialValue: U): U;\n\n    /**\n     * Reverses the elements in an Array.\n     */\n    reverse(): this;\n\n    /**\n     * Sets a value or an array of values.\n     * @param array A typed or untyped array of values to set.\n     * @param offset The index in the current array at which the values are to be written.\n     */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n     * Returns a section of an array.\n     * @param start The beginning of the specified portion of the array.\n     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.\n     */\n    slice(start?: number, end?: number): Float16Array<ArrayBuffer>;\n\n    /**\n     * Determines whether the specified callback function returns true for any element of an array.\n     * @param predicate A function that accepts up to three arguments. The some method calls\n     * the predicate function for each element in the array until the predicate returns a value\n     * which is coercible to the Boolean value true, or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    some(predicate: (value: number, index: number, array: this) => unknown, thisArg?: any): boolean;\n\n    /**\n     * Sorts an array.\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\n     * a negative value if first argument is less than second argument, zero if they're equal and a positive\n     * value otherwise. If omitted, the elements are sorted in ascending order.\n     * ```ts\n     * [11,2,22,1].sort((a, b) => a - b)\n     * ```\n     */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n     * Gets a new Float16Array view of the ArrayBuffer store for this array, referencing the elements\n     * at begin, inclusive, up to end, exclusive.\n     * @param begin The index of the beginning of the array.\n     * @param end The index of the end of the array.\n     */\n    subarray(begin?: number, end?: number): Float16Array<TArrayBuffer>;\n\n    /**\n     * Converts a number to a string by using the current locale.\n     */\n    toLocaleString(locales?: string | string[], options?: Intl.NumberFormatOptions): string;\n\n    /**\n     * Copies the array and returns the copy with the elements in reverse order.\n     */\n    toReversed(): Float16Array<ArrayBuffer>;\n\n    /**\n     * Copies and sorts the array.\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\n     * a negative value if the first argument is less than the second argument, zero if they're equal, and a positive\n     * value otherwise. If omitted, the elements are sorted in ascending order.\n     * ```ts\n     * const myNums = Float16Array.from([11.25, 2, -22.5, 1]);\n     * myNums.toSorted((a, b) => a - b) // Float16Array(4) [-22.5, 1, 2, 11.5]\n     * ```\n     */\n    toSorted(compareFn?: (a: number, b: number) => number): Float16Array<ArrayBuffer>;\n\n    /**\n     * Returns a string representation of an array.\n     */\n    toString(): string;\n\n    /** Returns the primitive value of the specified object. */\n    valueOf(): this;\n\n    /**\n     * Copies the array and inserts the given number at the provided index.\n     * @param index The index of the value to overwrite. If the index is\n     * negative, then it replaces from the end of the array.\n     * @param value The value to insert into the copied array.\n     * @returns A copy of the original array with the inserted value.\n     */\n    with(index: number, value: number): Float16Array<ArrayBuffer>;\n\n    [index: number]: number;\n\n    [Symbol.iterator](): ArrayIterator<number>;\n\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): ArrayIterator<[number, number]>;\n\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): ArrayIterator<number>;\n\n    /**\n     * Returns an list of values in the array\n     */\n    values(): ArrayIterator<number>;\n\n    readonly [Symbol.toStringTag]: \"Float16Array\";\n}\n\ninterface Float16ArrayConstructor {\n    readonly prototype: Float16Array<ArrayBufferLike>;\n    new (length?: number): Float16Array<ArrayBuffer>;\n    new (array: ArrayLike<number> | Iterable<number>): Float16Array<ArrayBuffer>;\n    new <TArrayBuffer extends ArrayBufferLike = ArrayBuffer>(buffer: TArrayBuffer, byteOffset?: number, length?: number): Float16Array<TArrayBuffer>;\n    new (buffer: ArrayBuffer, byteOffset?: number, length?: number): Float16Array<ArrayBuffer>;\n    new (array: ArrayLike<number> | ArrayBuffer): Float16Array<ArrayBuffer>;\n\n    /**\n     * The size in bytes of each element in the array.\n     */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n     * Returns a new array from a set of elements.\n     * @param items A set of elements to include in the new array object.\n     */\n    of(...items: number[]): Float16Array<ArrayBuffer>;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like object to convert to an array.\n     */\n    from(arrayLike: ArrayLike<number>): Float16Array<ArrayBuffer>;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => number, thisArg?: any): Float16Array<ArrayBuffer>;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param elements An iterable object to convert to an array.\n     */\n    from(elements: Iterable<number>): Float16Array<ArrayBuffer>;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param elements An iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from<T>(elements: Iterable<T>, mapfn?: (v: T, k: number) => number, thisArg?: any): Float16Array<ArrayBuffer>;\n}\ndeclare var Float16Array: Float16ArrayConstructor;\n\ninterface Math {\n    /**\n     * Returns the nearest half precision float representation of a number.\n     * @param x A numeric expression.\n     */\n    f16round(x: number): number;\n}\n\ninterface DataView<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Gets the Float16 value at the specified byte offset from the start of the view. There is\n     * no alignment constraint; multi-byte values may be fetched from any offset.\n     * @param byteOffset The place in the buffer at which the value should be retrieved.\n     * @param littleEndian If false or undefined, a big-endian value should be read.\n     */\n    getFloat16(byteOffset: number, littleEndian?: boolean): number;\n\n    /**\n     * Stores an Float16 value at the specified byte offset from the start of the view.\n     * @param byteOffset The place in the buffer at which the value should be set.\n     * @param value The value to set.\n     * @param littleEndian If false or undefined, a big-endian value should be written.\n     */\n    setFloat16(byteOffset: number, value: number, littleEndian?: boolean): void;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.esnext.float16.d.ts",
        "start": 1,
        "end": 445,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 445,
          "column": 2,
          "position": 1888
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.esnext.float16.d.ts",
        "start": 1,
        "end": 445,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 445,
          "column": 2,
          "position": 1888
        }
      }
    },
    {
      "format": "typescript",
      "lines": 193,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\n/// <reference lib=\"es2015.symbol\" />\n/// <reference lib=\"es2015.iterable\" />\n/// <reference lib=\"es2018.asynciterable\" />\n\ninterface SymbolConstructor {\n    /**\n     * A method that is used to release resources held by an object. Called by the semantics of the `using` statement.\n     */\n    readonly dispose: unique symbol;\n\n    /**\n     * A method that is used to asynchronously release resources held by an object. Called by the semantics of the `await using` statement.\n     */\n    readonly asyncDispose: unique symbol;\n}\n\ninterface Disposable {\n    [Symbol.dispose](): void;\n}\n\ninterface AsyncDisposable {\n    [Symbol.asyncDispose](): PromiseLike<void>;\n}\n\ninterface SuppressedError extends Error {\n    error: any;\n    suppressed: any;\n}\n\ninterface SuppressedErrorConstructor {\n    new (error: any, suppressed: any, message?: string): SuppressedError;\n    (error: any, suppressed: any, message?: string): SuppressedError;\n    readonly prototype: SuppressedError;\n}\ndeclare var SuppressedError: SuppressedErrorConstructor;\n\ninterface DisposableStack {\n    /**\n     * Returns a value indicating whether this stack has been disposed.\n     */\n    readonly disposed: boolean;\n    /**\n     * Disposes each resource in the stack in the reverse order that they were added.\n     */\n    dispose(): void;\n    /**\n     * Adds a disposable resource to the stack, returning the resource.\n     * @param value The resource to add. `null` and `undefined` will not be added, but will be returned.\n     * @returns The provided {@link value}.\n     */\n    use<T extends Disposable | null | undefined>(value: T): T;\n    /**\n     * Adds a value and associated disposal callback as a resource to the stack.\n     * @param value The value to add.\n     * @param onDispose The callback to use in place of a `[Symbol.dispose]()` method. Will be invoked with `value`\n     * as the first parameter.\n     * @returns The provided {@link value}.\n     */\n    adopt<T>(value: T, onDispose: (value: T) => void): T;\n    /**\n     * Adds a callback to be invoked when the stack is disposed.\n     */\n    defer(onDispose: () => void): void;\n    /**\n     * Move all resources out of this stack and into a new `DisposableStack`, and marks this stack as disposed.\n     * @example\n     * ```ts\n     * class C {\n     *   #res1: Disposable;\n     *   #res2: Disposable;\n     *   #disposables: DisposableStack;\n     *   constructor() {\n     *     // stack will be disposed when exiting constructor for any reason\n     *     using stack = new DisposableStack();\n     *\n     *     // get first resource\n     *     this.#res1 = stack.use(getResource1());\n     *\n     *     // get second resource. If this fails, both `stack` and `#res1` will be disposed.\n     *     this.#res2 = stack.use(getResource2());\n     *\n     *     // all operations succeeded, move resources out of `stack` so that they aren't disposed\n     *     // when constructor exits\n     *     this.#disposables = stack.move();\n     *   }\n     *\n     *   [Symbol.dispose]() {\n     *     this.#disposables.dispose();\n     *   }\n     * }\n     * ```\n     */\n    move(): DisposableStack;\n    [Symbol.dispose](): void;\n    readonly [Symbol.toStringTag]: string;\n}\n\ninterface DisposableStackConstructor {\n    new (): DisposableStack;\n    readonly prototype: DisposableStack;\n}\ndeclare var DisposableStack: DisposableStackConstructor;\n\ninterface AsyncDisposableStack {\n    /**\n     * Returns a value indicating whether this stack has been disposed.\n     */\n    readonly disposed: boolean;\n    /**\n     * Disposes each resource in the stack in the reverse order that they were added.\n     */\n    disposeAsync(): Promise<void>;\n    /**\n     * Adds a disposable resource to the stack, returning the resource.\n     * @param value The resource to add. `null` and `undefined` will not be added, but will be returned.\n     * @returns The provided {@link value}.\n     */\n    use<T extends AsyncDisposable | Disposable | null | undefined>(value: T): T;\n    /**\n     * Adds a value and associated disposal callback as a resource to the stack.\n     * @param value The value to add.\n     * @param onDisposeAsync The callback to use in place of a `[Symbol.asyncDispose]()` method. Will be invoked with `value`\n     * as the first parameter.\n     * @returns The provided {@link value}.\n     */\n    adopt<T>(value: T, onDisposeAsync: (value: T) => PromiseLike<void> | void): T;\n    /**\n     * Adds a callback to be invoked when the stack is disposed.\n     */\n    defer(onDisposeAsync: () => PromiseLike<void> | void): void;\n    /**\n     * Move all resources out of this stack and into a new `DisposableStack`, and marks this stack as disposed.\n     * @example\n     * ```ts\n     * class C {\n     *   #res1: Disposable;\n     *   #res2: Disposable;\n     *   #disposables: DisposableStack;\n     *   constructor() {\n     *     // stack will be disposed when exiting constructor for any reason\n     *     using stack = new DisposableStack();\n     *\n     *     // get first resource\n     *     this.#res1 = stack.use(getResource1());\n     *\n     *     // get second resource. If this fails, both `stack` and `#res1` will be disposed.\n     *     this.#res2 = stack.use(getResource2());\n     *\n     *     // all operations succeeded, move resources out of `stack` so that they aren't disposed\n     *     // when constructor exits\n     *     this.#disposables = stack.move();\n     *   }\n     *\n     *   [Symbol.dispose]() {\n     *     this.#disposables.dispose();\n     *   }\n     * }\n     * ```\n     */\n    move(): AsyncDisposableStack;\n    [Symbol.asyncDispose](): Promise<void>;\n    readonly [Symbol.toStringTag]: string;\n}\n\ninterface AsyncDisposableStackConstructor {\n    new (): AsyncDisposableStack;\n    readonly prototype: AsyncDisposableStack;\n}\ndeclare var AsyncDisposableStack: AsyncDisposableStackConstructor;\n\ninterface IteratorObject<T, TReturn, TNext> extends Disposable {\n}\n\ninterface AsyncIteratorObject<T, TReturn, TNext> extends AsyncDisposable {\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.esnext.disposable.d.ts",
        "start": 1,
        "end": 193,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 193,
          "column": 2,
          "position": 661
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.esnext.disposable.d.ts",
        "start": 1,
        "end": 193,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 193,
          "column": 2,
          "position": 661
        }
      }
    },
    {
      "format": "typescript",
      "lines": 96,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\n/// <reference lib=\"es2024.collection\" />\n\ninterface ReadonlySetLike<T> {\n    /**\n     * Despite its name, returns an iterator of the values in the set-like.\n     */\n    keys(): Iterator<T>;\n    /**\n     * @returns a boolean indicating whether an element with the specified value exists in the set-like or not.\n     */\n    has(value: T): boolean;\n    /**\n     * @returns the number of (unique) elements in the set-like.\n     */\n    readonly size: number;\n}\n\ninterface Set<T> {\n    /**\n     * @returns a new Set containing all the elements in this Set and also all the elements in the argument.\n     */\n    union<U>(other: ReadonlySetLike<U>): Set<T | U>;\n    /**\n     * @returns a new Set containing all the elements which are both in this Set and in the argument.\n     */\n    intersection<U>(other: ReadonlySetLike<U>): Set<T & U>;\n    /**\n     * @returns a new Set containing all the elements in this Set which are not also in the argument.\n     */\n    difference<U>(other: ReadonlySetLike<U>): Set<T>;\n    /**\n     * @returns a new Set containing all the elements which are in either this Set or in the argument, but not in both.\n     */\n    symmetricDifference<U>(other: ReadonlySetLike<U>): Set<T | U>;\n    /**\n     * @returns a boolean indicating whether all the elements in this Set are also in the argument.\n     */\n    isSubsetOf(other: ReadonlySetLike<unknown>): boolean;\n    /**\n     * @returns a boolean indicating whether all the elements in the argument are also in this Set.\n     */\n    isSupersetOf(other: ReadonlySetLike<unknown>): boolean;\n    /**\n     * @returns a boolean indicating whether this Set has no elements in common with the argument.\n     */\n    isDisjointFrom(other: ReadonlySetLike<unknown>): boolean;\n}\n\ninterface ReadonlySet<T> {\n    /**\n     * @returns a new Set containing all the elements in this Set and also all the elements in the argument.\n     */\n    union<U>(other: ReadonlySetLike<U>): Set<T | U>;\n    /**\n     * @returns a new Set containing all the elements which are both in this Set and in the argument.\n     */\n    intersection<U>(other: ReadonlySetLike<U>): Set<T & U>;\n    /**\n     * @returns a new Set containing all the elements in this Set which are not also in the argument.\n     */\n    difference<U>(other: ReadonlySetLike<U>): Set<T>;\n    /**\n     * @returns a new Set containing all the elements which are in either this Set or in the argument, but not in both.\n     */\n    symmetricDifference<U>(other: ReadonlySetLike<U>): Set<T | U>;\n    /**\n     * @returns a boolean indicating whether all the elements in this Set are also in the argument.\n     */\n    isSubsetOf(other: ReadonlySetLike<unknown>): boolean;\n    /**\n     * @returns a boolean indicating whether all the elements in the argument are also in this Set.\n     */\n    isSupersetOf(other: ReadonlySetLike<unknown>): boolean;\n    /**\n     * @returns a boolean indicating whether this Set has no elements in common with the argument.\n     */\n    isDisjointFrom(other: ReadonlySetLike<unknown>): boolean;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.esnext.collection.d.ts",
        "start": 1,
        "end": 96,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 96,
          "column": 2,
          "position": 424
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.esnext.collection.d.ts",
        "start": 1,
        "end": 65,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 65,
          "column": 2,
          "position": 243
        }
      }
    },
    {
      "format": "typescript",
      "lines": 35,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\ninterface ArrayConstructor {\n    /**\n     * Creates an array from an async iterator or iterable object.\n     * @param iterableOrArrayLike An async iterator or array-like object to convert to an array.\n     */\n    fromAsync<T>(iterableOrArrayLike: AsyncIterable<T> | Iterable<T | PromiseLike<T>> | ArrayLike<T | PromiseLike<T>>): Promise<T[]>;\n\n    /**\n     * Creates an array from an async iterator or iterable object.\n     *\n     * @param iterableOrArrayLike An async iterator or array-like object to convert to an array.\n     * @param mapfn A mapping function to call on every element of itarableOrArrayLike.\n     *      Each return value is awaited before being added to result array.\n     * @param thisArg Value of 'this' used when executing mapfn.\n     */\n    fromAsync<T, U>(iterableOrArrayLike: AsyncIterable<T> | Iterable<T> | ArrayLike<T>, mapFn: (value: Awaited<T>, index: number) => U, thisArg?: any): Promise<Awaited<U>[]>;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.esnext.array.d.ts",
        "start": 1,
        "end": 35,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 35,
          "column": 2,
          "position": 145
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.esnext.array.d.ts",
        "start": 1,
        "end": 35,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 35,
          "column": 2,
          "position": 145
        }
      }
    },
    {
      "format": "typescript",
      "lines": 68,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\n/// <reference lib=\"es2020.bigint\" />\n\ninterface Atomics {\n    /**\n     * A non-blocking, asynchronous version of wait which is usable on the main thread.\n     * Waits asynchronously on a shared memory location and returns a Promise\n     * @param typedArray A shared Int32Array or BigInt64Array.\n     * @param index The position in the typedArray to wait on.\n     * @param value The expected value to test.\n     * @param [timeout] The expected value to test.\n     */\n    waitAsync(typedArray: Int32Array, index: number, value: number, timeout?: number): { async: false; value: \"not-equal\" | \"timed-out\"; } | { async: true; value: Promise<\"ok\" | \"timed-out\">; };\n\n    /**\n     * A non-blocking, asynchronous version of wait which is usable on the main thread.\n     * Waits asynchronously on a shared memory location and returns a Promise\n     * @param typedArray A shared Int32Array or BigInt64Array.\n     * @param index The position in the typedArray to wait on.\n     * @param value The expected value to test.\n     * @param [timeout] The expected value to test.\n     */\n    waitAsync(typedArray: BigInt64Array, index: number, value: bigint, timeout?: number): { async: false; value: \"not-equal\" | \"timed-out\"; } | { async: true; value: Promise<\"ok\" | \"timed-out\">; };\n}\n\ninterface SharedArrayBuffer {\n    /**\n     * Returns true if this SharedArrayBuffer can be grown.\n     *\n     * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer/growable)\n     */\n    get growable(): boolean;\n\n    /**\n     * If this SharedArrayBuffer is growable, returns the maximum byte length given during construction; returns the byte length if not.\n     *\n     * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer/maxByteLength)\n     */\n    get maxByteLength(): number;\n\n    /**\n     * Grows the SharedArrayBuffer to the specified size (in bytes).\n     *\n     * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer/grow)\n     */\n    grow(newByteLength?: number): void;\n}\n\ninterface SharedArrayBufferConstructor {\n    new (byteLength: number, options?: { maxByteLength?: number; }): SharedArrayBuffer;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2024.sharedmemory.d.ts",
        "start": 1,
        "end": 68,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 68,
          "column": 2,
          "position": 268
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2024.sharedmemory.d.ts",
        "start": 1,
        "end": 68,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 68,
          "column": 2,
          "position": 268
        }
      }
    },
    {
      "format": "typescript",
      "lines": 35,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\ninterface PromiseWithResolvers<T> {\n    promise: Promise<T>;\n    resolve: (value: T | PromiseLike<T>) => void;\n    reject: (reason?: any) => void;\n}\n\ninterface PromiseConstructor {\n    /**\n     * Creates a new Promise and returns it in an object, along with its resolve and reject functions.\n     * @returns An object with the properties `promise`, `resolve`, and `reject`.\n     *\n     * ```ts\n     * const { promise, resolve, reject } = Promise.withResolvers<T>();\n     * ```\n     */\n    withResolvers<T>(): PromiseWithResolvers<T>;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2024.promise.d.ts",
        "start": 1,
        "end": 35,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 35,
          "column": 2,
          "position": 93
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2024.promise.d.ts",
        "start": 1,
        "end": 35,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 35,
          "column": 2,
          "position": 93
        }
      }
    },
    {
      "format": "typescript",
      "lines": 65,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\ninterface ArrayBuffer {\n    /**\n     * If this ArrayBuffer is resizable, returns the maximum byte length given during construction; returns the byte length if not.\n     *\n     * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/maxByteLength)\n     */\n    get maxByteLength(): number;\n\n    /**\n     * Returns true if this ArrayBuffer can be resized.\n     *\n     * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/resizable)\n     */\n    get resizable(): boolean;\n\n    /**\n     * Resizes the ArrayBuffer to the specified size (in bytes).\n     *\n     * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/resize)\n     */\n    resize(newByteLength?: number): void;\n\n    /**\n     * Returns a boolean indicating whether or not this buffer has been detached (transferred).\n     *\n     * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/detached)\n     */\n    get detached(): boolean;\n\n    /**\n     * Creates a new ArrayBuffer with the same byte content as this buffer, then detaches this buffer.\n     *\n     * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/transfer)\n     */\n    transfer(newByteLength?: number): ArrayBuffer;\n\n    /**\n     * Creates a new non-resizable ArrayBuffer with the same byte content as this buffer, then detaches this buffer.\n     *\n     * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/transferToFixedLength)\n     */\n    transferToFixedLength(newByteLength?: number): ArrayBuffer;\n}\n\ninterface ArrayBufferConstructor {\n    new (byteLength: number, options?: { maxByteLength?: number; }): ArrayBuffer;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2024.arraybuffer.d.ts",
        "start": 1,
        "end": 65,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 65,
          "column": 2,
          "position": 150
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2024.arraybuffer.d.ts",
        "start": 1,
        "end": 65,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 65,
          "column": 2,
          "position": 150
        }
      }
    },
    {
      "format": "typescript",
      "lines": 56,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\ndeclare namespace Intl {\n    interface NumberFormatOptionsUseGroupingRegistry {\n        min2: never;\n        auto: never;\n        always: never;\n    }\n\n    interface NumberFormatOptionsSignDisplayRegistry {\n        negative: never;\n    }\n\n    interface NumberFormatOptions {\n        roundingPriority?: \"auto\" | \"morePrecision\" | \"lessPrecision\" | undefined;\n        roundingIncrement?: 1 | 2 | 5 | 10 | 20 | 25 | 50 | 100 | 200 | 250 | 500 | 1000 | 2000 | 2500 | 5000 | undefined;\n        roundingMode?: \"ceil\" | \"floor\" | \"expand\" | \"trunc\" | \"halfCeil\" | \"halfFloor\" | \"halfExpand\" | \"halfTrunc\" | \"halfEven\" | undefined;\n        trailingZeroDisplay?: \"auto\" | \"stripIfInteger\" | undefined;\n    }\n\n    interface ResolvedNumberFormatOptions {\n        roundingPriority: \"auto\" | \"morePrecision\" | \"lessPrecision\";\n        roundingMode: \"ceil\" | \"floor\" | \"expand\" | \"trunc\" | \"halfCeil\" | \"halfFloor\" | \"halfExpand\" | \"halfTrunc\" | \"halfEven\";\n        roundingIncrement: 1 | 2 | 5 | 10 | 20 | 25 | 50 | 100 | 200 | 250 | 500 | 1000 | 2000 | 2500 | 5000;\n        trailingZeroDisplay: \"auto\" | \"stripIfInteger\";\n    }\n\n    interface NumberRangeFormatPart extends NumberFormatPart {\n        source: \"startRange\" | \"endRange\" | \"shared\";\n    }\n\n    type StringNumericLiteral = `${number}` | \"Infinity\" | \"-Infinity\" | \"+Infinity\";\n\n    interface NumberFormat {\n        format(value: number | bigint | StringNumericLiteral): string;\n        formatToParts(value: number | bigint | StringNumericLiteral): NumberFormatPart[];\n        formatRange(start: number | bigint | StringNumericLiteral, end: number | bigint | StringNumericLiteral): string;\n        formatRangeToParts(start: number | bigint | StringNumericLiteral, end: number | bigint | StringNumericLiteral): NumberRangeFormatPart[];\n    }\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2023.intl.d.ts",
        "start": 1,
        "end": 56,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 56,
          "column": 2,
          "position": 546
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2023.intl.d.ts",
        "start": 1,
        "end": 56,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 56,
          "column": 2,
          "position": 546
        }
      }
    },
    {
      "format": "typescript",
      "lines": 924,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\ninterface Array<T> {\n    /**\n     * Returns the value of the last element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate findLast calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found, findLast\n     * immediately returns that element value. Otherwise, findLast returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLast<S extends T>(predicate: (value: T, index: number, array: T[]) => value is S, thisArg?: any): S | undefined;\n    findLast(predicate: (value: T, index: number, array: T[]) => unknown, thisArg?: any): T | undefined;\n\n    /**\n     * Returns the index of the last element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate findLastIndex calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLastIndex(predicate: (value: T, index: number, array: T[]) => unknown, thisArg?: any): number;\n\n    /**\n     * Returns a copy of an array with its elements reversed.\n     */\n    toReversed(): T[];\n\n    /**\n     * Returns a copy of an array with its elements sorted.\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\n     * a negative value if the first argument is less than the second argument, zero if they're equal, and a positive\n     * value otherwise. If omitted, the elements are sorted in ascending, UTF-16 code unit order.\n     * ```ts\n     * [11, 2, 22, 1].toSorted((a, b) => a - b) // [1, 2, 11, 22]\n     * ```\n     */\n    toSorted(compareFn?: (a: T, b: T) => number): T[];\n\n    /**\n     * Copies an array and removes elements and, if necessary, inserts new elements in their place. Returns the copied array.\n     * @param start The zero-based location in the array from which to start removing elements.\n     * @param deleteCount The number of elements to remove.\n     * @param items Elements to insert into the copied array in place of the deleted elements.\n     * @returns The copied array.\n     */\n    toSpliced(start: number, deleteCount: number, ...items: T[]): T[];\n\n    /**\n     * Copies an array and removes elements while returning the remaining elements.\n     * @param start The zero-based location in the array from which to start removing elements.\n     * @param deleteCount The number of elements to remove.\n     * @returns A copy of the original array with the remaining elements.\n     */\n    toSpliced(start: number, deleteCount?: number): T[];\n\n    /**\n     * Copies an array, then overwrites the value at the provided index with the\n     * given value. If the index is negative, then it replaces from the end\n     * of the array.\n     * @param index The index of the value to overwrite. If the index is\n     * negative, then it replaces from the end of the array.\n     * @param value The value to write into the copied array.\n     * @returns The copied array with the updated value.\n     */\n    with(index: number, value: T): T[];\n}\n\ninterface ReadonlyArray<T> {\n    /**\n     * Returns the value of the last element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate findLast calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found, findLast\n     * immediately returns that element value. Otherwise, findLast returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLast<S extends T>(\n        predicate: (value: T, index: number, array: readonly T[]) => value is S,\n        thisArg?: any,\n    ): S | undefined;\n    findLast(\n        predicate: (value: T, index: number, array: readonly T[]) => unknown,\n        thisArg?: any,\n    ): T | undefined;\n\n    /**\n     * Returns the index of the last element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate findLastIndex calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLastIndex(\n        predicate: (value: T, index: number, array: readonly T[]) => unknown,\n        thisArg?: any,\n    ): number;\n\n    /**\n     * Copies the array and returns the copied array with all of its elements reversed.\n     */\n    toReversed(): T[];\n\n    /**\n     * Copies and sorts the array.\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\n     * a negative value if the first argument is less than the second argument, zero if they're equal, and a positive\n     * value otherwise. If omitted, the elements are sorted in ascending, UTF-16 code unit order.\n     * ```ts\n     * [11, 2, 22, 1].toSorted((a, b) => a - b) // [1, 2, 11, 22]\n     * ```\n     */\n    toSorted(compareFn?: (a: T, b: T) => number): T[];\n\n    /**\n     * Copies an array and removes elements while, if necessary, inserting new elements in their place, returning the remaining elements.\n     * @param start The zero-based location in the array from which to start removing elements.\n     * @param deleteCount The number of elements to remove.\n     * @param items Elements to insert into the copied array in place of the deleted elements.\n     * @returns A copy of the original array with the remaining elements.\n     */\n    toSpliced(start: number, deleteCount: number, ...items: T[]): T[];\n\n    /**\n     * Copies an array and removes elements while returning the remaining elements.\n     * @param start The zero-based location in the array from which to start removing elements.\n     * @param deleteCount The number of elements to remove.\n     * @returns A copy of the original array with the remaining elements.\n     */\n    toSpliced(start: number, deleteCount?: number): T[];\n\n    /**\n     * Copies an array, then overwrites the value at the provided index with the\n     * given value. If the index is negative, then it replaces from the end\n     * of the array\n     * @param index The index of the value to overwrite. If the index is\n     * negative, then it replaces from the end of the array.\n     * @param value The value to insert into the copied array.\n     * @returns A copy of the original array with the inserted value.\n     */\n    with(index: number, value: T): T[];\n}\n\ninterface Int8Array<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Returns the value of the last element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate findLast calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found, findLast\n     * immediately returns that element value. Otherwise, findLast returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLast<S extends number>(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => value is S,\n        thisArg?: any,\n    ): S | undefined;\n    findLast(\n        predicate: (value: number, index: number, array: this) => unknown,\n        thisArg?: any,\n    ): number | undefined;\n\n    /**\n     * Returns the index of the last element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate findLastIndex calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLastIndex(\n        predicate: (value: number, index: number, array: this) => unknown,\n        thisArg?: any,\n    ): number;\n\n    /**\n     * Copies the array and returns the copy with the elements in reverse order.\n     */\n    toReversed(): Int8Array<ArrayBuffer>;\n\n    /**\n     * Copies and sorts the array.\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\n     * a negative value if the first argument is less than the second argument, zero if they're equal, and a positive\n     * value otherwise. If omitted, the elements are sorted in ascending order.\n     * ```ts\n     * const myNums = Int8Array.from([11, 2, 22, 1]);\n     * myNums.toSorted((a, b) => a - b) // Int8Array(4) [1, 2, 11, 22]\n     * ```\n     */\n    toSorted(compareFn?: (a: number, b: number) => number): Int8Array<ArrayBuffer>;\n\n    /**\n     * Copies the array and inserts the given number at the provided index.\n     * @param index The index of the value to overwrite. If the index is\n     * negative, then it replaces from the end of the array.\n     * @param value The value to insert into the copied array.\n     * @returns A copy of the original array with the inserted value.\n     */\n    with(index: number, value: number): Int8Array<ArrayBuffer>;\n}\n\ninterface Uint8Array<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Returns the value of the last element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate findLast calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found, findLast\n     * immediately returns that element value. Otherwise, findLast returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLast<S extends number>(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => value is S,\n        thisArg?: any,\n    ): S | undefined;\n    findLast(\n        predicate: (value: number, index: number, array: this) => unknown,\n        thisArg?: any,\n    ): number | undefined;\n\n    /**\n     * Returns the index of the last element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate findLastIndex calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLastIndex(\n        predicate: (value: number, index: number, array: this) => unknown,\n        thisArg?: any,\n    ): number;\n\n    /**\n     * Copies the array and returns the copy with the elements in reverse order.\n     */\n    toReversed(): Uint8Array<ArrayBuffer>;\n\n    /**\n     * Copies and sorts the array.\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\n     * a negative value if the first argument is less than the second argument, zero if they're equal, and a positive\n     * value otherwise. If omitted, the elements are sorted in ascending order.\n     * ```ts\n     * const myNums = Uint8Array.from([11, 2, 22, 1]);\n     * myNums.toSorted((a, b) => a - b) // Uint8Array(4) [1, 2, 11, 22]\n     * ```\n     */\n    toSorted(compareFn?: (a: number, b: number) => number): Uint8Array<ArrayBuffer>;\n\n    /**\n     * Copies the array and inserts the given number at the provided index.\n     * @param index The index of the value to overwrite. If the index is\n     * negative, then it replaces from the end of the array.\n     * @param value The value to insert into the copied array.\n     * @returns A copy of the original array with the inserted value.\n     */\n    with(index: number, value: number): Uint8Array<ArrayBuffer>;\n}\n\ninterface Uint8ClampedArray<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Returns the value of the last element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate findLast calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found, findLast\n     * immediately returns that element value. Otherwise, findLast returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLast<S extends number>(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => value is S,\n        thisArg?: any,\n    ): S | undefined;\n    findLast(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => unknown,\n        thisArg?: any,\n    ): number | undefined;\n\n    /**\n     * Returns the index of the last element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate findLastIndex calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLastIndex(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => unknown,\n        thisArg?: any,\n    ): number;\n\n    /**\n     * Copies the array and returns the copy with the elements in reverse order.\n     */\n    toReversed(): Uint8ClampedArray<ArrayBuffer>;\n\n    /**\n     * Copies and sorts the array.\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\n     * a negative value if the first argument is less than the second argument, zero if they're equal, and a positive\n     * value otherwise. If omitted, the elements are sorted in ascending order.\n     * ```ts\n     * const myNums = Uint8ClampedArray.from([11, 2, 22, 1]);\n     * myNums.toSorted((a, b) => a - b) // Uint8ClampedArray(4) [1, 2, 11, 22]\n     * ```\n     */\n    toSorted(compareFn?: (a: number, b: number) => number): Uint8ClampedArray<ArrayBuffer>;\n\n    /**\n     * Copies the array and inserts the given number at the provided index.\n     * @param index The index of the value to overwrite. If the index is\n     * negative, then it replaces from the end of the array.\n     * @param value The value to insert into the copied array.\n     * @returns A copy of the original array with the inserted value.\n     */\n    with(index: number, value: number): Uint8ClampedArray<ArrayBuffer>;\n}\n\ninterface Int16Array<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Returns the value of the last element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate findLast calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found, findLast\n     * immediately returns that element value. Otherwise, findLast returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLast<S extends number>(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => value is S,\n        thisArg?: any,\n    ): S | undefined;\n    findLast(\n        predicate: (value: number, index: number, array: this) => unknown,\n        thisArg?: any,\n    ): number | undefined;\n\n    /**\n     * Returns the index of the last element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate findLastIndex calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLastIndex(\n        predicate: (value: number, index: number, array: this) => unknown,\n        thisArg?: any,\n    ): number;\n\n    /**\n     * Copies the array and returns the copy with the elements in reverse order.\n     */\n    toReversed(): Int16Array<ArrayBuffer>;\n\n    /**\n     * Copies and sorts the array.\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\n     * a negative value if the first argument is less than the second argument, zero if they're equal, and a positive\n     * value otherwise. If omitted, the elements are sorted in ascending order.\n     * ```ts\n     * const myNums = Int16Array.from([11, 2, -22, 1]);\n     * myNums.toSorted((a, b) => a - b) // Int16Array(4) [-22, 1, 2, 11]\n     * ```\n     */\n    toSorted(compareFn?: (a: number, b: number) => number): Int16Array<ArrayBuffer>;\n\n    /**\n     * Copies the array and inserts the given number at the provided index.\n     * @param index The index of the value to overwrite. If the index is\n     * negative, then it replaces from the end of the array.\n     * @param value The value to insert into the copied array.\n     * @returns A copy of the original array with the inserted value.\n     */\n    with(index: number, value: number): Int16Array<ArrayBuffer>;\n}\n\ninterface Uint16Array<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Returns the value of the last element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate findLast calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found, findLast\n     * immediately returns that element value. Otherwise, findLast returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLast<S extends number>(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => value is S,\n        thisArg?: any,\n    ): S | undefined;\n    findLast(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => unknown,\n        thisArg?: any,\n    ): number | undefined;\n\n    /**\n     * Returns the index of the last element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate findLastIndex calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLastIndex(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => unknown,\n        thisArg?: any,\n    ): number;\n\n    /**\n     * Copies the array and returns the copy with the elements in reverse order.\n     */\n    toReversed(): Uint16Array<ArrayBuffer>;\n\n    /**\n     * Copies and sorts the array.\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\n     * a negative value if the first argument is less than the second argument, zero if they're equal, and a positive\n     * value otherwise. If omitted, the elements are sorted in ascending order.\n     * ```ts\n     * const myNums = Uint16Array.from([11, 2, 22, 1]);\n     * myNums.toSorted((a, b) => a - b) // Uint16Array(4) [1, 2, 11, 22]\n     * ```\n     */\n    toSorted(compareFn?: (a: number, b: number) => number): Uint16Array<ArrayBuffer>;\n\n    /**\n     * Copies the array and inserts the given number at the provided index.\n     * @param index The index of the value to overwrite. If the index is\n     * negative, then it replaces from the end of the array.\n     * @param value The value to insert into the copied array.\n     * @returns A copy of the original array with the inserted value.\n     */\n    with(index: number, value: number): Uint16Array<ArrayBuffer>;\n}\n\ninterface Int32Array<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Returns the value of the last element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate findLast calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found, findLast\n     * immediately returns that element value. Otherwise, findLast returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLast<S extends number>(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => value is S,\n        thisArg?: any,\n    ): S | undefined;\n    findLast(\n        predicate: (value: number, index: number, array: this) => unknown,\n        thisArg?: any,\n    ): number | undefined;\n\n    /**\n     * Returns the index of the last element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate findLastIndex calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLastIndex(\n        predicate: (value: number, index: number, array: this) => unknown,\n        thisArg?: any,\n    ): number;\n\n    /**\n     * Copies the array and returns the copy with the elements in reverse order.\n     */\n    toReversed(): Int32Array<ArrayBuffer>;\n\n    /**\n     * Copies and sorts the array.\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\n     * a negative value if the first argument is less than the second argument, zero if they're equal, and a positive\n     * value otherwise. If omitted, the elements are sorted in ascending order.\n     * ```ts\n     * const myNums = Int32Array.from([11, 2, -22, 1]);\n     * myNums.toSorted((a, b) => a - b) // Int32Array(4) [-22, 1, 2, 11]\n     * ```\n     */\n    toSorted(compareFn?: (a: number, b: number) => number): Int32Array<ArrayBuffer>;\n\n    /**\n     * Copies the array and inserts the given number at the provided index.\n     * @param index The index of the value to overwrite. If the index is\n     * negative, then it replaces from the end of the array.\n     * @param value The value to insert into the copied array.\n     * @returns A copy of the original array with the inserted value.\n     */\n    with(index: number, value: number): Int32Array<ArrayBuffer>;\n}\n\ninterface Uint32Array<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Returns the value of the last element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate findLast calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found, findLast\n     * immediately returns that element value. Otherwise, findLast returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLast<S extends number>(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => value is S,\n        thisArg?: any,\n    ): S | undefined;\n    findLast(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => unknown,\n        thisArg?: any,\n    ): number | undefined;\n\n    /**\n     * Returns the index of the last element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate findLastIndex calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLastIndex(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => unknown,\n        thisArg?: any,\n    ): number;\n\n    /**\n     * Copies the array and returns the copy with the elements in reverse order.\n     */\n    toReversed(): Uint32Array<ArrayBuffer>;\n\n    /**\n     * Copies and sorts the array.\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\n     * a negative value if the first argument is less than the second argument, zero if they're equal, and a positive\n     * value otherwise. If omitted, the elements are sorted in ascending order.\n     * ```ts\n     * const myNums = Uint32Array.from([11, 2, 22, 1]);\n     * myNums.toSorted((a, b) => a - b) // Uint32Array(4) [1, 2, 11, 22]\n     * ```\n     */\n    toSorted(compareFn?: (a: number, b: number) => number): Uint32Array<ArrayBuffer>;\n\n    /**\n     * Copies the array and inserts the given number at the provided index.\n     * @param index The index of the value to overwrite. If the index is\n     * negative, then it replaces from the end of the array.\n     * @param value The value to insert into the copied array.\n     * @returns A copy of the original array with the inserted value.\n     */\n    with(index: number, value: number): Uint32Array<ArrayBuffer>;\n}\n\ninterface Float32Array<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Returns the value of the last element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate findLast calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found, findLast\n     * immediately returns that element value. Otherwise, findLast returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLast<S extends number>(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => value is S,\n        thisArg?: any,\n    ): S | undefined;\n    findLast(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => unknown,\n        thisArg?: any,\n    ): number | undefined;\n\n    /**\n     * Returns the index of the last element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate findLastIndex calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLastIndex(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => unknown,\n        thisArg?: any,\n    ): number;\n\n    /**\n     * Copies the array and returns the copy with the elements in reverse order.\n     */\n    toReversed(): Float32Array<ArrayBuffer>;\n\n    /**\n     * Copies and sorts the array.\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\n     * a negative value if the first argument is less than the second argument, zero if they're equal, and a positive\n     * value otherwise. If omitted, the elements are sorted in ascending order.\n     * ```ts\n     * const myNums = Float32Array.from([11.25, 2, -22.5, 1]);\n     * myNums.toSorted((a, b) => a - b) // Float32Array(4) [-22.5, 1, 2, 11.5]\n     * ```\n     */\n    toSorted(compareFn?: (a: number, b: number) => number): Float32Array<ArrayBuffer>;\n\n    /**\n     * Copies the array and inserts the given number at the provided index.\n     * @param index The index of the value to overwrite. If the index is\n     * negative, then it replaces from the end of the array.\n     * @param value The value to insert into the copied array.\n     * @returns A copy of the original array with the inserted value.\n     */\n    with(index: number, value: number): Float32Array<ArrayBuffer>;\n}\n\ninterface Float64Array<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Returns the value of the last element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate findLast calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found, findLast\n     * immediately returns that element value. Otherwise, findLast returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLast<S extends number>(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => value is S,\n        thisArg?: any,\n    ): S | undefined;\n    findLast(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => unknown,\n        thisArg?: any,\n    ): number | undefined;\n\n    /**\n     * Returns the index of the last element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate findLastIndex calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLastIndex(\n        predicate: (\n            value: number,\n            index: number,\n            array: this,\n        ) => unknown,\n        thisArg?: any,\n    ): number;\n\n    /**\n     * Copies the array and returns the copy with the elements in reverse order.\n     */\n    toReversed(): Float64Array<ArrayBuffer>;\n\n    /**\n     * Copies and sorts the array.\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\n     * a negative value if the first argument is less than the second argument, zero if they're equal, and a positive\n     * value otherwise. If omitted, the elements are sorted in ascending order.\n     * ```ts\n     * const myNums = Float64Array.from([11.25, 2, -22.5, 1]);\n     * myNums.toSorted((a, b) => a - b) // Float64Array(4) [-22.5, 1, 2, 11.5]\n     * ```\n     */\n    toSorted(compareFn?: (a: number, b: number) => number): Float64Array<ArrayBuffer>;\n\n    /**\n     * Copies the array and inserts the given number at the provided index.\n     * @param index The index of the value to overwrite. If the index is\n     * negative, then it replaces from the end of the array.\n     * @param value The value to insert into the copied array.\n     * @returns A copy of the original array with the inserted value.\n     */\n    with(index: number, value: number): Float64Array<ArrayBuffer>;\n}\n\ninterface BigInt64Array<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Returns the value of the last element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate findLast calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found, findLast\n     * immediately returns that element value. Otherwise, findLast returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLast<S extends bigint>(\n        predicate: (\n            value: bigint,\n            index: number,\n            array: this,\n        ) => value is S,\n        thisArg?: any,\n    ): S | undefined;\n    findLast(\n        predicate: (\n            value: bigint,\n            index: number,\n            array: this,\n        ) => unknown,\n        thisArg?: any,\n    ): bigint | undefined;\n\n    /**\n     * Returns the index of the last element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate findLastIndex calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLastIndex(\n        predicate: (\n            value: bigint,\n            index: number,\n            array: this,\n        ) => unknown,\n        thisArg?: any,\n    ): number;\n\n    /**\n     * Copies the array and returns the copy with the elements in reverse order.\n     */\n    toReversed(): BigInt64Array<ArrayBuffer>;\n\n    /**\n     * Copies and sorts the array.\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\n     * a negative value if the first argument is less than the second argument, zero if they're equal, and a positive\n     * value otherwise. If omitted, the elements are sorted in ascending order.\n     * ```ts\n     * const myNums = BigInt64Array.from([11n, 2n, -22n, 1n]);\n     * myNums.toSorted((a, b) => Number(a - b)) // BigInt64Array(4) [-22n, 1n, 2n, 11n]\n     * ```\n     */\n    toSorted(compareFn?: (a: bigint, b: bigint) => number): BigInt64Array<ArrayBuffer>;\n\n    /**\n     * Copies the array and inserts the given bigint at the provided index.\n     * @param index The index of the value to overwrite. If the index is\n     * negative, then it replaces from the end of the array.\n     * @param value The value to insert into the copied array.\n     * @returns A copy of the original array with the inserted value.\n     */\n    with(index: number, value: bigint): BigInt64Array<ArrayBuffer>;\n}\n\ninterface BigUint64Array<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Returns the value of the last element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate findLast calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found, findLast\n     * immediately returns that element value. Otherwise, findLast returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLast<S extends bigint>(\n        predicate: (\n            value: bigint,\n            index: number,\n            array: this,\n        ) => value is S,\n        thisArg?: any,\n    ): S | undefined;\n    findLast(\n        predicate: (\n            value: bigint,\n            index: number,\n            array: this,\n        ) => unknown,\n        thisArg?: any,\n    ): bigint | undefined;\n\n    /**\n     * Returns the index of the last element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate findLastIndex calls predicate once for each element of the array, in descending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findLastIndex(\n        predicate: (\n            value: bigint,\n            index: number,\n            array: this,\n        ) => unknown,\n        thisArg?: any,\n    ): number;\n\n    /**\n     * Copies the array and returns the copy with the elements in reverse order.\n     */\n    toReversed(): BigUint64Array<ArrayBuffer>;\n\n    /**\n     * Copies and sorts the array.\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\n     * a negative value if the first argument is less than the second argument, zero if they're equal, and a positive\n     * value otherwise. If omitted, the elements are sorted in ascending order.\n     * ```ts\n     * const myNums = BigUint64Array.from([11n, 2n, 22n, 1n]);\n     * myNums.toSorted((a, b) => Number(a - b)) // BigUint64Array(4) [1n, 2n, 11n, 22n]\n     * ```\n     */\n    toSorted(compareFn?: (a: bigint, b: bigint) => number): BigUint64Array<ArrayBuffer>;\n\n    /**\n     * Copies the array and inserts the given bigint at the provided index.\n     * @param index The index of the value to overwrite. If the index is\n     * negative, then it replaces from the end of the array.\n     * @param value The value to insert into the copied array.\n     * @returns A copy of the original array with the inserted value.\n     */\n    with(index: number, value: bigint): BigUint64Array<ArrayBuffer>;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2023.array.d.ts",
        "start": 1,
        "end": 924,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 924,
          "column": 2,
          "position": 3678
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2023.array.d.ts",
        "start": 1,
        "end": 924,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 924,
          "column": 2,
          "position": 3678
        }
      }
    },
    {
      "format": "typescript",
      "lines": 39,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\ninterface RegExpMatchArray {\n    indices?: RegExpIndicesArray;\n}\n\ninterface RegExpExecArray {\n    indices?: RegExpIndicesArray;\n}\n\ninterface RegExpIndicesArray extends Array<[number, number]> {\n    groups?: {\n        [key: string]: [number, number];\n    };\n}\n\ninterface RegExp {\n    /**\n     * Returns a Boolean value indicating the state of the hasIndices flag (d) used with a regular expression.\n     * Default is false. Read-only.\n     */\n    readonly hasIndices: boolean;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2022.regexp.d.ts",
        "start": 1,
        "end": 39,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 39,
          "column": 2,
          "position": 108
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2022.regexp.d.ts",
        "start": 1,
        "end": 39,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 39,
          "column": 2,
          "position": 108
        }
      }
    },
    {
      "format": "typescript",
      "lines": 145,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\ndeclare namespace Intl {\n    /**\n     * An object with some or all properties of the `Intl.Segmenter` constructor `options` parameter.\n     *\n     * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/Segmenter/Segmenter#parameters)\n     */\n    interface SegmenterOptions {\n        /** The locale matching algorithm to use. For information about this option, see [Intl page](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_negotiation). */\n        localeMatcher?: \"best fit\" | \"lookup\" | undefined;\n        /** The type of input to be split */\n        granularity?: \"grapheme\" | \"word\" | \"sentence\" | undefined;\n    }\n\n    /**\n     * The `Intl.Segmenter` object enables locale-sensitive text segmentation, enabling you to get meaningful items (graphemes, words or sentences) from a string.\n     *\n     * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/Segmenter)\n     */\n    interface Segmenter {\n        /**\n         * Returns `Segments` object containing the segments of the input string, using the segmenter's locale and granularity.\n         *\n         * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/Segmenter/segment)\n         *\n         * @param input - The text to be segmented as a `string`.\n         *\n         * @returns A new iterable Segments object containing the segments of the input string, using the segmenter's locale and granularity.\n         */\n        segment(input: string): Segments;\n        /**\n         * The `resolvedOptions()` method of `Intl.Segmenter` instances returns a new object with properties reflecting the options computed during initialization of this `Segmenter` object.\n         *\n         * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/Segmenter/resolvedOptions)\n         */\n        resolvedOptions(): ResolvedSegmenterOptions;\n    }\n\n    interface ResolvedSegmenterOptions {\n        locale: string;\n        granularity: \"grapheme\" | \"word\" | \"sentence\";\n    }\n\n    interface SegmentIterator<T> extends IteratorObject<T, BuiltinIteratorReturn, unknown> {\n        [Symbol.iterator](): SegmentIterator<T>;\n    }\n\n    /**\n     * A `Segments` object is an iterable collection of the segments of a text string. It is returned by a call to the `segment()` method of an `Intl.Segmenter` object.\n     *\n     * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/Segmenter/segment/Segments)\n     */\n    interface Segments {\n        /**\n         * Returns an object describing the segment in the original string that includes the code unit at a specified index.\n         *\n         * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/Segmenter/segment/Segments/containing)\n         *\n         * @param codeUnitIndex - A number specifying the index of the code unit in the original input string. If the value is omitted, it defaults to `0`.\n         */\n        containing(codeUnitIndex?: number): SegmentData | undefined;\n\n        /** Returns an iterator to iterate over the segments. */\n        [Symbol.iterator](): SegmentIterator<SegmentData>;\n    }\n\n    interface SegmentData {\n        /** A string containing the segment extracted from the original input string. */\n        segment: string;\n        /** The code unit index in the original input string at which the segment begins. */\n        index: number;\n        /** The complete input string that was segmented. */\n        input: string;\n        /**\n         * A boolean value only if granularity is \"word\"; otherwise, undefined.\n         * If granularity is \"word\", then isWordLike is true when the segment is word-like (i.e., consists of letters/numbers/ideographs/etc.); otherwise, false.\n         */\n        isWordLike?: boolean;\n    }\n\n    /**\n     * The `Intl.Segmenter` object enables locale-sensitive text segmentation, enabling you to get meaningful items (graphemes, words or sentences) from a string.\n     *\n     * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/Segmenter)\n     */\n    const Segmenter: {\n        prototype: Segmenter;\n\n        /**\n         * Creates a new `Intl.Segmenter` object.\n         *\n         * @param locales - A string with a [BCP 47 language tag](http://tools.ietf.org/html/rfc5646), or an array of such strings.\n         *  For the general form and interpretation of the `locales` argument,\n         *  see the [`Intl` page](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_identification_and_negotiation).\n         *\n         * @param options - An [object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/Segmenter/Segmenter#parameters)\n         *  with some or all options of `SegmenterOptions`.\n         *\n         * @returns [Intl.Segmenter](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/Segments) object.\n         *\n         * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/Segmenter).\n         */\n        new (locales?: LocalesArgument, options?: SegmenterOptions): Segmenter;\n\n        /**\n         * Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.\n         *\n         * @param locales - A string with a [BCP 47 language tag](http://tools.ietf.org/html/rfc5646), or an array of such strings.\n         *  For the general form and interpretation of the `locales` argument,\n         *  see the [`Intl` page](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_identification_and_negotiation).\n         *\n         * @param options An [object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/Segmenter/supportedLocalesOf#parameters).\n         *  with some or all possible options.\n         *\n         * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/Segmenter/supportedLocalesOf)\n         */\n        supportedLocalesOf(locales: LocalesArgument, options?: Pick<SegmenterOptions, \"localeMatcher\">): UnicodeBCP47LocaleIdentifier[];\n    };\n\n    /**\n     * Returns a sorted array of the supported collation, calendar, currency, numbering system, timezones, and units by the implementation.\n     * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/supportedValuesOf)\n     *\n     * @param key A string indicating the category of values to return.\n     * @returns A sorted array of the supported values.\n     */\n    function supportedValuesOf(key: \"calendar\" | \"collation\" | \"currency\" | \"numberingSystem\" | \"timeZone\" | \"unit\"): string[];\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2022.intl.d.ts",
        "start": 1,
        "end": 145,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 145,
          "column": 2,
          "position": 417
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2022.intl.d.ts",
        "start": 1,
        "end": 145,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 145,
          "column": 2,
          "position": 417
        }
      }
    },
    {
      "format": "typescript",
      "lines": 75,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\n/// <reference lib=\"es2021.promise\" />\n\ninterface ErrorOptions {\n    cause?: unknown;\n}\n\ninterface Error {\n    cause?: unknown;\n}\n\ninterface ErrorConstructor {\n    new (message?: string, options?: ErrorOptions): Error;\n    (message?: string, options?: ErrorOptions): Error;\n}\n\ninterface EvalErrorConstructor {\n    new (message?: string, options?: ErrorOptions): EvalError;\n    (message?: string, options?: ErrorOptions): EvalError;\n}\n\ninterface RangeErrorConstructor {\n    new (message?: string, options?: ErrorOptions): RangeError;\n    (message?: string, options?: ErrorOptions): RangeError;\n}\n\ninterface ReferenceErrorConstructor {\n    new (message?: string, options?: ErrorOptions): ReferenceError;\n    (message?: string, options?: ErrorOptions): ReferenceError;\n}\n\ninterface SyntaxErrorConstructor {\n    new (message?: string, options?: ErrorOptions): SyntaxError;\n    (message?: string, options?: ErrorOptions): SyntaxError;\n}\n\ninterface TypeErrorConstructor {\n    new (message?: string, options?: ErrorOptions): TypeError;\n    (message?: string, options?: ErrorOptions): TypeError;\n}\n\ninterface URIErrorConstructor {\n    new (message?: string, options?: ErrorOptions): URIError;\n    (message?: string, options?: ErrorOptions): URIError;\n}\n\ninterface AggregateErrorConstructor {\n    new (\n        errors: Iterable<any>,\n        message?: string,\n        options?: ErrorOptions,\n    ): AggregateError;\n    (\n        errors: Iterable<any>,\n        message?: string,\n        options?: ErrorOptions,\n    ): AggregateError;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2022.error.d.ts",
        "start": 1,
        "end": 75,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 75,
          "column": 2,
          "position": 481
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2022.error.d.ts",
        "start": 1,
        "end": 75,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 75,
          "column": 2,
          "position": 481
        }
      }
    },
    {
      "format": "typescript",
      "lines": 121,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\ninterface Array<T> {\n    /**\n     * Returns the item located at the specified index.\n     * @param index The zero-based index of the desired code unit. A negative index will count back from the last item.\n     */\n    at(index: number): T | undefined;\n}\n\ninterface ReadonlyArray<T> {\n    /**\n     * Returns the item located at the specified index.\n     * @param index The zero-based index of the desired code unit. A negative index will count back from the last item.\n     */\n    at(index: number): T | undefined;\n}\n\ninterface Int8Array<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Returns the item located at the specified index.\n     * @param index The zero-based index of the desired code unit. A negative index will count back from the last item.\n     */\n    at(index: number): number | undefined;\n}\n\ninterface Uint8Array<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Returns the item located at the specified index.\n     * @param index The zero-based index of the desired code unit. A negative index will count back from the last item.\n     */\n    at(index: number): number | undefined;\n}\n\ninterface Uint8ClampedArray<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Returns the item located at the specified index.\n     * @param index The zero-based index of the desired code unit. A negative index will count back from the last item.\n     */\n    at(index: number): number | undefined;\n}\n\ninterface Int16Array<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Returns the item located at the specified index.\n     * @param index The zero-based index of the desired code unit. A negative index will count back from the last item.\n     */\n    at(index: number): number | undefined;\n}\n\ninterface Uint16Array<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Returns the item located at the specified index.\n     * @param index The zero-based index of the desired code unit. A negative index will count back from the last item.\n     */\n    at(index: number): number | undefined;\n}\n\ninterface Int32Array<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Returns the item located at the specified index.\n     * @param index The zero-based index of the desired code unit. A negative index will count back from the last item.\n     */\n    at(index: number): number | undefined;\n}\n\ninterface Uint32Array<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Returns the item located at the specified index.\n     * @param index The zero-based index of the desired code unit. A negative index will count back from the last item.\n     */\n    at(index: number): number | undefined;\n}\n\ninterface Float32Array<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Returns the item located at the specified index.\n     * @param index The zero-based index of the desired code unit. A negative index will count back from the last item.\n     */\n    at(index: number): number | undefined;\n}\n\ninterface Float64Array<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Returns the item located at the specified index.\n     * @param index The zero-based index of the desired code unit. A negative index will count back from the last item.\n     */\n    at(index: number): number | undefined;\n}\n\ninterface BigInt64Array<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Returns the item located at the specified index.\n     * @param index The zero-based index of the desired code unit. A negative index will count back from the last item.\n     */\n    at(index: number): bigint | undefined;\n}\n\ninterface BigUint64Array<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Returns the item located at the specified index.\n     * @param index The zero-based index of the desired code unit. A negative index will count back from the last item.\n     */\n    at(index: number): bigint | undefined;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2022.array.d.ts",
        "start": 1,
        "end": 121,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 121,
          "column": 2,
          "position": 464
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2022.array.d.ts",
        "start": 1,
        "end": 121,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 121,
          "column": 2,
          "position": 464
        }
      }
    },
    {
      "format": "typescript",
      "lines": 78,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\n/// <reference lib=\"es2015.symbol.wellknown\" />\n\ninterface WeakRef<T extends WeakKey> {\n    readonly [Symbol.toStringTag]: \"WeakRef\";\n\n    /**\n     * Returns the WeakRef instance's target value, or undefined if the target value has been\n     * reclaimed.\n     * In es2023 the value can be either a symbol or an object, in previous versions only object is permissible.\n     */\n    deref(): T | undefined;\n}\n\ninterface WeakRefConstructor {\n    readonly prototype: WeakRef<any>;\n\n    /**\n     * Creates a WeakRef instance for the given target value.\n     * In es2023 the value can be either a symbol or an object, in previous versions only object is permissible.\n     * @param target The target value for the WeakRef instance.\n     */\n    new <T extends WeakKey>(target: T): WeakRef<T>;\n}\n\ndeclare var WeakRef: WeakRefConstructor;\n\ninterface FinalizationRegistry<T> {\n    readonly [Symbol.toStringTag]: \"FinalizationRegistry\";\n\n    /**\n     * Registers a value with the registry.\n     * In es2023 the value can be either a symbol or an object, in previous versions only object is permissible.\n     * @param target The target value to register.\n     * @param heldValue The value to pass to the finalizer for this value. This cannot be the\n     * target value.\n     * @param unregisterToken The token to pass to the unregister method to unregister the target\n     * value. If not provided, the target cannot be unregistered.\n     */\n    register(target: WeakKey, heldValue: T, unregisterToken?: WeakKey): void;\n\n    /**\n     * Unregisters a value from the registry.\n     * In es2023 the value can be either a symbol or an object, in previous versions only object is permissible.\n     * @param unregisterToken The token that was used as the unregisterToken argument when calling\n     * register to register the target value.\n     */\n    unregister(unregisterToken: WeakKey): boolean;\n}\n\ninterface FinalizationRegistryConstructor {\n    readonly prototype: FinalizationRegistry<any>;\n\n    /**\n     * Creates a finalization registry with an associated cleanup callback\n     * @param cleanupCallback The callback to call after a value in the registry has been reclaimed.\n     */\n    new <T>(cleanupCallback: (heldValue: T) => void): FinalizationRegistry<T>;\n}\n\ndeclare var FinalizationRegistry: FinalizationRegistryConstructor;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2021.weakref.d.ts",
        "start": 1,
        "end": 78,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 78,
          "column": 2,
          "position": 250
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2021.weakref.d.ts",
        "start": 1,
        "end": 78,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 78,
          "column": 2,
          "position": 250
        }
      }
    },
    {
      "format": "typescript",
      "lines": 33,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\ninterface String {\n    /**\n     * Replace all instances of a substring in a string, using a regular expression or search string.\n     * @param searchValue A string to search for.\n     * @param replaceValue A string containing the text to replace for every successful match of searchValue in this string.\n     */\n    replaceAll(searchValue: string | RegExp, replaceValue: string): string;\n\n    /**\n     * Replace all instances of a substring in a string, using a regular expression or search string.\n     * @param searchValue A string to search for.\n     * @param replacer A function that returns the replacement text.\n     */\n    replaceAll(searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2021.string.d.ts",
        "start": 1,
        "end": 33,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 33,
          "column": 2,
          "position": 84
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2021.string.d.ts",
        "start": 1,
        "end": 33,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 33,
          "column": 2,
          "position": 84
        }
      }
    },
    {
      "format": "typescript",
      "lines": 48,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\ninterface AggregateError extends Error {\n    errors: any[];\n}\n\ninterface AggregateErrorConstructor {\n    new (errors: Iterable<any>, message?: string): AggregateError;\n    (errors: Iterable<any>, message?: string): AggregateError;\n    readonly prototype: AggregateError;\n}\n\ndeclare var AggregateError: AggregateErrorConstructor;\n\n/**\n * Represents the completion of an asynchronous operation\n */\ninterface PromiseConstructor {\n    /**\n     * The any function returns a promise that is fulfilled by the first given promise to be fulfilled, or rejected with an AggregateError containing an array of rejection reasons if all of the given promises are rejected. It resolves all elements of the passed iterable to promises as it runs this algorithm.\n     * @param values An array or iterable of Promises.\n     * @returns A new Promise.\n     */\n    any<T extends readonly unknown[] | []>(values: T): Promise<Awaited<T[number]>>;\n\n    /**\n     * The any function returns a promise that is fulfilled by the first given promise to be fulfilled, or rejected with an AggregateError containing an array of rejection reasons if all of the given promises are rejected. It resolves all elements of the passed iterable to promises as it runs this algorithm.\n     * @param values An array or iterable of Promises.\n     * @returns A new Promise.\n     */\n    any<T>(values: Iterable<T | PromiseLike<T>>): Promise<Awaited<T>>;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2021.promise.d.ts",
        "start": 1,
        "end": 48,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 48,
          "column": 2,
          "position": 186
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2021.promise.d.ts",
        "start": 1,
        "end": 48,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 48,
          "column": 2,
          "position": 186
        }
      }
    },
    {
      "format": "typescript",
      "lines": 166,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\ndeclare namespace Intl {\n    interface DateTimeFormatPartTypesRegistry {\n        fractionalSecond: any;\n    }\n\n    interface DateTimeFormatOptions {\n        formatMatcher?: \"basic\" | \"best fit\" | \"best fit\" | undefined;\n        dateStyle?: \"full\" | \"long\" | \"medium\" | \"short\" | undefined;\n        timeStyle?: \"full\" | \"long\" | \"medium\" | \"short\" | undefined;\n        dayPeriod?: \"narrow\" | \"short\" | \"long\" | undefined;\n        fractionalSecondDigits?: 1 | 2 | 3 | undefined;\n    }\n\n    interface DateTimeRangeFormatPart extends DateTimeFormatPart {\n        source: \"startRange\" | \"endRange\" | \"shared\";\n    }\n\n    interface DateTimeFormat {\n        formatRange(startDate: Date | number | bigint, endDate: Date | number | bigint): string;\n        formatRangeToParts(startDate: Date | number | bigint, endDate: Date | number | bigint): DateTimeRangeFormatPart[];\n    }\n\n    interface ResolvedDateTimeFormatOptions {\n        formatMatcher?: \"basic\" | \"best fit\" | \"best fit\";\n        dateStyle?: \"full\" | \"long\" | \"medium\" | \"short\";\n        timeStyle?: \"full\" | \"long\" | \"medium\" | \"short\";\n        hourCycle?: \"h11\" | \"h12\" | \"h23\" | \"h24\";\n        dayPeriod?: \"narrow\" | \"short\" | \"long\";\n        fractionalSecondDigits?: 1 | 2 | 3;\n    }\n\n    /**\n     * The locale matching algorithm to use.\n     *\n     * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/ListFormat/ListFormat#parameters).\n     */\n    type ListFormatLocaleMatcher = \"lookup\" | \"best fit\";\n\n    /**\n     * The format of output message.\n     *\n     * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/ListFormat/ListFormat#parameters).\n     */\n    type ListFormatType = \"conjunction\" | \"disjunction\" | \"unit\";\n\n    /**\n     * The length of the formatted message.\n     *\n     * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/ListFormat/ListFormat#parameters).\n     */\n    type ListFormatStyle = \"long\" | \"short\" | \"narrow\";\n\n    /**\n     * An object with some or all properties of the `Intl.ListFormat` constructor `options` parameter.\n     *\n     * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/ListFormat/ListFormat#parameters).\n     */\n    interface ListFormatOptions {\n        /** The locale matching algorithm to use. For information about this option, see [Intl page](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_negotiation). */\n        localeMatcher?: ListFormatLocaleMatcher | undefined;\n        /** The format of output message. */\n        type?: ListFormatType | undefined;\n        /** The length of the internationalized message. */\n        style?: ListFormatStyle | undefined;\n    }\n\n    interface ResolvedListFormatOptions {\n        locale: string;\n        style: ListFormatStyle;\n        type: ListFormatType;\n    }\n\n    interface ListFormat {\n        /**\n         * Returns a string with a language-specific representation of the list.\n         *\n         * @param list - An iterable object, such as an [Array](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array).\n         *\n         * @throws `TypeError` if `list` includes something other than the possible values.\n         *\n         * @returns {string} A language-specific formatted string representing the elements of the list.\n         *\n         * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/ListFormat/format).\n         */\n        format(list: Iterable<string>): string;\n\n        /**\n         * Returns an Array of objects representing the different components that can be used to format a list of values in a locale-aware fashion.\n         *\n         * @param list - An iterable object, such as an [Array](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array), to be formatted according to a locale.\n         *\n         * @throws `TypeError` if `list` includes something other than the possible values.\n         *\n         * @returns {{ type: \"element\" | \"literal\", value: string; }[]} An Array of components which contains the formatted parts from the list.\n         *\n         * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/ListFormat/formatToParts).\n         */\n        formatToParts(list: Iterable<string>): { type: \"element\" | \"literal\"; value: string; }[];\n\n        /**\n         * Returns a new object with properties reflecting the locale and style\n         * formatting options computed during the construction of the current\n         * `Intl.ListFormat` object.\n         *\n         * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/ListFormat/resolvedOptions).\n         */\n        resolvedOptions(): ResolvedListFormatOptions;\n    }\n\n    const ListFormat: {\n        prototype: ListFormat;\n\n        /**\n         * Creates [Intl.ListFormat](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/ListFormat) objects that\n         * enable language-sensitive list formatting.\n         *\n         * @param locales - A string with a [BCP 47 language tag](http://tools.ietf.org/html/rfc5646), or an array of such strings.\n         *  For the general form and interpretation of the `locales` argument,\n         *  see the [`Intl` page](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_identification_and_negotiation).\n         *\n         * @param options - An [object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/ListFormat/ListFormat#parameters)\n         *  with some or all options of `ListFormatOptions`.\n         *\n         * @returns [Intl.ListFormatOptions](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/ListFormat) object.\n         *\n         * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/ListFormat).\n         */\n        new (locales?: LocalesArgument, options?: ListFormatOptions): ListFormat;\n\n        /**\n         * Returns an array containing those of the provided locales that are\n         * supported in list formatting without having to fall back to the runtime's default locale.\n         *\n         * @param locales - A string with a [BCP 47 language tag](http://tools.ietf.org/html/rfc5646), or an array of such strings.\n         *  For the general form and interpretation of the `locales` argument,\n         *  see the [`Intl` page](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_identification_and_negotiation).\n         *\n         * @param options - An [object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/ListFormat/supportedLocalesOf#parameters).\n         *  with some or all possible options.\n         *\n         * @returns An array of strings representing a subset of the given locale tags that are supported in list\n         *  formatting without having to fall back to the runtime's default locale.\n         *\n         * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/ListFormat/supportedLocalesOf).\n         */\n        supportedLocalesOf(locales: LocalesArgument, options?: Pick<ListFormatOptions, \"localeMatcher\">): UnicodeBCP47LocaleIdentifier[];\n    };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2021.intl.d.ts",
        "start": 1,
        "end": 166,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 166,
          "column": 2,
          "position": 697
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2021.intl.d.ts",
        "start": 1,
        "end": 166,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 166,
          "column": 2,
          "position": 697
        }
      }
    },
    {
      "format": "typescript",
      "lines": 41,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\n/// <reference lib=\"es2015.iterable\" />\n/// <reference lib=\"es2015.symbol\" />\n\ninterface SymbolConstructor {\n    /**\n     * A regular expression method that matches the regular expression against a string. Called\n     * by the String.prototype.matchAll method.\n     */\n    readonly matchAll: unique symbol;\n}\n\ninterface RegExpStringIterator<T> extends IteratorObject<T, BuiltinIteratorReturn, unknown> {\n    [Symbol.iterator](): RegExpStringIterator<T>;\n}\n\ninterface RegExp {\n    /**\n     * Matches a string with this regular expression, and returns an iterable of matches\n     * containing the results of that search.\n     * @param string A string to search within.\n     */\n    [Symbol.matchAll](str: string): RegExpStringIterator<RegExpMatchArray>;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2020.symbol.wellknown.d.ts",
        "start": 1,
        "end": 41,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 41,
          "column": 2,
          "position": 105
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2020.symbol.wellknown.d.ts",
        "start": 1,
        "end": 41,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 41,
          "column": 2,
          "position": 105
        }
      }
    },
    {
      "format": "typescript",
      "lines": 44,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\n/// <reference lib=\"es2015.iterable\" />\n/// <reference lib=\"es2020.intl\" />\n/// <reference lib=\"es2020.symbol.wellknown\" />\n\ninterface String {\n    /**\n     * Matches a string with a regular expression, and returns an iterable of matches\n     * containing the results of that search.\n     * @param regexp A variable name or string literal containing the regular expression pattern and flags.\n     */\n    matchAll(regexp: RegExp): RegExpStringIterator<RegExpExecArray>;\n\n    /** Converts all alphabetic characters to lowercase, taking into account the host environment's current locale. */\n    toLocaleLowerCase(locales?: Intl.LocalesArgument): string;\n\n    /** Returns a string where all alphabetic characters have been converted to uppercase, taking into account the host environment's current locale. */\n    toLocaleUpperCase(locales?: Intl.LocalesArgument): string;\n\n    /**\n     * Determines whether two strings are equivalent in the current or specified locale.\n     * @param that String to compare to target string\n     * @param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used. This parameter must conform to BCP 47 standards; see the Intl.Collator object for details.\n     * @param options An object that contains one or more properties that specify comparison options. see the Intl.Collator object for details.\n     */\n    localeCompare(that: string, locales?: Intl.LocalesArgument, options?: Intl.CollatorOptions): number;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2020.string.d.ts",
        "start": 1,
        "end": 44,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 44,
          "column": 2,
          "position": 114
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2020.string.d.ts",
        "start": 1,
        "end": 44,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 44,
          "column": 2,
          "position": 114
        }
      }
    },
    {
      "format": "typescript",
      "lines": 99,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\n/// <reference lib=\"es2020.bigint\" />\n\ninterface Atomics {\n    /**\n     * Adds a value to the value at the given position in the array, returning the original value.\n     * Until this atomic operation completes, any other read or write operation against the array\n     * will block.\n     */\n    add(typedArray: BigInt64Array<ArrayBufferLike> | BigUint64Array<ArrayBufferLike>, index: number, value: bigint): bigint;\n\n    /**\n     * Stores the bitwise AND of a value with the value at the given position in the array,\n     * returning the original value. Until this atomic operation completes, any other read or\n     * write operation against the array will block.\n     */\n    and(typedArray: BigInt64Array<ArrayBufferLike> | BigUint64Array<ArrayBufferLike>, index: number, value: bigint): bigint;\n\n    /**\n     * Replaces the value at the given position in the array if the original value equals the given\n     * expected value, returning the original value. Until this atomic operation completes, any\n     * other read or write operation against the array will block.\n     */\n    compareExchange(typedArray: BigInt64Array<ArrayBufferLike> | BigUint64Array<ArrayBufferLike>, index: number, expectedValue: bigint, replacementValue: bigint): bigint;\n\n    /**\n     * Replaces the value at the given position in the array, returning the original value. Until\n     * this atomic operation completes, any other read or write operation against the array will\n     * block.\n     */\n    exchange(typedArray: BigInt64Array<ArrayBufferLike> | BigUint64Array<ArrayBufferLike>, index: number, value: bigint): bigint;\n\n    /**\n     * Returns the value at the given position in the array. Until this atomic operation completes,\n     * any other read or write operation against the array will block.\n     */\n    load(typedArray: BigInt64Array<ArrayBufferLike> | BigUint64Array<ArrayBufferLike>, index: number): bigint;\n\n    /**\n     * Stores the bitwise OR of a value with the value at the given position in the array,\n     * returning the original value. Until this atomic operation completes, any other read or write\n     * operation against the array will block.\n     */\n    or(typedArray: BigInt64Array<ArrayBufferLike> | BigUint64Array<ArrayBufferLike>, index: number, value: bigint): bigint;\n\n    /**\n     * Stores a value at the given position in the array, returning the new value. Until this\n     * atomic operation completes, any other read or write operation against the array will block.\n     */\n    store(typedArray: BigInt64Array<ArrayBufferLike> | BigUint64Array<ArrayBufferLike>, index: number, value: bigint): bigint;\n\n    /**\n     * Subtracts a value from the value at the given position in the array, returning the original\n     * value. Until this atomic operation completes, any other read or write operation against the\n     * array will block.\n     */\n    sub(typedArray: BigInt64Array<ArrayBufferLike> | BigUint64Array<ArrayBufferLike>, index: number, value: bigint): bigint;\n\n    /**\n     * If the value at the given position in the array is equal to the provided value, the current\n     * agent is put to sleep causing execution to suspend until the timeout expires (returning\n     * `\"timed-out\"`) or until the agent is awoken (returning `\"ok\"`); otherwise, returns\n     * `\"not-equal\"`.\n     */\n    wait(typedArray: BigInt64Array<ArrayBufferLike>, index: number, value: bigint, timeout?: number): \"ok\" | \"not-equal\" | \"timed-out\";\n\n    /**\n     * Wakes up sleeping agents that are waiting on the given index of the array, returning the\n     * number of agents that were awoken.\n     * @param typedArray A shared BigInt64Array.\n     * @param index The position in the typedArray to wake up on.\n     * @param count The number of sleeping agents to notify. Defaults to +Infinity.\n     */\n    notify(typedArray: BigInt64Array<ArrayBufferLike>, index: number, count?: number): number;\n\n    /**\n     * Stores the bitwise XOR of a value with the value at the given position in the array,\n     * returning the original value. Until this atomic operation completes, any other read or write\n     * operation against the array will block.\n     */\n    xor(typedArray: BigInt64Array<ArrayBufferLike> | BigUint64Array<ArrayBufferLike>, index: number, value: bigint): bigint;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2020.sharedmemory.d.ts",
        "start": 1,
        "end": 99,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 99,
          "column": 2,
          "position": 446
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2020.sharedmemory.d.ts",
        "start": 1,
        "end": 99,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 99,
          "column": 2,
          "position": 446
        }
      }
    },
    {
      "format": "typescript",
      "lines": 47,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\ninterface PromiseFulfilledResult<T> {\n    status: \"fulfilled\";\n    value: T;\n}\n\ninterface PromiseRejectedResult {\n    status: \"rejected\";\n    reason: any;\n}\n\ntype PromiseSettledResult<T> = PromiseFulfilledResult<T> | PromiseRejectedResult;\n\ninterface PromiseConstructor {\n    /**\n     * Creates a Promise that is resolved with an array of results when all\n     * of the provided Promises resolve or reject.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    allSettled<T extends readonly unknown[] | []>(values: T): Promise<{ -readonly [P in keyof T]: PromiseSettledResult<Awaited<T[P]>>; }>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all\n     * of the provided Promises resolve or reject.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    allSettled<T>(values: Iterable<T | PromiseLike<T>>): Promise<PromiseSettledResult<Awaited<T>>[]>;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2020.promise.d.ts",
        "start": 1,
        "end": 47,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 47,
          "column": 2,
          "position": 183
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2020.promise.d.ts",
        "start": 1,
        "end": 47,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 47,
          "column": 2,
          "position": 183
        }
      }
    },
    {
      "format": "typescript",
      "lines": 474,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\n/// <reference lib=\"es2018.intl\" />\ndeclare namespace Intl {\n    /**\n     * A string that is a valid [Unicode BCP 47 Locale Identifier](https://unicode.org/reports/tr35/#Unicode_locale_identifier).\n     *\n     * For example: \"fa\", \"es-MX\", \"zh-Hant-TW\".\n     *\n     * See [MDN - Intl - locales argument](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl#locales_argument).\n     */\n    type UnicodeBCP47LocaleIdentifier = string;\n\n    /**\n     * Unit to use in the relative time internationalized message.\n     *\n     * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/RelativeTimeFormat/format#Parameters).\n     */\n    type RelativeTimeFormatUnit =\n        | \"year\"\n        | \"years\"\n        | \"quarter\"\n        | \"quarters\"\n        | \"month\"\n        | \"months\"\n        | \"week\"\n        | \"weeks\"\n        | \"day\"\n        | \"days\"\n        | \"hour\"\n        | \"hours\"\n        | \"minute\"\n        | \"minutes\"\n        | \"second\"\n        | \"seconds\";\n\n    /**\n     * Value of the `unit` property in objects returned by\n     * `Intl.RelativeTimeFormat.prototype.formatToParts()`. `formatToParts` and\n     * `format` methods accept either singular or plural unit names as input,\n     * but `formatToParts` only outputs singular (e.g. \"day\") not plural (e.g.\n     * \"days\").\n     *\n     * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/RelativeTimeFormat/formatToParts#Using_formatToParts).\n     */\n    type RelativeTimeFormatUnitSingular =\n        | \"year\"\n        | \"quarter\"\n        | \"month\"\n        | \"week\"\n        | \"day\"\n        | \"hour\"\n        | \"minute\"\n        | \"second\";\n\n    /**\n     * The locale matching algorithm to use.\n     *\n     * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_negotiation).\n     */\n    type RelativeTimeFormatLocaleMatcher = \"lookup\" | \"best fit\";\n\n    /**\n     * The format of output message.\n     *\n     * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/RelativeTimeFormat/RelativeTimeFormat#Parameters).\n     */\n    type RelativeTimeFormatNumeric = \"always\" | \"auto\";\n\n    /**\n     * The length of the internationalized message.\n     *\n     * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/RelativeTimeFormat/RelativeTimeFormat#Parameters).\n     */\n    type RelativeTimeFormatStyle = \"long\" | \"short\" | \"narrow\";\n\n    /**\n     * The locale or locales to use\n     *\n     * See [MDN - Intl - locales argument](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl#locales_argument).\n     */\n    type LocalesArgument = UnicodeBCP47LocaleIdentifier | Locale | readonly (UnicodeBCP47LocaleIdentifier | Locale)[] | undefined;\n\n    /**\n     * An object with some or all of properties of `options` parameter\n     * of `Intl.RelativeTimeFormat` constructor.\n     *\n     * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/RelativeTimeFormat/RelativeTimeFormat#Parameters).\n     */\n    interface RelativeTimeFormatOptions {\n        /** The locale matching algorithm to use. For information about this option, see [Intl page](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_negotiation). */\n        localeMatcher?: RelativeTimeFormatLocaleMatcher;\n        /** The format of output message. */\n        numeric?: RelativeTimeFormatNumeric;\n        /** The length of the internationalized message. */\n        style?: RelativeTimeFormatStyle;\n    }\n\n    /**\n     * An object with properties reflecting the locale\n     * and formatting options computed during initialization\n     * of the `Intl.RelativeTimeFormat` object\n     *\n     * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/RelativeTimeFormat/resolvedOptions#Description).\n     */\n    interface ResolvedRelativeTimeFormatOptions {\n        locale: UnicodeBCP47LocaleIdentifier;\n        style: RelativeTimeFormatStyle;\n        numeric: RelativeTimeFormatNumeric;\n        numberingSystem: string;\n    }\n\n    /**\n     * An object representing the relative time format in parts\n     * that can be used for custom locale-aware formatting.\n     *\n     * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/RelativeTimeFormat/formatToParts#Using_formatToParts).\n     */\n    type RelativeTimeFormatPart =\n        | {\n            type: \"literal\";\n            value: string;\n        }\n        | {\n            type: Exclude<NumberFormatPartTypes, \"literal\">;\n            value: string;\n            unit: RelativeTimeFormatUnitSingular;\n        };\n\n    interface RelativeTimeFormat {\n        /**\n         * Formats a value and a unit according to the locale\n         * and formatting options of the given\n         * [`Intl.RelativeTimeFormat`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/RelativeTimeFormat)\n         * object.\n         *\n         * While this method automatically provides the correct plural forms,\n         * the grammatical form is otherwise as neutral as possible.\n         *\n         * It is the caller's responsibility to handle cut-off logic\n         * such as deciding between displaying \"in 7 days\" or \"in 1 week\".\n         * This API does not support relative dates involving compound units.\n         * e.g \"in 5 days and 4 hours\".\n         *\n         * @param value -  Numeric value to use in the internationalized relative time message\n         *\n         * @param unit - [Unit](https://tc39.es/ecma402/#sec-singularrelativetimeunit) to use in the relative time internationalized message.\n         *\n         * @throws `RangeError` if `unit` was given something other than `unit` possible values\n         *\n         * @returns {string} Internationalized relative time message as string\n         *\n         * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/RelativeTimeFormat/format).\n         */\n        format(value: number, unit: RelativeTimeFormatUnit): string;\n\n        /**\n         *  Returns an array of objects representing the relative time format in parts that can be used for custom locale-aware formatting.\n         *\n         *  @param value - Numeric value to use in the internationalized relative time message\n         *\n         *  @param unit - [Unit](https://tc39.es/ecma402/#sec-singularrelativetimeunit) to use in the relative time internationalized message.\n         *\n         *  @throws `RangeError` if `unit` was given something other than `unit` possible values\n         *\n         *  [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/RelativeTimeFormat/formatToParts).\n         */\n        formatToParts(value: number, unit: RelativeTimeFormatUnit): RelativeTimeFormatPart[];\n\n        /**\n         * Provides access to the locale and options computed during initialization of this `Intl.RelativeTimeFormat` object.\n         *\n         * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/RelativeTimeFormat/resolvedOptions).\n         */\n        resolvedOptions(): ResolvedRelativeTimeFormatOptions;\n    }\n\n    /**\n     * The [`Intl.RelativeTimeFormat`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/RelativeTimeFormat)\n     * object is a constructor for objects that enable language-sensitive relative time formatting.\n     *\n     * [Compatibility](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/RelativeTimeFormat#Browser_compatibility).\n     */\n    const RelativeTimeFormat: {\n        /**\n         * Creates [Intl.RelativeTimeFormat](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/RelativeTimeFormat) objects\n         *\n         * @param locales - A string with a [BCP 47 language tag](http://tools.ietf.org/html/rfc5646), or an array of such strings.\n         *  For the general form and interpretation of the locales argument,\n         *  see the [`Intl` page](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_identification_and_negotiation).\n         *\n         * @param options - An [object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/RelativeTimeFormat/RelativeTimeFormat#Parameters)\n         *  with some or all of options of `RelativeTimeFormatOptions`.\n         *\n         * @returns [Intl.RelativeTimeFormat](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/RelativeTimeFormat) object.\n         *\n         * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/RelativeTimeFormat/RelativeTimeFormat).\n         */\n        new (\n            locales?: LocalesArgument,\n            options?: RelativeTimeFormatOptions,\n        ): RelativeTimeFormat;\n\n        /**\n         * Returns an array containing those of the provided locales\n         * that are supported in date and time formatting\n         * without having to fall back to the runtime's default locale.\n         *\n         * @param locales - A string with a [BCP 47 language tag](http://tools.ietf.org/html/rfc5646), or an array of such strings.\n         *  For the general form and interpretation of the locales argument,\n         *  see the [`Intl` page](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_identification_and_negotiation).\n         *\n         * @param options - An [object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/RelativeTimeFormat/RelativeTimeFormat#Parameters)\n         *  with some or all of options of the formatting.\n         *\n         * @returns An array containing those of the provided locales\n         *  that are supported in date and time formatting\n         *  without having to fall back to the runtime's default locale.\n         *\n         * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/RelativeTimeFormat/supportedLocalesOf).\n         */\n        supportedLocalesOf(\n            locales?: LocalesArgument,\n            options?: RelativeTimeFormatOptions,\n        ): UnicodeBCP47LocaleIdentifier[];\n    };\n\n    interface NumberFormatOptionsStyleRegistry {\n        unit: never;\n    }\n\n    interface NumberFormatOptionsCurrencyDisplayRegistry {\n        narrowSymbol: never;\n    }\n\n    interface NumberFormatOptionsSignDisplayRegistry {\n        auto: never;\n        never: never;\n        always: never;\n        exceptZero: never;\n    }\n\n    type NumberFormatOptionsSignDisplay = keyof NumberFormatOptionsSignDisplayRegistry;\n\n    interface NumberFormatOptions {\n        numberingSystem?: string | undefined;\n        compactDisplay?: \"short\" | \"long\" | undefined;\n        notation?: \"standard\" | \"scientific\" | \"engineering\" | \"compact\" | undefined;\n        signDisplay?: NumberFormatOptionsSignDisplay | undefined;\n        unit?: string | undefined;\n        unitDisplay?: \"short\" | \"long\" | \"narrow\" | undefined;\n        currencySign?: \"standard\" | \"accounting\" | undefined;\n    }\n\n    interface ResolvedNumberFormatOptions {\n        compactDisplay?: \"short\" | \"long\";\n        notation: \"standard\" | \"scientific\" | \"engineering\" | \"compact\";\n        signDisplay: NumberFormatOptionsSignDisplay;\n        unit?: string;\n        unitDisplay?: \"short\" | \"long\" | \"narrow\";\n        currencySign?: \"standard\" | \"accounting\";\n    }\n\n    interface NumberFormatPartTypeRegistry {\n        compact: never;\n        exponentInteger: never;\n        exponentMinusSign: never;\n        exponentSeparator: never;\n        unit: never;\n        unknown: never;\n    }\n\n    interface DateTimeFormatOptions {\n        calendar?: string | undefined;\n        dayPeriod?: \"narrow\" | \"short\" | \"long\" | undefined;\n        numberingSystem?: string | undefined;\n\n        dateStyle?: \"full\" | \"long\" | \"medium\" | \"short\" | undefined;\n        timeStyle?: \"full\" | \"long\" | \"medium\" | \"short\" | undefined;\n        hourCycle?: \"h11\" | \"h12\" | \"h23\" | \"h24\" | undefined;\n    }\n\n    type LocaleHourCycleKey = \"h12\" | \"h23\" | \"h11\" | \"h24\";\n    type LocaleCollationCaseFirst = \"upper\" | \"lower\" | \"false\";\n\n    interface LocaleOptions {\n        /** A string containing the language, and the script and region if available. */\n        baseName?: string;\n        /** The part of the Locale that indicates the locale's calendar era. */\n        calendar?: string;\n        /** Flag that defines whether case is taken into account for the locale's collation rules. */\n        caseFirst?: LocaleCollationCaseFirst;\n        /** The collation type used for sorting */\n        collation?: string;\n        /** The time keeping format convention used by the locale. */\n        hourCycle?: LocaleHourCycleKey;\n        /** The primary language subtag associated with the locale. */\n        language?: string;\n        /** The numeral system used by the locale. */\n        numberingSystem?: string;\n        /** Flag that defines whether the locale has special collation handling for numeric characters. */\n        numeric?: boolean;\n        /** The region of the world (usually a country) associated with the locale. Possible values are region codes as defined by ISO 3166-1. */\n        region?: string;\n        /** The script used for writing the particular language used in the locale. Possible values are script codes as defined by ISO 15924. */\n        script?: string;\n    }\n\n    interface Locale extends LocaleOptions {\n        /** A string containing the language, and the script and region if available. */\n        baseName: string;\n        /** The primary language subtag associated with the locale. */\n        language: string;\n        /** Gets the most likely values for the language, script, and region of the locale based on existing values. */\n        maximize(): Locale;\n        /** Attempts to remove information about the locale that would be added by calling `Locale.maximize()`. */\n        minimize(): Locale;\n        /** Returns the locale's full locale identifier string. */\n        toString(): UnicodeBCP47LocaleIdentifier;\n    }\n\n    /**\n     * Constructor creates [Intl.Locale](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/Locale)\n     * objects\n     *\n     * @param tag - A string with a [BCP 47 language tag](http://tools.ietf.org/html/rfc5646).\n     *  For the general form and interpretation of the locales argument,\n     *  see the [`Intl` page](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_identification_and_negotiation).\n     *\n     * @param options - An [object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/Locale/Locale#Parameters) with some or all of options of the locale.\n     *\n     * @returns [Intl.Locale](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/Locale) object.\n     *\n     * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/Locale).\n     */\n    const Locale: {\n        new (tag: UnicodeBCP47LocaleIdentifier | Locale, options?: LocaleOptions): Locale;\n    };\n\n    type DisplayNamesFallback =\n        | \"code\"\n        | \"none\";\n\n    type DisplayNamesType =\n        | \"language\"\n        | \"region\"\n        | \"script\"\n        | \"calendar\"\n        | \"dateTimeField\"\n        | \"currency\";\n\n    type DisplayNamesLanguageDisplay =\n        | \"dialect\"\n        | \"standard\";\n\n    interface DisplayNamesOptions {\n        localeMatcher?: RelativeTimeFormatLocaleMatcher;\n        style?: RelativeTimeFormatStyle;\n        type: DisplayNamesType;\n        languageDisplay?: DisplayNamesLanguageDisplay;\n        fallback?: DisplayNamesFallback;\n    }\n\n    interface ResolvedDisplayNamesOptions {\n        locale: UnicodeBCP47LocaleIdentifier;\n        style: RelativeTimeFormatStyle;\n        type: DisplayNamesType;\n        fallback: DisplayNamesFallback;\n        languageDisplay?: DisplayNamesLanguageDisplay;\n    }\n\n    interface DisplayNames {\n        /**\n         * Receives a code and returns a string based on the locale and options provided when instantiating\n         * [`Intl.DisplayNames()`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/DisplayNames)\n         *\n         * @param code The `code` to provide depends on the `type` passed to display name during creation:\n         *  - If the type is `\"region\"`, code should be either an [ISO-3166 two letters region code](https://www.iso.org/iso-3166-country-codes.html),\n         *    or a [three digits UN M49 Geographic Regions](https://unstats.un.org/unsd/methodology/m49/).\n         *  - If the type is `\"script\"`, code should be an [ISO-15924 four letters script code](https://unicode.org/iso15924/iso15924-codes.html).\n         *  - If the type is `\"language\"`, code should be a `languageCode` [\"-\" `scriptCode`] [\"-\" `regionCode` ] *(\"-\" `variant` )\n         *    subsequence of the unicode_language_id grammar in [UTS 35's Unicode Language and Locale Identifiers grammar](https://unicode.org/reports/tr35/#Unicode_language_identifier).\n         *    `languageCode` is either a two letters ISO 639-1 language code or a three letters ISO 639-2 language code.\n         *  - If the type is `\"currency\"`, code should be a [3-letter ISO 4217 currency code](https://www.iso.org/iso-4217-currency-codes.html).\n         *\n         * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/DisplayNames/of).\n         */\n        of(code: string): string | undefined;\n        /**\n         * Returns a new object with properties reflecting the locale and style formatting options computed during the construction of the current\n         * [`Intl/DisplayNames`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/DisplayNames) object.\n         *\n         * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/DisplayNames/resolvedOptions).\n         */\n        resolvedOptions(): ResolvedDisplayNamesOptions;\n    }\n\n    /**\n     * The [`Intl.DisplayNames()`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/DisplayNames)\n     * object enables the consistent translation of language, region and script display names.\n     *\n     * [Compatibility](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/DisplayNames#browser_compatibility).\n     */\n    const DisplayNames: {\n        prototype: DisplayNames;\n\n        /**\n         * @param locales A string with a BCP 47 language tag, or an array of such strings.\n         *   For the general form and interpretation of the `locales` argument, see the [Intl](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl#locale_identification_and_negotiation)\n         *   page.\n         *\n         * @param options An object for setting up a display name.\n         *\n         * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/DisplayNames/DisplayNames).\n         */\n        new (locales: LocalesArgument, options: DisplayNamesOptions): DisplayNames;\n\n        /**\n         * Returns an array containing those of the provided locales that are supported in display names without having to fall back to the runtime's default locale.\n         *\n         * @param locales A string with a BCP 47 language tag, or an array of such strings.\n         *   For the general form and interpretation of the `locales` argument, see the [Intl](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl#locale_identification_and_negotiation)\n         *   page.\n         *\n         * @param options An object with a locale matcher.\n         *\n         * @returns An array of strings representing a subset of the given locale tags that are supported in display names without having to fall back to the runtime's default locale.\n         *\n         * [MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/DisplayNames/supportedLocalesOf).\n         */\n        supportedLocalesOf(locales?: LocalesArgument, options?: { localeMatcher?: RelativeTimeFormatLocaleMatcher; }): UnicodeBCP47LocaleIdentifier[];\n    };\n\n    interface CollatorConstructor {\n        new (locales?: LocalesArgument, options?: CollatorOptions): Collator;\n        (locales?: LocalesArgument, options?: CollatorOptions): Collator;\n        supportedLocalesOf(locales: LocalesArgument, options?: CollatorOptions): string[];\n    }\n\n    interface DateTimeFormatConstructor {\n        new (locales?: LocalesArgument, options?: DateTimeFormatOptions): DateTimeFormat;\n        (locales?: LocalesArgument, options?: DateTimeFormatOptions): DateTimeFormat;\n        supportedLocalesOf(locales: LocalesArgument, options?: DateTimeFormatOptions): string[];\n    }\n\n    interface NumberFormatConstructor {\n        new (locales?: LocalesArgument, options?: NumberFormatOptions): NumberFormat;\n        (locales?: LocalesArgument, options?: NumberFormatOptions): NumberFormat;\n        supportedLocalesOf(locales: LocalesArgument, options?: NumberFormatOptions): string[];\n    }\n\n    interface PluralRulesConstructor {\n        new (locales?: LocalesArgument, options?: PluralRulesOptions): PluralRules;\n        (locales?: LocalesArgument, options?: PluralRulesOptions): PluralRules;\n\n        supportedLocalesOf(locales: LocalesArgument, options?: { localeMatcher?: \"lookup\" | \"best fit\"; }): string[];\n    }\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2020.intl.d.ts",
        "start": 1,
        "end": 474,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 474,
          "column": 2,
          "position": 1942
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2020.intl.d.ts",
        "start": 1,
        "end": 474,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 474,
          "column": 2,
          "position": 1942
        }
      }
    },
    {
      "format": "typescript",
      "lines": 42,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\n/// <reference lib=\"es2020.intl\" />\n\ninterface Date {\n    /**\n     * Converts a date and time to a string by using the current or specified locale.\n     * @param locales A locale string, array of locale strings, Intl.Locale object, or array of Intl.Locale objects that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n     * @param options An object that contains one or more properties that specify comparison options.\n     */\n    toLocaleString(locales?: Intl.LocalesArgument, options?: Intl.DateTimeFormatOptions): string;\n\n    /**\n     * Converts a date to a string by using the current or specified locale.\n     * @param locales A locale string, array of locale strings, Intl.Locale object, or array of Intl.Locale objects that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n     * @param options An object that contains one or more properties that specify comparison options.\n     */\n    toLocaleDateString(locales?: Intl.LocalesArgument, options?: Intl.DateTimeFormatOptions): string;\n\n    /**\n     * Converts a time to a string by using the current or specified locale.\n     * @param locales A locale string, array of locale strings, Intl.Locale object, or array of Intl.Locale objects that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n     * @param options An object that contains one or more properties that specify comparison options.\n     */\n    toLocaleTimeString(locales?: Intl.LocalesArgument, options?: Intl.DateTimeFormatOptions): string;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2020.date.d.ts",
        "start": 1,
        "end": 42,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 42,
          "column": 2,
          "position": 102
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2020.date.d.ts",
        "start": 1,
        "end": 42,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 42,
          "column": 2,
          "position": 102
        }
      }
    },
    {
      "format": "typescript",
      "lines": 765,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\n/// <reference lib=\"es2020.intl\" />\n\ninterface BigIntToLocaleStringOptions {\n    /**\n     * The locale matching algorithm to use.The default is \"best fit\". For information about this option, see the {@link https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_negotiation Intl page}.\n     */\n    localeMatcher?: string;\n    /**\n     * The formatting style to use , the default is \"decimal\".\n     */\n    style?: string;\n\n    numberingSystem?: string;\n    /**\n     * The unit to use in unit formatting, Possible values are core unit identifiers, defined in UTS #35, Part 2, Section 6. A subset of units from the full list was selected for use in ECMAScript. Pairs of simple units can be concatenated with \"-per-\" to make a compound unit. There is no default value; if the style is \"unit\", the unit property must be provided.\n     */\n    unit?: string;\n\n    /**\n     * The unit formatting style to use in unit formatting, the defaults is \"short\".\n     */\n    unitDisplay?: string;\n\n    /**\n     * The currency to use in currency formatting. Possible values are the ISO 4217 currency codes, such as \"USD\" for the US dollar, \"EUR\" for the euro, or \"CNY\" for the Chinese RMB  see the Current currency & funds code list. There is no default value; if the style is \"currency\", the currency property must be provided. It is only used when [[Style]] has the value \"currency\".\n     */\n    currency?: string;\n\n    /**\n     * How to display the currency in currency formatting. It is only used when [[Style]] has the value \"currency\". The default is \"symbol\".\n     *\n     * \"symbol\" to use a localized currency symbol such as ,\n     *\n     * \"code\" to use the ISO currency code,\n     *\n     * \"name\" to use a localized currency name such as \"dollar\"\n     */\n    currencyDisplay?: string;\n\n    /**\n     * Whether to use grouping separators, such as thousands separators or thousand/lakh/crore separators. The default is true.\n     */\n    useGrouping?: boolean;\n\n    /**\n     * The minimum number of integer digits to use. Possible values are from 1 to 21; the default is 1.\n     */\n    minimumIntegerDigits?: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21;\n\n    /**\n     * The minimum number of fraction digits to use. Possible values are from 0 to 20; the default for plain number and percent formatting is 0; the default for currency formatting is the number of minor unit digits provided by the {@link http://www.currency-iso.org/en/home/tables/table-a1.html ISO 4217 currency codes list} (2 if the list doesn't provide that information).\n     */\n    minimumFractionDigits?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20;\n\n    /**\n     * The maximum number of fraction digits to use. Possible values are from 0 to 20; the default for plain number formatting is the larger of minimumFractionDigits and 3; the default for currency formatting is the larger of minimumFractionDigits and the number of minor unit digits provided by the {@link http://www.currency-iso.org/en/home/tables/table-a1.html ISO 4217 currency codes list} (2 if the list doesn't provide that information); the default for percent formatting is the larger of minimumFractionDigits and 0.\n     */\n    maximumFractionDigits?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20;\n\n    /**\n     * The minimum number of significant digits to use. Possible values are from 1 to 21; the default is 1.\n     */\n    minimumSignificantDigits?: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21;\n\n    /**\n     * The maximum number of significant digits to use. Possible values are from 1 to 21; the default is 21.\n     */\n    maximumSignificantDigits?: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21;\n\n    /**\n     * The formatting that should be displayed for the number, the defaults is \"standard\"\n     *\n     *     \"standard\" plain number formatting\n     *\n     *     \"scientific\" return the order-of-magnitude for formatted number.\n     *\n     *     \"engineering\" return the exponent of ten when divisible by three\n     *\n     *     \"compact\" string representing exponent, defaults is using the \"short\" form\n     */\n    notation?: string;\n\n    /**\n     * used only when notation is \"compact\"\n     */\n    compactDisplay?: string;\n}\n\ninterface BigInt {\n    /**\n     * Returns a string representation of an object.\n     * @param radix Specifies a radix for converting numeric values to strings.\n     */\n    toString(radix?: number): string;\n\n    /** Returns a string representation appropriate to the host environment's current locale. */\n    toLocaleString(locales?: Intl.LocalesArgument, options?: BigIntToLocaleStringOptions): string;\n\n    /** Returns the primitive value of the specified object. */\n    valueOf(): bigint;\n\n    readonly [Symbol.toStringTag]: \"BigInt\";\n}\n\ninterface BigIntConstructor {\n    (value: bigint | boolean | number | string): bigint;\n    readonly prototype: BigInt;\n\n    /**\n     * Interprets the low bits of a BigInt as a 2's-complement signed integer.\n     * All higher bits are discarded.\n     * @param bits The number of low bits to use\n     * @param int The BigInt whose bits to extract\n     */\n    asIntN(bits: number, int: bigint): bigint;\n    /**\n     * Interprets the low bits of a BigInt as an unsigned integer.\n     * All higher bits are discarded.\n     * @param bits The number of low bits to use\n     * @param int The BigInt whose bits to extract\n     */\n    asUintN(bits: number, int: bigint): bigint;\n}\n\ndeclare var BigInt: BigIntConstructor;\n\n/**\n * A typed array of 64-bit signed integer values. The contents are initialized to 0. If the\n * requested number of bytes could not be allocated, an exception is raised.\n */\ninterface BigInt64Array<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike> {\n    /** The size in bytes of each element in the array. */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /** The ArrayBuffer instance referenced by the array. */\n    readonly buffer: TArrayBuffer;\n\n    /** The length in bytes of the array. */\n    readonly byteLength: number;\n\n    /** The offset in bytes of the array. */\n    readonly byteOffset: number;\n\n    /**\n     * Returns the this object after copying a section of the array identified by start and end\n     * to the same array starting at position target\n     * @param target If target is negative, it is treated as length+target where length is the\n     * length of the array.\n     * @param start If start is negative, it is treated as length+start. If end is negative, it\n     * is treated as length+end.\n     * @param end If not specified, length of the this object is used as its default value.\n     */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /** Yields index, value pairs for every entry in the array. */\n    entries(): ArrayIterator<[number, bigint]>;\n\n    /**\n     * Determines whether all the members of an array satisfy the specified test.\n     * @param predicate A function that accepts up to three arguments. The every method calls\n     * the predicate function for each element in the array until the predicate returns false,\n     * or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    every(predicate: (value: bigint, index: number, array: BigInt64Array<TArrayBuffer>) => boolean, thisArg?: any): boolean;\n\n    /**\n     * Changes all array elements from `start` to `end` index to a static `value` and returns the modified array\n     * @param value value to fill array section with\n     * @param start index to start filling the array at. If start is negative, it is treated as\n     * length+start where length is the length of the array.\n     * @param end index to stop filling the array at. If end is negative, it is treated as\n     * length+end.\n     */\n    fill(value: bigint, start?: number, end?: number): this;\n\n    /**\n     * Returns the elements of an array that meet the condition specified in a callback function.\n     * @param predicate A function that accepts up to three arguments. The filter method calls\n     * the predicate function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    filter(predicate: (value: bigint, index: number, array: BigInt64Array<TArrayBuffer>) => any, thisArg?: any): BigInt64Array<ArrayBuffer>;\n\n    /**\n     * Returns the value of the first element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found, find\n     * immediately returns that element value. Otherwise, find returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    find(predicate: (value: bigint, index: number, array: BigInt64Array<TArrayBuffer>) => boolean, thisArg?: any): bigint | undefined;\n\n    /**\n     * Returns the index of the first element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findIndex(predicate: (value: bigint, index: number, array: BigInt64Array<TArrayBuffer>) => boolean, thisArg?: any): number;\n\n    /**\n     * Performs the specified action for each element in an array.\n     * @param callbackfn A function that accepts up to three arguments. forEach calls the\n     * callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    forEach(callbackfn: (value: bigint, index: number, array: BigInt64Array<TArrayBuffer>) => void, thisArg?: any): void;\n\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: bigint, fromIndex?: number): boolean;\n\n    /**\n     * Returns the index of the first occurrence of a value in an array.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n     * search starts at index 0.\n     */\n    indexOf(searchElement: bigint, fromIndex?: number): number;\n\n    /**\n     * Adds all the elements of an array separated by the specified separator string.\n     * @param separator A string used to separate one element of an array from the next in the\n     * resulting String. If omitted, the array elements are separated with a comma.\n     */\n    join(separator?: string): string;\n\n    /** Yields each index in the array. */\n    keys(): ArrayIterator<number>;\n\n    /**\n     * Returns the index of the last occurrence of a value in an array.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n     * search starts at index 0.\n     */\n    lastIndexOf(searchElement: bigint, fromIndex?: number): number;\n\n    /** The length of the array. */\n    readonly length: number;\n\n    /**\n     * Calls a defined callback function on each element of an array, and returns an array that\n     * contains the results.\n     * @param callbackfn A function that accepts up to three arguments. The map method calls the\n     * callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    map(callbackfn: (value: bigint, index: number, array: BigInt64Array<TArrayBuffer>) => bigint, thisArg?: any): BigInt64Array<ArrayBuffer>;\n\n    /**\n     * Calls the specified callback function for all the elements in an array. The return value of\n     * the callback function is the accumulated result, and is provided as an argument in the next\n     * call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n     * callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduce(callbackfn: (previousValue: bigint, currentValue: bigint, currentIndex: number, array: BigInt64Array<TArrayBuffer>) => bigint): bigint;\n\n    /**\n     * Calls the specified callback function for all the elements in an array. The return value of\n     * the callback function is the accumulated result, and is provided as an argument in the next\n     * call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n     * callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: bigint, currentIndex: number, array: BigInt64Array<TArrayBuffer>) => U, initialValue: U): U;\n\n    /**\n     * Calls the specified callback function for all the elements in an array, in descending order.\n     * The return value of the callback function is the accumulated result, and is provided as an\n     * argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n     * the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an\n     * argument instead of an array value.\n     */\n    reduceRight(callbackfn: (previousValue: bigint, currentValue: bigint, currentIndex: number, array: BigInt64Array<TArrayBuffer>) => bigint): bigint;\n\n    /**\n     * Calls the specified callback function for all the elements in an array, in descending order.\n     * The return value of the callback function is the accumulated result, and is provided as an\n     * argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n     * the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: bigint, currentIndex: number, array: BigInt64Array<TArrayBuffer>) => U, initialValue: U): U;\n\n    /** Reverses the elements in the array. */\n    reverse(): this;\n\n    /**\n     * Sets a value or an array of values.\n     * @param array A typed or untyped array of values to set.\n     * @param offset The index in the current array at which the values are to be written.\n     */\n    set(array: ArrayLike<bigint>, offset?: number): void;\n\n    /**\n     * Returns a section of an array.\n     * @param start The beginning of the specified portion of the array.\n     * @param end The end of the specified portion of the array.\n     */\n    slice(start?: number, end?: number): BigInt64Array<ArrayBuffer>;\n\n    /**\n     * Determines whether the specified callback function returns true for any element of an array.\n     * @param predicate A function that accepts up to three arguments. The some method calls the\n     * predicate function for each element in the array until the predicate returns true, or until\n     * the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    some(predicate: (value: bigint, index: number, array: BigInt64Array<TArrayBuffer>) => boolean, thisArg?: any): boolean;\n\n    /**\n     * Sorts the array.\n     * @param compareFn The function used to determine the order of the elements. If omitted, the elements are sorted in ascending order.\n     */\n    sort(compareFn?: (a: bigint, b: bigint) => number | bigint): this;\n\n    /**\n     * Gets a new BigInt64Array view of the ArrayBuffer store for this array, referencing the elements\n     * at begin, inclusive, up to end, exclusive.\n     * @param begin The index of the beginning of the array.\n     * @param end The index of the end of the array.\n     */\n    subarray(begin?: number, end?: number): BigInt64Array<TArrayBuffer>;\n\n    /** Converts the array to a string by using the current locale. */\n    toLocaleString(locales?: string | string[], options?: Intl.NumberFormatOptions): string;\n\n    /** Returns a string representation of the array. */\n    toString(): string;\n\n    /** Returns the primitive value of the specified object. */\n    valueOf(): BigInt64Array<TArrayBuffer>;\n\n    /** Yields each value in the array. */\n    values(): ArrayIterator<bigint>;\n\n    [Symbol.iterator](): ArrayIterator<bigint>;\n\n    readonly [Symbol.toStringTag]: \"BigInt64Array\";\n\n    [index: number]: bigint;\n}\ninterface BigInt64ArrayConstructor {\n    readonly prototype: BigInt64Array<ArrayBufferLike>;\n    new (length?: number): BigInt64Array<ArrayBuffer>;\n    new (array: ArrayLike<bigint> | Iterable<bigint>): BigInt64Array<ArrayBuffer>;\n    new <TArrayBuffer extends ArrayBufferLike = ArrayBuffer>(buffer: TArrayBuffer, byteOffset?: number, length?: number): BigInt64Array<TArrayBuffer>;\n    new (buffer: ArrayBuffer, byteOffset?: number, length?: number): BigInt64Array<ArrayBuffer>;\n    new (array: ArrayLike<bigint> | ArrayBuffer): BigInt64Array<ArrayBuffer>;\n\n    /** The size in bytes of each element in the array. */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n     * Returns a new array from a set of elements.\n     * @param items A set of elements to include in the new array object.\n     */\n    of(...items: bigint[]): BigInt64Array<ArrayBuffer>;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like object to convert to an array.\n     */\n    from(arrayLike: ArrayLike<bigint>): BigInt64Array<ArrayBuffer>;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from<U>(arrayLike: ArrayLike<U>, mapfn: (v: U, k: number) => bigint, thisArg?: any): BigInt64Array<ArrayBuffer>;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param elements An iterable object to convert to an array.\n     */\n    from(elements: Iterable<bigint>): BigInt64Array<ArrayBuffer>;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param elements An iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from<T>(elements: Iterable<T>, mapfn?: (v: T, k: number) => bigint, thisArg?: any): BigInt64Array<ArrayBuffer>;\n}\ndeclare var BigInt64Array: BigInt64ArrayConstructor;\n\n/**\n * A typed array of 64-bit unsigned integer values. The contents are initialized to 0. If the\n * requested number of bytes could not be allocated, an exception is raised.\n */\ninterface BigUint64Array<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike> {\n    /** The size in bytes of each element in the array. */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /** The ArrayBuffer instance referenced by the array. */\n    readonly buffer: TArrayBuffer;\n\n    /** The length in bytes of the array. */\n    readonly byteLength: number;\n\n    /** The offset in bytes of the array. */\n    readonly byteOffset: number;\n\n    /**\n     * Returns the this object after copying a section of the array identified by start and end\n     * to the same array starting at position target\n     * @param target If target is negative, it is treated as length+target where length is the\n     * length of the array.\n     * @param start If start is negative, it is treated as length+start. If end is negative, it\n     * is treated as length+end.\n     * @param end If not specified, length of the this object is used as its default value.\n     */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /** Yields index, value pairs for every entry in the array. */\n    entries(): ArrayIterator<[number, bigint]>;\n\n    /**\n     * Determines whether all the members of an array satisfy the specified test.\n     * @param predicate A function that accepts up to three arguments. The every method calls\n     * the predicate function for each element in the array until the predicate returns false,\n     * or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    every(predicate: (value: bigint, index: number, array: BigUint64Array<TArrayBuffer>) => boolean, thisArg?: any): boolean;\n\n    /**\n     * Changes all array elements from `start` to `end` index to a static `value` and returns the modified array\n     * @param value value to fill array section with\n     * @param start index to start filling the array at. If start is negative, it is treated as\n     * length+start where length is the length of the array.\n     * @param end index to stop filling the array at. If end is negative, it is treated as\n     * length+end.\n     */\n    fill(value: bigint, start?: number, end?: number): this;\n\n    /**\n     * Returns the elements of an array that meet the condition specified in a callback function.\n     * @param predicate A function that accepts up to three arguments. The filter method calls\n     * the predicate function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    filter(predicate: (value: bigint, index: number, array: BigUint64Array<TArrayBuffer>) => any, thisArg?: any): BigUint64Array<ArrayBuffer>;\n\n    /**\n     * Returns the value of the first element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found, find\n     * immediately returns that element value. Otherwise, find returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    find(predicate: (value: bigint, index: number, array: BigUint64Array<TArrayBuffer>) => boolean, thisArg?: any): bigint | undefined;\n\n    /**\n     * Returns the index of the first element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findIndex(predicate: (value: bigint, index: number, array: BigUint64Array<TArrayBuffer>) => boolean, thisArg?: any): number;\n\n    /**\n     * Performs the specified action for each element in an array.\n     * @param callbackfn A function that accepts up to three arguments. forEach calls the\n     * callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    forEach(callbackfn: (value: bigint, index: number, array: BigUint64Array<TArrayBuffer>) => void, thisArg?: any): void;\n\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: bigint, fromIndex?: number): boolean;\n\n    /**\n     * Returns the index of the first occurrence of a value in an array.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n     * search starts at index 0.\n     */\n    indexOf(searchElement: bigint, fromIndex?: number): number;\n\n    /**\n     * Adds all the elements of an array separated by the specified separator string.\n     * @param separator A string used to separate one element of an array from the next in the\n     * resulting String. If omitted, the array elements are separated with a comma.\n     */\n    join(separator?: string): string;\n\n    /** Yields each index in the array. */\n    keys(): ArrayIterator<number>;\n\n    /**\n     * Returns the index of the last occurrence of a value in an array.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n     * search starts at index 0.\n     */\n    lastIndexOf(searchElement: bigint, fromIndex?: number): number;\n\n    /** The length of the array. */\n    readonly length: number;\n\n    /**\n     * Calls a defined callback function on each element of an array, and returns an array that\n     * contains the results.\n     * @param callbackfn A function that accepts up to three arguments. The map method calls the\n     * callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    map(callbackfn: (value: bigint, index: number, array: BigUint64Array<TArrayBuffer>) => bigint, thisArg?: any): BigUint64Array<ArrayBuffer>;\n\n    /**\n     * Calls the specified callback function for all the elements in an array. The return value of\n     * the callback function is the accumulated result, and is provided as an argument in the next\n     * call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n     * callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduce(callbackfn: (previousValue: bigint, currentValue: bigint, currentIndex: number, array: BigUint64Array<TArrayBuffer>) => bigint): bigint;\n\n    /**\n     * Calls the specified callback function for all the elements in an array. The return value of\n     * the callback function is the accumulated result, and is provided as an argument in the next\n     * call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n     * callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: bigint, currentIndex: number, array: BigUint64Array<TArrayBuffer>) => U, initialValue: U): U;\n\n    /**\n     * Calls the specified callback function for all the elements in an array, in descending order.\n     * The return value of the callback function is the accumulated result, and is provided as an\n     * argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n     * the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an\n     * argument instead of an array value.\n     */\n    reduceRight(callbackfn: (previousValue: bigint, currentValue: bigint, currentIndex: number, array: BigUint64Array<TArrayBuffer>) => bigint): bigint;\n\n    /**\n     * Calls the specified callback function for all the elements in an array, in descending order.\n     * The return value of the callback function is the accumulated result, and is provided as an\n     * argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n     * the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: bigint, currentIndex: number, array: BigUint64Array<TArrayBuffer>) => U, initialValue: U): U;\n\n    /** Reverses the elements in the array. */\n    reverse(): this;\n\n    /**\n     * Sets a value or an array of values.\n     * @param array A typed or untyped array of values to set.\n     * @param offset The index in the current array at which the values are to be written.\n     */\n    set(array: ArrayLike<bigint>, offset?: number): void;\n\n    /**\n     * Returns a section of an array.\n     * @param start The beginning of the specified portion of the array.\n     * @param end The end of the specified portion of the array.\n     */\n    slice(start?: number, end?: number): BigUint64Array<ArrayBuffer>;\n\n    /**\n     * Determines whether the specified callback function returns true for any element of an array.\n     * @param predicate A function that accepts up to three arguments. The some method calls the\n     * predicate function for each element in the array until the predicate returns true, or until\n     * the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    some(predicate: (value: bigint, index: number, array: BigUint64Array<TArrayBuffer>) => boolean, thisArg?: any): boolean;\n\n    /**\n     * Sorts the array.\n     * @param compareFn The function used to determine the order of the elements. If omitted, the elements are sorted in ascending order.\n     */\n    sort(compareFn?: (a: bigint, b: bigint) => number | bigint): this;\n\n    /**\n     * Gets a new BigUint64Array view of the ArrayBuffer store for this array, referencing the elements\n     * at begin, inclusive, up to end, exclusive.\n     * @param begin The index of the beginning of the array.\n     * @param end The index of the end of the array.\n     */\n    subarray(begin?: number, end?: number): BigUint64Array<TArrayBuffer>;\n\n    /** Converts the array to a string by using the current locale. */\n    toLocaleString(locales?: string | string[], options?: Intl.NumberFormatOptions): string;\n\n    /** Returns a string representation of the array. */\n    toString(): string;\n\n    /** Returns the primitive value of the specified object. */\n    valueOf(): BigUint64Array<TArrayBuffer>;\n\n    /** Yields each value in the array. */\n    values(): ArrayIterator<bigint>;\n\n    [Symbol.iterator](): ArrayIterator<bigint>;\n\n    readonly [Symbol.toStringTag]: \"BigUint64Array\";\n\n    [index: number]: bigint;\n}\ninterface BigUint64ArrayConstructor {\n    readonly prototype: BigUint64Array<ArrayBufferLike>;\n    new (length?: number): BigUint64Array<ArrayBuffer>;\n    new (array: ArrayLike<bigint> | Iterable<bigint>): BigUint64Array<ArrayBuffer>;\n    new <TArrayBuffer extends ArrayBufferLike = ArrayBuffer>(buffer: TArrayBuffer, byteOffset?: number, length?: number): BigUint64Array<TArrayBuffer>;\n    new (buffer: ArrayBuffer, byteOffset?: number, length?: number): BigUint64Array<ArrayBuffer>;\n    new (array: ArrayLike<bigint> | ArrayBuffer): BigUint64Array<ArrayBuffer>;\n\n    /** The size in bytes of each element in the array. */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n     * Returns a new array from a set of elements.\n     * @param items A set of elements to include in the new array object.\n     */\n    of(...items: bigint[]): BigUint64Array<ArrayBuffer>;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like object to convert to an array.\n     */\n    from(arrayLike: ArrayLike<bigint>): BigUint64Array<ArrayBuffer>;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from<U>(arrayLike: ArrayLike<U>, mapfn: (v: U, k: number) => bigint, thisArg?: any): BigUint64Array<ArrayBuffer>;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param elements An iterable object to convert to an array.\n     */\n    from(elements: Iterable<bigint>): BigUint64Array<ArrayBuffer>;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param elements An iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from<T>(elements: Iterable<T>, mapfn?: (v: T, k: number) => bigint, thisArg?: any): BigUint64Array<ArrayBuffer>;\n}\ndeclare var BigUint64Array: BigUint64ArrayConstructor;\n\ninterface DataView<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Gets the BigInt64 value at the specified byte offset from the start of the view. There is\n     * no alignment constraint; multi-byte values may be fetched from any offset.\n     * @param byteOffset The place in the buffer at which the value should be retrieved.\n     * @param littleEndian If false or undefined, a big-endian value should be read.\n     */\n    getBigInt64(byteOffset: number, littleEndian?: boolean): bigint;\n\n    /**\n     * Gets the BigUint64 value at the specified byte offset from the start of the view. There is\n     * no alignment constraint; multi-byte values may be fetched from any offset.\n     * @param byteOffset The place in the buffer at which the value should be retrieved.\n     * @param littleEndian If false or undefined, a big-endian value should be read.\n     */\n    getBigUint64(byteOffset: number, littleEndian?: boolean): bigint;\n\n    /**\n     * Stores a BigInt64 value at the specified byte offset from the start of the view.\n     * @param byteOffset The place in the buffer at which the value should be set.\n     * @param value The value to set.\n     * @param littleEndian If false or undefined, a big-endian value should be written.\n     */\n    setBigInt64(byteOffset: number, value: bigint, littleEndian?: boolean): void;\n\n    /**\n     * Stores a BigUint64 value at the specified byte offset from the start of the view.\n     * @param byteOffset The place in the buffer at which the value should be set.\n     * @param value The value to set.\n     * @param littleEndian If false or undefined, a big-endian value should be written.\n     */\n    setBigUint64(byteOffset: number, value: bigint, littleEndian?: boolean): void;\n}\n\ndeclare namespace Intl {\n    interface NumberFormat {\n        format(value: number | bigint): string;\n    }\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2020.bigint.d.ts",
        "start": 1,
        "end": 765,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 765,
          "column": 2,
          "position": 3817
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2020.bigint.d.ts",
        "start": 1,
        "end": 765,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 765,
          "column": 2,
          "position": 3817
        }
      }
    },
    {
      "format": "typescript",
      "lines": 33,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\n/// <reference lib=\"es2015.iterable\" />\n\ninterface ObjectConstructor {\n    /**\n     * Returns an object created by key-value entries for properties and methods\n     * @param entries An iterable object that contains key-value entries for properties and methods.\n     */\n    fromEntries<T = any>(entries: Iterable<readonly [PropertyKey, T]>): { [k: string]: T; };\n\n    /**\n     * Returns an object created by key-value entries for properties and methods\n     * @param entries An iterable object that contains key-value entries for properties and methods.\n     */\n    fromEntries(entries: Iterable<readonly any[]>): any;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2019.object.d.ts",
        "start": 1,
        "end": 33,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 33,
          "column": 2,
          "position": 86
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2019.object.d.ts",
        "start": 1,
        "end": 33,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 33,
          "column": 2,
          "position": 86
        }
      }
    },
    {
      "format": "typescript",
      "lines": 79,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\ntype FlatArray<Arr, Depth extends number> = {\n    done: Arr;\n    recur: Arr extends ReadonlyArray<infer InnerArr> ? FlatArray<InnerArr, [-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20][Depth]>\n        : Arr;\n}[Depth extends -1 ? \"done\" : \"recur\"];\n\ninterface ReadonlyArray<T> {\n    /**\n     * Calls a defined callback function on each element of an array. Then, flattens the result into\n     * a new array.\n     * This is identical to a map followed by flat with depth 1.\n     *\n     * @param callback A function that accepts up to three arguments. The flatMap method calls the\n     * callback function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callback function. If\n     * thisArg is omitted, undefined is used as the this value.\n     */\n    flatMap<U, This = undefined>(\n        callback: (this: This, value: T, index: number, array: T[]) => U | ReadonlyArray<U>,\n        thisArg?: This,\n    ): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<A, D extends number = 1>(\n        this: A,\n        depth?: D,\n    ): FlatArray<A, D>[];\n}\n\ninterface Array<T> {\n    /**\n     * Calls a defined callback function on each element of an array. Then, flattens the result into\n     * a new array.\n     * This is identical to a map followed by flat with depth 1.\n     *\n     * @param callback A function that accepts up to three arguments. The flatMap method calls the\n     * callback function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callback function. If\n     * thisArg is omitted, undefined is used as the this value.\n     */\n    flatMap<U, This = undefined>(\n        callback: (this: This, value: T, index: number, array: T[]) => U | ReadonlyArray<U>,\n        thisArg?: This,\n    ): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<A, D extends number = 1>(\n        this: A,\n        depth?: D,\n    ): FlatArray<A, D>[];\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2019.array.d.ts",
        "start": 1,
        "end": 79,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 79,
          "column": 2,
          "position": 431
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2019.array.d.ts",
        "start": 1,
        "end": 51,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 51,
          "column": 2,
          "position": 290
        }
      }
    },
    {
      "format": "typescript",
      "lines": 83,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\ndeclare namespace Intl {\n    // http://cldr.unicode.org/index/cldr-spec/plural-rules#TOC-Determining-Plural-Categories\n    type LDMLPluralRule = \"zero\" | \"one\" | \"two\" | \"few\" | \"many\" | \"other\";\n    type PluralRuleType = \"cardinal\" | \"ordinal\";\n\n    interface PluralRulesOptions {\n        localeMatcher?: \"lookup\" | \"best fit\" | undefined;\n        type?: PluralRuleType | undefined;\n        minimumIntegerDigits?: number | undefined;\n        minimumFractionDigits?: number | undefined;\n        maximumFractionDigits?: number | undefined;\n        minimumSignificantDigits?: number | undefined;\n        maximumSignificantDigits?: number | undefined;\n    }\n\n    interface ResolvedPluralRulesOptions {\n        locale: string;\n        pluralCategories: LDMLPluralRule[];\n        type: PluralRuleType;\n        minimumIntegerDigits: number;\n        minimumFractionDigits: number;\n        maximumFractionDigits: number;\n        minimumSignificantDigits?: number;\n        maximumSignificantDigits?: number;\n    }\n\n    interface PluralRules {\n        resolvedOptions(): ResolvedPluralRulesOptions;\n        select(n: number): LDMLPluralRule;\n    }\n\n    interface PluralRulesConstructor {\n        new (locales?: string | readonly string[], options?: PluralRulesOptions): PluralRules;\n        (locales?: string | readonly string[], options?: PluralRulesOptions): PluralRules;\n        supportedLocalesOf(locales: string | readonly string[], options?: { localeMatcher?: \"lookup\" | \"best fit\"; }): string[];\n    }\n\n    const PluralRules: PluralRulesConstructor;\n\n    interface NumberFormatPartTypeRegistry {\n        literal: never;\n        nan: never;\n        infinity: never;\n        percent: never;\n        integer: never;\n        group: never;\n        decimal: never;\n        fraction: never;\n        plusSign: never;\n        minusSign: never;\n        percentSign: never;\n        currency: never;\n    }\n\n    type NumberFormatPartTypes = keyof NumberFormatPartTypeRegistry;\n\n    interface NumberFormatPart {\n        type: NumberFormatPartTypes;\n        value: string;\n    }\n\n    interface NumberFormat {\n        formatToParts(number?: number | bigint): NumberFormatPart[];\n    }\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2018.intl.d.ts",
        "start": 1,
        "end": 83,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 83,
          "column": 2,
          "position": 551
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2018.intl.d.ts",
        "start": 1,
        "end": 83,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 83,
          "column": 2,
          "position": 551
        }
      }
    },
    {
      "format": "typescript",
      "lines": 53,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\n/// <reference lib=\"es2015.symbol\" />\n/// <reference lib=\"es2015.iterable\" />\n\ninterface SymbolConstructor {\n    /**\n     * A method that returns the default async iterator for an object. Called by the semantics of\n     * the for-await-of statement.\n     */\n    readonly asyncIterator: unique symbol;\n}\n\ninterface AsyncIterator<T, TReturn = any, TNext = any> {\n    // NOTE: 'next' is defined using a tuple to ensure we report the correct assignability errors in all places.\n    next(...[value]: [] | [TNext]): Promise<IteratorResult<T, TReturn>>;\n    return?(value?: TReturn | PromiseLike<TReturn>): Promise<IteratorResult<T, TReturn>>;\n    throw?(e?: any): Promise<IteratorResult<T, TReturn>>;\n}\n\ninterface AsyncIterable<T, TReturn = any, TNext = any> {\n    [Symbol.asyncIterator](): AsyncIterator<T, TReturn, TNext>;\n}\n\n/**\n * Describes a user-defined {@link AsyncIterator} that is also async iterable.\n */\ninterface AsyncIterableIterator<T, TReturn = any, TNext = any> extends AsyncIterator<T, TReturn, TNext> {\n    [Symbol.asyncIterator](): AsyncIterableIterator<T, TReturn, TNext>;\n}\n\n/**\n * Describes an {@link AsyncIterator} produced by the runtime that inherits from the intrinsic `AsyncIterator.prototype`.\n */\ninterface AsyncIteratorObject<T, TReturn = unknown, TNext = unknown> extends AsyncIterator<T, TReturn, TNext> {\n    [Symbol.asyncIterator](): AsyncIteratorObject<T, TReturn, TNext>;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2018.asynciterable.d.ts",
        "start": 1,
        "end": 53,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 53,
          "column": 2,
          "position": 319
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2018.asynciterable.d.ts",
        "start": 1,
        "end": 53,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 53,
          "column": 2,
          "position": 319
        }
      }
    },
    {
      "format": "typescript",
      "lines": 77,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\n/// <reference lib=\"es2018.asynciterable\" />\n\ninterface AsyncGenerator<T = unknown, TReturn = any, TNext = any> extends AsyncIteratorObject<T, TReturn, TNext> {\n    // NOTE: 'next' is defined using a tuple to ensure we report the correct assignability errors in all places.\n    next(...[value]: [] | [TNext]): Promise<IteratorResult<T, TReturn>>;\n    return(value: TReturn | PromiseLike<TReturn>): Promise<IteratorResult<T, TReturn>>;\n    throw(e: any): Promise<IteratorResult<T, TReturn>>;\n    [Symbol.asyncIterator](): AsyncGenerator<T, TReturn, TNext>;\n}\n\ninterface AsyncGeneratorFunction {\n    /**\n     * Creates a new AsyncGenerator object.\n     * @param args A list of arguments the function accepts.\n     */\n    new (...args: any[]): AsyncGenerator;\n    /**\n     * Creates a new AsyncGenerator object.\n     * @param args A list of arguments the function accepts.\n     */\n    (...args: any[]): AsyncGenerator;\n    /**\n     * The length of the arguments.\n     */\n    readonly length: number;\n    /**\n     * Returns the name of the function.\n     */\n    readonly name: string;\n    /**\n     * A reference to the prototype.\n     */\n    readonly prototype: AsyncGenerator;\n}\n\ninterface AsyncGeneratorFunctionConstructor {\n    /**\n     * Creates a new AsyncGenerator function.\n     * @param args A list of arguments the function accepts.\n     */\n    new (...args: string[]): AsyncGeneratorFunction;\n    /**\n     * Creates a new AsyncGenerator function.\n     * @param args A list of arguments the function accepts.\n     */\n    (...args: string[]): AsyncGeneratorFunction;\n    /**\n     * The length of the arguments.\n     */\n    readonly length: number;\n    /**\n     * Returns the name of the function.\n     */\n    readonly name: string;\n    /**\n     * A reference to the prototype.\n     */\n    readonly prototype: AsyncGeneratorFunction;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2018.asyncgenerator.d.ts",
        "start": 1,
        "end": 77,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 77,
          "column": 2,
          "position": 321
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2018.asyncgenerator.d.ts",
        "start": 1,
        "end": 77,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 77,
          "column": 2,
          "position": 321
        }
      }
    },
    {
      "format": "typescript",
      "lines": 53,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\ninterface Int8ArrayConstructor {\n    new (): Int8Array<ArrayBuffer>;\n}\n\ninterface Uint8ArrayConstructor {\n    new (): Uint8Array<ArrayBuffer>;\n}\n\ninterface Uint8ClampedArrayConstructor {\n    new (): Uint8ClampedArray<ArrayBuffer>;\n}\n\ninterface Int16ArrayConstructor {\n    new (): Int16Array<ArrayBuffer>;\n}\n\ninterface Uint16ArrayConstructor {\n    new (): Uint16Array<ArrayBuffer>;\n}\n\ninterface Int32ArrayConstructor {\n    new (): Int32Array<ArrayBuffer>;\n}\n\ninterface Uint32ArrayConstructor {\n    new (): Uint32Array<ArrayBuffer>;\n}\n\ninterface Float32ArrayConstructor {\n    new (): Float32Array<ArrayBuffer>;\n}\n\ninterface Float64ArrayConstructor {\n    new (): Float64Array<ArrayBuffer>;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2017.typedarrays.d.ts",
        "start": 1,
        "end": 53,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 53,
          "column": 2,
          "position": 202
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2017.typedarrays.d.ts",
        "start": 1,
        "end": 53,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 53,
          "column": 2,
          "position": 202
        }
      }
    },
    {
      "format": "typescript",
      "lines": 135,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\n/// <reference lib=\"es2015.symbol\" />\n/// <reference lib=\"es2015.symbol.wellknown\" />\n\ninterface SharedArrayBuffer {\n    /**\n     * Read-only. The length of the ArrayBuffer (in bytes).\n     */\n    readonly byteLength: number;\n\n    /**\n     * Returns a section of an SharedArrayBuffer.\n     */\n    slice(begin?: number, end?: number): SharedArrayBuffer;\n    readonly [Symbol.toStringTag]: \"SharedArrayBuffer\";\n}\n\ninterface SharedArrayBufferConstructor {\n    readonly prototype: SharedArrayBuffer;\n    new (byteLength?: number): SharedArrayBuffer;\n    readonly [Symbol.species]: SharedArrayBufferConstructor;\n}\ndeclare var SharedArrayBuffer: SharedArrayBufferConstructor;\n\ninterface ArrayBufferTypes {\n    SharedArrayBuffer: SharedArrayBuffer;\n}\n\ninterface Atomics {\n    /**\n     * Adds a value to the value at the given position in the array, returning the original value.\n     * Until this atomic operation completes, any other read or write operation against the array\n     * will block.\n     */\n    add(typedArray: Int8Array<ArrayBufferLike> | Uint8Array<ArrayBufferLike> | Int16Array<ArrayBufferLike> | Uint16Array<ArrayBufferLike> | Int32Array<ArrayBufferLike> | Uint32Array<ArrayBufferLike>, index: number, value: number): number;\n\n    /**\n     * Stores the bitwise AND of a value with the value at the given position in the array,\n     * returning the original value. Until this atomic operation completes, any other read or\n     * write operation against the array will block.\n     */\n    and(typedArray: Int8Array<ArrayBufferLike> | Uint8Array<ArrayBufferLike> | Int16Array<ArrayBufferLike> | Uint16Array<ArrayBufferLike> | Int32Array<ArrayBufferLike> | Uint32Array<ArrayBufferLike>, index: number, value: number): number;\n\n    /**\n     * Replaces the value at the given position in the array if the original value equals the given\n     * expected value, returning the original value. Until this atomic operation completes, any\n     * other read or write operation against the array will block.\n     */\n    compareExchange(typedArray: Int8Array<ArrayBufferLike> | Uint8Array<ArrayBufferLike> | Int16Array<ArrayBufferLike> | Uint16Array<ArrayBufferLike> | Int32Array<ArrayBufferLike> | Uint32Array<ArrayBufferLike>, index: number, expectedValue: number, replacementValue: number): number;\n\n    /**\n     * Replaces the value at the given position in the array, returning the original value. Until\n     * this atomic operation completes, any other read or write operation against the array will\n     * block.\n     */\n    exchange(typedArray: Int8Array<ArrayBufferLike> | Uint8Array<ArrayBufferLike> | Int16Array<ArrayBufferLike> | Uint16Array<ArrayBufferLike> | Int32Array<ArrayBufferLike> | Uint32Array<ArrayBufferLike>, index: number, value: number): number;\n\n    /**\n     * Returns a value indicating whether high-performance algorithms can use atomic operations\n     * (`true`) or must use locks (`false`) for the given number of bytes-per-element of a typed\n     * array.\n     */\n    isLockFree(size: number): boolean;\n\n    /**\n     * Returns the value at the given position in the array. Until this atomic operation completes,\n     * any other read or write operation against the array will block.\n     */\n    load(typedArray: Int8Array<ArrayBufferLike> | Uint8Array<ArrayBufferLike> | Int16Array<ArrayBufferLike> | Uint16Array<ArrayBufferLike> | Int32Array<ArrayBufferLike> | Uint32Array<ArrayBufferLike>, index: number): number;\n\n    /**\n     * Stores the bitwise OR of a value with the value at the given position in the array,\n     * returning the original value. Until this atomic operation completes, any other read or write\n     * operation against the array will block.\n     */\n    or(typedArray: Int8Array<ArrayBufferLike> | Uint8Array<ArrayBufferLike> | Int16Array<ArrayBufferLike> | Uint16Array<ArrayBufferLike> | Int32Array<ArrayBufferLike> | Uint32Array<ArrayBufferLike>, index: number, value: number): number;\n\n    /**\n     * Stores a value at the given position in the array, returning the new value. Until this\n     * atomic operation completes, any other read or write operation against the array will block.\n     */\n    store(typedArray: Int8Array<ArrayBufferLike> | Uint8Array<ArrayBufferLike> | Int16Array<ArrayBufferLike> | Uint16Array<ArrayBufferLike> | Int32Array<ArrayBufferLike> | Uint32Array<ArrayBufferLike>, index: number, value: number): number;\n\n    /**\n     * Subtracts a value from the value at the given position in the array, returning the original\n     * value. Until this atomic operation completes, any other read or write operation against the\n     * array will block.\n     */\n    sub(typedArray: Int8Array<ArrayBufferLike> | Uint8Array<ArrayBufferLike> | Int16Array<ArrayBufferLike> | Uint16Array<ArrayBufferLike> | Int32Array<ArrayBufferLike> | Uint32Array<ArrayBufferLike>, index: number, value: number): number;\n\n    /**\n     * If the value at the given position in the array is equal to the provided value, the current\n     * agent is put to sleep causing execution to suspend until the timeout expires (returning\n     * `\"timed-out\"`) or until the agent is awoken (returning `\"ok\"`); otherwise, returns\n     * `\"not-equal\"`.\n     */\n    wait(typedArray: Int32Array<ArrayBufferLike>, index: number, value: number, timeout?: number): \"ok\" | \"not-equal\" | \"timed-out\";\n\n    /**\n     * Wakes up sleeping agents that are waiting on the given index of the array, returning the\n     * number of agents that were awoken.\n     * @param typedArray A shared Int32Array<ArrayBufferLike>.\n     * @param index The position in the typedArray to wake up on.\n     * @param count The number of sleeping agents to notify. Defaults to +Infinity.\n     */\n    notify(typedArray: Int32Array<ArrayBufferLike>, index: number, count?: number): number;\n\n    /**\n     * Stores the bitwise XOR of a value with the value at the given position in the array,\n     * returning the original value. Until this atomic operation completes, any other read or write\n     * operation against the array will block.\n     */\n    xor(typedArray: Int8Array<ArrayBufferLike> | Uint8Array<ArrayBufferLike> | Int16Array<ArrayBufferLike> | Uint16Array<ArrayBufferLike> | Int32Array<ArrayBufferLike> | Uint32Array<ArrayBufferLike>, index: number, value: number): number;\n\n    readonly [Symbol.toStringTag]: \"Atomics\";\n}\n\ndeclare var Atomics: Atomics;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2017.sharedmemory.d.ts",
        "start": 1,
        "end": 135,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 135,
          "column": 2,
          "position": 873
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2017.sharedmemory.d.ts",
        "start": 1,
        "end": 135,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 135,
          "column": 2,
          "position": 873
        }
      }
    },
    {
      "format": "typescript",
      "lines": 49,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\ninterface ObjectConstructor {\n    /**\n     * Returns an array of values of the enumerable own properties of an object\n     * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\n     */\n    values<T>(o: { [s: string]: T; } | ArrayLike<T>): T[];\n\n    /**\n     * Returns an array of values of the enumerable own properties of an object\n     * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\n     */\n    values(o: {}): any[];\n\n    /**\n     * Returns an array of key/values of the enumerable own properties of an object\n     * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\n     */\n    entries<T>(o: { [s: string]: T; } | ArrayLike<T>): [string, T][];\n\n    /**\n     * Returns an array of key/values of the enumerable own properties of an object\n     * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\n     */\n    entries(o: {}): [string, any][];\n\n    /**\n     * Returns an object containing all own property descriptors of an object\n     * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\n     */\n    getOwnPropertyDescriptors<T>(o: T): { [P in keyof T]: TypedPropertyDescriptor<T[P]>; } & { [x: string]: PropertyDescriptor; };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2017.object.d.ts",
        "start": 1,
        "end": 49,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 49,
          "column": 2,
          "position": 205
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2017.object.d.ts",
        "start": 1,
        "end": 49,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 49,
          "column": 2,
          "position": 205
        }
      }
    },
    {
      "format": "typescript",
      "lines": 44,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\ndeclare namespace Intl {\n    interface DateTimeFormatPartTypesRegistry {\n        day: any;\n        dayPeriod: any;\n        era: any;\n        hour: any;\n        literal: any;\n        minute: any;\n        month: any;\n        second: any;\n        timeZoneName: any;\n        weekday: any;\n        year: any;\n    }\n\n    type DateTimeFormatPartTypes = keyof DateTimeFormatPartTypesRegistry;\n\n    interface DateTimeFormatPart {\n        type: DateTimeFormatPartTypes;\n        value: string;\n    }\n\n    interface DateTimeFormat {\n        formatToParts(date?: Date | number): DateTimeFormatPart[];\n    }\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2017.intl.d.ts",
        "start": 1,
        "end": 44,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 44,
          "column": 2,
          "position": 171
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2017.intl.d.ts",
        "start": 1,
        "end": 44,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 44,
          "column": 2,
          "position": 171
        }
      }
    },
    {
      "format": "typescript",
      "lines": 116,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\ninterface Array<T> {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: T, fromIndex?: number): boolean;\n}\n\ninterface ReadonlyArray<T> {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: T, fromIndex?: number): boolean;\n}\n\ninterface Int8Array<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}\n\ninterface Uint8Array<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}\n\ninterface Uint8ClampedArray<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}\n\ninterface Int16Array<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}\n\ninterface Uint16Array<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}\n\ninterface Int32Array<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}\n\ninterface Uint32Array<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}\n\ninterface Float32Array<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}\n\ninterface Float64Array<TArrayBuffer extends ArrayBufferLike> {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2016.array.include.d.ts",
        "start": 1,
        "end": 116,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 116,
          "column": 2,
          "position": 425
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2016.array.include.d.ts",
        "start": 1,
        "end": 116,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 116,
          "column": 2,
          "position": 425
        }
      }
    },
    {
      "format": "typescript",
      "lines": 326,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\n/// <reference lib=\"es2015.symbol\" />\n\ninterface SymbolConstructor {\n    /**\n     * A method that determines if a constructor object recognizes an object as one of the\n     * constructors instances. Called by the semantics of the instanceof operator.\n     */\n    readonly hasInstance: unique symbol;\n\n    /**\n     * A Boolean value that if true indicates that an object should flatten to its array elements\n     * by Array.prototype.concat.\n     */\n    readonly isConcatSpreadable: unique symbol;\n\n    /**\n     * A regular expression method that matches the regular expression against a string. Called\n     * by the String.prototype.match method.\n     */\n    readonly match: unique symbol;\n\n    /**\n     * A regular expression method that replaces matched substrings of a string. Called by the\n     * String.prototype.replace method.\n     */\n    readonly replace: unique symbol;\n\n    /**\n     * A regular expression method that returns the index within a string that matches the\n     * regular expression. Called by the String.prototype.search method.\n     */\n    readonly search: unique symbol;\n\n    /**\n     * A function valued property that is the constructor function that is used to create\n     * derived objects.\n     */\n    readonly species: unique symbol;\n\n    /**\n     * A regular expression method that splits a string at the indices that match the regular\n     * expression. Called by the String.prototype.split method.\n     */\n    readonly split: unique symbol;\n\n    /**\n     * A method that converts an object to a corresponding primitive value.\n     * Called by the ToPrimitive abstract operation.\n     */\n    readonly toPrimitive: unique symbol;\n\n    /**\n     * A String value that is used in the creation of the default string description of an object.\n     * Called by the built-in method Object.prototype.toString.\n     */\n    readonly toStringTag: unique symbol;\n\n    /**\n     * An Object whose truthy properties are properties that are excluded from the 'with'\n     * environment bindings of the associated objects.\n     */\n    readonly unscopables: unique symbol;\n}\n\ninterface Symbol {\n    /**\n     * Converts a Symbol object to a symbol.\n     */\n    [Symbol.toPrimitive](hint: string): symbol;\n\n    readonly [Symbol.toStringTag]: string;\n}\n\ninterface Array<T> {\n    /**\n     * Is an object whose properties have the value 'true'\n     * when they will be absent when used in a 'with' statement.\n     */\n    readonly [Symbol.unscopables]: {\n        [K in keyof any[]]?: boolean;\n    };\n}\n\ninterface ReadonlyArray<T> {\n    /**\n     * Is an object whose properties have the value 'true'\n     * when they will be absent when used in a 'with' statement.\n     */\n    readonly [Symbol.unscopables]: {\n        [K in keyof readonly any[]]?: boolean;\n    };\n}\n\ninterface Date {\n    /**\n     * Converts a Date object to a string.\n     */\n    [Symbol.toPrimitive](hint: \"default\"): string;\n    /**\n     * Converts a Date object to a string.\n     */\n    [Symbol.toPrimitive](hint: \"string\"): string;\n    /**\n     * Converts a Date object to a number.\n     */\n    [Symbol.toPrimitive](hint: \"number\"): number;\n    /**\n     * Converts a Date object to a string or number.\n     *\n     * @param hint The strings \"number\", \"string\", or \"default\" to specify what primitive to return.\n     *\n     * @throws {TypeError} If 'hint' was given something other than \"number\", \"string\", or \"default\".\n     * @returns A number if 'hint' was \"number\", a string if 'hint' was \"string\" or \"default\".\n     */\n    [Symbol.toPrimitive](hint: string): string | number;\n}\n\ninterface Map<K, V> {\n    readonly [Symbol.toStringTag]: string;\n}\n\ninterface WeakMap<K extends WeakKey, V> {\n    readonly [Symbol.toStringTag]: string;\n}\n\ninterface Set<T> {\n    readonly [Symbol.toStringTag]: string;\n}\n\ninterface WeakSet<T extends WeakKey> {\n    readonly [Symbol.toStringTag]: string;\n}\n\ninterface JSON {\n    readonly [Symbol.toStringTag]: string;\n}\n\ninterface Function {\n    /**\n     * Determines whether the given value inherits from this function if this function was used\n     * as a constructor function.\n     *\n     * A constructor function can control which objects are recognized as its instances by\n     * 'instanceof' by overriding this method.\n     */\n    [Symbol.hasInstance](value: any): boolean;\n}\n\ninterface GeneratorFunction {\n    readonly [Symbol.toStringTag]: string;\n}\n\ninterface Math {\n    readonly [Symbol.toStringTag]: string;\n}\n\ninterface Promise<T> {\n    readonly [Symbol.toStringTag]: string;\n}\n\ninterface PromiseConstructor {\n    readonly [Symbol.species]: PromiseConstructor;\n}\n\ninterface RegExp {\n    /**\n     * Matches a string with this regular expression, and returns an array containing the results of\n     * that search.\n     * @param string A string to search within.\n     */\n    [Symbol.match](string: string): RegExpMatchArray | null;\n\n    /**\n     * Replaces text in a string, using this regular expression.\n     * @param string A String object or string literal whose contents matching against\n     *               this regular expression will be replaced\n     * @param replaceValue A String object or string literal containing the text to replace for every\n     *                     successful match of this regular expression.\n     */\n    [Symbol.replace](string: string, replaceValue: string): string;\n\n    /**\n     * Replaces text in a string, using this regular expression.\n     * @param string A String object or string literal whose contents matching against\n     *               this regular expression will be replaced\n     * @param replacer A function that returns the replacement text.\n     */\n    [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string;\n\n    /**\n     * Finds the position beginning first substring match in a regular expression search\n     * using this regular expression.\n     *\n     * @param string The string to search within.\n     */\n    [Symbol.search](string: string): number;\n\n    /**\n     * Returns an array of substrings that were delimited by strings in the original input that\n     * match against this regular expression.\n     *\n     * If the regular expression contains capturing parentheses, then each time this\n     * regular expression matches, the results (including any undefined results) of the\n     * capturing parentheses are spliced.\n     *\n     * @param string string value to split\n     * @param limit if not undefined, the output array is truncated so that it contains no more\n     * than 'limit' elements.\n     */\n    [Symbol.split](string: string, limit?: number): string[];\n}\n\ninterface RegExpConstructor {\n    readonly [Symbol.species]: RegExpConstructor;\n}\n\ninterface String {\n    /**\n     * Matches a string or an object that supports being matched against, and returns an array\n     * containing the results of that search, or null if no matches are found.\n     * @param matcher An object that supports being matched against.\n     */\n    match(matcher: { [Symbol.match](string: string): RegExpMatchArray | null; }): RegExpMatchArray | null;\n\n    /**\n     * Passes a string and {@linkcode replaceValue} to the `[Symbol.replace]` method on {@linkcode searchValue}. This method is expected to implement its own replacement algorithm.\n     * @param searchValue An object that supports searching for and replacing matches within a string.\n     * @param replaceValue The replacement text.\n     */\n    replace(searchValue: { [Symbol.replace](string: string, replaceValue: string): string; }, replaceValue: string): string;\n\n    /**\n     * Replaces text in a string, using an object that supports replacement within a string.\n     * @param searchValue A object can search for and replace matches within a string.\n     * @param replacer A function that returns the replacement text.\n     */\n    replace(searchValue: { [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string; }, replacer: (substring: string, ...args: any[]) => string): string;\n\n    /**\n     * Finds the first substring match in a regular expression search.\n     * @param searcher An object which supports searching within a string.\n     */\n    search(searcher: { [Symbol.search](string: string): number; }): number;\n\n    /**\n     * Split a string into substrings using the specified separator and return them as an array.\n     * @param splitter An object that can split a string.\n     * @param limit A value used to limit the number of elements returned in the array.\n     */\n    split(splitter: { [Symbol.split](string: string, limit?: number): string[]; }, limit?: number): string[];\n}\n\ninterface ArrayBuffer {\n    readonly [Symbol.toStringTag]: \"ArrayBuffer\";\n}\n\ninterface DataView<TArrayBuffer extends ArrayBufferLike> {\n    readonly [Symbol.toStringTag]: string;\n}\n\ninterface Int8Array<TArrayBuffer extends ArrayBufferLike> {\n    readonly [Symbol.toStringTag]: \"Int8Array\";\n}\n\ninterface Uint8Array<TArrayBuffer extends ArrayBufferLike> {\n    readonly [Symbol.toStringTag]: \"Uint8Array\";\n}\n\ninterface Uint8ClampedArray<TArrayBuffer extends ArrayBufferLike> {\n    readonly [Symbol.toStringTag]: \"Uint8ClampedArray\";\n}\n\ninterface Int16Array<TArrayBuffer extends ArrayBufferLike> {\n    readonly [Symbol.toStringTag]: \"Int16Array\";\n}\n\ninterface Uint16Array<TArrayBuffer extends ArrayBufferLike> {\n    readonly [Symbol.toStringTag]: \"Uint16Array\";\n}\n\ninterface Int32Array<TArrayBuffer extends ArrayBufferLike> {\n    readonly [Symbol.toStringTag]: \"Int32Array\";\n}\n\ninterface Uint32Array<TArrayBuffer extends ArrayBufferLike> {\n    readonly [Symbol.toStringTag]: \"Uint32Array\";\n}\n\ninterface Float32Array<TArrayBuffer extends ArrayBufferLike> {\n    readonly [Symbol.toStringTag]: \"Float32Array\";\n}\n\ninterface Float64Array<TArrayBuffer extends ArrayBufferLike> {\n    readonly [Symbol.toStringTag]: \"Float64Array\";\n}\n\ninterface ArrayConstructor {\n    readonly [Symbol.species]: ArrayConstructor;\n}\ninterface MapConstructor {\n    readonly [Symbol.species]: MapConstructor;\n}\ninterface SetConstructor {\n    readonly [Symbol.species]: SetConstructor;\n}\ninterface ArrayBufferConstructor {\n    readonly [Symbol.species]: ArrayBufferConstructor;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2015.symbol.wellknown.d.ts",
        "start": 1,
        "end": 326,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 326,
          "column": 2,
          "position": 1501
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2015.symbol.wellknown.d.ts",
        "start": 1,
        "end": 326,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 326,
          "column": 2,
          "position": 1501
        }
      }
    },
    {
      "format": "typescript",
      "lines": 46,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\ninterface SymbolConstructor {\n    /**\n     * A reference to the prototype.\n     */\n    readonly prototype: Symbol;\n\n    /**\n     * Returns a new unique Symbol value.\n     * @param  description Description of the new Symbol object.\n     */\n    (description?: string | number): symbol;\n\n    /**\n     * Returns a Symbol object from the global symbol registry matching the given key if found.\n     * Otherwise, returns a new symbol with this key.\n     * @param key key to search for.\n     */\n    for(key: string): symbol;\n\n    /**\n     * Returns a key from the global symbol registry matching the given Symbol if found.\n     * Otherwise, returns a undefined.\n     * @param sym Symbol to find the key for.\n     */\n    keyFor(sym: symbol): string | undefined;\n}\n\ndeclare var Symbol: SymbolConstructor;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2015.symbol.d.ts",
        "start": 1,
        "end": 46,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 46,
          "column": 2,
          "position": 95
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2015.symbol.d.ts",
        "start": 1,
        "end": 46,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 46,
          "column": 2,
          "position": 95
        }
      }
    },
    {
      "format": "typescript",
      "lines": 144,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\ndeclare namespace Reflect {\n    /**\n     * Calls the function with the specified object as the this value\n     * and the elements of specified array as the arguments.\n     * @param target The function to call.\n     * @param thisArgument The object to be used as the this object.\n     * @param argumentsList An array of argument values to be passed to the function.\n     */\n    function apply<T, A extends readonly any[], R>(\n        target: (this: T, ...args: A) => R,\n        thisArgument: T,\n        argumentsList: Readonly<A>,\n    ): R;\n    function apply(target: Function, thisArgument: any, argumentsList: ArrayLike<any>): any;\n\n    /**\n     * Constructs the target with the elements of specified array as the arguments\n     * and the specified constructor as the `new.target` value.\n     * @param target The constructor to invoke.\n     * @param argumentsList An array of argument values to be passed to the constructor.\n     * @param newTarget The constructor to be used as the `new.target` object.\n     */\n    function construct<A extends readonly any[], R>(\n        target: new (...args: A) => R,\n        argumentsList: Readonly<A>,\n        newTarget?: new (...args: any) => any,\n    ): R;\n    function construct(target: Function, argumentsList: ArrayLike<any>, newTarget?: Function): any;\n\n    /**\n     * Adds a property to an object, or modifies attributes of an existing property.\n     * @param target Object on which to add or modify the property. This can be a native JavaScript object\n     *        (that is, a user-defined object or a built in object) or a DOM object.\n     * @param propertyKey The property name.\n     * @param attributes Descriptor for the property. It can be for a data property or an accessor property.\n     */\n    function defineProperty(target: object, propertyKey: PropertyKey, attributes: PropertyDescriptor & ThisType<any>): boolean;\n\n    /**\n     * Removes a property from an object, equivalent to `delete target[propertyKey]`,\n     * except it won't throw if `target[propertyKey]` is non-configurable.\n     * @param target Object from which to remove the own property.\n     * @param propertyKey The property name.\n     */\n    function deleteProperty(target: object, propertyKey: PropertyKey): boolean;\n\n    /**\n     * Gets the property of target, equivalent to `target[propertyKey]` when `receiver === target`.\n     * @param target Object that contains the property on itself or in its prototype chain.\n     * @param propertyKey The property name.\n     * @param receiver The reference to use as the `this` value in the getter function,\n     *        if `target[propertyKey]` is an accessor property.\n     */\n    function get<T extends object, P extends PropertyKey>(\n        target: T,\n        propertyKey: P,\n        receiver?: unknown,\n    ): P extends keyof T ? T[P] : any;\n\n    /**\n     * Gets the own property descriptor of the specified object.\n     * An own property descriptor is one that is defined directly on the object and is not inherited from the object's prototype.\n     * @param target Object that contains the property.\n     * @param propertyKey The property name.\n     */\n    function getOwnPropertyDescriptor<T extends object, P extends PropertyKey>(\n        target: T,\n        propertyKey: P,\n    ): TypedPropertyDescriptor<P extends keyof T ? T[P] : any> | undefined;\n\n    /**\n     * Returns the prototype of an object.\n     * @param target The object that references the prototype.\n     */\n    function getPrototypeOf(target: object): object | null;\n\n    /**\n     * Equivalent to `propertyKey in target`.\n     * @param target Object that contains the property on itself or in its prototype chain.\n     * @param propertyKey Name of the property.\n     */\n    function has(target: object, propertyKey: PropertyKey): boolean;\n\n    /**\n     * Returns a value that indicates whether new properties can be added to an object.\n     * @param target Object to test.\n     */\n    function isExtensible(target: object): boolean;\n\n    /**\n     * Returns the string and symbol keys of the own properties of an object. The own properties of an object\n     * are those that are defined directly on that object, and are not inherited from the object's prototype.\n     * @param target Object that contains the own properties.\n     */\n    function ownKeys(target: object): (string | symbol)[];\n\n    /**\n     * Prevents the addition of new properties to an object.\n     * @param target Object to make non-extensible.\n     * @return Whether the object has been made non-extensible.\n     */\n    function preventExtensions(target: object): boolean;\n\n    /**\n     * Sets the property of target, equivalent to `target[propertyKey] = value` when `receiver === target`.\n     * @param target Object that contains the property on itself or in its prototype chain.\n     * @param propertyKey Name of the property.\n     * @param receiver The reference to use as the `this` value in the setter function,\n     *        if `target[propertyKey]` is an accessor property.\n     */\n    function set<T extends object, P extends PropertyKey>(\n        target: T,\n        propertyKey: P,\n        value: P extends keyof T ? T[P] : any,\n        receiver?: any,\n    ): boolean;\n    function set(target: object, propertyKey: PropertyKey, value: any, receiver?: any): boolean;\n\n    /**\n     * Sets the prototype of a specified object o to object proto or null.\n     * @param target The object to change its prototype.\n     * @param proto The value of the new prototype or null.\n     * @return Whether setting the prototype was successful.\n     */\n    function setPrototypeOf(target: object, proto: object | null): boolean;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2015.reflect.d.ts",
        "start": 1,
        "end": 144,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 144,
          "column": 2,
          "position": 684
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2015.reflect.d.ts",
        "start": 1,
        "end": 144,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 144,
          "column": 2,
          "position": 684
        }
      }
    },
    {
      "format": "typescript",
      "lines": 128,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\ninterface ProxyHandler<T extends object> {\n    /**\n     * A trap method for a function call.\n     * @param target The original callable object which is being proxied.\n     */\n    apply?(target: T, thisArg: any, argArray: any[]): any;\n\n    /**\n     * A trap for the `new` operator.\n     * @param target The original object which is being proxied.\n     * @param newTarget The constructor that was originally called.\n     */\n    construct?(target: T, argArray: any[], newTarget: Function): object;\n\n    /**\n     * A trap for `Object.defineProperty()`.\n     * @param target The original object which is being proxied.\n     * @returns A `Boolean` indicating whether or not the property has been defined.\n     */\n    defineProperty?(target: T, property: string | symbol, attributes: PropertyDescriptor): boolean;\n\n    /**\n     * A trap for the `delete` operator.\n     * @param target The original object which is being proxied.\n     * @param p The name or `Symbol` of the property to delete.\n     * @returns A `Boolean` indicating whether or not the property was deleted.\n     */\n    deleteProperty?(target: T, p: string | symbol): boolean;\n\n    /**\n     * A trap for getting a property value.\n     * @param target The original object which is being proxied.\n     * @param p The name or `Symbol` of the property to get.\n     * @param receiver The proxy or an object that inherits from the proxy.\n     */\n    get?(target: T, p: string | symbol, receiver: any): any;\n\n    /**\n     * A trap for `Object.getOwnPropertyDescriptor()`.\n     * @param target The original object which is being proxied.\n     * @param p The name of the property whose description should be retrieved.\n     */\n    getOwnPropertyDescriptor?(target: T, p: string | symbol): PropertyDescriptor | undefined;\n\n    /**\n     * A trap for the `[[GetPrototypeOf]]` internal method.\n     * @param target The original object which is being proxied.\n     */\n    getPrototypeOf?(target: T): object | null;\n\n    /**\n     * A trap for the `in` operator.\n     * @param target The original object which is being proxied.\n     * @param p The name or `Symbol` of the property to check for existence.\n     */\n    has?(target: T, p: string | symbol): boolean;\n\n    /**\n     * A trap for `Object.isExtensible()`.\n     * @param target The original object which is being proxied.\n     */\n    isExtensible?(target: T): boolean;\n\n    /**\n     * A trap for `Reflect.ownKeys()`.\n     * @param target The original object which is being proxied.\n     */\n    ownKeys?(target: T): ArrayLike<string | symbol>;\n\n    /**\n     * A trap for `Object.preventExtensions()`.\n     * @param target The original object which is being proxied.\n     */\n    preventExtensions?(target: T): boolean;\n\n    /**\n     * A trap for setting a property value.\n     * @param target The original object which is being proxied.\n     * @param p The name or `Symbol` of the property to set.\n     * @param receiver The object to which the assignment was originally directed.\n     * @returns A `Boolean` indicating whether or not the property was set.\n     */\n    set?(target: T, p: string | symbol, newValue: any, receiver: any): boolean;\n\n    /**\n     * A trap for `Object.setPrototypeOf()`.\n     * @param target The original object which is being proxied.\n     * @param newPrototype The object's new prototype or `null`.\n     */\n    setPrototypeOf?(target: T, v: object | null): boolean;\n}\n\ninterface ProxyConstructor {\n    /**\n     * Creates a revocable Proxy object.\n     * @param target A target object to wrap with Proxy.\n     * @param handler An object whose properties define the behavior of Proxy when an operation is attempted on it.\n     */\n    revocable<T extends object>(target: T, handler: ProxyHandler<T>): { proxy: T; revoke: () => void; };\n\n    /**\n     * Creates a Proxy object. The Proxy object allows you to create an object that can be used in place of the\n     * original object, but which may redefine fundamental Object operations like getting, setting, and defining\n     * properties. Proxy objects are commonly used to log property accesses, validate, format, or sanitize inputs.\n     * @param target A target object to wrap with Proxy.\n     * @param handler An object whose properties define the behavior of Proxy when an operation is attempted on it.\n     */\n    new <T extends object>(target: T, handler: ProxyHandler<T>): T;\n}\ndeclare var Proxy: ProxyConstructor;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2015.proxy.d.ts",
        "start": 1,
        "end": 128,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 128,
          "column": 2,
          "position": 494
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2015.proxy.d.ts",
        "start": 1,
        "end": 128,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 128,
          "column": 2,
          "position": 494
        }
      }
    },
    {
      "format": "typescript",
      "lines": 81,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\ninterface PromiseConstructor {\n    /**\n     * A reference to the prototype.\n     */\n    readonly prototype: Promise<any>;\n\n    /**\n     * Creates a new Promise.\n     * @param executor A callback used to initialize the promise. This callback is passed two arguments:\n     * a resolve callback used to resolve the promise with a value or the result of another promise,\n     * and a reject callback used to reject the promise with a provided reason or error.\n     */\n    new <T>(executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void): Promise<T>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T extends readonly unknown[] | []>(values: T): Promise<{ -readonly [P in keyof T]: Awaited<T[P]>; }>;\n\n    // see: lib.es2015.iterable.d.ts\n    // all<T>(values: Iterable<T | PromiseLike<T>>): Promise<Awaited<T>[]>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T extends readonly unknown[] | []>(values: T): Promise<Awaited<T[number]>>;\n\n    // see: lib.es2015.iterable.d.ts\n    // race<T>(values: Iterable<T | PromiseLike<T>>): Promise<Awaited<T>>;\n\n    /**\n     * Creates a new rejected promise for the provided reason.\n     * @param reason The reason the promise was rejected.\n     * @returns A new rejected Promise.\n     */\n    reject<T = never>(reason?: any): Promise<T>;\n\n    /**\n     * Creates a new resolved promise.\n     * @returns A resolved promise.\n     */\n    resolve(): Promise<void>;\n    /**\n     * Creates a new resolved promise for the provided value.\n     * @param value A promise.\n     * @returns A promise whose internal state matches the provided promise.\n     */\n    resolve<T>(value: T): Promise<Awaited<T>>;\n    /**\n     * Creates a new resolved promise for the provided value.\n     * @param value A promise.\n     * @returns A promise whose internal state matches the provided promise.\n     */\n    resolve<T>(value: T | PromiseLike<T>): Promise<Awaited<T>>;\n}\n\ndeclare var Promise: PromiseConstructor;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2015.promise.d.ts",
        "start": 1,
        "end": 81,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 81,
          "column": 2,
          "position": 319
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2015.promise.d.ts",
        "start": 1,
        "end": 81,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 81,
          "column": 2,
          "position": 319
        }
      }
    },
    {
      "format": "typescript",
      "lines": 605,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\n/// <reference lib=\"es2015.symbol\" />\n\ninterface SymbolConstructor {\n    /**\n     * A method that returns the default iterator for an object. Called by the semantics of the\n     * for-of statement.\n     */\n    readonly iterator: unique symbol;\n}\n\ninterface IteratorYieldResult<TYield> {\n    done?: false;\n    value: TYield;\n}\n\ninterface IteratorReturnResult<TReturn> {\n    done: true;\n    value: TReturn;\n}\n\ntype IteratorResult<T, TReturn = any> = IteratorYieldResult<T> | IteratorReturnResult<TReturn>;\n\ninterface Iterator<T, TReturn = any, TNext = any> {\n    // NOTE: 'next' is defined using a tuple to ensure we report the correct assignability errors in all places.\n    next(...[value]: [] | [TNext]): IteratorResult<T, TReturn>;\n    return?(value?: TReturn): IteratorResult<T, TReturn>;\n    throw?(e?: any): IteratorResult<T, TReturn>;\n}\n\ninterface Iterable<T, TReturn = any, TNext = any> {\n    [Symbol.iterator](): Iterator<T, TReturn, TNext>;\n}\n\n/**\n * Describes a user-defined {@link Iterator} that is also iterable.\n */\ninterface IterableIterator<T, TReturn = any, TNext = any> extends Iterator<T, TReturn, TNext> {\n    [Symbol.iterator](): IterableIterator<T, TReturn, TNext>;\n}\n\n/**\n * Describes an {@link Iterator} produced by the runtime that inherits from the intrinsic `Iterator.prototype`.\n */\ninterface IteratorObject<T, TReturn = unknown, TNext = unknown> extends Iterator<T, TReturn, TNext> {\n    [Symbol.iterator](): IteratorObject<T, TReturn, TNext>;\n}\n\n/**\n * Defines the `TReturn` type used for built-in iterators produced by `Array`, `Map`, `Set`, and others.\n * This is `undefined` when `strictBuiltInIteratorReturn` is `true`; otherwise, this is `any`.\n */\ntype BuiltinIteratorReturn = intrinsic;\n\ninterface ArrayIterator<T> extends IteratorObject<T, BuiltinIteratorReturn, unknown> {\n    [Symbol.iterator](): ArrayIterator<T>;\n}\n\ninterface Array<T> {\n    /** Iterator */\n    [Symbol.iterator](): ArrayIterator<T>;\n\n    /**\n     * Returns an iterable of key, value pairs for every entry in the array\n     */\n    entries(): ArrayIterator<[number, T]>;\n\n    /**\n     * Returns an iterable of keys in the array\n     */\n    keys(): ArrayIterator<number>;\n\n    /**\n     * Returns an iterable of values in the array\n     */\n    values(): ArrayIterator<T>;\n}\n\ninterface ArrayConstructor {\n    /**\n     * Creates an array from an iterable object.\n     * @param iterable An iterable object to convert to an array.\n     */\n    from<T>(iterable: Iterable<T> | ArrayLike<T>): T[];\n\n    /**\n     * Creates an array from an iterable object.\n     * @param iterable An iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from<T, U>(iterable: Iterable<T> | ArrayLike<T>, mapfn: (v: T, k: number) => U, thisArg?: any): U[];\n}\n\ninterface ReadonlyArray<T> {\n    /** Iterator of values in the array. */\n    [Symbol.iterator](): ArrayIterator<T>;\n\n    /**\n     * Returns an iterable of key, value pairs for every entry in the array\n     */\n    entries(): ArrayIterator<[number, T]>;\n\n    /**\n     * Returns an iterable of keys in the array\n     */\n    keys(): ArrayIterator<number>;\n\n    /**\n     * Returns an iterable of values in the array\n     */\n    values(): ArrayIterator<T>;\n}\n\ninterface IArguments {\n    /** Iterator */\n    [Symbol.iterator](): ArrayIterator<any>;\n}\n\ninterface MapIterator<T> extends IteratorObject<T, BuiltinIteratorReturn, unknown> {\n    [Symbol.iterator](): MapIterator<T>;\n}\n\ninterface Map<K, V> {\n    /** Returns an iterable of entries in the map. */\n    [Symbol.iterator](): MapIterator<[K, V]>;\n\n    /**\n     * Returns an iterable of key, value pairs for every entry in the map.\n     */\n    entries(): MapIterator<[K, V]>;\n\n    /**\n     * Returns an iterable of keys in the map\n     */\n    keys(): MapIterator<K>;\n\n    /**\n     * Returns an iterable of values in the map\n     */\n    values(): MapIterator<V>;\n}\n\ninterface ReadonlyMap<K, V> {\n    /** Returns an iterable of entries in the map. */\n    [Symbol.iterator](): MapIterator<[K, V]>;\n\n    /**\n     * Returns an iterable of key, value pairs for every entry in the map.\n     */\n    entries(): MapIterator<[K, V]>;\n\n    /**\n     * Returns an iterable of keys in the map\n     */\n    keys(): MapIterator<K>;\n\n    /**\n     * Returns an iterable of values in the map\n     */\n    values(): MapIterator<V>;\n}\n\ninterface MapConstructor {\n    new (): Map<any, any>;\n    new <K, V>(iterable?: Iterable<readonly [K, V]> | null): Map<K, V>;\n}\n\ninterface WeakMap<K extends WeakKey, V> {}\n\ninterface WeakMapConstructor {\n    new <K extends WeakKey, V>(iterable: Iterable<readonly [K, V]>): WeakMap<K, V>;\n}\n\ninterface SetIterator<T> extends IteratorObject<T, BuiltinIteratorReturn, unknown> {\n    [Symbol.iterator](): SetIterator<T>;\n}\n\ninterface Set<T> {\n    /** Iterates over values in the set. */\n    [Symbol.iterator](): SetIterator<T>;\n\n    /**\n     * Returns an iterable of [v,v] pairs for every value `v` in the set.\n     */\n    entries(): SetIterator<[T, T]>;\n\n    /**\n     * Despite its name, returns an iterable of the values in the set.\n     */\n    keys(): SetIterator<T>;\n\n    /**\n     * Returns an iterable of values in the set.\n     */\n    values(): SetIterator<T>;\n}\n\ninterface ReadonlySet<T> {\n    /** Iterates over values in the set. */\n    [Symbol.iterator](): SetIterator<T>;\n\n    /**\n     * Returns an iterable of [v,v] pairs for every value `v` in the set.\n     */\n    entries(): SetIterator<[T, T]>;\n\n    /**\n     * Despite its name, returns an iterable of the values in the set.\n     */\n    keys(): SetIterator<T>;\n\n    /**\n     * Returns an iterable of values in the set.\n     */\n    values(): SetIterator<T>;\n}\n\ninterface SetConstructor {\n    new <T>(iterable?: Iterable<T> | null): Set<T>;\n}\n\ninterface WeakSet<T extends WeakKey> {}\n\ninterface WeakSetConstructor {\n    new <T extends WeakKey = WeakKey>(iterable: Iterable<T>): WeakSet<T>;\n}\n\ninterface Promise<T> {}\n\ninterface PromiseConstructor {\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An iterable of Promises.\n     * @returns A new Promise.\n     */\n    all<T>(values: Iterable<T | PromiseLike<T>>): Promise<Awaited<T>[]>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An iterable of Promises.\n     * @returns A new Promise.\n     */\n    race<T>(values: Iterable<T | PromiseLike<T>>): Promise<Awaited<T>>;\n}\n\ninterface StringIterator<T> extends IteratorObject<T, BuiltinIteratorReturn, unknown> {\n    [Symbol.iterator](): StringIterator<T>;\n}\n\ninterface String {\n    /** Iterator */\n    [Symbol.iterator](): StringIterator<string>;\n}\n\ninterface Int8Array<TArrayBuffer extends ArrayBufferLike> {\n    [Symbol.iterator](): ArrayIterator<number>;\n\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): ArrayIterator<[number, number]>;\n\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): ArrayIterator<number>;\n\n    /**\n     * Returns an list of values in the array\n     */\n    values(): ArrayIterator<number>;\n}\n\ninterface Int8ArrayConstructor {\n    new (elements: Iterable<number>): Int8Array<ArrayBuffer>;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param elements An iterable object to convert to an array.\n     */\n    from(elements: Iterable<number>): Int8Array<ArrayBuffer>;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param elements An iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from<T>(elements: Iterable<T>, mapfn?: (v: T, k: number) => number, thisArg?: any): Int8Array<ArrayBuffer>;\n}\n\ninterface Uint8Array<TArrayBuffer extends ArrayBufferLike> {\n    [Symbol.iterator](): ArrayIterator<number>;\n\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): ArrayIterator<[number, number]>;\n\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): ArrayIterator<number>;\n\n    /**\n     * Returns an list of values in the array\n     */\n    values(): ArrayIterator<number>;\n}\n\ninterface Uint8ArrayConstructor {\n    new (elements: Iterable<number>): Uint8Array<ArrayBuffer>;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param elements An iterable object to convert to an array.\n     */\n    from(elements: Iterable<number>): Uint8Array<ArrayBuffer>;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param elements An iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from<T>(elements: Iterable<T>, mapfn?: (v: T, k: number) => number, thisArg?: any): Uint8Array<ArrayBuffer>;\n}\n\ninterface Uint8ClampedArray<TArrayBuffer extends ArrayBufferLike> {\n    [Symbol.iterator](): ArrayIterator<number>;\n\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): ArrayIterator<[number, number]>;\n\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): ArrayIterator<number>;\n\n    /**\n     * Returns an list of values in the array\n     */\n    values(): ArrayIterator<number>;\n}\n\ninterface Uint8ClampedArrayConstructor {\n    new (elements: Iterable<number>): Uint8ClampedArray<ArrayBuffer>;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param elements An iterable object to convert to an array.\n     */\n    from(elements: Iterable<number>): Uint8ClampedArray<ArrayBuffer>;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param elements An iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from<T>(elements: Iterable<T>, mapfn?: (v: T, k: number) => number, thisArg?: any): Uint8ClampedArray<ArrayBuffer>;\n}\n\ninterface Int16Array<TArrayBuffer extends ArrayBufferLike> {\n    [Symbol.iterator](): ArrayIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): ArrayIterator<[number, number]>;\n\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): ArrayIterator<number>;\n\n    /**\n     * Returns an list of values in the array\n     */\n    values(): ArrayIterator<number>;\n}\n\ninterface Int16ArrayConstructor {\n    new (elements: Iterable<number>): Int16Array<ArrayBuffer>;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param elements An iterable object to convert to an array.\n     */\n    from(elements: Iterable<number>): Int16Array<ArrayBuffer>;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param elements An iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from<T>(elements: Iterable<T>, mapfn?: (v: T, k: number) => number, thisArg?: any): Int16Array<ArrayBuffer>;\n}\n\ninterface Uint16Array<TArrayBuffer extends ArrayBufferLike> {\n    [Symbol.iterator](): ArrayIterator<number>;\n\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): ArrayIterator<[number, number]>;\n\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): ArrayIterator<number>;\n\n    /**\n     * Returns an list of values in the array\n     */\n    values(): ArrayIterator<number>;\n}\n\ninterface Uint16ArrayConstructor {\n    new (elements: Iterable<number>): Uint16Array<ArrayBuffer>;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param elements An iterable object to convert to an array.\n     */\n    from(elements: Iterable<number>): Uint16Array<ArrayBuffer>;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param elements An iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from<T>(elements: Iterable<T>, mapfn?: (v: T, k: number) => number, thisArg?: any): Uint16Array<ArrayBuffer>;\n}\n\ninterface Int32Array<TArrayBuffer extends ArrayBufferLike> {\n    [Symbol.iterator](): ArrayIterator<number>;\n\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): ArrayIterator<[number, number]>;\n\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): ArrayIterator<number>;\n\n    /**\n     * Returns an list of values in the array\n     */\n    values(): ArrayIterator<number>;\n}\n\ninterface Int32ArrayConstructor {\n    new (elements: Iterable<number>): Int32Array<ArrayBuffer>;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param elements An iterable object to convert to an array.\n     */\n    from(elements: Iterable<number>): Int32Array<ArrayBuffer>;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param elements An iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from<T>(elements: Iterable<T>, mapfn?: (v: T, k: number) => number, thisArg?: any): Int32Array<ArrayBuffer>;\n}\n\ninterface Uint32Array<TArrayBuffer extends ArrayBufferLike> {\n    [Symbol.iterator](): ArrayIterator<number>;\n\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): ArrayIterator<[number, number]>;\n\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): ArrayIterator<number>;\n\n    /**\n     * Returns an list of values in the array\n     */\n    values(): ArrayIterator<number>;\n}\n\ninterface Uint32ArrayConstructor {\n    new (elements: Iterable<number>): Uint32Array<ArrayBuffer>;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param elements An iterable object to convert to an array.\n     */\n    from(elements: Iterable<number>): Uint32Array<ArrayBuffer>;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param elements An iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from<T>(elements: Iterable<T>, mapfn?: (v: T, k: number) => number, thisArg?: any): Uint32Array<ArrayBuffer>;\n}\n\ninterface Float32Array<TArrayBuffer extends ArrayBufferLike> {\n    [Symbol.iterator](): ArrayIterator<number>;\n\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): ArrayIterator<[number, number]>;\n\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): ArrayIterator<number>;\n\n    /**\n     * Returns an list of values in the array\n     */\n    values(): ArrayIterator<number>;\n}\n\ninterface Float32ArrayConstructor {\n    new (elements: Iterable<number>): Float32Array<ArrayBuffer>;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param elements An iterable object to convert to an array.\n     */\n    from(elements: Iterable<number>): Float32Array<ArrayBuffer>;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param elements An iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from<T>(elements: Iterable<T>, mapfn?: (v: T, k: number) => number, thisArg?: any): Float32Array<ArrayBuffer>;\n}\n\ninterface Float64Array<TArrayBuffer extends ArrayBufferLike> {\n    [Symbol.iterator](): ArrayIterator<number>;\n\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): ArrayIterator<[number, number]>;\n\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): ArrayIterator<number>;\n\n    /**\n     * Returns an list of values in the array\n     */\n    values(): ArrayIterator<number>;\n}\n\ninterface Float64ArrayConstructor {\n    new (elements: Iterable<number>): Float64Array<ArrayBuffer>;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param elements An iterable object to convert to an array.\n     */\n    from(elements: Iterable<number>): Float64Array<ArrayBuffer>;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param elements An iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from<T>(elements: Iterable<T>, mapfn?: (v: T, k: number) => number, thisArg?: any): Float64Array<ArrayBuffer>;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2015.iterable.d.ts",
        "start": 1,
        "end": 605,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 605,
          "column": 2,
          "position": 3284
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2015.iterable.d.ts",
        "start": 1,
        "end": 605,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 605,
          "column": 2,
          "position": 3284
        }
      }
    },
    {
      "format": "typescript",
      "lines": 77,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\n/// <reference lib=\"es2015.iterable\" />\n\ninterface Generator<T = unknown, TReturn = any, TNext = any> extends IteratorObject<T, TReturn, TNext> {\n    // NOTE: 'next' is defined using a tuple to ensure we report the correct assignability errors in all places.\n    next(...[value]: [] | [TNext]): IteratorResult<T, TReturn>;\n    return(value: TReturn): IteratorResult<T, TReturn>;\n    throw(e: any): IteratorResult<T, TReturn>;\n    [Symbol.iterator](): Generator<T, TReturn, TNext>;\n}\n\ninterface GeneratorFunction {\n    /**\n     * Creates a new Generator object.\n     * @param args A list of arguments the function accepts.\n     */\n    new (...args: any[]): Generator;\n    /**\n     * Creates a new Generator object.\n     * @param args A list of arguments the function accepts.\n     */\n    (...args: any[]): Generator;\n    /**\n     * The length of the arguments.\n     */\n    readonly length: number;\n    /**\n     * Returns the name of the function.\n     */\n    readonly name: string;\n    /**\n     * A reference to the prototype.\n     */\n    readonly prototype: Generator;\n}\n\ninterface GeneratorFunctionConstructor {\n    /**\n     * Creates a new Generator function.\n     * @param args A list of arguments the function accepts.\n     */\n    new (...args: string[]): GeneratorFunction;\n    /**\n     * Creates a new Generator function.\n     * @param args A list of arguments the function accepts.\n     */\n    (...args: string[]): GeneratorFunction;\n    /**\n     * The length of the arguments.\n     */\n    readonly length: number;\n    /**\n     * Returns the name of the function.\n     */\n    readonly name: string;\n    /**\n     * A reference to the prototype.\n     */\n    readonly prototype: GeneratorFunction;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2015.generator.d.ts",
        "start": 1,
        "end": 77,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 77,
          "column": 2,
          "position": 308
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2015.generator.d.ts",
        "start": 1,
        "end": 77,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 77,
          "column": 2,
          "position": 308
        }
      }
    },
    {
      "format": "typescript",
      "lines": 597,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\ninterface Array<T> {\n    /**\n     * Returns the value of the first element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found, find\n     * immediately returns that element value. Otherwise, find returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    find<S extends T>(predicate: (value: T, index: number, obj: T[]) => value is S, thisArg?: any): S | undefined;\n    find(predicate: (value: T, index: number, obj: T[]) => unknown, thisArg?: any): T | undefined;\n\n    /**\n     * Returns the index of the first element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findIndex(predicate: (value: T, index: number, obj: T[]) => unknown, thisArg?: any): number;\n\n    /**\n     * Changes all array elements from `start` to `end` index to a static `value` and returns the modified array\n     * @param value value to fill array section with\n     * @param start index to start filling the array at. If start is negative, it is treated as\n     * length+start where length is the length of the array.\n     * @param end index to stop filling the array at. If end is negative, it is treated as\n     * length+end.\n     */\n    fill(value: T, start?: number, end?: number): this;\n\n    /**\n     * Returns the this object after copying a section of the array identified by start and end\n     * to the same array starting at position target\n     * @param target If target is negative, it is treated as length+target where length is the\n     * length of the array.\n     * @param start If start is negative, it is treated as length+start. If end is negative, it\n     * is treated as length+end.\n     * @param end If not specified, length of the this object is used as its default value.\n     */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    toLocaleString(locales: string | string[], options?: Intl.NumberFormatOptions & Intl.DateTimeFormatOptions): string;\n}\n\ninterface ArrayConstructor {\n    /**\n     * Creates an array from an array-like object.\n     * @param arrayLike An array-like object to convert to an array.\n     */\n    from<T>(arrayLike: ArrayLike<T>): T[];\n\n    /**\n     * Creates an array from an iterable object.\n     * @param arrayLike An array-like object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from<T, U>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => U, thisArg?: any): U[];\n\n    /**\n     * Returns a new array from a set of elements.\n     * @param items A set of elements to include in the new array object.\n     */\n    of<T>(...items: T[]): T[];\n}\n\ninterface DateConstructor {\n    new (value: number | string | Date): Date;\n}\n\ninterface Function {\n    /**\n     * Returns the name of the function. Function names are read-only and can not be changed.\n     */\n    readonly name: string;\n}\n\ninterface Math {\n    /**\n     * Returns the number of leading zero bits in the 32-bit binary representation of a number.\n     * @param x A numeric expression.\n     */\n    clz32(x: number): number;\n\n    /**\n     * Returns the result of 32-bit multiplication of two numbers.\n     * @param x First number\n     * @param y Second number\n     */\n    imul(x: number, y: number): number;\n\n    /**\n     * Returns the sign of the x, indicating whether x is positive, negative or zero.\n     * @param x The numeric expression to test\n     */\n    sign(x: number): number;\n\n    /**\n     * Returns the base 10 logarithm of a number.\n     * @param x A numeric expression.\n     */\n    log10(x: number): number;\n\n    /**\n     * Returns the base 2 logarithm of a number.\n     * @param x A numeric expression.\n     */\n    log2(x: number): number;\n\n    /**\n     * Returns the natural logarithm of 1 + x.\n     * @param x A numeric expression.\n     */\n    log1p(x: number): number;\n\n    /**\n     * Returns the result of (e^x - 1), which is an implementation-dependent approximation to\n     * subtracting 1 from the exponential function of x (e raised to the power of x, where e\n     * is the base of the natural logarithms).\n     * @param x A numeric expression.\n     */\n    expm1(x: number): number;\n\n    /**\n     * Returns the hyperbolic cosine of a number.\n     * @param x A numeric expression that contains an angle measured in radians.\n     */\n    cosh(x: number): number;\n\n    /**\n     * Returns the hyperbolic sine of a number.\n     * @param x A numeric expression that contains an angle measured in radians.\n     */\n    sinh(x: number): number;\n\n    /**\n     * Returns the hyperbolic tangent of a number.\n     * @param x A numeric expression that contains an angle measured in radians.\n     */\n    tanh(x: number): number;\n\n    /**\n     * Returns the inverse hyperbolic cosine of a number.\n     * @param x A numeric expression that contains an angle measured in radians.\n     */\n    acosh(x: number): number;\n\n    /**\n     * Returns the inverse hyperbolic sine of a number.\n     * @param x A numeric expression that contains an angle measured in radians.\n     */\n    asinh(x: number): number;\n\n    /**\n     * Returns the inverse hyperbolic tangent of a number.\n     * @param x A numeric expression that contains an angle measured in radians.\n     */\n    atanh(x: number): number;\n\n    /**\n     * Returns the square root of the sum of squares of its arguments.\n     * @param values Values to compute the square root for.\n     *     If no arguments are passed, the result is +0.\n     *     If there is only one argument, the result is the absolute value.\n     *     If any argument is +Infinity or -Infinity, the result is +Infinity.\n     *     If any argument is NaN, the result is NaN.\n     *     If all arguments are either +0 or 0, the result is +0.\n     */\n    hypot(...values: number[]): number;\n\n    /**\n     * Returns the integral part of the a numeric expression, x, removing any fractional digits.\n     * If x is already an integer, the result is x.\n     * @param x A numeric expression.\n     */\n    trunc(x: number): number;\n\n    /**\n     * Returns the nearest single precision float representation of a number.\n     * @param x A numeric expression.\n     */\n    fround(x: number): number;\n\n    /**\n     * Returns an implementation-dependent approximation to the cube root of number.\n     * @param x A numeric expression.\n     */\n    cbrt(x: number): number;\n}\n\ninterface NumberConstructor {\n    /**\n     * The value of Number.EPSILON is the difference between 1 and the smallest value greater than 1\n     * that is representable as a Number value, which is approximately:\n     * 2.2204460492503130808472633361816 x 1016.\n     */\n    readonly EPSILON: number;\n\n    /**\n     * Returns true if passed value is finite.\n     * Unlike the global isFinite, Number.isFinite doesn't forcibly convert the parameter to a\n     * number. Only finite values of the type number, result in true.\n     * @param number A numeric value.\n     */\n    isFinite(number: unknown): boolean;\n\n    /**\n     * Returns true if the value passed is an integer, false otherwise.\n     * @param number A numeric value.\n     */\n    isInteger(number: unknown): boolean;\n\n    /**\n     * Returns a Boolean value that indicates whether a value is the reserved value NaN (not a\n     * number). Unlike the global isNaN(), Number.isNaN() doesn't forcefully convert the parameter\n     * to a number. Only values of the type number, that are also NaN, result in true.\n     * @param number A numeric value.\n     */\n    isNaN(number: unknown): boolean;\n\n    /**\n     * Returns true if the value passed is a safe integer.\n     * @param number A numeric value.\n     */\n    isSafeInteger(number: unknown): boolean;\n\n    /**\n     * The value of the largest integer n such that n and n + 1 are both exactly representable as\n     * a Number value.\n     * The value of Number.MAX_SAFE_INTEGER is 9007199254740991 2^53  1.\n     */\n    readonly MAX_SAFE_INTEGER: number;\n\n    /**\n     * The value of the smallest integer n such that n and n  1 are both exactly representable as\n     * a Number value.\n     * The value of Number.MIN_SAFE_INTEGER is 9007199254740991 ((2^53  1)).\n     */\n    readonly MIN_SAFE_INTEGER: number;\n\n    /**\n     * Converts a string to a floating-point number.\n     * @param string A string that contains a floating-point number.\n     */\n    parseFloat(string: string): number;\n\n    /**\n     * Converts A string to an integer.\n     * @param string A string to convert into a number.\n     * @param radix A value between 2 and 36 that specifies the base of the number in `string`.\n     * If this argument is not supplied, strings with a prefix of '0x' are considered hexadecimal.\n     * All other strings are considered decimal.\n     */\n    parseInt(string: string, radix?: number): number;\n}\n\ninterface ObjectConstructor {\n    /**\n     * Copy the values of all of the enumerable own properties from one or more source objects to a\n     * target object. Returns the target object.\n     * @param target The target object to copy to.\n     * @param source The source object from which to copy properties.\n     */\n    assign<T extends {}, U>(target: T, source: U): T & U;\n\n    /**\n     * Copy the values of all of the enumerable own properties from one or more source objects to a\n     * target object. Returns the target object.\n     * @param target The target object to copy to.\n     * @param source1 The first source object from which to copy properties.\n     * @param source2 The second source object from which to copy properties.\n     */\n    assign<T extends {}, U, V>(target: T, source1: U, source2: V): T & U & V;\n\n    /**\n     * Copy the values of all of the enumerable own properties from one or more source objects to a\n     * target object. Returns the target object.\n     * @param target The target object to copy to.\n     * @param source1 The first source object from which to copy properties.\n     * @param source2 The second source object from which to copy properties.\n     * @param source3 The third source object from which to copy properties.\n     */\n    assign<T extends {}, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W;\n\n    /**\n     * Copy the values of all of the enumerable own properties from one or more source objects to a\n     * target object. Returns the target object.\n     * @param target The target object to copy to.\n     * @param sources One or more source objects from which to copy properties\n     */\n    assign(target: object, ...sources: any[]): any;\n\n    /**\n     * Returns an array of all symbol properties found directly on object o.\n     * @param o Object to retrieve the symbols from.\n     */\n    getOwnPropertySymbols(o: any): symbol[];\n\n    /**\n     * Returns the names of the enumerable string properties and methods of an object.\n     * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\n     */\n    keys(o: {}): string[];\n\n    /**\n     * Returns true if the values are the same value, false otherwise.\n     * @param value1 The first value.\n     * @param value2 The second value.\n     */\n    is(value1: any, value2: any): boolean;\n\n    /**\n     * Sets the prototype of a specified object o to object proto or null. Returns the object o.\n     * @param o The object to change its prototype.\n     * @param proto The value of the new prototype or null.\n     */\n    setPrototypeOf(o: any, proto: object | null): any;\n}\n\ninterface ReadonlyArray<T> {\n    /**\n     * Returns the value of the first element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found, find\n     * immediately returns that element value. Otherwise, find returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    find<S extends T>(predicate: (value: T, index: number, obj: readonly T[]) => value is S, thisArg?: any): S | undefined;\n    find(predicate: (value: T, index: number, obj: readonly T[]) => unknown, thisArg?: any): T | undefined;\n\n    /**\n     * Returns the index of the first element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findIndex(predicate: (value: T, index: number, obj: readonly T[]) => unknown, thisArg?: any): number;\n\n    toLocaleString(locales: string | string[], options?: Intl.NumberFormatOptions & Intl.DateTimeFormatOptions): string;\n}\n\ninterface RegExp {\n    /**\n     * Returns a string indicating the flags of the regular expression in question. This field is read-only.\n     * The characters in this string are sequenced and concatenated in the following order:\n     *\n     *    - \"g\" for global\n     *    - \"i\" for ignoreCase\n     *    - \"m\" for multiline\n     *    - \"u\" for unicode\n     *    - \"y\" for sticky\n     *\n     * If no flags are set, the value is the empty string.\n     */\n    readonly flags: string;\n\n    /**\n     * Returns a Boolean value indicating the state of the sticky flag (y) used with a regular\n     * expression. Default is false. Read-only.\n     */\n    readonly sticky: boolean;\n\n    /**\n     * Returns a Boolean value indicating the state of the Unicode flag (u) used with a regular\n     * expression. Default is false. Read-only.\n     */\n    readonly unicode: boolean;\n}\n\ninterface RegExpConstructor {\n    new (pattern: RegExp | string, flags?: string): RegExp;\n    (pattern: RegExp | string, flags?: string): RegExp;\n}\n\ninterface String {\n    /**\n     * Returns a nonnegative integer Number less than 1114112 (0x110000) that is the code point\n     * value of the UTF-16 encoded code point starting at the string element at position pos in\n     * the String resulting from converting this object to a String.\n     * If there is no element at that position, the result is undefined.\n     * If a valid UTF-16 surrogate pair does not begin at pos, the result is the code unit at pos.\n     */\n    codePointAt(pos: number): number | undefined;\n\n    /**\n     * Returns true if searchString appears as a substring of the result of converting this\n     * object to a String, at one or more positions that are\n     * greater than or equal to position; otherwise, returns false.\n     * @param searchString search string\n     * @param position If position is undefined, 0 is assumed, so as to search all of the String.\n     */\n    includes(searchString: string, position?: number): boolean;\n\n    /**\n     * Returns true if the sequence of elements of searchString converted to a String is the\n     * same as the corresponding elements of this object (converted to a String) starting at\n     * endPosition  length(this). Otherwise returns false.\n     */\n    endsWith(searchString: string, endPosition?: number): boolean;\n\n    /**\n     * Returns the String value result of normalizing the string into the normalization form\n     * named by form as specified in Unicode Standard Annex #15, Unicode Normalization Forms.\n     * @param form Applicable values: \"NFC\", \"NFD\", \"NFKC\", or \"NFKD\", If not specified default\n     * is \"NFC\"\n     */\n    normalize(form: \"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\"): string;\n\n    /**\n     * Returns the String value result of normalizing the string into the normalization form\n     * named by form as specified in Unicode Standard Annex #15, Unicode Normalization Forms.\n     * @param form Applicable values: \"NFC\", \"NFD\", \"NFKC\", or \"NFKD\", If not specified default\n     * is \"NFC\"\n     */\n    normalize(form?: string): string;\n\n    /**\n     * Returns a String value that is made from count copies appended together. If count is 0,\n     * the empty string is returned.\n     * @param count number of copies to append\n     */\n    repeat(count: number): string;\n\n    /**\n     * Returns true if the sequence of elements of searchString converted to a String is the\n     * same as the corresponding elements of this object (converted to a String) starting at\n     * position. Otherwise returns false.\n     */\n    startsWith(searchString: string, position?: number): boolean;\n\n    /**\n     * Returns an `<a>` HTML anchor element and sets the name attribute to the text value\n     * @deprecated A legacy feature for browser compatibility\n     * @param name\n     */\n    anchor(name: string): string;\n\n    /**\n     * Returns a `<big>` HTML element\n     * @deprecated A legacy feature for browser compatibility\n     */\n    big(): string;\n\n    /**\n     * Returns a `<blink>` HTML element\n     * @deprecated A legacy feature for browser compatibility\n     */\n    blink(): string;\n\n    /**\n     * Returns a `<b>` HTML element\n     * @deprecated A legacy feature for browser compatibility\n     */\n    bold(): string;\n\n    /**\n     * Returns a `<tt>` HTML element\n     * @deprecated A legacy feature for browser compatibility\n     */\n    fixed(): string;\n\n    /**\n     * Returns a `<font>` HTML element and sets the color attribute value\n     * @deprecated A legacy feature for browser compatibility\n     */\n    fontcolor(color: string): string;\n\n    /**\n     * Returns a `<font>` HTML element and sets the size attribute value\n     * @deprecated A legacy feature for browser compatibility\n     */\n    fontsize(size: number): string;\n\n    /**\n     * Returns a `<font>` HTML element and sets the size attribute value\n     * @deprecated A legacy feature for browser compatibility\n     */\n    fontsize(size: string): string;\n\n    /**\n     * Returns an `<i>` HTML element\n     * @deprecated A legacy feature for browser compatibility\n     */\n    italics(): string;\n\n    /**\n     * Returns an `<a>` HTML element and sets the href attribute value\n     * @deprecated A legacy feature for browser compatibility\n     */\n    link(url: string): string;\n\n    /**\n     * Returns a `<small>` HTML element\n     * @deprecated A legacy feature for browser compatibility\n     */\n    small(): string;\n\n    /**\n     * Returns a `<strike>` HTML element\n     * @deprecated A legacy feature for browser compatibility\n     */\n    strike(): string;\n\n    /**\n     * Returns a `<sub>` HTML element\n     * @deprecated A legacy feature for browser compatibility\n     */\n    sub(): string;\n\n    /**\n     * Returns a `<sup>` HTML element\n     * @deprecated A legacy feature for browser compatibility\n     */\n    sup(): string;\n}\n\ninterface StringConstructor {\n    /**\n     * Return the String value whose elements are, in order, the elements in the List elements.\n     * If length is 0, the empty string is returned.\n     */\n    fromCodePoint(...codePoints: number[]): string;\n\n    /**\n     * String.raw is usually used as a tag function of a Tagged Template String. When called as\n     * such, the first argument will be a well formed template call site object and the rest\n     * parameter will contain the substitution values. It can also be called directly, for example,\n     * to interleave strings and values from your own tag function, and in this case the only thing\n     * it needs from the first argument is the raw property.\n     * @param template A well-formed template string call site representation.\n     * @param substitutions A set of substitution values.\n     */\n    raw(template: { raw: readonly string[] | ArrayLike<string>; }, ...substitutions: any[]): string;\n}\n\ninterface Int8Array<TArrayBuffer extends ArrayBufferLike> {\n    toLocaleString(locales: string | string[], options?: Intl.NumberFormatOptions): string;\n}\n\ninterface Uint8Array<TArrayBuffer extends ArrayBufferLike> {\n    toLocaleString(locales: string | string[], options?: Intl.NumberFormatOptions): string;\n}\n\ninterface Uint8ClampedArray<TArrayBuffer extends ArrayBufferLike> {\n    toLocaleString(locales: string | string[], options?: Intl.NumberFormatOptions): string;\n}\n\ninterface Int16Array<TArrayBuffer extends ArrayBufferLike> {\n    toLocaleString(locales: string | string[], options?: Intl.NumberFormatOptions): string;\n}\n\ninterface Uint16Array<TArrayBuffer extends ArrayBufferLike> {\n    toLocaleString(locales: string | string[], options?: Intl.NumberFormatOptions): string;\n}\n\ninterface Int32Array<TArrayBuffer extends ArrayBufferLike> {\n    toLocaleString(locales: string | string[], options?: Intl.NumberFormatOptions): string;\n}\n\ninterface Uint32Array<TArrayBuffer extends ArrayBufferLike> {\n    toLocaleString(locales: string | string[], options?: Intl.NumberFormatOptions): string;\n}\n\ninterface Float32Array<TArrayBuffer extends ArrayBufferLike> {\n    toLocaleString(locales: string | string[], options?: Intl.NumberFormatOptions): string;\n}\n\ninterface Float64Array<TArrayBuffer extends ArrayBufferLike> {\n    toLocaleString(locales: string | string[], options?: Intl.NumberFormatOptions): string;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2015.core.d.ts",
        "start": 1,
        "end": 597,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 597,
          "column": 2,
          "position": 2319
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2015.core.d.ts",
        "start": 1,
        "end": 597,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 597,
          "column": 2,
          "position": 2319
        }
      }
    },
    {
      "format": "typescript",
      "lines": 147,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\ninterface Map<K, V> {\n    clear(): void;\n    /**\n     * @returns true if an element in the Map existed and has been removed, or false if the element does not exist.\n     */\n    delete(key: K): boolean;\n    /**\n     * Executes a provided function once per each key/value pair in the Map, in insertion order.\n     */\n    forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: any): void;\n    /**\n     * Returns a specified element from the Map object. If the value that is associated to the provided key is an object, then you will get a reference to that object and any change made to that object will effectively modify it inside the Map.\n     * @returns Returns the element associated with the specified key. If no element is associated with the specified key, undefined is returned.\n     */\n    get(key: K): V | undefined;\n    /**\n     * @returns boolean indicating whether an element with the specified key exists or not.\n     */\n    has(key: K): boolean;\n    /**\n     * Adds a new element with a specified key and value to the Map. If an element with the same key already exists, the element will be updated.\n     */\n    set(key: K, value: V): this;\n    /**\n     * @returns the number of elements in the Map.\n     */\n    readonly size: number;\n}\n\ninterface MapConstructor {\n    new (): Map<any, any>;\n    new <K, V>(entries?: readonly (readonly [K, V])[] | null): Map<K, V>;\n    readonly prototype: Map<any, any>;\n}\ndeclare var Map: MapConstructor;\n\ninterface ReadonlyMap<K, V> {\n    forEach(callbackfn: (value: V, key: K, map: ReadonlyMap<K, V>) => void, thisArg?: any): void;\n    get(key: K): V | undefined;\n    has(key: K): boolean;\n    readonly size: number;\n}\n\ninterface WeakMap<K extends WeakKey, V> {\n    /**\n     * Removes the specified element from the WeakMap.\n     * @returns true if the element was successfully removed, or false if it was not present.\n     */\n    delete(key: K): boolean;\n    /**\n     * @returns a specified element.\n     */\n    get(key: K): V | undefined;\n    /**\n     * @returns a boolean indicating whether an element with the specified key exists or not.\n     */\n    has(key: K): boolean;\n    /**\n     * Adds a new element with a specified key and value.\n     * @param key Must be an object or symbol.\n     */\n    set(key: K, value: V): this;\n}\n\ninterface WeakMapConstructor {\n    new <K extends WeakKey = WeakKey, V = any>(entries?: readonly (readonly [K, V])[] | null): WeakMap<K, V>;\n    readonly prototype: WeakMap<WeakKey, any>;\n}\ndeclare var WeakMap: WeakMapConstructor;\n\ninterface Set<T> {\n    /**\n     * Appends a new element with a specified value to the end of the Set.\n     */\n    add(value: T): this;\n\n    clear(): void;\n    /**\n     * Removes a specified value from the Set.\n     * @returns Returns true if an element in the Set existed and has been removed, or false if the element does not exist.\n     */\n    delete(value: T): boolean;\n    /**\n     * Executes a provided function once per each value in the Set object, in insertion order.\n     */\n    forEach(callbackfn: (value: T, value2: T, set: Set<T>) => void, thisArg?: any): void;\n    /**\n     * @returns a boolean indicating whether an element with the specified value exists in the Set or not.\n     */\n    has(value: T): boolean;\n    /**\n     * @returns the number of (unique) elements in Set.\n     */\n    readonly size: number;\n}\n\ninterface SetConstructor {\n    new <T = any>(values?: readonly T[] | null): Set<T>;\n    readonly prototype: Set<any>;\n}\ndeclare var Set: SetConstructor;\n\ninterface ReadonlySet<T> {\n    forEach(callbackfn: (value: T, value2: T, set: ReadonlySet<T>) => void, thisArg?: any): void;\n    has(value: T): boolean;\n    readonly size: number;\n}\n\ninterface WeakSet<T extends WeakKey> {\n    /**\n     * Appends a new value to the end of the WeakSet.\n     */\n    add(value: T): this;\n    /**\n     * Removes the specified element from the WeakSet.\n     * @returns Returns true if the element existed and has been removed, or false if the element does not exist.\n     */\n    delete(value: T): boolean;\n    /**\n     * @returns a boolean indicating whether a value exists in the WeakSet or not.\n     */\n    has(value: T): boolean;\n}\n\ninterface WeakSetConstructor {\n    new <T extends WeakKey = WeakKey>(values?: readonly T[] | null): WeakSet<T>;\n    readonly prototype: WeakSet<WeakKey>;\n}\ndeclare var WeakSet: WeakSetConstructor;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.es2015.collection.d.ts",
        "start": 1,
        "end": 147,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 147,
          "column": 2,
          "position": 945
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.es2015.collection.d.ts",
        "start": 1,
        "end": 147,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 147,
          "column": 2,
          "position": 945
        }
      }
    },
    {
      "format": "typescript",
      "lines": 571,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\n/////////////////////////////\n/// Window Iterable APIs\n/////////////////////////////\n\ninterface AudioParam {\n    /**\n     * The **`setValueCurveAtTime()`** method of the following a curve defined by a list of values.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/AudioParam/setValueCurveAtTime)\n     */\n    setValueCurveAtTime(values: Iterable<number>, startTime: number, duration: number): AudioParam;\n}\n\ninterface AudioParamMap extends ReadonlyMap<string, AudioParam> {\n}\n\ninterface BaseAudioContext {\n    /**\n     * The **`createIIRFilter()`** method of the BaseAudioContext interface creates an IIRFilterNode, which represents a general **infinite impulse response** (IIR) filter which can be configured to serve as various types of filter.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/BaseAudioContext/createIIRFilter)\n     */\n    createIIRFilter(feedforward: Iterable<number>, feedback: Iterable<number>): IIRFilterNode;\n    /**\n     * The `createPeriodicWave()` method of the BaseAudioContext interface is used to create a PeriodicWave.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/BaseAudioContext/createPeriodicWave)\n     */\n    createPeriodicWave(real: Iterable<number>, imag: Iterable<number>, constraints?: PeriodicWaveConstraints): PeriodicWave;\n}\n\ninterface CSSKeyframesRule {\n    [Symbol.iterator](): ArrayIterator<CSSKeyframeRule>;\n}\n\ninterface CSSNumericArray {\n    [Symbol.iterator](): ArrayIterator<CSSNumericValue>;\n    entries(): ArrayIterator<[number, CSSNumericValue]>;\n    keys(): ArrayIterator<number>;\n    values(): ArrayIterator<CSSNumericValue>;\n}\n\ninterface CSSRuleList {\n    [Symbol.iterator](): ArrayIterator<CSSRule>;\n}\n\ninterface CSSStyleDeclaration {\n    [Symbol.iterator](): ArrayIterator<string>;\n}\n\ninterface CSSTransformValue {\n    [Symbol.iterator](): ArrayIterator<CSSTransformComponent>;\n    entries(): ArrayIterator<[number, CSSTransformComponent]>;\n    keys(): ArrayIterator<number>;\n    values(): ArrayIterator<CSSTransformComponent>;\n}\n\ninterface CSSUnparsedValue {\n    [Symbol.iterator](): ArrayIterator<CSSUnparsedSegment>;\n    entries(): ArrayIterator<[number, CSSUnparsedSegment]>;\n    keys(): ArrayIterator<number>;\n    values(): ArrayIterator<CSSUnparsedSegment>;\n}\n\ninterface Cache {\n    /**\n     * The **`addAll()`** method of the Cache interface takes an array of URLs, retrieves them, and adds the resulting response objects to the given cache.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Cache/addAll)\n     */\n    addAll(requests: Iterable<RequestInfo>): Promise<void>;\n}\n\ninterface CanvasPath {\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/roundRect) */\n    roundRect(x: number, y: number, w: number, h: number, radii?: number | DOMPointInit | Iterable<number | DOMPointInit>): void;\n}\n\ninterface CanvasPathDrawingStyles {\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash) */\n    setLineDash(segments: Iterable<number>): void;\n}\n\ninterface CookieStoreManager {\n    /**\n     * The **`subscribe()`** method of the CookieStoreManager interface subscribes a ServiceWorkerRegistration to cookie change events.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/CookieStoreManager/subscribe)\n     */\n    subscribe(subscriptions: Iterable<CookieStoreGetOptions>): Promise<void>;\n    /**\n     * The **`unsubscribe()`** method of the CookieStoreManager interface stops the ServiceWorkerRegistration from receiving previously subscribed events.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/CookieStoreManager/unsubscribe)\n     */\n    unsubscribe(subscriptions: Iterable<CookieStoreGetOptions>): Promise<void>;\n}\n\ninterface CustomStateSet extends Set<string> {\n}\n\ninterface DOMRectList {\n    [Symbol.iterator](): ArrayIterator<DOMRect>;\n}\n\ninterface DOMStringList {\n    [Symbol.iterator](): ArrayIterator<string>;\n}\n\ninterface DOMTokenList {\n    [Symbol.iterator](): ArrayIterator<string>;\n    entries(): ArrayIterator<[number, string]>;\n    keys(): ArrayIterator<number>;\n    values(): ArrayIterator<string>;\n}\n\ninterface DataTransferItemList {\n    [Symbol.iterator](): ArrayIterator<DataTransferItem>;\n}\n\ninterface EventCounts extends ReadonlyMap<string, number> {\n}\n\ninterface FileList {\n    [Symbol.iterator](): ArrayIterator<File>;\n}\n\ninterface FontFaceSet extends Set<FontFace> {\n}\n\ninterface FormDataIterator<T> extends IteratorObject<T, BuiltinIteratorReturn, unknown> {\n    [Symbol.iterator](): FormDataIterator<T>;\n}\n\ninterface FormData {\n    [Symbol.iterator](): FormDataIterator<[string, FormDataEntryValue]>;\n    /** Returns an array of key, value pairs for every entry in the list. */\n    entries(): FormDataIterator<[string, FormDataEntryValue]>;\n    /** Returns a list of keys in the list. */\n    keys(): FormDataIterator<string>;\n    /** Returns a list of values in the list. */\n    values(): FormDataIterator<FormDataEntryValue>;\n}\n\ninterface HTMLAllCollection {\n    [Symbol.iterator](): ArrayIterator<Element>;\n}\n\ninterface HTMLCollectionBase {\n    [Symbol.iterator](): ArrayIterator<Element>;\n}\n\ninterface HTMLCollectionOf<T extends Element> {\n    [Symbol.iterator](): ArrayIterator<T>;\n}\n\ninterface HTMLFormElement {\n    [Symbol.iterator](): ArrayIterator<Element>;\n}\n\ninterface HTMLSelectElement {\n    [Symbol.iterator](): ArrayIterator<HTMLOptionElement>;\n}\n\ninterface HeadersIterator<T> extends IteratorObject<T, BuiltinIteratorReturn, unknown> {\n    [Symbol.iterator](): HeadersIterator<T>;\n}\n\ninterface Headers {\n    [Symbol.iterator](): HeadersIterator<[string, string]>;\n    /** Returns an iterator allowing to go through all key/value pairs contained in this object. */\n    entries(): HeadersIterator<[string, string]>;\n    /** Returns an iterator allowing to go through all keys of the key/value pairs contained in this object. */\n    keys(): HeadersIterator<string>;\n    /** Returns an iterator allowing to go through all values of the key/value pairs contained in this object. */\n    values(): HeadersIterator<string>;\n}\n\ninterface Highlight extends Set<AbstractRange> {\n}\n\ninterface HighlightRegistry extends Map<string, Highlight> {\n}\n\ninterface IDBDatabase {\n    /**\n     * The **`transaction`** method of the IDBDatabase interface immediately returns a transaction object (IDBTransaction) containing the IDBTransaction.objectStore method, which you can use to access your object store.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBDatabase/transaction)\n     */\n    transaction(storeNames: string | Iterable<string>, mode?: IDBTransactionMode, options?: IDBTransactionOptions): IDBTransaction;\n}\n\ninterface IDBObjectStore {\n    /**\n     * The **`createIndex()`** method of the field/column defining a new data point for each database record to contain.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBObjectStore/createIndex)\n     */\n    createIndex(name: string, keyPath: string | Iterable<string>, options?: IDBIndexParameters): IDBIndex;\n}\n\ninterface ImageTrackList {\n    [Symbol.iterator](): ArrayIterator<ImageTrack>;\n}\n\ninterface MIDIInputMap extends ReadonlyMap<string, MIDIInput> {\n}\n\ninterface MIDIOutput {\n    /**\n     * The **`send()`** method of the MIDIOutput interface queues messages for the corresponding MIDI port.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/MIDIOutput/send)\n     */\n    send(data: Iterable<number>, timestamp?: DOMHighResTimeStamp): void;\n}\n\ninterface MIDIOutputMap extends ReadonlyMap<string, MIDIOutput> {\n}\n\ninterface MediaKeyStatusMapIterator<T> extends IteratorObject<T, BuiltinIteratorReturn, unknown> {\n    [Symbol.iterator](): MediaKeyStatusMapIterator<T>;\n}\n\ninterface MediaKeyStatusMap {\n    [Symbol.iterator](): MediaKeyStatusMapIterator<[BufferSource, MediaKeyStatus]>;\n    entries(): MediaKeyStatusMapIterator<[BufferSource, MediaKeyStatus]>;\n    keys(): MediaKeyStatusMapIterator<BufferSource>;\n    values(): MediaKeyStatusMapIterator<MediaKeyStatus>;\n}\n\ninterface MediaList {\n    [Symbol.iterator](): ArrayIterator<string>;\n}\n\ninterface MessageEvent<T = any> {\n    /** @deprecated */\n    initMessageEvent(type: string, bubbles?: boolean, cancelable?: boolean, data?: any, origin?: string, lastEventId?: string, source?: MessageEventSource | null, ports?: Iterable<MessagePort>): void;\n}\n\ninterface MimeTypeArray {\n    [Symbol.iterator](): ArrayIterator<MimeType>;\n}\n\ninterface NamedNodeMap {\n    [Symbol.iterator](): ArrayIterator<Attr>;\n}\n\ninterface Navigator {\n    /**\n     * The **`requestMediaKeySystemAccess()`** method of the Navigator interface returns a Promise which delivers a MediaKeySystemAccess object that can be used to access a particular media key system, which can in turn be used to create keys for decrypting a media stream.\n     * Available only in secure contexts.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Navigator/requestMediaKeySystemAccess)\n     */\n    requestMediaKeySystemAccess(keySystem: string, supportedConfigurations: Iterable<MediaKeySystemConfiguration>): Promise<MediaKeySystemAccess>;\n    /**\n     * The **`vibrate()`** method of the Navigator interface pulses the vibration hardware on the device, if such hardware exists.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Navigator/vibrate)\n     */\n    vibrate(pattern: Iterable<number>): boolean;\n}\n\ninterface NodeList {\n    [Symbol.iterator](): ArrayIterator<Node>;\n    /** Returns an array of key, value pairs for every entry in the list. */\n    entries(): ArrayIterator<[number, Node]>;\n    /** Returns an list of keys in the list. */\n    keys(): ArrayIterator<number>;\n    /** Returns an list of values in the list. */\n    values(): ArrayIterator<Node>;\n}\n\ninterface NodeListOf<TNode extends Node> {\n    [Symbol.iterator](): ArrayIterator<TNode>;\n    /** Returns an array of key, value pairs for every entry in the list. */\n    entries(): ArrayIterator<[number, TNode]>;\n    /** Returns an list of keys in the list. */\n    keys(): ArrayIterator<number>;\n    /** Returns an list of values in the list. */\n    values(): ArrayIterator<TNode>;\n}\n\ninterface Plugin {\n    [Symbol.iterator](): ArrayIterator<MimeType>;\n}\n\ninterface PluginArray {\n    [Symbol.iterator](): ArrayIterator<Plugin>;\n}\n\ninterface RTCRtpTransceiver {\n    /**\n     * The **`setCodecPreferences()`** method of the RTCRtpTransceiver interface is used to set the codecs that the transceiver allows for decoding _received_ data, in order of decreasing preference.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCRtpTransceiver/setCodecPreferences)\n     */\n    setCodecPreferences(codecs: Iterable<RTCRtpCodec>): void;\n}\n\ninterface RTCStatsReport extends ReadonlyMap<string, any> {\n}\n\ninterface SVGLengthList {\n    [Symbol.iterator](): ArrayIterator<SVGLength>;\n}\n\ninterface SVGNumberList {\n    [Symbol.iterator](): ArrayIterator<SVGNumber>;\n}\n\ninterface SVGPointList {\n    [Symbol.iterator](): ArrayIterator<DOMPoint>;\n}\n\ninterface SVGStringList {\n    [Symbol.iterator](): ArrayIterator<string>;\n}\n\ninterface SVGTransformList {\n    [Symbol.iterator](): ArrayIterator<SVGTransform>;\n}\n\ninterface SourceBufferList {\n    [Symbol.iterator](): ArrayIterator<SourceBuffer>;\n}\n\ninterface SpeechRecognitionResult {\n    [Symbol.iterator](): ArrayIterator<SpeechRecognitionAlternative>;\n}\n\ninterface SpeechRecognitionResultList {\n    [Symbol.iterator](): ArrayIterator<SpeechRecognitionResult>;\n}\n\ninterface StylePropertyMapReadOnlyIterator<T> extends IteratorObject<T, BuiltinIteratorReturn, unknown> {\n    [Symbol.iterator](): StylePropertyMapReadOnlyIterator<T>;\n}\n\ninterface StylePropertyMapReadOnly {\n    [Symbol.iterator](): StylePropertyMapReadOnlyIterator<[string, Iterable<CSSStyleValue>]>;\n    entries(): StylePropertyMapReadOnlyIterator<[string, Iterable<CSSStyleValue>]>;\n    keys(): StylePropertyMapReadOnlyIterator<string>;\n    values(): StylePropertyMapReadOnlyIterator<Iterable<CSSStyleValue>>;\n}\n\ninterface StyleSheetList {\n    [Symbol.iterator](): ArrayIterator<CSSStyleSheet>;\n}\n\ninterface SubtleCrypto {\n    /**\n     * The **`deriveKey()`** method of the SubtleCrypto interface can be used to derive a secret key from a master key.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/deriveKey)\n     */\n    deriveKey(algorithm: AlgorithmIdentifier | EcdhKeyDeriveParams | HkdfParams | Pbkdf2Params, baseKey: CryptoKey, derivedKeyType: AlgorithmIdentifier | AesDerivedKeyParams | HmacImportParams | HkdfParams | Pbkdf2Params, extractable: boolean, keyUsages: Iterable<KeyUsage>): Promise<CryptoKey>;\n    /**\n     * The **`generateKey()`** method of the SubtleCrypto interface is used to generate a new key (for symmetric algorithms) or key pair (for public-key algorithms).\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/generateKey)\n     */\n    generateKey(algorithm: \"Ed25519\" | { name: \"Ed25519\" }, extractable: boolean, keyUsages: ReadonlyArray<\"sign\" | \"verify\">): Promise<CryptoKeyPair>;\n    generateKey(algorithm: RsaHashedKeyGenParams | EcKeyGenParams, extractable: boolean, keyUsages: ReadonlyArray<KeyUsage>): Promise<CryptoKeyPair>;\n    generateKey(algorithm: AesKeyGenParams | HmacKeyGenParams | Pbkdf2Params, extractable: boolean, keyUsages: ReadonlyArray<KeyUsage>): Promise<CryptoKey>;\n    generateKey(algorithm: AlgorithmIdentifier, extractable: boolean, keyUsages: Iterable<KeyUsage>): Promise<CryptoKeyPair | CryptoKey>;\n    /**\n     * The **`importKey()`** method of the SubtleCrypto interface imports a key: that is, it takes as input a key in an external, portable format and gives you a CryptoKey object that you can use in the Web Crypto API.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/importKey)\n     */\n    importKey(format: \"jwk\", keyData: JsonWebKey, algorithm: AlgorithmIdentifier | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | AesKeyAlgorithm, extractable: boolean, keyUsages: ReadonlyArray<KeyUsage>): Promise<CryptoKey>;\n    importKey(format: Exclude<KeyFormat, \"jwk\">, keyData: BufferSource, algorithm: AlgorithmIdentifier | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | AesKeyAlgorithm, extractable: boolean, keyUsages: Iterable<KeyUsage>): Promise<CryptoKey>;\n    /**\n     * The **`unwrapKey()`** method of the SubtleCrypto interface 'unwraps' a key.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/unwrapKey)\n     */\n    unwrapKey(format: KeyFormat, wrappedKey: BufferSource, unwrappingKey: CryptoKey, unwrapAlgorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams, unwrappedKeyAlgorithm: AlgorithmIdentifier | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | AesKeyAlgorithm, extractable: boolean, keyUsages: Iterable<KeyUsage>): Promise<CryptoKey>;\n}\n\ninterface TextTrackCueList {\n    [Symbol.iterator](): ArrayIterator<TextTrackCue>;\n}\n\ninterface TextTrackList {\n    [Symbol.iterator](): ArrayIterator<TextTrack>;\n}\n\ninterface TouchList {\n    [Symbol.iterator](): ArrayIterator<Touch>;\n}\n\ninterface URLSearchParamsIterator<T> extends IteratorObject<T, BuiltinIteratorReturn, unknown> {\n    [Symbol.iterator](): URLSearchParamsIterator<T>;\n}\n\ninterface URLSearchParams {\n    [Symbol.iterator](): URLSearchParamsIterator<[string, string]>;\n    /** Returns an array of key, value pairs for every entry in the search params. */\n    entries(): URLSearchParamsIterator<[string, string]>;\n    /** Returns a list of keys in the search params. */\n    keys(): URLSearchParamsIterator<string>;\n    /** Returns a list of values in the search params. */\n    values(): URLSearchParamsIterator<string>;\n}\n\ninterface ViewTransitionTypeSet extends Set<string> {\n}\n\ninterface WEBGL_draw_buffers {\n    /**\n     * The **`WEBGL_draw_buffers.drawBuffersWEBGL()`** method is part of the WebGL API and allows you to define the draw buffers to which all fragment colors are written.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_draw_buffers/drawBuffersWEBGL)\n     */\n    drawBuffersWEBGL(buffers: Iterable<GLenum>): void;\n}\n\ninterface WEBGL_multi_draw {\n    /**\n     * The **`WEBGL_multi_draw.multiDrawArraysInstancedWEBGL()`** method of the WebGL API renders multiple primitives from array data.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_multi_draw/multiDrawArraysInstancedWEBGL)\n     */\n    multiDrawArraysInstancedWEBGL(mode: GLenum, firstsList: Int32Array<ArrayBufferLike> | Iterable<GLint>, firstsOffset: number, countsList: Int32Array<ArrayBufferLike> | Iterable<GLsizei>, countsOffset: number, instanceCountsList: Int32Array<ArrayBufferLike> | Iterable<GLsizei>, instanceCountsOffset: number, drawcount: GLsizei): void;\n    /**\n     * The **`WEBGL_multi_draw.multiDrawArraysWEBGL()`** method of the WebGL API renders multiple primitives from array data.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_multi_draw/multiDrawArraysWEBGL)\n     */\n    multiDrawArraysWEBGL(mode: GLenum, firstsList: Int32Array<ArrayBufferLike> | Iterable<GLint>, firstsOffset: number, countsList: Int32Array<ArrayBufferLike> | Iterable<GLsizei>, countsOffset: number, drawcount: GLsizei): void;\n    /**\n     * The **`WEBGL_multi_draw.multiDrawElementsInstancedWEBGL()`** method of the WebGL API renders multiple primitives from array data.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_multi_draw/multiDrawElementsInstancedWEBGL)\n     */\n    multiDrawElementsInstancedWEBGL(mode: GLenum, countsList: Int32Array<ArrayBufferLike> | Iterable<GLsizei>, countsOffset: number, type: GLenum, offsetsList: Int32Array<ArrayBufferLike> | Iterable<GLsizei>, offsetsOffset: number, instanceCountsList: Int32Array<ArrayBufferLike> | Iterable<GLsizei>, instanceCountsOffset: number, drawcount: GLsizei): void;\n    /**\n     * The **`WEBGL_multi_draw.multiDrawElementsWEBGL()`** method of the WebGL API renders multiple primitives from array data.\n     *\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_multi_draw/multiDrawElementsWEBGL)\n     */\n    multiDrawElementsWEBGL(mode: GLenum, countsList: Int32Array<ArrayBufferLike> | Iterable<GLsizei>, countsOffset: number, type: GLenum, offsetsList: Int32Array<ArrayBufferLike> | Iterable<GLsizei>, offsetsOffset: number, drawcount: GLsizei): void;\n}\n\ninterface WebGL2RenderingContextBase {\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/clearBuffer) */\n    clearBufferfv(buffer: GLenum, drawbuffer: GLint, values: Iterable<GLfloat>, srcOffset?: number): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/clearBuffer) */\n    clearBufferiv(buffer: GLenum, drawbuffer: GLint, values: Iterable<GLint>, srcOffset?: number): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/clearBuffer) */\n    clearBufferuiv(buffer: GLenum, drawbuffer: GLint, values: Iterable<GLuint>, srcOffset?: number): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/drawBuffers) */\n    drawBuffers(buffers: Iterable<GLenum>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/getActiveUniforms) */\n    getActiveUniforms(program: WebGLProgram, uniformIndices: Iterable<GLuint>, pname: GLenum): any;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/getUniformIndices) */\n    getUniformIndices(program: WebGLProgram, uniformNames: Iterable<string>): GLuint[] | null;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/invalidateFramebuffer) */\n    invalidateFramebuffer(target: GLenum, attachments: Iterable<GLenum>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/invalidateSubFramebuffer) */\n    invalidateSubFramebuffer(target: GLenum, attachments: Iterable<GLenum>, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/transformFeedbackVaryings) */\n    transformFeedbackVaryings(program: WebGLProgram, varyings: Iterable<string>, bufferMode: GLenum): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniform) */\n    uniform1uiv(location: WebGLUniformLocation | null, data: Iterable<GLuint>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniform) */\n    uniform2uiv(location: WebGLUniformLocation | null, data: Iterable<GLuint>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniform) */\n    uniform3uiv(location: WebGLUniformLocation | null, data: Iterable<GLuint>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniform) */\n    uniform4uiv(location: WebGLUniformLocation | null, data: Iterable<GLuint>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniformMatrix) */\n    uniformMatrix2x3fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniformMatrix) */\n    uniformMatrix2x4fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniformMatrix) */\n    uniformMatrix3x2fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniformMatrix) */\n    uniformMatrix3x4fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniformMatrix) */\n    uniformMatrix4x2fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniformMatrix) */\n    uniformMatrix4x3fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/vertexAttribI) */\n    vertexAttribI4iv(index: GLuint, values: Iterable<GLint>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/vertexAttribI) */\n    vertexAttribI4uiv(index: GLuint, values: Iterable<GLuint>): void;\n}\n\ninterface WebGL2RenderingContextOverloads {\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform1fv(location: WebGLUniformLocation | null, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform1iv(location: WebGLUniformLocation | null, data: Iterable<GLint>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform2fv(location: WebGLUniformLocation | null, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform2iv(location: WebGLUniformLocation | null, data: Iterable<GLint>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform3fv(location: WebGLUniformLocation | null, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform3iv(location: WebGLUniformLocation | null, data: Iterable<GLint>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform4fv(location: WebGLUniformLocation | null, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform4iv(location: WebGLUniformLocation | null, data: Iterable<GLint>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext/uniformMatrix) */\n    uniformMatrix2fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniformMatrix) */\n    uniformMatrix3fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniformMatrix) */\n    uniformMatrix4fv(location: WebGLUniformLocation | null, transpose: GLboolean, data: Iterable<GLfloat>, srcOffset?: number, srcLength?: GLuint): void;\n}\n\ninterface WebGLRenderingContextBase {\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/vertexAttrib) */\n    vertexAttrib1fv(index: GLuint, values: Iterable<GLfloat>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/vertexAttrib) */\n    vertexAttrib2fv(index: GLuint, values: Iterable<GLfloat>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/vertexAttrib) */\n    vertexAttrib3fv(index: GLuint, values: Iterable<GLfloat>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/vertexAttrib) */\n    vertexAttrib4fv(index: GLuint, values: Iterable<GLfloat>): void;\n}\n\ninterface WebGLRenderingContextOverloads {\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform1fv(location: WebGLUniformLocation | null, v: Iterable<GLfloat>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform1iv(location: WebGLUniformLocation | null, v: Iterable<GLint>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform2fv(location: WebGLUniformLocation | null, v: Iterable<GLfloat>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform2iv(location: WebGLUniformLocation | null, v: Iterable<GLint>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform3fv(location: WebGLUniformLocation | null, v: Iterable<GLfloat>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform3iv(location: WebGLUniformLocation | null, v: Iterable<GLint>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform4fv(location: WebGLUniformLocation | null, v: Iterable<GLfloat>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniform) */\n    uniform4iv(location: WebGLUniformLocation | null, v: Iterable<GLint>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniformMatrix) */\n    uniformMatrix2fv(location: WebGLUniformLocation | null, transpose: GLboolean, value: Iterable<GLfloat>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniformMatrix) */\n    uniformMatrix3fv(location: WebGLUniformLocation | null, transpose: GLboolean, value: Iterable<GLfloat>): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext/uniformMatrix) */\n    uniformMatrix4fv(location: WebGLUniformLocation | null, transpose: GLboolean, value: Iterable<GLfloat>): void;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.dom.iterable.d.ts",
        "start": 1,
        "end": 571,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 571,
          "column": 2,
          "position": 5144
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.dom.iterable.d.ts",
        "start": 1,
        "end": 340,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 340,
          "column": 2,
          "position": 3734
        }
      }
    },
    {
      "format": "typescript",
      "lines": 41,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\n/////////////////////////////\n/// Window Async Iterable APIs\n/////////////////////////////\n\ninterface FileSystemDirectoryHandleAsyncIterator<T> extends AsyncIteratorObject<T, BuiltinIteratorReturn, unknown> {\n    [Symbol.asyncIterator](): FileSystemDirectoryHandleAsyncIterator<T>;\n}\n\ninterface FileSystemDirectoryHandle {\n    [Symbol.asyncIterator](): FileSystemDirectoryHandleAsyncIterator<[string, FileSystemHandle]>;\n    entries(): FileSystemDirectoryHandleAsyncIterator<[string, FileSystemHandle]>;\n    keys(): FileSystemDirectoryHandleAsyncIterator<string>;\n    values(): FileSystemDirectoryHandleAsyncIterator<FileSystemHandle>;\n}\n\ninterface ReadableStreamAsyncIterator<T> extends AsyncIteratorObject<T, BuiltinIteratorReturn, unknown> {\n    [Symbol.asyncIterator](): ReadableStreamAsyncIterator<T>;\n}\n\ninterface ReadableStream<R = any> {\n    [Symbol.asyncIterator](options?: ReadableStreamIteratorOptions): ReadableStreamAsyncIterator<R>;\n    values(options?: ReadableStreamIteratorOptions): ReadableStreamAsyncIterator<R>;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.dom.asynciterable.d.ts",
        "start": 1,
        "end": 41,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 41,
          "column": 2,
          "position": 218
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.dom.asynciterable.d.ts",
        "start": 1,
        "end": 41,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 41,
          "column": 2,
          "position": 218
        }
      }
    },
    {
      "format": "typescript",
      "lines": 22,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\ndeclare type ClassDecorator = <TFunction extends Function>(target: TFunction) => TFunction | void;\ndeclare type PropertyDecorator = (target: Object, propertyKey: string | symbol) => void;\ndeclare type MethodDecorator = <T>(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<T>) => TypedPropertyDescriptor<T> | void;\ndeclare type ParameterDecorator = (target: Object, propertyKey: string | symbol | undefined, parameterIndex: number) => void;",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.decorators.legacy.d.ts",
        "start": 1,
        "end": 22,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 22,
          "column": 2,
          "position": 155
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.decorators.legacy.d.ts",
        "start": 1,
        "end": 22,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 22,
          "column": 2,
          "position": 155
        }
      }
    },
    {
      "format": "typescript",
      "lines": 384,
      "fragment": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib=\"true\"/>\n\n/**\n * The decorator context types provided to class element decorators.\n */\ntype ClassMemberDecoratorContext =\n    | ClassMethodDecoratorContext\n    | ClassGetterDecoratorContext\n    | ClassSetterDecoratorContext\n    | ClassFieldDecoratorContext\n    | ClassAccessorDecoratorContext;\n\n/**\n * The decorator context types provided to any decorator.\n */\ntype DecoratorContext =\n    | ClassDecoratorContext\n    | ClassMemberDecoratorContext;\n\ntype DecoratorMetadataObject = Record<PropertyKey, unknown> & object;\n\ntype DecoratorMetadata = typeof globalThis extends { Symbol: { readonly metadata: symbol; }; } ? DecoratorMetadataObject : DecoratorMetadataObject | undefined;\n\n/**\n * Context provided to a class decorator.\n * @template Class The type of the decorated class associated with this context.\n */\ninterface ClassDecoratorContext<\n    Class extends abstract new (...args: any) => any = abstract new (...args: any) => any,\n> {\n    /** The kind of element that was decorated. */\n    readonly kind: \"class\";\n\n    /** The name of the decorated class. */\n    readonly name: string | undefined;\n\n    /**\n     * Adds a callback to be invoked after the class definition has been finalized.\n     *\n     * @example\n     * ```ts\n     * function customElement(name: string): ClassDecoratorFunction {\n     *   return (target, context) => {\n     *     context.addInitializer(function () {\n     *       customElements.define(name, this);\n     *     });\n     *   }\n     * }\n     *\n     * @customElement(\"my-element\")\n     * class MyElement {}\n     * ```\n     */\n    addInitializer(initializer: (this: Class) => void): void;\n\n    readonly metadata: DecoratorMetadata;\n}\n\n/**\n * Context provided to a class method decorator.\n * @template This The type on which the class element will be defined. For a static class element, this will be\n * the type of the constructor. For a non-static class element, this will be the type of the instance.\n * @template Value The type of the decorated class method.\n */\ninterface ClassMethodDecoratorContext<\n    This = unknown,\n    Value extends (this: This, ...args: any) => any = (this: This, ...args: any) => any,\n> {\n    /** The kind of class element that was decorated. */\n    readonly kind: \"method\";\n\n    /** The name of the decorated class element. */\n    readonly name: string | symbol;\n\n    /** A value indicating whether the class element is a static (`true`) or instance (`false`) element. */\n    readonly static: boolean;\n\n    /** A value indicating whether the class element has a private name. */\n    readonly private: boolean;\n\n    /** An object that can be used to access the current value of the class element at runtime. */\n    readonly access: {\n        /**\n         * Determines whether an object has a property with the same name as the decorated element.\n         */\n        has(object: This): boolean;\n        /**\n         * Gets the current value of the method from the provided object.\n         *\n         * @example\n         * let fn = context.access.get(instance);\n         */\n        get(object: This): Value;\n    };\n\n    /**\n     * Adds a callback to be invoked either after static methods are defined but before\n     * static initializers are run (when decorating a `static` element), or before instance\n     * initializers are run (when decorating a non-`static` element).\n     *\n     * @example\n     * ```ts\n     * const bound: ClassMethodDecoratorFunction = (value, context) {\n     *   if (context.private) throw new TypeError(\"Not supported on private methods.\");\n     *   context.addInitializer(function () {\n     *     this[context.name] = this[context.name].bind(this);\n     *   });\n     * }\n     *\n     * class C {\n     *   message = \"Hello\";\n     *\n     *   @bound\n     *   m() {\n     *     console.log(this.message);\n     *   }\n     * }\n     * ```\n     */\n    addInitializer(initializer: (this: This) => void): void;\n\n    readonly metadata: DecoratorMetadata;\n}\n\n/**\n * Context provided to a class getter decorator.\n * @template This The type on which the class element will be defined. For a static class element, this will be\n * the type of the constructor. For a non-static class element, this will be the type of the instance.\n * @template Value The property type of the decorated class getter.\n */\ninterface ClassGetterDecoratorContext<\n    This = unknown,\n    Value = unknown,\n> {\n    /** The kind of class element that was decorated. */\n    readonly kind: \"getter\";\n\n    /** The name of the decorated class element. */\n    readonly name: string | symbol;\n\n    /** A value indicating whether the class element is a static (`true`) or instance (`false`) element. */\n    readonly static: boolean;\n\n    /** A value indicating whether the class element has a private name. */\n    readonly private: boolean;\n\n    /** An object that can be used to access the current value of the class element at runtime. */\n    readonly access: {\n        /**\n         * Determines whether an object has a property with the same name as the decorated element.\n         */\n        has(object: This): boolean;\n        /**\n         * Invokes the getter on the provided object.\n         *\n         * @example\n         * let value = context.access.get(instance);\n         */\n        get(object: This): Value;\n    };\n\n    /**\n     * Adds a callback to be invoked either after static methods are defined but before\n     * static initializers are run (when decorating a `static` element), or before instance\n     * initializers are run (when decorating a non-`static` element).\n     */\n    addInitializer(initializer: (this: This) => void): void;\n\n    readonly metadata: DecoratorMetadata;\n}\n\n/**\n * Context provided to a class setter decorator.\n * @template This The type on which the class element will be defined. For a static class element, this will be\n * the type of the constructor. For a non-static class element, this will be the type of the instance.\n * @template Value The type of the decorated class setter.\n */\ninterface ClassSetterDecoratorContext<\n    This = unknown,\n    Value = unknown,\n> {\n    /** The kind of class element that was decorated. */\n    readonly kind: \"setter\";\n\n    /** The name of the decorated class element. */\n    readonly name: string | symbol;\n\n    /** A value indicating whether the class element is a static (`true`) or instance (`false`) element. */\n    readonly static: boolean;\n\n    /** A value indicating whether the class element has a private name. */\n    readonly private: boolean;\n\n    /** An object that can be used to access the current value of the class element at runtime. */\n    readonly access: {\n        /**\n         * Determines whether an object has a property with the same name as the decorated element.\n         */\n        has(object: This): boolean;\n        /**\n         * Invokes the setter on the provided object.\n         *\n         * @example\n         * context.access.set(instance, value);\n         */\n        set(object: This, value: Value): void;\n    };\n\n    /**\n     * Adds a callback to be invoked either after static methods are defined but before\n     * static initializers are run (when decorating a `static` element), or before instance\n     * initializers are run (when decorating a non-`static` element).\n     */\n    addInitializer(initializer: (this: This) => void): void;\n\n    readonly metadata: DecoratorMetadata;\n}\n\n/**\n * Context provided to a class `accessor` field decorator.\n * @template This The type on which the class element will be defined. For a static class element, this will be\n * the type of the constructor. For a non-static class element, this will be the type of the instance.\n * @template Value The type of decorated class field.\n */\ninterface ClassAccessorDecoratorContext<\n    This = unknown,\n    Value = unknown,\n> {\n    /** The kind of class element that was decorated. */\n    readonly kind: \"accessor\";\n\n    /** The name of the decorated class element. */\n    readonly name: string | symbol;\n\n    /** A value indicating whether the class element is a static (`true`) or instance (`false`) element. */\n    readonly static: boolean;\n\n    /** A value indicating whether the class element has a private name. */\n    readonly private: boolean;\n\n    /** An object that can be used to access the current value of the class element at runtime. */\n    readonly access: {\n        /**\n         * Determines whether an object has a property with the same name as the decorated element.\n         */\n        has(object: This): boolean;\n\n        /**\n         * Invokes the getter on the provided object.\n         *\n         * @example\n         * let value = context.access.get(instance);\n         */\n        get(object: This): Value;\n\n        /**\n         * Invokes the setter on the provided object.\n         *\n         * @example\n         * context.access.set(instance, value);\n         */\n        set(object: This, value: Value): void;\n    };\n\n    /**\n     * Adds a callback to be invoked immediately after the auto `accessor` being\n     * decorated is initialized (regardless if the `accessor` is `static` or not).\n     */\n    addInitializer(initializer: (this: This) => void): void;\n\n    readonly metadata: DecoratorMetadata;\n}\n\n/**\n * Describes the target provided to class `accessor` field decorators.\n * @template This The `this` type to which the target applies.\n * @template Value The property type for the class `accessor` field.\n */\ninterface ClassAccessorDecoratorTarget<This, Value> {\n    /**\n     * Invokes the getter that was defined prior to decorator application.\n     *\n     * @example\n     * let value = target.get.call(instance);\n     */\n    get(this: This): Value;\n\n    /**\n     * Invokes the setter that was defined prior to decorator application.\n     *\n     * @example\n     * target.set.call(instance, value);\n     */\n    set(this: This, value: Value): void;\n}\n\n/**\n * Describes the allowed return value from a class `accessor` field decorator.\n * @template This The `this` type to which the target applies.\n * @template Value The property type for the class `accessor` field.\n */\ninterface ClassAccessorDecoratorResult<This, Value> {\n    /**\n     * An optional replacement getter function. If not provided, the existing getter function is used instead.\n     */\n    get?(this: This): Value;\n\n    /**\n     * An optional replacement setter function. If not provided, the existing setter function is used instead.\n     */\n    set?(this: This, value: Value): void;\n\n    /**\n     * An optional initializer mutator that is invoked when the underlying field initializer is evaluated.\n     * @param value The incoming initializer value.\n     * @returns The replacement initializer value.\n     */\n    init?(this: This, value: Value): Value;\n}\n\n/**\n * Context provided to a class field decorator.\n * @template This The type on which the class element will be defined. For a static class element, this will be\n * the type of the constructor. For a non-static class element, this will be the type of the instance.\n * @template Value The type of the decorated class field.\n */\ninterface ClassFieldDecoratorContext<\n    This = unknown,\n    Value = unknown,\n> {\n    /** The kind of class element that was decorated. */\n    readonly kind: \"field\";\n\n    /** The name of the decorated class element. */\n    readonly name: string | symbol;\n\n    /** A value indicating whether the class element is a static (`true`) or instance (`false`) element. */\n    readonly static: boolean;\n\n    /** A value indicating whether the class element has a private name. */\n    readonly private: boolean;\n\n    /** An object that can be used to access the current value of the class element at runtime. */\n    readonly access: {\n        /**\n         * Determines whether an object has a property with the same name as the decorated element.\n         */\n        has(object: This): boolean;\n\n        /**\n         * Gets the value of the field on the provided object.\n         */\n        get(object: This): Value;\n\n        /**\n         * Sets the value of the field on the provided object.\n         */\n        set(object: This, value: Value): void;\n    };\n\n    /**\n     * Adds a callback to be invoked immediately after the field being decorated\n     * is initialized (regardless if the field is `static` or not).\n     */\n    addInitializer(initializer: (this: This) => void): void;\n\n    readonly metadata: DecoratorMetadata;\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/typescript/lib/lib.decorators.d.ts",
        "start": 1,
        "end": 384,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 384,
          "column": 2,
          "position": 1317
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/typescript/lib/lib.decorators.d.ts",
        "start": 1,
        "end": 384,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 384,
          "column": 2,
          "position": 1317
        }
      }
    },
    {
      "format": "typescript",
      "lines": 32,
      "fragment": "import { readdirSync, writeFileSync, statSync } from \"fs\";\n\nconst ignore = [\"src/index.ts\"];\n\nfunction checkSrcDir(path: string): string[] {\n  const lines: string[] = [];\n\n  for (const item of readdirSync(path)) {\n    const itemPath = path + \"/\" + item;\n\n    if (ignore.includes(itemPath)) {\n      continue;\n    }\n\n    if (statSync(itemPath).isDirectory()) {\n      lines.push(...checkSrcDir(itemPath));\n    } else if (item.endsWith(\".ts\")) {\n      lines.push('export * from \"./' + itemPath.slice(4, -2) + 'js\"');\n    }\n  }\n\n  return lines;\n}\n\nconst lines = checkSrcDir(\"src\");\n\nlines.push(\n  'import { zodToJsonSchema } from \"./zodToJsonSchema.js\"',\n  \"export default zodToJsonSchema;\",\n);\n\nwriteFileSync(\"./src/index.ts\", lines.join(\";\\n\"));",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/node_modules/zod-to-json-schema/createIndex.ts",
        "start": 1,
        "end": 32,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 32,
          "column": 2,
          "position": 256
        }
      },
      "secondFile": {
        "name": "packages/extractors/node_modules/zod-to-json-schema/createIndex.ts",
        "start": 1,
        "end": 32,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 32,
          "column": 2,
          "position": 256
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": ", () => {\n    const config = {\n      validation: {\n        phases: [{\n          name: 'Test',\n          steps: [{ name: 'Test', command: 'npm test' }]\n        }]\n      },\n      hooks: {\n        preCommit: {\n          enabled: true,\n          secretScanning: {\n            enabled: true",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/test/schema.test.ts",
        "start": 259,
        "end": 271,
        "startLoc": {
          "line": 259,
          "column": 71,
          "position": 1987
        },
        "endLoc": {
          "line": 271,
          "column": 5,
          "position": 2083
        }
      },
      "secondFile": {
        "name": "packages/config/test/schema.test.ts",
        "start": 215,
        "end": 227,
        "startLoc": {
          "line": 215,
          "column": 55,
          "position": 1654
        },
        "endLoc": {
          "line": 227,
          "column": 6,
          "position": 1750
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": ", () => {\n    const config = {\n      validation: {\n        phases: [{\n          name: 'Test',\n          steps: [{ name: 'Test', command: 'npm test' }]\n        }]\n      },\n      hooks: {\n        preCommit: {\n          secretScanning: {\n            enabled: true,\n            scanCommand: ''",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/test/schema.test.ts",
        "start": 331,
        "end": 343,
        "startLoc": {
          "line": 331,
          "column": 34,
          "position": 2522
        },
        "endLoc": {
          "line": 343,
          "column": 3,
          "position": 2618
        }
      },
      "secondFile": {
        "name": "packages/config/test/schema.test.ts",
        "start": 284,
        "end": 296,
        "startLoc": {
          "line": 284,
          "column": 36,
          "position": 2190
        },
        "endLoc": {
          "line": 296,
          "column": 31,
          "position": 2286
        }
      }
    },
    {
      "format": "typescript",
      "lines": 17,
      "fragment": ", () => {\n    const config = {\n      validation: {\n        phases: [{\n          name: 'Test',\n          steps: [{ name: 'Test', command: 'npm test' }]\n        }]\n      },\n      locking: {\n        enabled: true,\n        concurrencyScope: 'directory'\n      }\n    };\n\n    const result = safeValidateConfig(config);\n    expect(result.success).toBe(true);\n    expect(result.data?.locking?.concurrencyScope",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/test/schema.test.ts",
        "start": 416,
        "end": 432,
        "startLoc": {
          "line": 416,
          "column": 56,
          "position": 3231
        },
        "endLoc": {
          "line": 432,
          "column": 17,
          "position": 3363
        }
      },
      "secondFile": {
        "name": "packages/config/test/schema.test.ts",
        "start": 357,
        "end": 373,
        "startLoc": {
          "line": 357,
          "column": 56,
          "position": 2738
        },
        "endLoc": {
          "line": 373,
          "column": 8,
          "position": 2870
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": ", () => {\n    const config = {\n      validation: {\n        phases: [{\n          name: 'Test',\n          steps: [{ name: 'Test', command: 'npm test' }]\n        }]\n      }\n    };\n\n    const result = safeValidateConfig(config);\n    expect(result.success).toBe(true);\n    expect(result.data?.extractors",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/test/schema.test.ts",
        "start": 616,
        "end": 628,
        "startLoc": {
          "line": 616,
          "column": 60,
          "position": 4954
        },
        "endLoc": {
          "line": 628,
          "column": 11,
          "position": 5060
        }
      },
      "secondFile": {
        "name": "packages/config/test/schema.test.ts",
        "start": 435,
        "end": 447,
        "startLoc": {
          "line": 435,
          "column": 51,
          "position": 3382
        },
        "endLoc": {
          "line": 447,
          "column": 8,
          "position": 3488
        }
      }
    },
    {
      "format": "typescript",
      "lines": 12,
      "fragment": ", () => {\n    const config = {\n      validation: {\n        phases: [{\n          name: 'Test',\n          steps: [{ name: 'Test', command: 'npm test' }]\n        }]\n      },\n      extractors: {\n        builtins: {\n          trust: 'full',\n          disable: ['maven-compiler']",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/test/schema.test.ts",
        "start": 795,
        "end": 806,
        "startLoc": {
          "line": 795,
          "column": 45,
          "position": 6424
        },
        "endLoc": {
          "line": 806,
          "column": 2,
          "position": 6516
        }
      },
      "secondFile": {
        "name": "packages/config/test/schema.test.ts",
        "start": 655,
        "end": 666,
        "startLoc": {
          "line": 655,
          "column": 59,
          "position": 5333
        },
        "endLoc": {
          "line": 666,
          "column": 2,
          "position": 5425
        }
      }
    },
    {
      "format": "typescript",
      "lines": 11,
      "fragment": "}\n      }\n    };\n\n    const result = safeValidateConfig(config);\n    expect(result.success).toBe(false);\n    expect(result.errors).toBeDefined();\n    expect(result.errors!.some(e => e.includes('Invalid enum') || e.includes('trust'))).toBe(true);\n  });\n\n  it('should reject invalid trust level for external extractor'",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/test/schema.test.ts",
        "start": 862,
        "end": 872,
        "startLoc": {
          "line": 862,
          "column": 9,
          "position": 7006
        },
        "endLoc": {
          "line": 872,
          "column": 59,
          "position": 7103
        }
      },
      "secondFile": {
        "name": "packages/config/test/schema.test.ts",
        "start": 345,
        "end": 851,
        "startLoc": {
          "line": 345,
          "column": 9,
          "position": 2624
        },
        "endLoc": {
          "line": 851,
          "column": 53,
          "position": 6919
        }
      }
    },
    {
      "format": "typescript",
      "lines": 12,
      "fragment": "}\n        ]\n      }\n    };\n\n    const result = safeValidateConfig(config);\n    expect(result.success).toBe(false);\n    expect(result.errors).toBeDefined();\n    expect(result.errors!.some(e => e.includes('Invalid enum') || e.includes('trust'))).toBe(true);\n  });\n\n  it('should reject empty package name for external extractor'",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/test/schema.test.ts",
        "start": 885,
        "end": 896,
        "startLoc": {
          "line": 885,
          "column": 11,
          "position": 7200
        },
        "endLoc": {
          "line": 896,
          "column": 58,
          "position": 7300
        }
      },
      "secondFile": {
        "name": "packages/config/test/schema.test.ts",
        "start": 563,
        "end": 851,
        "startLoc": {
          "line": 563,
          "column": 9,
          "position": 4520
        },
        "endLoc": {
          "line": 851,
          "column": 53,
          "position": 6919
        }
      }
    },
    {
      "format": "typescript",
      "lines": 11,
      "fragment": "}\n      }\n    };\n\n    const result = safeValidateConfig(config);\n    expect(result.success).toBe(false);\n    expect(result.errors).toBeDefined();\n    expect(result.errors!.some(e => e.includes('Unrecognized key'))).toBe(true);\n  });\n\n  it('should reject unknown properties in external extractor'",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/test/schema.test.ts",
        "start": 932,
        "end": 942,
        "startLoc": {
          "line": 932,
          "column": 9,
          "position": 7591
        },
        "endLoc": {
          "line": 942,
          "column": 57,
          "position": 7679
        }
      },
      "secondFile": {
        "name": "packages/config/test/schema.test.ts",
        "start": 345,
        "end": 532,
        "startLoc": {
          "line": 345,
          "column": 9,
          "position": 2624
        },
        "endLoc": {
          "line": 532,
          "column": 62,
          "position": 4244
        }
      }
    },
    {
      "format": "typescript",
      "lines": 13,
      "fragment": ", () => {\n    const config = {\n      validation: {\n        phases: [{\n          name: 'Test',\n          steps: [{ name: 'Test', command: 'npm test' }]\n        }]\n      },\n      extractors: {\n        external: [\n          {\n            package: '@myorg/plugin',\n            trust: 'sandbox'",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/test/schema.test.ts",
        "start": 942,
        "end": 954,
        "startLoc": {
          "line": 942,
          "column": 57,
          "position": 7680
        },
        "endLoc": {
          "line": 954,
          "column": 10,
          "position": 7773
        }
      },
      "secondFile": {
        "name": "packages/config/test/schema.test.ts",
        "start": 872,
        "end": 884,
        "startLoc": {
          "line": 872,
          "column": 59,
          "position": 7104
        },
        "endLoc": {
          "line": 884,
          "column": 10,
          "position": 7197
        }
      }
    },
    {
      "format": "typescript",
      "lines": 11,
      "fragment": "}\n        ]\n      }\n    };\n\n    const result = safeValidateConfig(config);\n    expect(result.success).toBe(false);\n    expect(result.errors).toBeDefined();\n    expect(result.errors!.some(e => e.includes('Unrecognized key'))).toBe(true);\n  });\n});",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/test/schema.test.ts",
        "start": 956,
        "end": 966,
        "startLoc": {
          "line": 956,
          "column": 11,
          "position": 7783
        },
        "endLoc": {
          "line": 966,
          "column": 2,
          "position": 7872
        }
      },
      "secondFile": {
        "name": "packages/config/test/schema.test.ts",
        "start": 563,
        "end": 511,
        "startLoc": {
          "line": 563,
          "column": 9,
          "position": 4520
        },
        "endLoc": {
          "line": 511,
          "column": 2,
          "position": 4055
        }
      }
    },
    {
      "format": "typescript",
      "lines": 14,
      "fragment": ");\n\n  if (result.success) {\n    return { success: true, data: result.data };\n  }\n\n  // Extract error messages with full path\n  const errors = result.error.errors.map(err => {\n    const path = err.path.join('.');\n    return path ? `${path}: ${err.message}` : err.message;\n  });\n\n  return { success: false, errors };\n}",
      "tokens": 0,
      "firstFile": {
        "name": "packages/config/src/schema.ts",
        "start": 359,
        "end": 372,
        "startLoc": {
          "line": 359,
          "column": 7,
          "position": 1897
        },
        "endLoc": {
          "line": 372,
          "column": 2,
          "position": 2026
        }
      },
      "secondFile": {
        "name": "packages/extractors/src/result-schema.ts",
        "start": 152,
        "end": 165,
        "startLoc": {
          "line": 152,
          "column": 5,
          "position": 714
        },
        "endLoc": {
          "line": 165,
          "column": 2,
          "position": 843
        }
      }
    }
  ]
}