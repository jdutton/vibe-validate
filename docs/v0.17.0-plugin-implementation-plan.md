# v0.17.0 Plugin Implementation Plan

**Status**: Ready to Implement
**Target**: v0.17.0 (after rc4)
**Estimated Effort**: 2-3 weeks

---

## Goals

1. ‚úÖ Enable custom extractors via config
2. ‚úÖ Sandbox plugins (vm2) for security
3. ‚úÖ Support YAML extractors (regex-only, no code)
4. ‚úÖ Create contribution workflow (`vv contribute-extractor`)
5. ‚úÖ Document extractor API

---

## Implementation Tasks

### Phase 1: Core Plugin System (Week 1)

#### Task 1.1: Plugin Loader
**File**: `packages/extractors/src/plugin-loader.ts`

```typescript
import { VM } from 'vm2';
import type { ExtractorDescriptor } from './extractor-registry.js';

export interface ExtractorPlugin {
  path?: string;       // Local file path
  package?: string;    // npm package name
  trust?: 'sandbox' | 'full' | 'builtin';
  priority?: number;
}

export async function loadExtractorPlugin(
  plugin: ExtractorPlugin
): Promise<ExtractorDescriptor> {
  // Load code from file or package
  const code = plugin.path
    ? await fs.readFile(plugin.path, 'utf-8')
    : await loadFromPackage(plugin.package!);

  // Check if YAML or JavaScript
  if (plugin.path?.endsWith('.yaml') || plugin.path?.endsWith('.yml')) {
    return loadYamlExtractor(code);
  }

  // Execute in sandbox (unless trust=full)
  if (plugin.trust !== 'full' && plugin.trust !== 'builtin') {
    return executeSandboxed(code);
  }

  // Trusted code: execute directly
  return executeDirectly(code);
}

function executeSandboxed(code: string): ExtractorDescriptor {
  const vm = new VM({
    timeout: 5000,
    sandbox: {
      console: createSafeConsole(),
    },
    require: {
      external: false,
      builtin: [],
    },
  });

  return vm.run(code);
}
```

**Tests**:
- [ ] Load JavaScript extractor from file
- [ ] Load TypeScript extractor (via esbuild)
- [ ] Load YAML extractor
- [ ] Load from npm package
- [ ] Sandbox blocks dangerous APIs (fs, child_process, etc.)
- [ ] Timeout after 5 seconds
- [ ] Error handling (invalid code)

**Estimated**: 2 days

---

#### Task 1.2: YAML Extractor Parser
**File**: `packages/extractors/src/yaml-extractor.ts`

```typescript
import yaml from 'yaml';

interface YamlExtractor {
  name: string;
  priority: number;
  detection: {
    patterns: Array<{
      regex: string;
      confidence: number;
    }>;
    minimumConfidence: number;
  };
  extraction: {
    errorPattern: string;
    summary: string;
    guidance: string;
  };
}

export function loadYamlExtractor(yamlContent: string): ExtractorDescriptor {
  const config: YamlExtractor = yaml.parse(yamlContent);

  return {
    name: config.name,
    priority: config.priority,

    detect(output: string) {
      let totalConfidence = 0;
      const matchedPatterns: string[] = [];

      for (const pattern of config.detection.patterns) {
        if (new RegExp(pattern.regex).test(output)) {
          totalConfidence += pattern.confidence;
          matchedPatterns.push(pattern.regex);
        }
      }

      if (totalConfidence >= config.detection.minimumConfidence) {
        return {
          confidence: totalConfidence,
          patterns: matchedPatterns,
          reason: `YAML extractor ${config.name} detected`
        };
      }

      return { confidence: 0, patterns: [], reason: '' };
    },

    extract(output: string) {
      const errors: FormattedError[] = [];
      const regex = new RegExp(config.extraction.errorPattern, 'gm');

      let match;
      while ((match = regex.exec(output)) !== null) {
        errors.push({
          file: match.groups?.file,
          line: match.groups?.line ? parseInt(match.groups.line) : undefined,
          column: match.groups?.column ? parseInt(match.groups.column) : undefined,
          message: match.groups?.message || match[0],
        });
      }

      return {
        errors,
        totalErrors: errors.length,
        summary: config.extraction.summary.replace('{{totalErrors}}', errors.length.toString()),
        guidance: config.extraction.guidance,
        errorSummary: errors.map(e => e.message).join('\n'),
      };
    },
  };
}
```

**Example YAML Extractor**:
```yaml
name: simple-build-tool
priority: 75

detection:
  patterns:
    - regex: "ERROR: Build failed"
      confidence: 40
    - regex: "\\[FAIL\\]"
      confidence: 30
  minimumConfidence: 70

extraction:
  # Named capture groups: file, line, column, message
  errorPattern: "^(?<file>[^:]+):(?<line>\\d+):(?<column>\\d+): (?<message>.+)$"
  summary: "{{totalErrors}} build error(s)"
  guidance: "Fix errors shown above and retry build"
```

**Tests**:
- [ ] Parse valid YAML extractor
- [ ] Detect patterns correctly
- [ ] Extract errors with regex
- [ ] Handle missing capture groups
- [ ] Error on invalid YAML
- [ ] Error on invalid regex

**Estimated**: 1 day

---

#### Task 1.3: Config Schema Update
**File**: `packages/config/src/schema.ts`

```typescript
export const ConfigSchema = z.object({
  version: z.literal(1),

  // NEW: Extractor plugins
  extractors: z.array(z.object({
    path: z.string().optional(),
    package: z.string().optional(),
    trust: z.enum(['sandbox', 'full', 'builtin']).default('sandbox'),
    priority: z.number().min(0).max(100).optional(),
  })).optional(),

  validation: z.object({
    // ... existing schema
  }),
});
```

**Tests**:
- [ ] Valid config with extractors
- [ ] Invalid config (missing path and package)
- [ ] Trust level validation
- [ ] Priority range validation

**Estimated**: 0.5 days

---

#### Task 1.4: Integration with smart-extractor.ts
**File**: `packages/extractors/src/smart-extractor.ts`

```typescript
import { EXTRACTOR_REGISTRY } from './extractor-registry.js';
import { loadExtractorPlugin } from './plugin-loader.js';

// Global registry (built-in + plugins)
let MERGED_REGISTRY: ExtractorDescriptor[] = [...EXTRACTOR_REGISTRY];

export async function registerExtractorPlugins(plugins: ExtractorPlugin[]): Promise<void> {
  const loaded = await Promise.all(
    plugins.map(plugin => loadExtractorPlugin(plugin))
  );

  // Merge with built-in extractors, sorted by priority
  MERGED_REGISTRY = [...EXTRACTOR_REGISTRY, ...loaded]
    .sort((a, b) => b.priority - a.priority);
}

export function autoDetectAndExtract(/* ... */): ErrorExtractorResult {
  // Use MERGED_REGISTRY instead of EXTRACTOR_REGISTRY
  for (const descriptor of MERGED_REGISTRY) {
    // ... detection logic
  }
}
```

**Tests**:
- [ ] Plugins load before validation
- [ ] Plugins sorted by priority
- [ ] Built-in extractors still work
- [ ] Plugin extractors detected correctly

**Estimated**: 1 day

---

### Phase 2: CLI Commands (Week 2)

#### Task 2.1: `vv create-extractor` Command
**File**: `packages/cli/src/commands/create-extractor.ts`

```bash
$ vv create-extractor gradle

Creating extractor for 'gradle'...

Choose extractor type:
  1. JavaScript/TypeScript (full control)
  2. YAML (simple regex-based)

> 1

Where should I save this?
  1. Local project (.vibe-validate/extractors/)
  2. Shared team (npm package)

> 1

‚úÖ Created: .vibe-validate/extractors/gradle.js
‚úÖ Updated: vibe-validate.config.yaml

Next steps:
  1. Edit .vibe-validate/extractors/gradle.js
  2. Test: vv run <command>
  3. Contribute: vv contribute-extractor gradle
```

**Generated Template** (JavaScript):
```javascript
// Auto-generated extractor for 'gradle'
// Edit this file to customize detection and extraction

export default {
  name: 'gradle',
  priority: 80,

  detect(output) {
    // TODO: Add detection patterns
    // Example:
    // if (output.includes('BUILD FAILED')) {
    //   return {
    //     confidence: 90,
    //     patterns: ['BUILD FAILED'],
    //     reason: 'Gradle build failure detected'
    //   };
    // }

    return { confidence: 0, patterns: [], reason: '' };
  },

  extract(output) {
    const errors = [];

    // TODO: Parse errors from output
    // Example:
    // const lines = output.split('\n');
    // for (const line of lines) {
    //   const match = /error: (.+)/.exec(line);
    //   if (match) {
    //     errors.push({ message: match[1] });
    //   }
    // }

    return {
      errors,
      totalErrors: errors.length,
      summary: `${errors.length} Gradle error(s)`,
      guidance: 'Run ./gradlew build --stacktrace for details',
      errorSummary: errors.map(e => e.message).join('\n')
    };
  }
};
```

**Generated Template** (YAML):
```yaml
name: gradle
priority: 80

detection:
  patterns:
    - regex: "BUILD FAILED"
      confidence: 40
    - regex: "FAILURE: Build failed"
      confidence: 50
  minimumConfidence: 70

extraction:
  errorPattern: "^error: (?<message>.+)$"
  summary: "{{totalErrors}} Gradle error(s)"
  guidance: "Run ./gradlew build --stacktrace for details"
```

**Tests**:
- [ ] Create JavaScript extractor
- [ ] Create YAML extractor
- [ ] Updates config file
- [ ] Creates directory if needed
- [ ] Error if extractor already exists

**Estimated**: 2 days

---

#### Task 2.2: `vv contribute-extractor` Command
**File**: `packages/cli/src/commands/contribute-extractor.ts`

```bash
$ vv contribute-extractor gradle

Preparing contribution for 'gradle' extractor...

‚úÖ Security audit passed (no dangerous APIs)
‚úÖ Generated test cases from sample output
‚úÖ Redacted sensitive paths

Ready to submit PR to github.com/jdutton/vibe-validate

Contribution includes:
  - Extractor code (audited)
  - 3 test cases
  - Documentation

Submit pull request? (yes/no)
> yes

‚úÖ PR created: https://github.com/jdutton/vibe-validate/pull/123

Thank you for contributing to vibe-validate! üéâ
```

**Implementation**:
1. Load extractor code
2. Run security audit (check for banned APIs)
3. Generate test cases from sample output
4. Redact sensitive data (paths, potential secrets)
5. Create PR via GitHub API

**Tests**:
- [ ] Security audit detects dangerous APIs
- [ ] Redacts sensitive paths
- [ ] Generates valid test cases
- [ ] Creates PR successfully

**Estimated**: 3 days

---

### Phase 3: Documentation & Examples (Week 3)

#### Task 3.1: Documentation
**Files**:
- `docs/building-custom-extractors.md` - Complete API reference
- `docs/yaml-extractors.md` - YAML extractor guide
- `docs/contributing-extractors.md` - How to contribute

**Content**:
- Extractor API specification
- Step-by-step tutorial (JavaScript & YAML)
- Security best practices
- Common patterns (file:line:col, test frameworks, etc.)
- Troubleshooting guide

**Estimated**: 2 days

---

#### Task 3.2: Example Extractors
**Directory**: `examples/custom-extractors/`

**Examples**:
- `gradle-extractor.js` - Gradle build tool
- `webpack-extractor.js` - Webpack bundler
- `pytest-extractor.js` - Python pytest
- `cargo-extractor.js` - Rust cargo
- `simple-regex.yaml` - YAML extractor example

**Tests**:
- [ ] All examples work with sample output
- [ ] Examples pass security audit
- [ ] Examples follow best practices

**Estimated**: 2 days

---

#### Task 3.3: Integration Tests
**File**: `packages/extractors/test/plugin-integration.test.ts`

**Test Scenarios**:
- [ ] Load JavaScript plugin
- [ ] Load YAML plugin
- [ ] Load npm package plugin
- [ ] Plugin priority ordering
- [ ] Sandboxed plugin cannot access fs
- [ ] Sandboxed plugin cannot execute commands
- [ ] Plugin timeout enforced
- [ ] Error handling for invalid plugins
- [ ] Built-in extractors still work with plugins loaded

**Estimated**: 1 day

---

## Dependencies

### New npm Packages
```json
{
  "dependencies": {
    "vm2": "^3.9.19",        // Sandboxing
    "yaml": "^2.3.4"          // YAML parsing
  }
}
```

### Security Audit Tool
```bash
# Use existing tools or build custom
eslint-plugin-security  # Detects dangerous patterns
```

---

## Testing Strategy

### Unit Tests
- Each component tested in isolation
- Mock file system, network, etc.
- Test error conditions

### Integration Tests
- End-to-end plugin loading
- Real extractor examples
- Security validation

### Manual Testing
- Test with real projects (Gradle, Webpack, etc.)
- Verify sandboxing works
- Test contribution workflow

---

## Rollout Plan

### v0.17.0-rc5 (Plugin Foundation)
- Core plugin loader
- YAML extractor support
- `vv create-extractor` command

### v0.17.0-rc6 (Contribution Workflow)
- `vv contribute-extractor` command
- Security audit tool
- Documentation

### v0.17.0 (Stable Release)
- All features tested
- Example extractors
- Complete documentation

---

## Success Metrics

### Developer Experience
- ‚è±Ô∏è Time to create extractor: < 5 minutes
- üìù Lines of code required: < 50 (typical case)
- üîí Security: 0 vulnerabilities from plugins

### Community Adoption
- üéØ Target: 5 community-contributed extractors in first month
- üì¶ Target: 10 total built-in extractors by v0.18.0
- ‚≠ê Target: 80% of users never need custom extractors (built-ins cover it)

### Quality
- ‚úÖ 100% test coverage on plugin loader
- ‚úÖ 0 SonarQube issues
- ‚úÖ All validation passing

---

## Risk Mitigation

### Security Risks
**Risk**: Malicious plugins
**Mitigation**:
- Sandbox by default
- Security audit tool
- Documentation on vetting plugins

### Performance Risks
**Risk**: Slow plugin loading
**Mitigation**:
- Cache compiled plugins
- Lazy load (only when needed)
- Timeout enforcement

### Breaking Changes
**Risk**: API changes break user plugins
**Mitigation**:
- Semantic versioning
- Deprecation warnings
- Migration guides

---

## Open Questions

1. **vm2 vs isolated-vm?**
   - vm2: Easier to use, good enough for most cases
   - isolated-vm: Better security, more complex
   - **Decision**: Start with vm2, evaluate isolated-vm for v0.18.0

2. **YAML extractor limitations?**
   - Can only do regex-based extraction
   - No complex logic (state machines, multi-line context)
   - **Decision**: Document limitations, provide JavaScript fallback

3. **Trust model UX?**
   - Should we prompt user on first run for "trust: full"?
   - **Decision**: Yes, show warning + require confirmation

4. **Plugin versioning?**
   - How do we handle plugin API changes?
   - **Decision**: Use semver, warn on incompatible versions

---

## Next Actions

1. Review this plan with stakeholders
2. Prioritize tasks
3. Assign work
4. Set milestone dates
5. Begin implementation

**Ready to start?** Let's build this! üöÄ
